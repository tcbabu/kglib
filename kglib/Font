FileListBrowser.c:  butn0[0].bkgr=-1;
FileListBrowser.c:  butn0[1].bkgr=-1;
FileListBrowser.c:    5,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
FileListBrowser.c:  b0.item = -1;
FileListBrowser.c:  t1.item = -1;
FileListBrowser.c:  x2.item = -1;
FileListBrowser.c:  y3.item = -1;
FileListBrowser.c:  y4.item = -1;
FileListBrowser.c:  butn5[0].bkgr=-1;
FileListBrowser.c:  butn5[1].bkgr=-1;
FileListBrowser.c:  butn5[2].bkgr=-130160130;
FileListBrowser.c:    5,0.500000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
FileListBrowser.c:  b5.item = -1;
FileListBrowser.c:  butn6[0].bkgr=-255255255;
FileListBrowser.c:    5,0.500000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
FileListBrowser.c:  h6.item = -1;
FileListBrowser.c:  butn7[0].bkgr=-1;
FileListBrowser.c:  butn7[1].bkgr=-1;
FileListBrowser.c:  butn7[2].bkgr=-1;
FileListBrowser.c:    5,0.500000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
FileListBrowser.c:  b7.item = -1;
FileListBrowser.c:  dtmp = D->d;
FileListBrowser.c:  d[0].N->item = -1;
FileListBrowser.c:  d[1].t->item = -1;
FileListBrowser.c:  d[2].x->item = -1;
FileListBrowser.c:  d[3].y->item = -1;
FileListBrowser.c:  d[4].y->item = -1;
FileListBrowser.c:  d[5].N->item = -1;
FileListBrowser.c:  d[6].h->item = -1;
FileListBrowser.c:  d[7].N->item = -1;
FileListBrowser.c:  D->d = dtmp;
FileListBrowser.c:   Gpt->arg= v; // kulina will double free this; you may modify
FileListBrowser.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
FileListBrowser.c:      D.xo= (xres-D.xl)/2;
FileListBrowser.c:      D.yo=(yres-D.yl)/2; 
FileListBrowserCallbacks.c:     while(th[i]!=NULL) th[i++]->sw = 1;
FileListBrowserCallbacks.c:     while(th[i]!=NULL) th[i++]->sw = 0;
FileListBrowserCallbacks.c:      int ret = -1;
FileListBrowserCallbacks.c:      sprintf ( job , "stat -t \"%s\"" , folder ) ;
FileListBrowserCallbacks.c:          Th [ i ] -> sw = 0;
FileListBrowserCallbacks.c:          Th [ i ] -> sw = 1;
FileListBrowserCallbacks.c:      int x = -1 , y = -1;
FileListBrowserCallbacks.c:                  name = ( char * ) malloc ( strlen ( Folder ) +strlen ( Th-> name ) +4 ) ;
FileListBrowserCallbacks.c:                  strcat ( name , Th-> name ) ;
FileListBrowserCallbacks.c:                  free ( Th-> name ) ;
FileListBrowserCallbacks.c:                  Th-> name = name; 
FileListBrowserCallbacks.c:      int x = -1 , y = -1;
FileListBrowserCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
FileListBrowserCallbacks.c:              th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
FileListBrowserCallbacks.c:              th [ i ] -> img = kgCopyImage ( folderimg ) ;
FileListBrowserCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
FileListBrowserCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
FileListBrowserCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:          else th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
FileListBrowserCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
FileListBrowserCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
FileListBrowserCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
FileListBrowserCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
FileListBrowserCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
FileListBrowserCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
FileListBrowserCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
FileListBrowserCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
FileListBrowserCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
FileListBrowserCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
FileListBrowserCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
FileListBrowserCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      n = B-> nx*B-> ny;
FileListBrowserCallbacks.c:	  BUT_STR *butns = (BUT_STR *)(B->buts);
FileListBrowserCallbacks.c:           ie 0 to (nx*ny-1) 
FileListBrowserCallbacks.c:      e = T-> elmt;
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      pt = D-> pt;
FileListBrowserCallbacks.c:      th = ( ThumbNail * ) kgPickThumbNail ( X , item-1 ) ;
FileListBrowserCallbacks.c:      strcat ( Folder , th-> name ) ;
FileListBrowserCallbacks.c: // One may setup browser list here by setting X->list
FileListBrowserCallbacks.c: // if it need to be freed set it as X->pt also
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      pt = D-> pt;
FileListBrowserCallbacks.c:      if ( DragItem ( Tmp , Y1 , item-1 ) ) return 1;
FileListBrowserCallbacks.c: // One may setup browser list here by setting Y->list
FileListBrowserCallbacks.c: // if it need to be freed set it as Y->pt also
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      pt = D-> pt;
FileListBrowserCallbacks.c:      if ( Drag2Item ( Tmp , Y2 , item-1 ) ) return 1;
FileListBrowserCallbacks.c: // One may setup browser list here by setting Y->list
FileListBrowserCallbacks.c: // if it need to be freed set it as Y->pt also
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      n = B-> nx*B-> ny;
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      n = B-> nx;
FileListBrowserCallbacks.c:          Strs [ j ] = ( char * ) malloc ( strlen ( th [ j ] -> name ) +1 ) ;
FileListBrowserCallbacks.c:          strcpy ( Strs [ j ] , th [ j ] -> name ) ;
FileListBrowserCallbacks.c:      pt = ( char *** ) D-> pt;
FileListBrowserCallbacks.c:      int x = -1 , y = -1;
FileListBrowserCallbacks.c:              name = ( char * ) malloc ( strlen ( Folder ) +strlen ( TH-> name ) +4 ) ;
FileListBrowserCallbacks.c:              strcat ( name , TH-> name ) ;
FileListBrowserCallbacks.c:              free ( TH-> name ) ;
FileListBrowserCallbacks.c:              TH-> name = name;
FileListBrowserCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
FileListBrowserCallbacks.c:      n = B-> nx*B-> ny;
FileListBrowserCallbacks.c:      pt = D-> pt;
FileListBrowserCallbacks.c:      pt = D-> pt;
FileListBrowserCallbacks.c:      d = D-> d;
FileListBrowserCallbacks.c:      if ( kbe-> event == 1 ) {
FileListBrowserCallbacks.c:          if ( kbe-> button == 1 ) {
FileListBrowserCallbacks.c:      dx = xres - D-> xl;
FileListBrowserCallbacks.c:      dy = yres - D-> yl;
FileListBrowserCallbacks.c:      D-> xl = xres;
FileListBrowserCallbacks.c:      D-> yl = yres;
GclrFileListBrowser.c:   gc = &(D->gc);
GclrFileListBrowser.c:   gc->FontSize =8;
GclrFileListBrowser.c:   gc->Font=23;
GclrGetFile.c:   gc = &(D->gc);
GclrGetFile.c:   gc->FontSize =8;
GclrGetFile.c:   gc->Font=23;
Gclrdia.c:  D.df = -1;
Gclrdia.c: d[0].b->x1 =11;
Gclrdia.c: d[0].b->y1 =13;
Gclrdia.c: d[0].b->x2 =328;
Gclrdia.c: d[0].b->y2 =190;
Gclrdia.c: D.df = -1;
Gclrdia.c: ret =  v0-1;
Gclrdia.c:  n = D->d[i].n;
Gclrdia.c:  df = n->bkgr[code-1]+1;
Gclrdia.c:  n->bkgr[code-1]=colorbox(df);
Gclrdia.c:  D.df = -1;
GetFile.c:  butn0[0].bkgr=-1;
GetFile.c:  butn0[1].bkgr=-1;
GetFile.c:    5,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
GetFile.c:  b0.item = -1;
GetFile.c:  x1.item = -1;
GetFile.c:  y2.item = -1;
GetFile.c:  butn3[0].bkgr=-155155155;
GetFile.c:  butn3[1].bkgr=-255255255;
GetFile.c:    5,0.500000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
GetFile.c:  h3.item = -1;
GetFile.c:    -1,0  
GetFile.c:  m4.item = -1;
GetFile.c:    -1,0  
GetFile.c:  m5.item = -1;
GetFile.c:  m6.item = -1;
GetFile.c:  dtmp = D->d;
GetFile.c:  d[0].N->item = -1;
GetFile.c:  d[1].x->item = -1;
GetFile.c:  d[2].y->item = -1;
GetFile.c:  d[3].h->item = -1;
GetFile.c:  d[4].m->item = -1;
GetFile.c:  d[5].m->item = -1;
GetFile.c:  d[6].m->item = -1;
GetFile.c:  D->d = dtmp;
GetFile.c:   Gpt->arg= v; // kulina will double free this; you may modify
GetFile.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
GetFile.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
GetFile.c:      D.xo= (xres-D.xl)/2;
GetFile.c:      D.yo= (yres-D.yl)/2; 
GetFileCallbacks.c:     while(th[i]!=NULL) th[i++]->sw = 1;
GetFileCallbacks.c:     while(th[i]!=NULL) th[i++]->sw = 0;
GetFileCallbacks.c:      int ret = -1;
GetFileCallbacks.c:      sprintf ( job , "stat -t \"%s\"" , folder ) ;
GetFileCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
GetFileCallbacks.c:              th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
GetFileCallbacks.c:              th [ i ] -> img = kgCopyImage ( folderimg ) ;
GetFileCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
GetFileCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
GetFileCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:          else th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
GetFileCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
GetFileCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
GetFileCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
GetFileCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
GetFileCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
GetFileCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
GetFileCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
GetFileCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
GetFileCallbacks.c:          sprintf ( fullname , "%-s/%-s" , Folder , th [ i ] -> name ) ;
GetFileCallbacks.c:                      th [ i ] -> img = kgThumbNailImage ( imgo , size , size ) ;
GetFileCallbacks.c:                  else th [ i ] -> img = kgCopyImage ( fileimg ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( linkimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( musicimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( videoimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( binaryimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( exeimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( gzipimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( tarimg , size , size ) ;
GetFileCallbacks.c:                  th [ i ] -> img = kgThumbNailImage ( cimg , size , size ) ;
GetFileCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
GetFileCallbacks.c:  n = B->nx*B->ny;
GetFileCallbacks.c:    BUT_STR *butns = (BUT_STR *)(B->buts);
GetFileCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
GetFileCallbacks.c:  pt = D->pt;
GetFileCallbacks.c:      th = ( ThumbNail * ) kgPickThumbNail ( X , item-1 ) ;
GetFileCallbacks.c:      strcat ( Folder , th-> name ) ;
GetFileCallbacks.c: // One may setup browser list here by setting X->list
GetFileCallbacks.c: // if it need to be freed set it as X->pt also
GetFileCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
GetFileCallbacks.c:  pt = D->pt;
GetFileCallbacks.c: // One may setup browser list here by setting Y->list
GetFileCallbacks.c: // if it need to be freed set it as Y->pt also
GetFileCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
GetFileCallbacks.c:  n = B->nx;
GetFileCallbacks.c:      str = (char **)(D->pt);
GetFileCallbacks.c:  pt = D->pt;
GetFileCallbacks.c:  pt = D->pt;
GetFileCallbacks.c:  d = D->d;
GetFileCallbacks.c:  if(kbe->event ==1) {
GetFileCallbacks.c:    if(kbe->button ==1) {
GetFileCallbacks.c:  dx = xres - D->xl;
GetFileCallbacks.c:  dy = yres - D->yl;
GetFileCallbacks.c:  D->xl= xres;
GetFileCallbacks.c:  D->yl= yres;
PngImage.c:#  define png_jmpbuf(png_ptr)   ((png_ptr)->jmpbuf)
PngImage.c:    /* could pass pointers to user-defined error handlers instead of NULLs: */
PngImage.c:     * useful if we want to keep pre- and post-IDAT chunk info separated
PngImage.c:     * (mainly for PNG-aware image editors and converters) */
PngImage.c:    /* setjmp() must be called in every function that calls a PNG-reading
PngImage.c: * scales values to 8-bit if necessary */
PngImage.c:    /* setjmp() must be called in every function that calls a PNG-reading
PngImage.c:     * bit-depth transformations, so check depth and adjust if necessary */
PngImage.c:        *red   = pBackground->red   >> 8;
PngImage.c:        *green = pBackground->green >> 8;
PngImage.c:        *blue  = pBackground->blue  >> 8;
PngImage.c:            *red = *green = *blue = pBackground->gray? 255 : 0;
PngImage.c:            *red = *green = *blue = (255/3) * pBackground->gray;
PngImage.c:            *red = *green = *blue = (255/15) * pBackground->gray;
PngImage.c:        *red   = (uch)pBackground->red;
PngImage.c:        *green = (uch)pBackground->green;
PngImage.c:        *blue  = (uch)pBackground->blue;
PngImage.c:    /* setjmp() must be called in every function that calls a PNG-reading
PngImage.c:    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
PngImage.c:     * transparency chunks to full alpha channel; strip 16-bit-per-sample
PngImage.c:     * this file may have come from--so if it doesn't have a file gamma, don't
PngImage.c:     * post-IDAT text/time/etc. is desired) */
PngImage.c:  png->image_width = image_width;
PngImage.c:  png->image_height = image_height;
PngImage.c:  png->image_channels=image_channels;
PngImage.c:  png->image_rowbytes=image_rowbytes;
PngImage.c:  png->image_data=image_data;
PngImage.c:  strcpy(png->Sign,"PNG");
PngImage.c:  png->incode=0;
add.c:#define uiset_clip_limits(wc,x1,y1,x2,y2) wc->c_v_x1=x1,wc->c_v_y1=y1,wc->c_v_x2=x2,wc->c_v_y2=y2
add.c:#define uibkup_clip_limits wc->c_v_x1_o=wc->c_v_x1,wc->c_v_y1_o=wc->c_v_y1,wc->c_v_x2_o=wc->c_v_x2,wc->c_v_y2_o=wc->c_v_y2
add.c:#define uiset_sup_clip_limits(wc,x1,y1,x2,y2) wc->s_v_x1=x1,wc->s_v_y1=y1,wc->s_v_x2=x2,wc->s_v_y2=y2
add.c:#define uirest_clip_limits wc->c_v_x1=wc->c_v_x1_o,wc->c_v_y1=wc->c_v_y1_o,wc->c_v_x2=wc->c_v_x2_o,wc->c_v_y2=wc->c_v_y2_o
add.c:#define IMAGE_BLUE_VAL  (((blue)*(wc->IMAGE->blue_mask)+(1<<(wc->BLUEMASKPOS-1)))/255)
add.c:#define IMAGE_GREEN_VAL ((((green) * (wc->IMAGE->green_mask) \
add.c:   + ( 1 << ( wc->GREENMASKPOS -1 ) ) ) /255 ) & ( wc->IMAGE->green_mask ) )
add.c:#define IMAGE_RED_VAL ((((red) * (wc->IMAGE->red_mask) \
add.c:   + ( 1 << ( wc->REDMASKPOS -1 ) ) ) /255 ) & ( wc->IMAGE->red_mask ) )
add.c:#define BLUE_VAL  (((val&0x0000ff)*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
add.c:#define GREEN_VAL (((((val>>8)&0x0000ff) * (uiImage->green_mask) \
add.c:   + ( 1 << ( GreenMaskPos -1 ) ) ) /255 ) & ( uiImage->green_mask ) )
add.c:#define RED_VAL (((((val>>16)&0x0000ff) * (uiImage->red_mask) \
add.c:   + ( 1 << ( RedMaskPos -1 ) ) ) /255 ) & ( uiImage->red_mask ) )
add.c:#define Image_BLUE_VAL  ((blue*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
add.c:#define Image_GREEN_VAL (((green * (uiImage->green_mask) \
add.c:   + ( 1 << ( GreenMaskPos -1 ) ) ) /255 ) & ( uiImage->green_mask ) )
add.c:#define Image_RED_VAL (((red * (uiImage->red_mask) \
add.c:   + ( 1 << ( RedMaskPos -1 ) ) ) /255 ) & ( uiImage->red_mask ) )
add.c:#define Img_BLUE_VAL  ((blue*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
add.c:static char FONTSTRF[60]= "-adobe-courier-medium-r-*-*-";
add.c:static char FONTSTRV[60]= "-adobe-courier-medium-r-*-*-";
add.c:static char FONTSTRV[60]= "-adobe-helvetica-bold-r-*-*-";
add.c:  static char FONTSTRF [ 60 ] = "-adobe-courier-bold-r-*-*-";
add.c:  static char FONTSTRV [ 60 ] = "-adobe-helvetica-bold-r-*-*-";
add.c:  static char FONTSTRV1 [ 60 ] = "-adobe-new century schoolbook-medium-r-*-*-";
add.c:  static char FONTSTRV2 [ 60 ] = "-adobe-times-medium-r-*-*-";
add.c:  static char FONTSTRV3 [ 60 ] = "-adobe-utopia-medium-r-*-*-";
add.c:  static char FONTSTR2 [ 20 ] = "-*-*-*-*-*-*-*";
add.c:#define FONT "-adobe-courier-medium-r-*-*-16-*-*-*-*-*-*-*"
aline.c:#define Fpart(x) ((x)-Ipart(x))
aline.c:#define Rfpart(x) ( 1-Fpart(x))
aline.c:   steep= (abs(y1 - y0) > abs(x1 - x0))?1:0;
aline.c:   dx = x1 - x0;
aline.c:   dy = y1 - y0;
aline.c:   yend = y0 + gradient * (xend - x0);
aline.c:   yend = y1 + gradient * (xend - x1);
aline.c:   for (x =xpxl1 + 1 ;x<=xpxl2 - 1;x++ ) {
antialiasedline.c:     return 1 - fpart(x)
antialiasedline.c:     boolean steep := abs(y1 - y0) > abs(x1 - x0)
antialiasedline.c:     dx := x1 - x0
antialiasedline.c:     dy := y1 - y0
antialiasedline.c:     yend := y0 + gradient * (xend - x0)
antialiasedline.c:     intery := yend + gradient // first y-intersection for the main loop
antialiasedline.c:     yend := y1 + gradient * (xend - x1)
antialiasedline.c:     for x from xpxl1 + 1 to xpxl2 - 1 do
base64.c: * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
base64.c: * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
base64.c: * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
base64.c: * Supercomputing Applications, University of Illinois, Urbana-Champaign.
base64.c:    nprbytes = (bufin - (const unsigned char *) bufcoded) - 1;
base64.c:    nprbytes = (bufin - (const unsigned char *) bufcoded) - 1;
base64.c:    nprbytes -= 4;
base64.c:    nbytesdecoded -= (4 - nprbytes) & 3;
base64.c:    for (i = 0; i < len - 2; i += 3) {
base64.c:    if (i == (len - 1)) {
base64.c:    return p - encoded;
cleantmpdir.c:                   if (w == -1) { \
cleantmpdir.c:  sprintf(command,"rm -r -f %-s",argv[2]);
cleanxpm.c:   printf("Usage: cleanxpm <in-file> \n");
clrtrans.c:  range r: 0-1
clrtrans.c:  range g: 0-1
clrtrans.c:  range b: 0-1
clrtrans.c:        h: 0-360
clrtrans.c:        s: 0-1
clrtrans.c:        v: 0-1
clrtrans.c:    while(h >= 360.) h -=360;
clrtrans.c:    f = h-i;
clrtrans.c:    p = v*(1-s);
clrtrans.c:    q = v*(1-s*f);
clrtrans.c:    t = v*(1-(s*(1-f)));
clrtrans.c:  if(max != 0) *s = (max -min)/max;
clrtrans.c:     del = max - min;
clrtrans.c:     if( r==max) *h= (g-b)/del;
clrtrans.c:       if(g==max) *h = 2+(b-r)/del;
clrtrans.c:          if(b==max) *h= 4+(r-g)/del;
clrtrans.c:    if( *l <= 0.5 ) *s = (max - min)/(max+min);
clrtrans.c:    else *s = (max - min)/(2 - max - min);
clrtrans.c:    del = max - min;
clrtrans.c:    if( r == max ) *h = (g-b)/del;
clrtrans.c:      if( g == max ) *h = 2+(b-r)/del;
clrtrans.c:      else *h = 4 + (r-g)/del;
clrtrans.c:  while (h >360) h -=360;
clrtrans.c:  if( h < 60 ) val = n1 + (n2 - n1)*h/60.;
clrtrans.c:       if( h < 240. ) val = n1 + (n2 - n1)*(240 -h)/60.;
clrtrans.c:   else m2 = l+s - l*s;
clrtrans.c:   m1 = 2*l -m2;
clrtrans.c:     *b = Value(m1,m2,h-120);
dlink.c:      tmp-> st = NULL;
dlink.c:      tmp-> en = NULL;
dlink.c:      tmp-> cr = NULL;
dlink.c:      Dup-> st = L-> st;
dlink.c:      Dup-> en = L-> en;
dlink.c:      Dup-> cr = L-> st;
dlink.c:      LN = F-> en;
dlink.c:          F-> st = LN;
dlink.c:          F-> en = LN;
dlink.c:          F-> cr = F-> en;
dlink.c:          LN-> nx = ( ( struct d_l * ) 0 ) ;
dlink.c:          LN-> pv = ( ( struct d_l * ) 0 ) ;
dlink.c:          LN-> bf = buf;
dlink.c:          LN-> nx = ( struct d_l * ) malloc ( sizeof ( struct d_l ) ) ;
dlink.c:          LN = LN-> nx;
dlink.c:          LN-> pv = tmp;
dlink.c:          LN-> nx = ( ( struct d_l * ) 0 ) ;
dlink.c:          LN-> bf = buf;
dlink.c:          F-> en = LN;
dlink.c:          F-> cr = F-> en;
dlink.c:      LN = F-> st;
dlink.c:          tmp = LN-> nx;
dlink.c:          if ( LN-> bf != ( void * ) 0 ) free ( LN-> bf ) ; free ( LN ) ;
dlink.c:      LN = F-> st;
dlink.c:          tmp = LN-> nx;
dlink.c:      if ( F != NULL ) F-> cr = F-> st;
dlink.c:      if ( F != NULL ) F-> cr = F-> en;
dlink.c:      if ( LN-> cr == LN-> st ) return;
dlink.c:      if ( LN-> st == ( ( void * ) 0 ) ) return;
dlink.c:      if ( LN-> cr == ( ( void * ) 0 ) ) { LN-> cr = LN-> en;n--;}
dlink.c:      pt = LN-> cr-> pv;
dlink.c:          LN-> cr = pt;
dlink.c:          pt = LN-> cr-> pv;
dlink.c:      if ( LN-> en == LN-> cr ) return;
dlink.c:      pt = LN-> cr-> nx;
dlink.c:          LN-> cr = pt;
dlink.c:          pt = LN-> cr-> nx;
dlink.c:      if ( LN-> cr == ( ( void * ) 0 ) ) return;
dlink.c:      pt = LN-> cr-> nx;
dlink.c:      pv = LN-> cr-> pv;
dlink.c:          free ( LN-> cr-> bf ) ;
dlink.c:          free ( LN-> cr ) ;
dlink.c:          if ( pt == ( ( void * ) 0 ) ) {LN-> cr = ( void * ) 0; break;}
dlink.c:          LN-> cr = pt;
dlink.c:          pt = LN-> cr-> nx;
dlink.c:      pt = LN-> cr;
dlink.c:          if ( pv != ( ( struct d_l * ) 0 ) ) {LN-> cr = pv;
dlink.c:          pv-> nx = ( ( struct d_l * ) 0 ) ;LN-> en = pv;}
dlink.c:          else { LN-> cr = ( ( D_l * ) 0 ) ; LN-> st = ( 
dlink.c:              ( D_l * ) 0 ) ; LN-> en = ( ( D_l * ) 0 ) ;}
dlink.c:          if ( pv != ( ( void * ) 0 ) ) pv-> nx = pt;
dlink.c:          else {LN-> cr-> pv = ( ( struct d_l * ) 0 ) ;LN-> st = LN-> cr;}
dlink.c:          if ( pt != ( ( void * ) 0 ) ) pt-> pv = pv;
dlink.c:      if ( LN-> cr == ( ( void * ) 0 ) ) return NULL;
dlink.c:      pt = LN-> cr-> nx;
dlink.c:      pv = LN-> cr-> pv;
dlink.c:          tmp = ( void * ) ( LN-> cr-> bf ) ;
dlink.c:          free ( LN-> cr ) ;
dlink.c:          LN-> cr = pt;
dlink.c:          pt = LN-> cr-> nx;
dlink.c:      pt = LN-> cr;
dlink.c:          if ( pv != ( ( D_l * ) 0 ) ) {LN-> cr = pv;pv-> nx = 
dlink.c:              ( ( struct d_l * ) 0 ) ;LN-> en = pv;}
dlink.c:          else { LN-> cr = ( ( D_l * ) 0 ) ; LN-> st = ( 
dlink.c:              ( D_l * ) 0 ) ; LN-> en = ( ( D_l * ) 0 ) ;}
dlink.c:          if ( pv != ( ( void * ) 0 ) ) pv-> nx = pt;
dlink.c:          else {LN-> cr-> pv = ( ( struct d_l * ) 0 ) ;LN-> st = LN-> cr;}
dlink.c:          if ( pt != ( ( void * ) 0 ) ) pt-> pv = pv;
dlink.c:      if ( F-> cr == ( ( void * ) 0 ) ) F-> cr = F-> en;
dlink.c:      if ( ( F-> st == ( ( void * ) 0 ) ) || ( F-> cr == ( ( void * ) 0 ) ) ) {
dlink.c:          LN = F-> cr;
dlink.c:          tmp-> nx = LN;
dlink.c:          tmp-> pv = LN-> pv;
dlink.c:          tmp-> bf = buf;
dlink.c:          if ( tmp-> pv == ( ( void * ) 0 ) ) { F-> st = tmp; }
dlink.c:          else {tmp-> pv-> nx = tmp;}
dlink.c:          F-> cr = tmp;
dlink.c:          LN-> pv = tmp;
dlink.c:      if ( F-> en == F-> cr ) F-> cr = ( ( D_l * ) 0 ) ;
dlink.c:      if ( ( F-> st == ( ( void * ) 0 ) ) || ( F-> cr == ( ( void * ) 0 ) ) ) {
dlink.c:          LN = F-> cr-> nx;
dlink.c:          tmp-> nx = LN;
dlink.c:          tmp-> pv = LN-> pv;
dlink.c:          tmp-> bf = buf;
dlink.c:          tmp-> pv-> nx = tmp;
dlink.c:          F-> cr = tmp;
dlink.c:          LN-> pv = tmp;
dlink.c:      pt = LN-> st;
dlink.c:          Dadd ( tmp , pt-> bf ) ;
dlink.c:          pt = pt-> nx;
dlink.c:      pt = LN-> st;
dlink.c:          if ( Dcondition ( s , pt-> bf ) ) Dadd ( tmp , pt-> bf ) ;
dlink.c:          pt = pt-> nx;
dlink.c:      pt = LN-> st;
dlink.c:          if ( Dcondition ( s , pt-> bf ) ) {
dlink.c:              LN-> cr = pt;
dlink.c:          pt = pt-> nx;
dlink.c:      pt = LN-> st;
dlink.c:          Dadd ( tmp , Dnewrule ( pt-> bf ) ) ;
dlink.c:          pt = pt-> nx;
dlink.c:      int ret = -1;
dlink.c:      tmp = LN-> st;
dlink.c:      while ( tmp-> nx != NULL ) {
dlink.c:          pt = tmp-> nx;
dlink.c:              if ( Dcmpitems ( pos-> bf , pt-> bf ) > 0 ) 
dlink.c:              pt = pt-> nx;
dlink.c:              dum = tmp-> bf;
dlink.c:              tmp-> bf = pos-> bf;
dlink.c:              pos-> bf = dum;
dlink.c:          tmp = tmp-> nx;
dlink.c:      tmp = LN-> st;
dlink.c:      pt = tmp-> nx;
dlink.c:          pos = LN-> st;
dlink.c:              if ( Dcmpitems ( pos-> bf , pt-> bf ) > 0 ) 
dlink.c:                   ( pt-> pv ) -> nx = pt-> nx;
dlink.c:                  if ( pt-> nx != NULL ) ( pt-> nx ) -> pv = pt-> pv;
dlink.c:                  else LN-> en = pt-> pv;
dlink.c:                  pt = pt-> nx;
dlink.c:                  if ( pos-> pv != NULL ) ( pos-> pv ) -> nx = tmp1;
dlink.c:                  tmp1-> pv = pos-> pv;
dlink.c:                  pos-> pv = tmp1;
dlink.c:                  tmp1-> nx = pos;
dlink.c:                  if ( pos == LN-> st ) LN-> st = tmp1;
dlink.c:              pos = pos-> nx;
dlink.c:          if ( pos == pt ) pt = pt-> nx;
dlink.c:       ( pt-> pv ) -> nx = pt-> nx; \
dlink.c:      if ( pt-> nx != NULL ) ( pt-> nx ) -> pv = pt-> pv; \
dlink.c:      else LN-> en = pt-> pv; \
dlink.c:      if ( pos-> pv != NULL ) ( pos-> pv ) -> nx = tmp1; \
dlink.c:      tmp1-> pv = pos-> pv; \
dlink.c:      pos-> pv = tmp1; \
dlink.c:      tmp1-> nx = pos; \
dlink.c:      if ( pos == LN-> st ) LN-> st = tmp1; \
dlink.c:      tmp = LN-> st;
dlink.c:      pt = tmp-> nx;
dlink.c:      pos = LN-> st;
dlink.c:      if ( Dcmpitems ( pos-> bf , pt-> bf ) > 0 ) { /* to be provided by user */ tmp1 = pt-> pv;
dlink.c:      pt = pt-> nx;
dlink.c:          pos = LN-> st;
dlink.c:          if ( Dcmpitems ( pos-> bf , pt-> bf ) > 0 ) { /* to be provided by user */ tmp1 = pt-> pv;
dlink.c:              pos = pt-> pv;
dlink.c:              if ( Dcmpitems ( pos-> bf , pt-> bf ) > 0 ) { /* to be provided by user */ tmp1 = pt-> pv;
dlink.c:                  cont1 = 1; cont2 = n-1;
dlink.c:                      tmp = LN-> cr;
dlink.c:                      if ( Dcmpitems ( tmp-> bf , pt-> bf ) > 0 ) {
dlink.c:          pt = pt-> nx;
dlink.c:/*------------------------------------------------------
dlink.c: ------------------------------------------------------ */
dlink.c:      LN = F-> st;
dlink.c:          LN = LN-> nx;
dlink.c:/*------------------------------------------------------
dlink.c: ------------------------------------------------------ */
dlink.c:      LN = F-> st;
dlink.c:      if ( n == 0 ) {F-> cr = F-> st; return;}
dlink.c:      if ( LN == ( void * ) 0 ) {F-> cr = NULL; return;}
dlink.c:          LN = LN-> nx;
dlink.c:      if ( LN == ( void * ) 0 ) LN = F-> en;
dlink.c:      F-> cr = LN;
dlink.c:/*------------------------------------------------------
dlink.c: ------------------------------------------------------ */
dlink.c:      d-> cr = d-> en;
dlink.c:      tmp = s-> st;
dlink.c:          Dadd ( d , tmp-> bf ) ;
dlink.c:          tmp = tmp-> nx;
dlink.c:/*------------------------------------------------------
dlink.c: ------------------------------------------------------ */
dlink.c:      tmp = LN-> st;
dlink.c:          sum += Dsumitem ( tmp-> bf ) ;
dlink.c:          tmp = tmp-> nx;
dlink.c:      tmp = LN-> st;
dlink.c:          sum += Dsumitem ( tmp-> bf ) ;
dlink.c:          tmp = tmp-> nx;
dlink.c:      tmp = LN-> st;
dlink.c:          sum += Dsumitem ( tmp-> bf ) ;
dlink.c:          tmp = tmp-> nx;
dlink.c:      t1 = L1-> st;
dlink.c:      t2 = L2-> st;
dlink.c:          if ( comprecord ( t1-> bf , t2-> bf ) != 1 ) return 0;
dlink.c:          t1 = t1-> nx;
dlink.c:          t2 = t2-> nx;
dlink.c:      tmp = L-> st;
dlink.c:          if ( write_link ( fp , tmp-> bf ) <= 0 ) {
dlink.c:              return -1;
dlink.c:          tmp = tmp-> nx;
dlink.c:          return -1;
dlink.c:              fclose ( fp ) ;return -1;
dlink.c:      if ( fwrite ( & count , sizeof ( int ) , 1 , fp ) <= 0 ) return -1;
dlink.c:      tmp = L-> st;
dlink.c:          if ( fwrite ( tmp-> bf , size_of_rec , 1 , fp ) <= 0 ) {
dlink.c:          tmp = tmp-> nx;
dlink.c:      tmp = L-> st;
dlink.c:          pt = ( char * ) ( tmp-> bf ) ;
dlink.c:          if ( tmp != L-> en ) {
dlink.c:              tmp1 = tmp-> nx;
dlink.c:                  pt1 = ( char * ) ( tmp1-> bf ) ;
dlink.c:                      L-> cr = tmp1;
dlink.c:                      if ( tmp1 == L-> en ) {
dlink.c:                      tmp1 = L-> cr;
dlink.c:                  else tmp1 = tmp1-> nx;
dlink.c:          tmp = tmp-> nx;
dlink.c:      tmp = L-> st;
dlink.c:          if ( tmp != L-> en ) {
dlink.c:              tmp1 = tmp-> nx;
dlink.c:                  if ( rule ( tmp-> bf , tmp1-> bf ) == 1 ) {
dlink.c:                      L-> cr = tmp1;
dlink.c:                      if ( tmp1 == L-> en ) {
dlink.c:                      tmp1 = L-> cr;
dlink.c:                      if ( tmp1 == L-> en ) break;
dlink.c:                  else tmp1 = tmp1-> nx;
dlink.c:          tmp = tmp-> nx;
dlink.c:      if ( L-> st == NULL ) return NULL;
dlink.c:      L-> cr = L-> st;
dlink.c:      return L-> cr-> bf;
dlink.c:      if ( ( L != NULL ) && ( L-> cr != NULL ) ) {
dlink.c:          tmp = L-> cr-> bf;
dlink.c:          L-> cr = L-> cr-> nx;
dlink.c:      if ( ( L != NULL ) && ( L-> cr != NULL ) ) {
dlink.c:          tmp = L-> cr-> bf;
dlink.c:          L-> cr = L-> cr-> pv;
dlink.c:              exit ( -1 ) ;
dlink.c:              exit ( -1 ) ;
dlink.c:          Tag1 [ strlen ( Tag1 ) -1 ] = '\0';
dlink.c:          Tag2 [ strlen ( Tag2 ) -1 ] = '\0';
dlink.c:      tmp = LN-> st;
dlink.c:      pt = tmp-> nx;
dlink.c:          pos = LN-> st;
dlink.c:              if ( Dcmpstring ( pos-> bf , pt-> bf , field , order ) > 0 ) {
dlink.c:                   ( pt-> pv ) -> nx = pt-> nx;
dlink.c:                  if ( pt-> nx != NULL ) ( pt-> nx ) -> pv = pt-> pv;
dlink.c:                  else LN-> en = pt-> pv;
dlink.c:                  pt = pt-> nx;
dlink.c:                  if ( pos-> pv != NULL ) ( pos-> pv ) -> nx = tmp1;
dlink.c:                  tmp1-> pv = pos-> pv;
dlink.c:                  pos-> pv = tmp1;
dlink.c:                  tmp1-> nx = pos;
dlink.c:                  if ( pos == LN-> st ) LN-> st = tmp1;
dlink.c:              pos = pos-> nx;
dlink.c:          if ( pos == pt ) pt = pt-> nx;
dlink.c:              exit ( -1 ) ;
dlink.c:              exit ( -1 ) ;
dlink.c:          Tag1 [ strlen ( Tag1 ) -1 ] = '\0';
dlink.c:          Tag2 [ strlen ( Tag2 ) -1 ] = '\0';
dlink.c:      tmp = LN-> st;
dlink.c:      pt = tmp-> nx;
dlink.c:          pos = LN-> st;
dlink.c:              if ( Dcmpnumber ( pos-> bf , pt-> bf , field , order ) > 0 ) {
dlink.c:                   ( pt-> pv ) -> nx = pt-> nx;
dlink.c:                  if ( pt-> nx != NULL ) ( pt-> nx ) -> pv = pt-> pv;
dlink.c:                  else LN-> en = pt-> pv;
dlink.c:                  pt = pt-> nx;
dlink.c:                  if ( pos-> pv != NULL ) ( pos-> pv ) -> nx = tmp1;
dlink.c:                  tmp1-> pv = pos-> pv;
dlink.c:                  pos-> pv = tmp1;
dlink.c:                  tmp1-> nx = pos;
dlink.c:                  if ( pos == LN-> st ) LN-> st = tmp1;
dlink.c:              pos = pos-> nx;
dlink.c:          if ( pos == pt ) pt = pt-> nx;
dlink.c:          if ( pt [ 0 ] == '-' ) Dappend ( FlagsList , pt ) ;
dlink.c:          if ( pt [ 0 ] != '-' ) Dappend ( ArgsList , pt ) ;
dlink.c:          if ( strncmp ( flag , "--" , 2 ) == 0 ) {
dlink.c:                  if ( Farg [ 0 ] == '-' ) {
dlink.c:                      fprintf ( stderr , "Error: Invalid arg for '%-s'\n" , flag ) ;
dlink.c:                          fprintf ( stderr , "Error: Invalid arg for '%-s'\n" , flag ) ;
dlink.c:                      if ( Farg [ 0 ] == '-' ) {
dlink.c:                          fprintf ( stderr , "Error: Invalid arg for '%-s'\n" , flag ) ;
dlink.c:                              fprintf ( stderr , "Error: Invalid arg for '%-s'\n" , flag ) ;
dlink.c:              Matched = ( ( strncmp ( pt , "--" , 2 ) != 0 ) && ( strncmp ( pt , fargpt [ j ] .flag , 2 ) == 0 ) ) 
dlink.c:          exit ( -1 ) ;
dlink.c:          exit ( -1 ) ;
dlink.c:          exit ( -1 ) ;
dlink.c:          exit ( -1 ) ;
dlink.c:          exit ( -1 ) ;
dlink.c:      Dposition ( L , pos-1 ) ;
dlink.c:	 * return -1 if rec field < name
dlink.c:      char *field = recv-> Flag;;
dlink.c://	return (recv - val);
dlink.c:      int mid , low = 0 , up = count-1 , cmp;
dlink.c:          else up = mid-1;
drawimg.c: if(dc->greek> 0) {\
drawimg.c:   dc->icpos = dc->icpostmp;\
drawimg.c:   dc->icxv = dc->icxvtmp;\
drawimg.c:   dc->icyv = dc->icyvtmp;\
drawimg.c: if(dc->greek> 0) {\
drawimg.c:   dc->icpostmp = dc->icpos;\
drawimg.c:   dc->icxvtmp = dc->icxv;\
drawimg.c:   dc->icyvtmp = dc->icyv;\
drawimg.c:   dc->icpos = dc->icposf0;\
drawimg.c:   dc->icxv = dc->icxvf0;\
drawimg.c:   dc->icyv = dc->icyvf0;\
drawimg.c:#define uiset_sup_clip_limits(wc,x1,y1,x2,y2) wc->s_v_x1=x1,wc->s_v_y1=y1,wc->s_v_x2=x2,wc->s_v_y2=y2
drawimg.c:#define uiset_clip_limits(wc,x1,y1,x2,y2) wc->c_v_x1=x1,wc->c_v_y1=y1,wc->c_v_x2=x2,wc->c_v_y2=y2
drawimg.c:  pixels = G->pixels;
drawimg.c:  wc = G->wc;
drawimg.c:  no = wc->c_color;
drawimg.c:  loc = (y*(wc->EVGAY)+x);
drawimg.c:  kgcolors = wc->kgcolors;
drawimg.c:  pixels = G->pixels;
drawimg.c:  wc = G->wc;
drawimg.c:  kgcolors = wc->kgcolors;
drawimg.c:  dc= G->dc;
drawimg.c:  wc =G->wc;
drawimg.c:  Dimg = G->img;
drawimg.c:  iw = Dimg->image_width;
drawimg.c:  ih = Dimg->image_height; 
drawimg.c:  w  = Simg->image_width;
drawimg.c:  h  = Simg->image_height;
drawimg.c:  channels= Simg->image_channels;
drawimg.c:  cx0=wc->c_v_x1;
drawimg.c:  cx1=wc->c_v_x2;
drawimg.c:  cy0=dc->EVGAY-1-wc->c_v_y2;
drawimg.c:  cy1=dc->EVGAY-1-wc->c_v_y1;
drawimg.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,((Image *)(Simg->image))->columns,((Image *)(Simg->image))->rows);
drawimg.c:  pixels = G->pixels;
drawimg.c:#define Fpart(x) ((x)-Ipart(x))
drawimg.c:#define Rfpart(x) ( 1-Fpart(x))
drawimg.c:   steep= (abs(y1 - y0) > abs(x1 - x0))?1:0;
drawimg.c:   dx = x1 - x0;
drawimg.c:   dy = y1 - y0;
drawimg.c:   yend = y0 + gradient * (xend - x0);
drawimg.c:   yend = y1 + gradient * (xend - x1);
drawimg.c:   for (x =xpxl1 + 1 ;x<=xpxl2 - 1;x++ ) {
drawimg.c:static char FontName[30]={"Times-Roman"};
drawimg.c:#define TX(x,y) (dc->cx +(x)*dc->cost+(y)*dc->sint)
drawimg.c:#define TY(x,y) (dc->cy -(x)*dc->sint+(y)*dc->cost)
drawimg.c:#define scr_x(x) (int)((x-dc->w_x1)*dc->u_x+0.5)
drawimg.c:#define fscr_y(y) (float)((y-dc->w_y1)*dc->u_y)
drawimg.c:#define fscr_x(x) (float)((x-dc->w_x1)*dc->u_x)
drawimg.c:#define scr_y(y) (int)((y-dc->w_y1)*dc->u_y+0.5)
drawimg.c:#define scr_z(z) (int)((z-dc->clip_min)*dc->CPCONS+0.5);
drawimg.c:#define fscr_z(z) (float)((z-dc->clip_min)*dc->CPCONS);
drawimg.c:#define cnv_x(x) (x*fx-sx)
drawimg.c:#define cnv_y(y) (y*fy-sy)
drawimg.c:#define set_clip_limits(x1,y1,x2,y2,x3,y3) wc->c_v_x1=x1,wc->c_v_y1=y1,wc->c_v_x2=x2,wc->c_v_y2=y2
drawimg.c:#define set_sup_clip_limits(x1,y1,x2,y2) wc->s_v_x1=x1,wc->s_v_y1=y1,wc->s_v_x2=x2,wc->s_v_y2=y2
drawimg.c:#define pclr(p)  (float)(((p-dc->pmin)*dc->dfac+0.))
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  dc->c_color=dc->ln_color;
drawimg.c:  dc= G->dc;
drawimg.c:  dc->c_color=dc->ln_color;
drawimg.c:  dc= G->dc;
drawimg.c:  xa=(int)(x1*dc->u_x);
drawimg.c:  ya=(int)(y1*dc->u_y);
drawimg.c:  xb=(int)(x2*dc->u_x);
drawimg.c:  yb=(int)(y2*dc->u_y);
drawimg.c:  dc->c_color=dc->ln_color;
drawimg.c:  dc= G->dc;
drawimg.c:  xa=(int)(x1*dc->u_x);
drawimg.c:  ya=(int)(y1*dc->u_y);
drawimg.c:  xb=(int)(x2*dc->u_x);
drawimg.c:  yb=(int)(y2*dc->u_y+0);
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  rd-=xa;
drawimg.c:  dc->c_color=dc->ln_color;
drawimg.c:  dc= G->dc;
drawimg.c:  xa=(int)(x1*dc->u_x);
drawimg.c:  ya=(int)(y1*dc->u_y+dc->v_y1);
drawimg.c:  rd=(int)(r/dc->r_d*dc->v_r);
drawimg.c:  dc= G->dc;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  row1 = dc->EVGAY-1-row;
drawimg.c:  if ((col > wc->c_v_x2) || (col <wc->c_v_x1) || (row1 > wc->c_v_y2) || (row1 <wc->c_v_y1)) return;
drawimg.c:  zbuf = ((kgDC *)(G->dc))->zbuf;
drawimg.c:  EVGAX = dc->EVGAX;
drawimg.c:   CPCONS = 65000./(float)(clip_max-clip_min);
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  dc->cur_x=xp ;
drawimg.c:  dc->cur_y=yp ;
drawimg.c:  dc->cur_z=zp;
drawimg.c:  dc= G->dc;
drawimg.c:  dc->cur_x=x1 ;
drawimg.c:  dc->cur_y=y1 ;
drawimg.c:  dc->cur_z=z1;
drawimg.c: dc= G->dc;
drawimg.c: EVGAY= dc->EVGAY-1;
drawimg.c: xf=x2-x1;yf=y2-y1;
drawimg.c:  else m = (float)(z2-z1)/(float)(yf);
drawimg.c:  cons = z1 - y1*m;
drawimg.c:  m = (float)(z2-z1)/(float)(xf);
drawimg.c:  cons = z1 - x1*m;
drawimg.c:	  dx=xb-xa;
drawimg.c:	  dy=yb-ya;
drawimg.c:		 g=inc1-dx1;
drawimg.c:		 inc2=g-dx1;
drawimg.c:		 else ch=-1;
drawimg.c:		 else rh=-1;
drawimg.c:/*        while (labs(c-f)>0)*/
drawimg.c:		 r = EVGAY-r;
drawimg.c:		    if (g > 0) { r-=rh; g+=inc2; }
drawimg.c:	  put_pix3(G,xb,(EVGAY-yb),z);
drawimg.c:		 g=inc1-dy1;
drawimg.c:		 inc2=g-dy1;
drawimg.c:		 else ch=-1;
drawimg.c:		 else rh=-1;
drawimg.c:/*        while (labs(c-f)>0)*/
drawimg.c:		 c = EVGAY-c;
drawimg.c:		 f = EVGAY-f;
drawimg.c:		   z = z_inter((EVGAY-c),m,cons);
drawimg.c:		   c-=ch;
drawimg.c:	  put_pix3(G,xb,(EVGAY-yb),z);
drawimg.c:              put_pix3(G,xa,(EVGAY-i),z);}
drawimg.c:	    put_pix3(G,i,(EVGAY-ya),z);
drawimg.c:  dc= G->dc;
drawimg.c:   if( dc->ln_width ==1){ _draw_line3( G,xa, ya, za, xb, yb, zb);return;};
drawimg.c:   i2=dc->ln_width/2;
drawimg.c:   dx = (float)(xb-xa);
drawimg.c:   dy = (float)(yb-ya);
drawimg.c:   if( ct< 0.) dy1 =(int)( ct*i2-0.5);
drawimg.c:   xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
drawimg.c:   for (i=1;i<dc->ln_width;i++)
drawimg.c:	     if( ct< 0.) dy1 =(int)( ct*i-0.5);
drawimg.c:	    _draw_line3( G,xa-dx1,ya+dy1,za,xb-dx1,yb+dy1,zb);
drawimg.c:  dc= G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:     put_pix3(G,xa,(EVGAY-y),za);
drawimg.c:  m = (float)(z2-z1)/(float)(x2-x1);
drawimg.c:  cons = z1 - x1*m;
drawimg.c:  for(i=xa;i<=xb;i++) {z=z_inter(i,m,cons);put_pix3(G,i,(EVGAY-y),z);}
drawimg.c:  dc= G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  xa=dc->cur_x;
drawimg.c:  ya=dc->cur_y;
drawimg.c:  za=dc->cur_z;
drawimg.c:	dc->cur_x=x;
drawimg.c:	dc->cur_y=y;
drawimg.c:	dc->cur_z=z;
drawimg.c:  if (dc->cur_x == x)
drawimg.c:    m = (float)(y-dc->cur_y)/(float)(z-dc->cur_z);
drawimg.c:    cons = dc->cur_z - dc->cur_y*m;  
drawimg.c:    m = (float)(x-dc->cur_x)/(float)(z-dc->cur_z);
drawimg.c:    cons = dc->cur_z - dc->cur_x*m;  
drawimg.c:   dx=xb-xa;
drawimg.c:   dy=yb-ya;
drawimg.c:    g=inc1-dx1;
drawimg.c:    inc2=g-dx1;
drawimg.c:    else ch=-1;
drawimg.c:    else rh=-1;
drawimg.c:    g=inc1-dy1;
drawimg.c:    inc2=g-dy1;
drawimg.c:    else ch=-1;
drawimg.c:    else rh=-1;
drawimg.c:   while (abs(c-f)>0)
drawimg.c:     while ((i<=dc->ln_style) && (abs(c-f)>0))
drawimg.c:	 if ( dx1 > dy1 ) {z=z_inter(c,m,cons);put_pix3(G,c,(EVGAY-r),z);}
drawimg.c:	 else   {z=z_inter(r,m,cons);put_pix3(G,r,(EVGAY-c),z);}
drawimg.c:    while ((i<=dc->ln_style) && (abs(c-f)>0))
drawimg.c:    dc->cur_x=x;
drawimg.c:    dc->cur_y=y;
drawimg.c:    dc->cur_z=z;
drawimg.c:   dc= G->dc;
drawimg.c:   xa=dc->cur_x;
drawimg.c:   ya=dc->cur_y;
drawimg.c:   za=dc->cur_z;
drawimg.c:   if ( dc->ln_style == 0) {
drawimg.c:     if(dc->ln_width==1) _draw3_(G, x,y,z);
drawimg.c:      i2=dc->ln_width/2;
drawimg.c:      dx = (float)(xb-xa);
drawimg.c:      dy = (float)(yb-ya);
drawimg.c:      if( ct< 0.) dy1 =(int)( ct*i2-0.5);
drawimg.c:      xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
drawimg.c:      dc->cur_x=xa,dc->cur_y=ya; dc->cur_z = za;
drawimg.c:      for (i=1;i<dc->ln_width;i++)
drawimg.c:             if( ct< 0.) dy1 =(int)( ct*i-0.5);
drawimg.c:             dc->cur_x=xa-dx1,dc->cur_y=ya+dy1;
drawimg.c:            _draw3_(G, xb-dx1,yb+dy1,zb);
drawimg.c:   dc->cur_x=x;
drawimg.c:   dc->cur_y=y;
drawimg.c:   dc->cur_z=z;
drawimg.c:  dc= G->dc;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  xup =-1000000;
drawimg.c:  ygrt=-1239000;
drawimg.c:	j=i-1;
drawimg.c:	  j--;
drawimg.c:  if((scan> (dc->EVGAY-1)) || (ygrt< 0) || (xlow> (dc->EVGAX-1)) || (xup< 0)) return;
drawimg.c:  tempc = dc->c_color;
drawimg.c:  dc->c_color= b_color;
drawimg.c:         if(scan>(dc->EVGAY-1)) break;
drawimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
drawimg.c:                   zcord[cnt]=(((float)(zmax[i]-zmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +zmin[i]));
drawimg.c:		j=i-1;
drawimg.c:		while(j>=0 && txx < xcord[j]){ zcord[j+1]=zcord[j];xcord[j+1]=xcord[j];j--;}
drawimg.c:  dc->c_color=dc->ln_color;
drawimg.c:  wc = G->wc;
drawimg.c:  dc=G->dc;
drawimg.c:  xup =-100000000;
drawimg.c:  ygrt=-123900000;
drawimg.c:  temp =wc->c_color;
drawimg.c:	j=i-1;
drawimg.c:	  j--;
drawimg.c:  if((scan> wc->c_v_y2)||(ygrt< wc->c_v_y1)||(xlow> wc->c_v_x2)||(xup< wc->c_v_x1)) return; 
drawimg.c:         if(scan<wc->c_v_y1) {scan++;continue;}
drawimg.c:         if(scan>wc->c_v_y2) break;
drawimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
drawimg.c:                   zcord[cnt]=(((float)(zmax[i]-zmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +zmin[i])+0.5);
drawimg.c:                   pcord[cnt]=(((float)(pmax[i]-pmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +pmin[i]));
drawimg.c:		j=i-1;
drawimg.c:                     pcord[j+1]=pcord[j];j--;}
drawimg.c:  dc->c_color=dc->ln_color;
drawimg.c:  wc = G->wc;
drawimg.c:  dc=G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  yy = EVGAY-y;
drawimg.c:  if((y>wc->c_v_y2) || (y<wc->c_v_y1) ) return;
drawimg.c:  if(p1<1) p1=dc->Cutoff;
drawimg.c:  if(p2<1) p2=dc->Cutoff;
drawimg.c:  if(p1>dc->max_clr) p1=dc->max_clr;
drawimg.c:  if(p2>dc->max_clr) p2=dc->max_clr;
drawimg.c:        tempc=dc->c_color;
drawimg.c:        if(p1>= 0) c_color=p1+dc->min_clr;
drawimg.c:        else c_color=dc->min_clr;
drawimg.c:        dc->c_color=c_color;
drawimg.c:        dc->c_color=tempc;
drawimg.c:  if (xa>wc->c_v_x2) return;
drawimg.c:  if (xb<wc->c_v_x1) return;
drawimg.c:  if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  if(xa<wc->c_v_x1) {
drawimg.c:       pval = pa+(wc->c_v_x1-xa)*pfac;
drawimg.c:       xa= wc->c_v_x1;
drawimg.c:       if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  if(xb>wc->c_v_x2) {
drawimg.c:       pval = pa+(wc->c_v_x2-xa)*pfac;
drawimg.c:       xb= wc->c_v_x2;
drawimg.c:       if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  m = (double)(z2-z1)/(double)(x2-x1);
drawimg.c:  cons = z1 - x1*m;
drawimg.c:    temp=(char)(pa+(i-xa)*pfac+0.5);
drawimg.c:    if(temp<1) temp=dc->Cutoff;
drawimg.c:    if(temp>dc->max_clr) temp=dc->max_clr;
drawimg.c:    if(temp >= 0 ) temp +=dc->min_clr;
drawimg.c:    dc->c_color=temp;
drawimg.c:  dc->c_color=c_color;
drawimg.c:  wc = G->wc;
drawimg.c:  dc=G->dc;
drawimg.c:  xup =-100000000;
drawimg.c:  ygrt=-123900000;
drawimg.c:  temp =dc->c_color;
drawimg.c:	j=i-1;
drawimg.c:	  j--;
drawimg.c:  if((scan> wc->c_v_y2)||(ygrt< wc->c_v_y1)||(xlow> wc->c_v_x2)||(xup< wc->c_v_x1)) return; 
drawimg.c:         if(scan<wc->c_v_y1) {scan++;continue;}
drawimg.c:         if(scan>wc->c_v_y2) break;
drawimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
drawimg.c:                   zcord[cnt]=(((float)(zmax[i]-zmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +zmin[i])+0.5);
drawimg.c:                   pcord[cnt]=(((float)(pmax[i]-pmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +pmin[i]));
drawimg.c:		j=i-1;
drawimg.c:                     pcord[j+1]=pcord[j];j--;}
drawimg.c:  dc->c_color = dc->ln_color;
drawimg.c:  wc = G->wc;
drawimg.c:  dc=G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  yy = EVGAY-y;
drawimg.c:  if((y>wc->c_v_y2) || (y<wc->c_v_y1) ) return;
drawimg.c:  if (xa>wc->c_v_x2) return;
drawimg.c:  if (xb<wc->c_v_x1) return;
drawimg.c:  if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  if(xa<wc->c_v_x1) {
drawimg.c:       pval = pa+(wc->c_v_x1-xa)*pfac;
drawimg.c:       xa= wc->c_v_x1;
drawimg.c:       if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  if(xb>wc->c_v_x2) {
drawimg.c:       pval = pa+(wc->c_v_x2-xa)*pfac;
drawimg.c:       xb= wc->c_v_x2;
drawimg.c:       if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  else m = (double)(z2-z1)/(double)(x2-x1);
drawimg.c:  cons = z1 - x1*m;
drawimg.c:    tempp=(pa+(i-xa)*pfac);
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:    m = (float)(z2-z1)/(float)(y2-y1);
drawimg.c:    cons = z1 - y1*m;
drawimg.c:    m = (float)(z2-z1)/(float)(x2-x1);
drawimg.c:    cons = z1 - x1*m;
drawimg.c:  temp=dc->c_color;
drawimg.c:  dc->c_color=color;
drawimg.c:  if(( x_min<=(dc->EVGAX-1)) && (x_max1>=0))
drawimg.c:    if(( y_min<=(dc->EVGAY-1)) && (y_max>=0))
drawimg.c:      if(x_max1>(dc->EVGAX-1)) x_max1 = (dc->EVGAX-1);
drawimg.c:      if(y_max>(dc->EVGAY-1)) y_max = (dc->EVGAY-1);
drawimg.c:           {z=z_inter(x_min,m,cons);put_pix3(G,x_min,EVGAY-j,z);}
drawimg.c:  dc->c_color=temp;
drawimg.c:  dc= G->dc;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  xup =-100000;
drawimg.c:  ygrt=-1239000;
drawimg.c:  tempc=dc->c_color;
drawimg.c:j=i-1;
drawimg.c:  j--;
drawimg.c:  if((scan> wc->c_v_y2) || (ygrt< wc->c_v_y1) || (xlow> wc->c_v_x2) || (xup< wc->c_v_x1)) return;
drawimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
drawimg.c:                   pcord[cnt]=(((float)(pmax[i]-pmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +pmin[i]));
drawimg.c:j=i-1;
drawimg.c:                     pcord[j+1]=pcord[j];j--;}
drawimg.c:  dc->c_color = dc->ln_color;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  c_color=dc->c_color;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  if((y>wc->c_v_y2) || (y<wc->c_v_y1) ) return;
drawimg.c:  yy = EVGAY-y;
drawimg.c:  if(p1<1) p1=dc->Cutoff;
drawimg.c:  if(p2<1) p2=dc->Cutoff;
drawimg.c:  if(p1>dc->max_clr) p1=dc->max_clr;
drawimg.c:  if(p2>dc->max_clr) p2=dc->max_clr;
drawimg.c:        if(p1>=0)p1 +=dc->min_clr;
drawimg.c:        tempc=dc->c_color;
drawimg.c:        dc->c_color = p1;
drawimg.c:        dc->c_color = tempc;
drawimg.c:    if (xa>wc->c_v_x2) return;
drawimg.c:    if (xb<wc->c_v_x1) return;
drawimg.c:    if (xb>wc->c_v_x2) return;
drawimg.c:    if (xa<wc->c_v_x1) return;
drawimg.c:  if(xb != xa) pfac = (pb-pa)/(xb-xa);
drawimg.c:  if(xa<wc->c_v_x1) {
drawimg.c:       pval = pa+(wc->c_v_x1-xa)*pfac;
drawimg.c:       xa= wc->c_v_x1;
drawimg.c:  if(xb>wc->c_v_x2) {
drawimg.c:       pval = pa+(wc->c_v_x2-xa)*pfac;
drawimg.c:       xb= wc->c_v_x2;
drawimg.c:    tempc=(int)(pa+(i-xa)*pfac+0.5);
drawimg.c:    if(tempc<1) tempc=dc->Cutoff;
drawimg.c:    if(tempc>dc->max_clr) tempc=dc->max_clr;
drawimg.c:    if(tempc >= 0) tempc +=dc->min_clr;
drawimg.c:    dc->c_color =tempc;
drawimg.c:  dc->c_color=c_color;
drawimg.c:  dc= G->dc;
drawimg.c:  dc= G->dc;
drawimg.c:  _godard_fill3(G,(short)n,x1,y1,z1,(short)dc->ibdr,p1);
drawimg.c:   if( (lt2->zmax < lt1->zmax )) return 1;
drawimg.c:  dc = G->dc;
drawimg.c:  dc->cur_x=xp ;
drawimg.c:  dc->cur_y=yp ;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  style = dc->m_style%20;
drawimg.c:  mf = dc->m_style/20;
drawimg.c:                 _draw_line(G,x-3*fac,y-3*fac,x+3*fac,y+3*fac);
drawimg.c:                 _draw_line(G,x-3*fac,y+3*fac,x+3*fac,y-3*fac);
drawimg.c:                 _box_fill(G,x-3*fac,y-3*fac,x+3*fac,y+3*fac,(unsigned int)15);
drawimg.c:	case 3 : _draw_line(G,x,y-4*fac,x,y+4*fac);
drawimg.c:				_draw_line(G,x-4*fac,y,x+4*fac,y);
drawimg.c:				_draw_line(G,x-2*fac,y-4*fac,x+2*fac,y-4*fac);
drawimg.c:				_draw_line(G,x-2*fac,y+4*fac,x+2*fac,y+4*fac);
drawimg.c:				_draw_line(G,x-4*fac,y-2*fac,x-4*fac,y+2*fac);
drawimg.c:				_draw_line(G,x+4*fac,y-2*fac,x+4*fac,y+2*fac);
drawimg.c:	case 4 : _draw_line(G,x-4*fac,y-4*fac,x+4*fac,y+4*fac);
drawimg.c:				_draw_line(G,x-4*fac,y+4*fac,x+4*fac,y-4*fac);
drawimg.c:				_draw_line(G,x-4*fac,y,x+4*fac,y);
drawimg.c:				_draw_line(G,x,y-4*fac,x,y+4*fac);
drawimg.c:	case 5 : _draw_line(G,x+3*fac,y,x,y-8*fac);
drawimg.c:				_draw_line(G,x-3*fac,y,x,y-8*fac);
drawimg.c:				_draw_line(G,x-3*fac,y,x,y+8*fac);
drawimg.c:	case 6 : _draw_line(G,x-4*fac,y,x+4*fac,y);
drawimg.c:				_draw_line(G,x,y-4*fac,x,y+4*fac);
drawimg.c:				_draw_line(G,x+2*fac,y-2*fac,x+2*fac,y+2*fac);
drawimg.c:				_draw_line(G,x+2*fac,y+2*fac,x-2*fac,y+2*fac);
drawimg.c:				_draw_line(G,x-2*fac,y+2*fac,x-2*fac,y-2*fac);
drawimg.c:				_draw_line(G,x-2*fac,y-2*fac,x+2*fac,y-2*fac);
drawimg.c:				_draw_line(G,x+7*fac,y,x+3*fac,y-3*fac);
drawimg.c:				_draw_line(G,x+3*fac,y-3*fac,x,y-7*fac);
drawimg.c:				_draw_line(G,x,y-7*fac,x-3*fac,y-3*fac);
drawimg.c:				_draw_line(G,x-3*fac,y-3*fac,x-7*fac,y);
drawimg.c:				_draw_line(G,x-7*fac,y,x-3*fac,y+3*fac);
drawimg.c:				_draw_line(G,x-3*fac,y+3*fac,x,y+7*fac);
drawimg.c:	case 8 : _draw_line(G,x-4*fac,y-4*fac,x+4*fac,y+4*fac);
drawimg.c:				_draw_line(G,x+4*fac,y-4*fac,x-4*fac,y+4*fac);
drawimg.c:				_draw_line(G,x+4*fac,y-4*fac,x+4*fac,y-2*fac);
drawimg.c:				_draw_line(G,x+4*fac,y-4*fac,x+2*fac,y-4*fac);
drawimg.c:				_draw_line(G,x-4*fac,y-4*fac,x-2*fac,y-4*fac);
drawimg.c:				_draw_line(G,x-4*fac,y-4*fac,x-4*fac,y-2*fac);
drawimg.c:				_draw_line(G,x-4*fac,y+4*fac,x-4*fac,y+2*fac);
drawimg.c:				_draw_line(G,x-4*fac,y+4*fac,x-2*fac,y+4*fac);
drawimg.c:                 px[0]=x+4*fac;py[0]=y;px[1]=x-4*fac;py[1]=y+4*fac;
drawimg.c:                 px[2]=x-4*fac;py[2]=y-4*fac;
drawimg.c:                 px[0]=x-4*fac;py[0]=y;px[1]=x+4*fac;py[1]=y+4*fac;
drawimg.c:                 px[2]=x+4*fac;py[2]=y-4*fac;
drawimg.c:                 px[0]=x;py[0]=y+4*fac;px[1]=x-4*fac;py[1]=y-4*fac;
drawimg.c:                 px[2]=x+4*fac;py[2]=y-4*fac;
drawimg.c:                 px[0]=x;py[0]=y-4*fac;px[1]=x-4*fac;py[1]=y+4*fac;
drawimg.c:                 _draw_line(G,x-2*fac,y-2*fac,x+2*fac,y+2*fac);
drawimg.c:                 _draw_line(G,x-2*fac,y+2*fac,x+2*fac,y-2*fac);
drawimg.c:                 px[0]=x+2*fac;py[0]=y;px[1]=x-2*fac;py[1]=y+2*fac;
drawimg.c:                 px[2]=x-2*fac;py[2]=y-2*fac;
drawimg.c:                 px[0]=x-2*fac;py[0]=y;px[1]=x+2*fac;py[1]=y+2*fac;
drawimg.c:                 px[2]=x+2*fac;py[2]=y-2*fac;
drawimg.c:                 px[0]=x;py[0]=y+2*fac;px[1]=x-2*fac;py[1]=y-2*fac;
drawimg.c:                 px[2]=x+2*fac;py[2]=y-2*fac;
drawimg.c:                 px[0]=x;py[0]=y-2*fac;px[1]=x-2*fac;py[1]=y+2*fac;
drawimg.c:  dc = G->dc;
drawimg.c:  dc->c_color=color;
drawimg.c:  dc = G->dc;
drawimg.c:  dc->ln_style=style;
drawimg.c:  if (y > wc->c_v_y2) t|=0x08;
drawimg.c:  if (y < wc->c_v_y1) t|=0x04;
drawimg.c:  if (x > wc->c_v_x2) t|=0x02;
drawimg.c:  if (x < wc->c_v_x1) t++;
drawimg.c:  wc = G->wc;
drawimg.c:  xs = wc->c_v_x1;
drawimg.c:  ys = wc->c_v_y1;
drawimg.c:         tx = ((*xb)-(*xa));
drawimg.c:         ty = ((*yb)-(*ya));
drawimg.c:                y=(int)(*ya+(wc->c_v_x1-(*xa))*ty/tx);
drawimg.c:                if ((y==ys) && ((ys>wc->c_v_y2) || (ys<wc->c_v_y1))) return(0);
drawimg.c:                x=wc->c_v_x1;
drawimg.c:                y=(int)(*ya+(wc->c_v_x2-(*xa))*ty/tx);
drawimg.c:                if ((y==ys) && ((ys>wc->c_v_y2) || (ys<wc->c_v_y1))) return(0);
drawimg.c:                x=wc->c_v_x2;
drawimg.c:                x=(int)(*xa+(wc->c_v_y2-(*ya))*tx/ty);
drawimg.c:                if (x==xs && ((xs<wc->c_v_x1) || (xs>wc->c_v_x2))) return(0);
drawimg.c:                y=wc->c_v_y2;
drawimg.c:                x=(int)(*xa+(wc->c_v_y1-(*ya))*tx/ty);
drawimg.c:                if (x==xs && ((xs<wc->c_v_x1) || (xs>wc->c_v_x2))) return(0);
drawimg.c:                y=wc->c_v_y1;
drawimg.c: dc = G->dc;
drawimg.c: EVGAY = dc->EVGAY-1;
drawimg.c: if(G->MAG==1) {
drawimg.c:	  dx=xb-xa;
drawimg.c:	  dy=yb-ya;
drawimg.c:		 g=inc1-dx1;
drawimg.c:		 inc2=g-dx1;
drawimg.c:		 else ch=-1;
drawimg.c:		 else rh=-1;
drawimg.c:/*        while (labs(c-f)>0)*/
drawimg.c:                 r = EVGAY-r;
drawimg.c:	            if (g > 0) { r-=rh; g+=inc2; }
drawimg.c:		 g=inc1-dy1;
drawimg.c:		 inc2=g-dy1;
drawimg.c:		 else ch=-1;
drawimg.c:		 else rh=-1;
drawimg.c:/*        while (labs(c-f)>0)*/
drawimg.c:                 c = EVGAY-c;
drawimg.c:                 f = EVGAY-f;
drawimg.c:                   c-=ch;
drawimg.c:          put_pixl(G,xb,(EVGAY-yb));
drawimg.c:  	  for (i=miny;i<=maxy;++i) put_pixl(G,xa,(EVGAY-i));
drawimg.c:          for (i=minx;i<=maxx;++i) put_pixl(G,i,(EVGAY-ya));
drawimg.c:   dc = G->dc;
drawimg.c:   if( dc->ln_width <=1 ){ _draw_line(G, xa, ya, xb, yb);return;};
drawimg.c:   i2=dc->ln_width/2;
drawimg.c:   dx = (float)(xb-xa);
drawimg.c:   dy = (float)(yb-ya);
drawimg.c:   if( ct< 0.) dy1 =(int)( ct*i2-0.5);
drawimg.c:   xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
drawimg.c:   for (i=1;i<dc->ln_width;i++)
drawimg.c:             if( ct< 0.) dy1 =(int)( ct*i-0.5);
drawimg.c:            _draw_line(G, xa-dx1,ya+dy1,xb-dx1,yb+dy1);
drawimg.c:   dc = G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  for(i=xa;i<=xb;i++) put_pixl(G,i,(EVGAY-y));
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  pt_no=(unsigned int)dc->c_color;
drawimg.c:  j=EVGAY-y;
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  for(i=ya;i<=yb;i++) put_pixl(G,x,(EVGAY-i));
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  xa=dc->cur_x;
drawimg.c:  ya=dc->cur_y;
drawimg.c:	dc->cur_x=x;
drawimg.c:	dc->cur_y=y;
drawimg.c:   ptn=ln_ptn[dc->ln_style%10];
drawimg.c:   dx=xb-xa;
drawimg.c:   dy=yb-ya;
drawimg.c:    g=inc1-dx1;
drawimg.c:    inc2=g-dx1;
drawimg.c:    else ch=-1;
drawimg.c:    else rh=-1;
drawimg.c:    g=inc1-dy1;
drawimg.c:    inc2=g-dy1;
drawimg.c:    else ch=-1;
drawimg.c:    else rh=-1;
drawimg.c:   i=dc->st_ptr[dc->ln_style%10];
drawimg.c:   while (abs(c-f)>0)
drawimg.c:        if ( dx1 > dy1 ) put_pixl(G,c,(EVGAY-r));
drawimg.c:        else   put_pixl(G,r,(EVGAY-c));
drawimg.c:   dc->st_ptr[dc->ln_style%10]=i;
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:   xa=dc->cur_x;
drawimg.c:   ya=dc->cur_y;
drawimg.c:   if ( dc->ln_style == 0) {_draw_line(G,xa,ya,xb,yb);}
drawimg.c:     if(dc->ln_width<=1) _draw_(G, x, y);
drawimg.c:      stloc=dc->st_ptr[dc->ln_style%10];
drawimg.c:      i2=dc->ln_width/2;
drawimg.c:      dx = (float)(xb-xa);
drawimg.c:      dy = (float)(yb-ya);
drawimg.c:      if( ct< 0.) dy1 =(int)( ct*i2-0.5);
drawimg.c:      xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
drawimg.c:      dc->cur_x=xa,dc->cur_y=ya;
drawimg.c:      for (i=1;i<dc->ln_width;i++)
drawimg.c:             dc->st_ptr[dc->ln_style%10]=stloc;
drawimg.c:             if( ct< 0.) dy1 =(int)( ct*i-0.5);
drawimg.c:             dc->cur_x=xa-dx1,dc->cur_y=ya+dy1;
drawimg.c:            _draw_(G, xb-dx1,yb+dy1);
drawimg.c:   dc->cur_x=x;
drawimg.c:   dc->cur_y=y;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  color=dc->t_color;
drawimg.c:  pnt=asc-32+dc->greek;
drawimg.c:  fact = dc->m_f[pnt];
drawimg.c:  xo=(int)(dc->cx+(dc->xp));
drawimg.c:  yo=(int)(dc->cy+dc->yp);
drawimg.c:  ptr= dc->icpos[pnt];
drawimg.c:     code= dc->icxv[ptr];n=dc->icyv[ptr];
drawimg.c:                   xdum=dc->icxv[ptr];ydum=dc->icyv[ptr];ptr++;
drawimg.c:                   x[i]=xdum*dc->txt_w42+xo;y[i]=yo+ydum*dc->txt_h42;
drawimg.c:        code= dc->icxv[ptr];n=dc->icyv[ptr];
drawimg.c:          temp =dc->c_color;dc->c_color=dc->t_color;
drawimg.c:          dc->c_color=temp;
drawimg.c:     dc->xp+=(dc->txt_wt*fact+dc->txt_sp);
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  color = dc->t_color;
drawimg.c:  pnt=asc-32+dc->greek;
drawimg.c:  fact = dc->m_f[pnt];
drawimg.c:  xo=(int)((dc->xp));
drawimg.c:  yo=(int)(dc->yp);
drawimg.c:  ptr= dc->icpos[pnt];
drawimg.c:  xa=(dc->cx+(xo)*dc->cost+yo*dc->sint);
drawimg.c:  ya=(dc->cy-(xo)*dc->sint+yo*dc->cost);
drawimg.c:     code= dc->icxv[ptr];n=dc->icyv[ptr];
drawimg.c:          xdum=dc->icxv[ptr];ydum=dc->icyv[ptr];ptr++;
drawimg.c:          xdum=(xo+xdum*dc->txt_w42);
drawimg.c:          ydum=(yo+ydum*dc->txt_h42);
drawimg.c:          x[i]=(dc->cx+(xdum)*dc->cost+(ydum)*dc->sint);
drawimg.c:          y[i]=(dc->cy+(ydum)*dc->cost-(xdum)*dc->sint);
drawimg.c:        code= dc->icxv[ptr];n=dc->icyv[ptr];
drawimg.c:          temp =dc->c_color;dc->c_color=dc->t_color;
drawimg.c:          dc->c_color=temp;
drawimg.c:     dc->xp+=(dc->txt_wt*fact+dc->txt_sp);
drawimg.c:     wc = G->wc;
drawimg.c:     dc = G->dc;
drawimg.c:      dc->txt_w42 = SSF*dc->txt_w42;
drawimg.c:      dc->txt_h42 = SSF*dc->txt_h42;
drawimg.c:      dc->txt_wt = SSF*dc->txt_wt;
drawimg.c:      dc->txt_ht = SSF*dc->txt_ht;
drawimg.c:                      dc->yp = dc->yp+1.4*dc->txt_ht;
drawimg.c:       else dc->yp= dc->yp-0.7*dc->txt_ht;
drawimg.c:       pt=dc->O_L;
drawimg.c:          if((pt->x2) < 0.){
drawimg.c:           if((pt->ymax)< (dc->yp+1.4*dc->txt_ht)) pt->ymax=dc->yp+1.4*dc->txt_ht;
drawimg.c:           if((pt->ymin)> (dc->yp-0.4*dc->txt_ht)) pt->ymin=dc->yp-0.4*dc->txt_ht;
drawimg.c:          pt=pt->Pr;
drawimg.c:     wc = G->wc;
drawimg.c:     dc = G->dc;
drawimg.c:      is = *ishft-((*ishft)/10)*10;
drawimg.c:                      *ishft = (*ishft)-1;
drawimg.c:                      dc->yp = dc->yp-1.4*dc->txt_ht;
drawimg.c:      else dc->yp= dc->yp+0.7*dc->txt_ht;
drawimg.c:      dc->txt_w42 = dc->txt_w42/SSF;
drawimg.c:      dc->txt_h42 = dc->txt_h42/SSF;
drawimg.c:      dc->txt_wt = dc->txt_wt/SSF;
drawimg.c:      dc->txt_ht = dc->txt_ht/SSF;
drawimg.c:/* this for special use expecting roots between (0-1) */
drawimg.c:      disc = b*b - 4*a*c;
drawimg.c:          *r1=*r2= -b/(2.*a);
drawimg.c:          if(*r1*(1-*r1)<= 0 ) *r1=*r2=0;
drawimg.c:          *r1 = (-b+disc)/(2.*a);
drawimg.c:          if(*r1*(1-*r1)<= 0 ) *r1=0;
drawimg.c:          *r2 = (-b-disc)/(2.*a);
drawimg.c:          if(*r2*(1-*r2)<= 0 ) *r2=0;
drawimg.c:  if( fabs(y1-y2)*Mag > n) n = fabs(y1 - y2)*Mag;
drawimg.c:  if( fabs(y1-y3)*Mag > n) n = fabs(y1 - y3)*Mag;
drawimg.c:  if( fabs(y1-y4)*Mag > n) n = fabs(y1 - y4)*Mag;
drawimg.c:  if( fabs(y2-y3)*Mag > n) n = fabs(y2 - y3)*Mag;
drawimg.c:  if( fabs(y2-y4)*Mag > n) n = fabs(y2 - y4)*Mag;
drawimg.c:  if( fabs(y3-y4)*Mag > n) n = fabs(y3 - y4)*Mag;
drawimg.c:     cx = 3*(x2-x1);
drawimg.c:     cy = 3*(y2-y1);
drawimg.c:     bx = 3*(x3-x2)-cx;
drawimg.c:     by = 3*(y3-y2)-cy;
drawimg.c:     ax = x4-x1-cx-bx;
drawimg.c:     ay = y4-y1-cy-by;
drawimg.c:       dist = (x-x1)*(x-x1)+(y-y1)*(y-y1);
drawimg.c:    j1=j-1;
drawimg.c:      { if( (x1[i]==x1[i-1]) &&(y1[i]==y1[i-1]))
drawimg.c:          { j--; for(k=i;k<j;k++) {x1[k]=x1[k+1];y1[k]=y1[k+1];}}
drawimg.c:   for(i=1;i<j;i++){x2[i-1]=x1[i];y2[i-1]=y1[i];}
drawimg.c:   x2[j-1]=x1[0];y2[j-1]=y1[0];
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  dc->O_L=NULL;
drawimg.c:  bold = dc->txt_bold;
drawimg.c:  font_o=dc->t_font;
drawimg.c:  dc->trot = (dc->cost<0.99);
drawimg.c:  dc->c_color = dc->t_color;
drawimg.c:  dc->cx=(int)(dc->cur_x+0.5);
drawimg.c:  dc->cy= (int)(dc->cur_y+0.5);
drawimg.c:  dc->xp=0.0;
drawimg.c:  dc->yp =0.0;
drawimg.c:  dc->greek=0;
drawimg.c:  lnwidth_o=dc->ln_width;
drawimg.c:  dc->ln_width=1;
drawimg.c:         if ( txt[i]!= '!') { if( dc->trot) uidrawgch(G,txt[i]);
drawimg.c:                              dc->greek=0;
drawimg.c:                            dc->greek=0;
drawimg.c:                            if(dc->trot)  uidrawgch(G,txt[i]);
drawimg.c:                            dc->xp =dc->xp -dc->txt_wt -dc->txt_sp;
drawimg.c:                            dc->txt_bold=2;
drawimg.c:                            dc->Slant=Slnt[1];
drawimg.c:                            dc->Slant = Slant_o; dc->txt_bold=txt_bold_o;
drawimg.c:                             while( (pt->x2) >=0.) pt=pt->Pr;
drawimg.c:                             (pt->x2)=dc->xp-dc->txt_sp;
drawimg.c:                             pt=pt->Pr;
drawimg.c:                            dc->greek=128;
drawimg.c:                            if(dc->O_P!=NULL){
drawimg.c:                              dc->xp=dc->O_P->x;
drawimg.c:                              dc->yp=dc->O_P->y;
drawimg.c:                              dc->D_P=dc->O_P;
drawimg.c:                              dc->O_P=dc->O_P->Pr;
drawimg.c:                              free(dc->D_P);
drawimg.c:                              if(dc->O_P==NULL) FB_P=NULL;
drawimg.c:                              dc->O_P=FB_P;
drawimg.c:                              dc->O_P->Nx=NULL;dc->O_P->Pr=NULL;
drawimg.c:                              dc->O_P->Nx=(B_K *) Malloc((int)sizeof(B_K));
drawimg.c:                              dc->O_P->Nx->Pr=dc->O_P;
drawimg.c:                              dc->O_P=dc->O_P->Nx;
drawimg.c:                              dc->O_P->Nx=NULL;
drawimg.c:                            (dc->O_P->x) = dc->xp;
drawimg.c:                            (dc->O_P->y) = dc->yp;
drawimg.c:                            dc->yp +=0.2*dc->txt_ht;
drawimg.c:                            dc->yp -=0.2*dc->txt_ht;
drawimg.c:                            dc->yp +=0.9*dc->txt_ht;
drawimg.c:                            dc->yp -=0.9*dc->txt_ht;
drawimg.c:                              dc->O_L=FO_L;
drawimg.c:                              dc->O_L->Nx=NULL;dc->O_L->Pr=NULL;
drawimg.c:                              dc->O_L->Nx=(L_N *) Malloc((int)sizeof(L_N));
drawimg.c:                              dc->O_L->Nx->Pr=dc->O_L;
drawimg.c:                              dc->O_L=dc->O_L->Nx;
drawimg.c:                              dc->O_L->Nx=NULL;
drawimg.c:                            (dc->O_L->x1) = dc->xp;
drawimg.c:                            (dc->O_L->x2) = -1.0;
drawimg.c:                            dc->O_L->ymax = dc->yp+1.4*dc->txt_ht;
drawimg.c:                            dc->O_L->ymin = dc->yp-0.4*dc->txt_ht;
drawimg.c:                            dc->O_L->p=cntl;
drawimg.c:                            pt=dc->O_L;
drawimg.c:                            dc->xp = (gap+1)*(dc->txt_wt+dc->txt_sp);
drawimg.c:                            Nu= (txt[i+1] -'0');
drawimg.c:                            De= (txt[i+2] -'0');
drawimg.c:                            dc->txt_w42 = dc->txt_w42*val;
drawimg.c:                            dc->txt_h42 = dc->txt_h42*val;
drawimg.c:                            dc->txt_wt = dc->txt_wt*val;
drawimg.c:                            dc->txt_ht = dc->txt_ht*val;
drawimg.c:                            Nu= (txt[i+1] -'0')*10+(txt[i+2]-'0');
drawimg.c:                            Nu= (txt[i+1] -'0')*10+(txt[i+2]-'0');
drawimg.c:                            Nu= (txt[i+1] -'0');
drawimg.c:                            De= (txt[i+2] -'0');
drawimg.c:                            dc->txt_h42 = dc->txt_h42*val;
drawimg.c:                            dc->txt_ht = dc->txt_ht*val;
drawimg.c:                            Nu= (txt[i+1] -'0');
drawimg.c:                            De= (txt[i+2] -'0');
drawimg.c:                            dc->txt_w42 = dc->txt_w42*val;
drawimg.c:                            dc->txt_wt = dc->txt_wt*val;
drawimg.c:      dc->txt_w42 = dc->txt_w42/fact;
drawimg.c:      dc->txt_h42 = dc->txt_h42/hfact;
drawimg.c:      dc->txt_wt = dc->txt_wt/fact;
drawimg.c:      dc->txt_ht = dc->txt_ht/hfact;
drawimg.c:      dc->ln_width=2;
drawimg.c:      dc->c_color = dc->ln_color;
drawimg.c:       if(pt->x2 <0. ) pt->x2=dc->xp;
drawimg.c:       if(pt->p =='U') {
drawimg.c:        _move(G,TX((pt->x1),pt->ymin),TY((pt->x1),pt->ymin));
drawimg.c:        _draw(G,TX((pt->x2),pt->ymin),TY((pt->x2),pt->ymin));
drawimg.c:        _move(G,TX((pt->x1),pt->ymax),TY((pt->x1),pt->ymax));
drawimg.c:        _draw(G,TX((pt->x2),pt->ymax),TY((pt->x2),pt->ymax));
drawimg.c:       dc->O_L=pt;
drawimg.c:       pt=pt->Nx;
drawimg.c:       free(dc->O_L);
drawimg.c:      dc->O_P=FB_P;
drawimg.c:      while(dc->O_P != NULL) {
drawimg.c:       dc->D_P=dc->O_P;
drawimg.c:       dc->O_P=dc->O_P->Pr;
drawimg.c:       free(dc->D_P);
drawimg.c:      dc->ln_width=lnwidth_o;
drawimg.c:      if(dc->t_font!=font_o) ui_txt_font(G,font_o);
drawimg.c:  dc= G->dc;
drawimg.c:  wc= G->wc;
drawimg.c:  temp=dc->c_color;
drawimg.c:  dc->c_color=color;
drawimg.c:  if(( x_min<=wc->c_v_x2) && (x_max1>=wc->c_v_x1))
drawimg.c:    if(( y_min<=wc->c_v_y2) && (y_max>=wc->c_v_y1))
drawimg.c:      if(x_max1>wc->c_v_x2) x_max1 = wc->c_v_x2;
drawimg.c:      if(x_min<wc->c_v_x1) x_min = wc->c_v_x1;
drawimg.c:      if(y_max>wc->c_v_y2) y_max = wc->c_v_y2;
drawimg.c:      if(y_min<wc->c_v_y1) y_min = wc->c_v_y1;
drawimg.c:  dc->c_color=temp;
drawimg.c:  dc= G->dc;
drawimg.c:  wc= G->wc;
drawimg.c:  xup =-100000;
drawimg.c:  ygrt=-1239000;
drawimg.c:	j=i-1;
drawimg.c:	  j--;
drawimg.c:  if((scan> wc->c_v_y2) || (ygrt< wc->c_v_y1) || (xlow> wc->c_v_x2) || (xup< wc->c_v_x1)) return;
drawimg.c:  tempc = dc->c_color;
drawimg.c:  dc->c_color= b_color;
drawimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
drawimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
drawimg.c:		j=i-1;
drawimg.c:		while(j>=0 && txx < xcord[j]){ xcord[j+1]=xcord[j];j--;}
drawimg.c:  dc->c_color = dc->ln_color;
drawimg.c:  dc= G->dc;
drawimg.c:  wc= G->wc;
drawimg.c:  xup =-1000000;
drawimg.c:  ygrt=-1239000;
drawimg.c:    j=i-1;
drawimg.c:      j--;
drawimg.c:  if((scan/Mag> wc->c_v_y2) || (ygrt/Mag< wc->c_v_y1) || (xlow/Mag> wc->c_v_x2) || (xup/Mag< wc->c_v_x1)) return;
drawimg.c:  tempc = dc->c_color;
drawimg.c:  dc->c_color=b_color;
drawimg.c:       xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
drawimg.c:                  *(scan-ymin[i]) +xmin[i]+0.5));
drawimg.c:   j=i-1;
drawimg.c:   while(j>=0 && txx < xcord[j]){ xcord[j+1]=xcord[j];j--;}
drawimg.c: dc->c_color=tempc;
drawimg.c:  ym=y-(short)(r/sqrt((double)2.));
drawimg.c:  for (j=y;j>=ym;--j)
drawimg.c:	i=x+(short)sqrt((double)sqrd-((y-j)*(y-j)));
drawimg.c:	put_pixel(G,i,2*y-j);
drawimg.c:	put_pixel(G,x+y-j,y+i-x);
drawimg.c:	put_pixel(G,x-y+j,y+i-x);
drawimg.c:	put_pixel(G,2*x-i,2*y-j);
drawimg.c:	put_pixel(G,2*x-i,j);
drawimg.c:	put_pixel(G,x-y+j,y-i+x);
drawimg.c:	put_pixel(G,x+y-j,y-i+x);
drawimg.c:  dc = G->dc;
drawimg.c:  ym=y-(short)(r/sqrt((double)2.));
drawimg.c:  temp=dc->c_color;
drawimg.c:  put_pixel(G,x,y+r),put_pixel(G,x,y-r);
drawimg.c:  put_pixel(G,x+r,y),put_pixel(G,x-r,y);
drawimg.c:  dc->c_color=color;
drawimg.c:  phori_line(G,x-r+1,x+r-1,y);
drawimg.c:	t=sqrd-(float)(j*j);
drawimg.c:        dc->c_color=temp;
drawimg.c:        put_pixel(G,x-i,y-j);
drawimg.c:        put_pixel(G,x+i,y-j);
drawimg.c:        put_pixel(G,x-i,y+j);
drawimg.c:        dc->c_color=color;
drawimg.c:        phori_line(G,x-i+1,x+i-1,y-j);
drawimg.c:        phori_line(G,x-i+1,x+i-1,y+j);
drawimg.c:  dc->c_color=temp;
drawimg.c:  dc = G->dc;
drawimg.c:  temp=dc->c_color;
drawimg.c:  dc->c_color=color;
drawimg.c:  EVGAX= dc->EVGAX-1;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  dc->c_color=temp;
drawimg.c:      font_o=dc->t_font;
drawimg.c:      wd = dc->txt_wtx;
drawimg.c:      gp = dc->txt_spx;
drawimg.c:      fj =0.0; gj = -1; fact = 1.0;
drawimg.c:            if( dc->pr_txt>0) fact1=dc->m_f[title[i]-32+greek]*fact;
drawimg.c:                         fj = fj-fact1;fjl-=1.; gj=gj-1;
drawimg.c:                        if(dc->O_P!=NULL){
drawimg.c:                          fj=dc->O_P->x;
drawimg.c:                          fjl=dc->O_P->xl;
drawimg.c:                          gj=dc->O_P->y;
drawimg.c:                          dc->D_P=dc->O_P;
drawimg.c:                          dc->O_P=dc->O_P->Pr;
drawimg.c:                          free(dc->D_P);
drawimg.c:                          if(dc->O_P==NULL) FB_P=NULL;
drawimg.c:                          dc->O_P=FB_P;
drawimg.c:                          dc->O_P->Nx=NULL;dc->O_P->Pr=NULL;
drawimg.c:                          dc->O_P->Nx=(B_K *) Malloc((int)sizeof(B_K));
drawimg.c:                          dc->O_P->Nx->Pr=dc->O_P;
drawimg.c:                          dc->O_P=dc->O_P->Nx;
drawimg.c:                          dc->O_P->Nx=NULL;
drawimg.c:                        (dc->O_P->x) = fj;
drawimg.c:                        (dc->O_P->xl) = fjl;
drawimg.c:                        (dc->O_P->y) = gj;
drawimg.c:                         val = title[i+1]-'0';
drawimg.c:                         val =  val*10+( title[i+2]-'0');
drawimg.c:                         /*gj = gj-2;*/
drawimg.c:                         val = title[i+2]-'0';
drawimg.c:                         val = (float)(title[i+1]-'0')/val;
drawimg.c:                         /*gj = gj-2;*/
drawimg.c:                         val = title[i+2]-'0';
drawimg.c:                         val = (float)(title[i+1]-'0')/val;
drawimg.c:                         /*gj = gj-2;*/
drawimg.c:                         val = title[i+2]-'0';
drawimg.c:                         val = (float)(title[i+1]-'0')/val;
drawimg.c:                         /*gj = gj-2;*/
drawimg.c:      dc->O_P=FB_P;
drawimg.c:      while(dc->O_P != NULL) {
drawimg.c:       dc->D_P=dc->O_P;
drawimg.c:       dc->O_P=dc->O_P->Pr;
drawimg.c:       free(dc->D_P);
drawimg.c:  dc= G->dc;
drawimg.c:  dc->ln_width= width;
drawimg.c:  dc= G->dc;
drawimg.c:  _godard_fill(G,(short)n,x1,y1,(short)dc->ibdr,p1);
drawimg.c:    kgcolors = (kgColor *)(wc->kgcolors);
drawimg.c:  if(G->D==NULL) wc= G->wc;
drawimg.c:  else wc= WC(G->D);
drawimg.c:  dc = G->dc;
drawimg.c://  if(G->D != NULL) wc = WC(G->D);
drawimg.c://  else wc = G->wc; 
drawimg.c:  wc = G->wc; 
drawimg.c:  MAXB = dc->EVGAX;
drawimg.c:  row1 = dc->EVGAY-1-row;
drawimg.c:  if ((col > wc->c_v_x2) || (col <wc->c_v_x1) || (row1 > wc->c_v_y2) || (row1 <wc->c_v_y1)) return;
drawimg.c:  imgGetColor(G,dc->c_color,addr);
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  MAXB = dc->EVGAX;
drawimg.c:  row1 = dc->EVGAY-1-row;
drawimg.c:  if ((col > wc->c_v_x2) || (col <wc->c_v_x1) || (row1 > wc->c_v_y2) || (row1 <wc->c_v_y1)) return;
drawimg.c:  imgGetColor(G,dc->c_color,addr);
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c:  MAXB = dc->EVGAX;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  if ((col > wc->c_v_x2) || (col <wc->c_v_x1) || (row > wc->c_v_y2) || (row <wc->c_v_y1)) return;
drawimg.c:  addr = (EVGAY-row)*MAXB + (col);
drawimg.c:  imgGetColor(G,dc->c_color,addr);
drawimg.c:   wc = G->wc;
drawimg.c:   dc = G->dc;
drawimg.c:   dc->vu_x1=x1,dc->vu_y1=y1,dc->vu_x2=x2,dc->vu_y2=y2;
drawimg.c:   EVGAX= (G->x2-G->x1+1)*G->MAG+0.1;
drawimg.c:   EVGAY= (abs(G->y2-G->y1)+1)*G->MAG+0.1;
drawimg.c:   dc->v_x1=x1*(float)EVGAX;
drawimg.c:   dc->v_y1= y1*(float)EVGAY;
drawimg.c:   dc->v_x2=x2*(float)EVGAX-1+0.1;
drawimg.c:   dc->v_y2= y2*(float)EVGAY-1+0.1;
drawimg.c:   if( dc->v_y2 <= 0) {printf("dc->v_y2<=0:%d\n",dc->v_y2);exit(0);}
drawimg.c:   dc->V_x=dc->v_x2-dc->v_x1;
drawimg.c:   dc->V_y=dc->v_y2-dc->v_y1;
drawimg.c:   t=(dc->V_x*dc->V_x+dc->V_y*dc->V_y);
drawimg.c:   dc->u_x=(dc->V_x/(dc->w_x2-dc->w_x1));
drawimg.c:   dc->u_y=(dc->V_y/(dc->w_y2-dc->w_y1));
drawimg.c:   dc->v_r=sqrt((double)t);
drawimg.c:   dc->EVGAX=dc->v_x2-dc->v_x1+1;
drawimg.c:   dc->EVGAY=dc->v_y2-dc->v_y1+1;
drawimg.c:  uiset_sup_clip_limits(wc,0,0,dc->EVGAX-1,dc->EVGAY-1);
drawimg.c:  uiset_clip_limits(wc,0,0,dc->EVGAX-1,dc->EVGAY-1);
drawimg.c:  png = G->img;
drawimg.c:  SyncImagePixels((Image *)(png->image));
drawimg.c:  wc = G->wc;
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAX= G->x2-G->x1+1;
drawimg.c:  EVGAY= abs(G->y2-G->y1)+1;
drawimg.c:  v_x1=dc->vu_x1*(float)EVGAX;
drawimg.c:  v_y1= dc->vu_y1*(float)EVGAY;
drawimg.c:  v_x2=dc->vu_x2*(float)EVGAX-1;
drawimg.c:  v_y2= dc->vu_y2*(float)EVGAY-1;
drawimg.c:  V_x=v_x2-v_x1+1;
drawimg.c:  V_y=v_y2-v_y1+1;
drawimg.c:  if( G->MAG > 1) {
drawimg.c:     if(G->MAG==2) G->rzimg = uiHalfSizegmImage(png);
drawimg.c:     else G->rzimg = uiChangeSizegmImage(png,V_x,V_y,1);
drawimg.c:     png = G->rzimg;
drawimg.c:  else png = G->img;
drawimg.c:  if(G->D==NULL) {D_x=D_y=0;}
drawimg.c:    D= G->D;
drawimg.c:    D_x=G->x1+D->xo+v_x1;
drawimg.c:    D_y = D->yo+G->y1+EVGAY-1-v_y2;
drawimg.c://    printf("Image: %d %d %d %d\n",D_x,D_y,png->image_width,png->image_height);
drawimg.c://    printf("%d %d %d %d %d %d\n",D->xo,D->yo,G->x1,G->y1,G->x2,G->y2);
drawimg.c:    kgImage(D,png,D_x,D_y,png->image_width,png->image_height,0.0,1.0);
drawimg.c://  uiWriteImage(G->img,"junk.png");
drawimg.c:  if( G->MAG > 1){uiFreeImage(G->rzimg); G->rzimg = NULL;}
drawimg.c:  png = G->img;
drawimg.c:  MAG = G->MAG+0.000001;
drawimg.c:  SyncImagePixels((Image *)(png->image));
drawimg.c:  wc = G->wc;
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAX= G->x2-G->x1+1;
drawimg.c:  EVGAY= abs(G->y2-G->y1)+1;
drawimg.c:  v_x1=dc->vu_x1*(float)EVGAX;
drawimg.c:  v_y1= dc->vu_y1*(float)EVGAY;
drawimg.c:  v_x2=dc->vu_x2*(float)EVGAX-1;
drawimg.c:  v_y2= dc->vu_y2*(float)EVGAY-1;
drawimg.c:  V_x=v_x2-v_x1+1;
drawimg.c:  V_y=v_y2-v_y1+1;
drawimg.c:// G->img will be freed elsewhere if MAG > 1
drawimg.c:       G->rzimg = uiHalfSizegmImage(png);
drawimg.c:            G->rzimg = uiHalfSizegmImage(png);
drawimg.c:            G->rzimg = uiChangeSizegmImage(png,V_x,V_y,9);
drawimg.c:     G->rzimg = uiChangeSizegmImage(png,V_x,V_y,9);
drawimg.c:     png = G->rzimg;
drawimg.c:  else png = G->img;
drawimg.c://  kgImage(D,png,D_x,D_y,png->image_width,png->image_height,0.0,1.0);
drawimg.c://  uiWriteImage(G->img,"junk1.png");
drawimg.c:  png = G->img;
drawimg.c:  SyncImagePixels((Image *)(png->image));
drawimg.c:  wc = G->wc;
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAX= G->x2-G->x1+1;
drawimg.c:  EVGAY= abs(G->y2-G->y1)+1;
drawimg.c:  v_x1=dc->vu_x1*(float)EVGAX;
drawimg.c:  v_y1= dc->vu_y1*(float)EVGAY;
drawimg.c:  v_x2=dc->vu_x2*(float)EVGAX-1;
drawimg.c:  v_y2= dc->vu_y2*(float)EVGAY-1;
drawimg.c:  V_x=v_x2-v_x1+1;
drawimg.c:  V_y=v_y2-v_y1+1;
drawimg.c:  if( G->MAG > 1) {
drawimg.c:     G->rzimg = uiChangeSizegmImage(png,V_x,V_y,4);
drawimg.c:     png = G->rzimg;
drawimg.c:  else png = G->img;
drawimg.c://  kgImage(D,png,D_x,D_y,png->image_width,png->image_height,0.0,1.0);
drawimg.c://  uiWriteImage(G->img,"junk1.png");
drawimg.c:  png = G->img;
drawimg.c:  SyncImagePixels((Image *)(png->image));
drawimg.c:  wc = G->wc;
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAX= G->x2-G->x1+1;
drawimg.c:  EVGAY= abs(G->y2-G->y1)+1;
drawimg.c:  v_x1=dc->vu_x1*(float)EVGAX;
drawimg.c:  v_y1= dc->vu_y1*(float)EVGAY;
drawimg.c:  v_x2=dc->vu_x2*(float)EVGAX-1;
drawimg.c:  v_y2= dc->vu_y2*(float)EVGAY-1;
drawimg.c:  V_x=v_x2-v_x1+1;
drawimg.c:  V_y=v_y2-v_y1+1;
drawimg.c:  if( G->MAG > 1) {
drawimg.c:     G->rzimg = uiChangeSizegmImage(png,V_x,V_y,7);
drawimg.c:     png = G->rzimg;
drawimg.c:  else png = G->img;
drawimg.c://  kgImage(D,png,D_x,D_y,png->image_width,png->image_height,0.0,1.0);
drawimg.c://  uiWriteImage(G->img,"junk1.png");
drawimg.c:  dc=G->dc;
drawimg.c:  wc=G->wc;
drawimg.c:  EVGAX=G->x2 -G->x1+1;
drawimg.c:  EVGAY=G->y2 - G->y1+1;
drawimg.c:  dc->ln_style=0;
drawimg.c:  dc->m_style=0;
drawimg.c:  dc->ln_color = 0x0F;
drawimg.c:  dc->c_bound =4;
drawimg.c:  dc->t_color = 14;
drawimg.c:  dc->t_pattern=15;
drawimg.c:  dc->t_fill = 1;
drawimg.c:  dc->zbuf= NULL;
drawimg.c:  dc->redbuf=NULL;
drawimg.c:  dc->greenbuf=NULL;
drawimg.c:  dc->bluebuf=NULL;
drawimg.c:  dc->clrbuf=NULL;
drawimg.c:  dc->DOUBLE=0;
drawimg.c://  dc->Fontlist= uiGetFontlist();
drawimg.c:  dc->Fontlist= (Dlink *)Loadfontstruct();
drawimg.c://  dc->icpos = icposf0;dc->icxv=icxvf0;dc->icyv=icyvf0;dc->m_f=m_f0;
drawimg.c:  count = Dcount(dc->Fontlist);
drawimg.c:  Dposition(dc->Fontlist,font+1);
drawimg.c:  pt = (FONT *)Getrecord(dc->Fontlist);
drawimg.c:  dc->icpos = pt->icpos;
drawimg.c:  dc->icxv = pt->icxv;
drawimg.c:  dc->icyv = pt->icyv;
drawimg.c:  dc->m_f =  pt->m_f;
drawimg.c:  dc->icposf0 = dc->icpos;dc->icxvf0=dc->icxv;
drawimg.c:  dc->icyvf0=dc->icyv;dc->m_f0=dc->m_f;
drawimg.c:  dc->t_font=font;
drawimg.c:  dc->t_bkgr = 0;
drawimg.c:  dc->t_bodr = 0;
drawimg.c:  dc->fil_color=0;
drawimg.c:  dc->bod_width=11;
drawimg.c:  dc->bod_color=1;
drawimg.c:  dc->ln_width=1;
drawimg.c:  dc->pr_txt=1;
drawimg.c:  dc->cost = 1.0;
drawimg.c:  dc->sint = 0.0;
drawimg.c:  dc->txt_ht=20;
drawimg.c:  dc->txt_wt=20;
drawimg.c:  dc->txt_htx=20;
drawimg.c:  dc->txt_wty=20;
drawimg.c:  dc->txt_hty=20;
drawimg.c:  dc->txt_wtx=20;
drawimg.c:  dc->txt_w42 = dc->txt_wt/CFact;
drawimg.c:  dc->txt_h42 = dc->txt_ht/CFact;
drawimg.c:  dc->txt_sp=2;
drawimg.c:  dc->txt_spy=2;
drawimg.c:  dc->txt_spx=2;
drawimg.c:  dc->v_x1=0;
drawimg.c:  dc->v_y1=0;
drawimg.c:  dc->v_x2=EVGAX-1;
drawimg.c:  dc->v_y2=EVGAY-1;
drawimg.c:  dc->w_x1=0;
drawimg.c:  dc->w_y1=0;
drawimg.c:  dc->w_x2=1.0;
drawimg.c:  dc->w_y2=1.0;
drawimg.c:  dc->u_x=EVGAX-1;
drawimg.c:  dc->u_y=EVGAY-1;
drawimg.c:  dc->V_x=EVGAX-1;
drawimg.c:  dc->V_y=EVGAY-1;
drawimg.c:  dc->D_x=0;
drawimg.c:  dc->D_y=0;
drawimg.c:  dc->ZBUFF=dc->SET3D=dc->TIFF=dc->PROJ=0;
drawimg.c:  dc->DBL_BUF=0;
drawimg.c:  dc->D_ON=0;
drawimg.c:  dc->Cutoff=1;
drawimg.c:  wc->Clip = Dopen();
drawimg.c:  wc->SBlist=Dopen();
drawimg.c:  dc->EVGAX=EVGAX;
drawimg.c:  dc->EVGAY=EVGAY;
drawimg.c:  uiset_sup_clip_limits(wc,0,0,dc->EVGAX-1,dc->EVGAY-1);
drawimg.c:  uiset_clip_limits(wc,0,0,dc->EVGAX-1,dc->EVGAY-1);
drawimg.c:    dc->ln_ptn[i]=ln_ptn[i];
drawimg.c:    dc->st_ptr[i]=st_ptr[i];
drawimg.c:  G->D=NULL;
drawimg.c:  G->wc = (kgWC *)Malloc(sizeof(kgWC));
drawimg.c:  wc = G->wc;
drawimg.c:  G->dc = dc;
drawimg.c:  G->x1=G->y1=0;
drawimg.c:  G->x2 = (int)(width-1);
drawimg.c:  G->y2 = (int)(height-1);
drawimg.c:  G->MAG=mag;
drawimg.c:  dc->Fontlist = NULL;
drawimg.c:  wc->kgcolors=(kgColor *) Malloc(sizeof(kgColor)*1024);
drawimg.c:    wc->kgcolors[i].red = kgIcode[i][0];
drawimg.c:    wc->kgcolors[i].green = kgIcode[i][1];
drawimg.c:    wc->kgcolors[i].blue = kgIcode[i][2];
drawimg.c:  for(l=0;l<10;l++) dc->st_ptr[l]=0;
drawimg.c:  G->B_min = 10400;
drawimg.c:  G->BACK_UP=0;
drawimg.c:  G->OPEN=1;
drawimg.c:  G->Byte=0;
drawimg.c:  G->R_Byte=0;
drawimg.c:  G->R_max=0;
drawimg.c:  G->D_ON=0;
drawimg.c:  G->img=NULL;
drawimg.c:  G->rzimg=NULL;
drawimg.c:  G->pixels=NULL;
drawimg.c:  kgUserFrame(G,0.,0.,(float)(width-1),(float)(height-1));
drawimg.c:  dc->ls_list=NULL;
drawimg.c:  dc->No_of_lights=0;
drawimg.c:  G->Rbuff = NULL;
drawimg.c:  if(G->D != NULL) return;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c://   printf("G->MAG = %d\n",G->MAG);
drawimg.c:  if((G->MAG > 1)&&(G->img != NULL)) {
drawimg.c:       uiFreeImage(G->img);
drawimg.c://  if(G->rzimg != NULL) uiFreeImage(G->rzimg); //user should take care of this after use
drawimg.c:  Dempty((Dlink *)(wc->Clip));
drawimg.c:  Dempty((Dlink *)(wc->SBlist));
drawimg.c://  Dfree((Dlink *)(dc->Fontlist));
drawimg.c:  Dempty((Dlink *)(dc->Fontlist));
drawimg.c:  free(wc->kgcolors);
drawimg.c:  free(G->dc);
drawimg.c:  free(G->wc);
drawimg.c:  G->D=NULL;
drawimg.c:  G->wc = (kgWC *)Malloc(sizeof(kgWC));
drawimg.c:  wc = G->wc;
drawimg.c:  G->dc = dc;
drawimg.c:  G->x1=G->y1=0;
drawimg.c:  G->x2 = (int)(width-1);
drawimg.c:  G->y2 = (int)(height-1);
drawimg.c:  G->MAG=mag;
drawimg.c:  wc->kgcolors=(kgColor *) Malloc(sizeof(kgColor)*1024);
drawimg.c:    wc->kgcolors[i].red = kgIcode[i][0];
drawimg.c:    wc->kgcolors[i].green = kgIcode[i][1];
drawimg.c:    wc->kgcolors[i].blue = kgIcode[i][2];
drawimg.c:  G->Obj_opn=0;
drawimg.c:  for(l=0;l<10;l++) dc->st_ptr[l]=0;
drawimg.c:  G->B_min = 10400;
drawimg.c:  G->BACK_UP=0;
drawimg.c:  G->OPEN=1;
drawimg.c:  G->Byte=0;
drawimg.c:  G->R_Byte=0;
drawimg.c:  G->R_max=0;
drawimg.c:  G->D_ON=0;
drawimg.c:  G->img=NULL;
drawimg.c:  G->rzimg=NULL;
drawimg.c:  G->pixels=NULL;
drawimg.c:  kgUserFrame(G,0.,0.,(float)(width-1),(float)(height-1));
drawimg.c:  strcpy(dc->objdir,flname);
drawimg.c:  strcpy(dc->reviewfile,dc->objdir);
drawimg.c:  strcat(dc->reviewfile,"/reviewdat");
drawimg.c:  G->rbuf = open(dc->reviewfile,O_CREAT|O_BINARY|O_TRUNC|O_RDWR,0666);
drawimg.c:  strcpy(dc->plotfile,dc->objdir);
drawimg.c:  strcat(dc->plotfile,"/plotgph");
drawimg.c:  strcpy(dc->cmdsfile,dc->objdir);
drawimg.c:  strcat(dc->cmdsfile,"/cmdsfile");
drawimg.c:  dc->ls_list=NULL;
drawimg.c:  dc->No_of_lights=0;
drawimg.c:  G->Rbuff = (unsigned char  *) Malloc(B_max+100);
drawimg.c:  G->hbuf =-1;
drawimg.c:  if(G->D != NULL) return;
drawimg.c:  dc = G->dc;
drawimg.c:  wc = G->wc;
drawimg.c://   printf("G->MAG = %d\n",G->MAG);
drawimg.c:  if((G->MAG > 1)&&(G->img != NULL)) {
drawimg.c:       uiFreeImage(G->img);
drawimg.c://  if(G->rzimg != NULL) uiFreeImage(G->rzimg); //user should take care of this after use
drawimg.c:  free(G->Rbuff);
drawimg.c:  kgCleanDir(dc->objdir);
drawimg.c:  Dempty((Dlink *)(wc->Clip));
drawimg.c:  Dempty((Dlink *)(wc->SBlist));
drawimg.c:  Dfree((Dlink *)(dc->Fontlist));
drawimg.c:  free(wc->kgcolors);
drawimg.c:  free(G->dc);
drawimg.c:  free(G->wc);
drawimg.c:  dc = G->dc;
drawimg.c:  EVGAY = dc->EVGAY-1;
drawimg.c:  Y1=EVGAY-scr_y(y1);
drawimg.c:  Y2=EVGAY-scr_y(y2);
drawimg.c:  if(strcmp(img->Sign,"FMG")==0){
drawimg.c:       img = (GMIMG *)kgGetInlineImage(fmg->image_data,fmg->size);
drawimg.c:  if(strcmp(img->Sign,"IMG")!=0) return;
drawimg.c:  w = X2-X1+1;
drawimg.c:  h = Y2 -Y1+1;
drawimg.c:  iw = img->image_width;
drawimg.c:  ih = img->image_height;
file_pro.c:   j=i-1;   
file_pro.c:  F->L = LN;
file_pro.c:  Resetlink(F->L);
file_pro.c:  F->C_pos=0;
file_pro.c:  strcpy(F->Name,flname);
file_pro.c:  F->L = Dopen();
file_pro.c:  F->C_pos=0;
file_pro.c:  strcpy(F->Name,flname);
file_pro.c:  Dappend(F->L,bf);
file_pro.c:  F->C_pos=0;
file_pro.c:  copy_to_file(F,F->Name);
file_pro.c:  Dempty(F->L);
file_pro.c:  Dempty(F->L);
file_pro.c:  Resetlink(F->L);
file_pro.c:  while( (bf=(char *)Getrecord(F->L)) != NULL) {
file_pro.c:  Resetlink(F->L);
file_pro.c:  F->C_pos=0;
file_pro.c:  Resetlink(F->L);
file_pro.c:  while( (bf=(char *)Getrecord(F->L)) != NULL) {
file_pro.c:   j=i-1;while( (j>=0) &&(bf[j]<= ' '))j--;  
file_pro.c:  Resetlink(F->L);
file_pro.c:  F->C_pos=0;
file_pro.c:  if(F== ((void *)0) ) return -1;
file_pro.c:  ln = (char *)Getrecord(F->L);
file_pro.c:  if(ln ==NULL) return -1;
file_pro.c:  F->C_pos=0;
file_pro.c:  if(F== ((void *)0) ) return -1;
file_pro.c:  ln = (char *)Getrecord(F->L);
file_pro.c:  ret = *(ln+F->C_pos);
file_pro.c:  F->C_pos +=1;
file_pro.c://  if(ln[F->C_pos] <' ') {
file_pro.c:  if(ln[F->C_pos] =='\0') {
file_pro.c:    F->C_pos=0;
file_pro.c:  else Dmove_back(F->L,1);
file_pro.c:  if(F== ((void *)0) ) return -1;
file_pro.c:  F->C_pos -=1;
file_pro.c:  while( F->C_pos < 0) {
file_pro.c:    Dmove_back(F->L,1);
file_pro.c:    ln = (char *) Getrecord(F->L);
file_pro.c:    if(ln== NULL) {F->C_pos=0;break;}
file_pro.c://    F->C_pos=strlen(ln)-2;
file_pro.c:    F->C_pos=strlen(ln)-1;
file_pro.c:    Dmove_back(F->L,1);
file_pro.c: Resetlink(F->L);
file_pro.c: F->C_pos= 0;
file_pro.c: Dend(F->L);
file_pro.c: F->C_pos= 0;
file_pro.c: Dmove_back(F->L,n);
file_pro.c: F->C_pos=0;
file_pro.c: Dmove_forward(F->L,n);
file_pro.c: F->C_pos=0;
file_pro.c: Ddelete_items(F->L,n);
file_pro.c: F->C_pos=0;
file_pro.c: Resetlink(tmp->L);
file_pro.c: Dmove_back(F->L,1);
file_pro.c: while( (bf= (char *)Getrecord(tmp->L))!= NULL) Dadd(F->L,bf);
file_pro.c: F->C_pos=0;
file_pro.c: Dfree(tmp->L);
file_pro.c: Dinsert(F->L,bf);
file_pro.c: F->C_pos=0;
file_pro.c: Dadd(F->L,bf);
file_pro.c: F->C_pos=0;
file_pro.c:  Resetlink(F->L);
file_pro.c:  while( (bf= (char *)Getrecord(F->L))!= NULL) {
file_pro.c:  Resetlink(F->L);
file_pro.c:  F->C_pos=0;
file_pro.c:  Resetlink(F->L);
file_pro.c:  while( (bf= (char *)Getrecord(F->L))!= NULL) {
file_pro.c:  Resetlink(F->L);
file_pro.c:  F->C_pos=0;
file_pro.c:    while(isdigit(*cpt)||(*cpt=='.')||(*cpt=='-')){ cpt++; }
gkernel.c:#define uiset_clip_limits(wc,x1,y1,x2,y2) wc->c_v_x1=x1,wc->c_v_y1=y1,wc->c_v_x2=x2,wc->c_v_y2=y2
gkernel.c:#define uibkup_clip_limits wc->c_v_x1_o=wc->c_v_x1,wc->c_v_y1_o=wc->c_v_y1,wc->c_v_x2_o=wc->c_v_x2,wc->c_v_y2_o=wc->c_v_y2
gkernel.c:#define uiset_sup_clip_limits(wc,x1,y1,x2,y2) wc->s_v_x1=x1,wc->s_v_y1=y1,wc->s_v_x2=x2,wc->s_v_y2=y2
gkernel.c:#define uirest_clip_limits wc->c_v_x1=wc->c_v_x1_o,wc->c_v_y1=wc->c_v_y1_o,wc->c_v_x2=wc->c_v_x2_o,wc->c_v_y2=wc->c_v_y2_o
gkernel.c:#define IMAGE_BLUE_VAL  (((blue)*(wc->IMAGE->blue_mask)+(1<<(wc->BLUEMASKPOS-1)))/255)
gkernel.c:#define IMAGE_GREEN_VAL ((((green) * (wc->IMAGE->green_mask) \
gkernel.c:   + ( 1 << ( wc->GREENMASKPOS -1 ) ) ) /255 ) & ( wc->IMAGE->green_mask ) )
gkernel.c:#define IMAGE_RED_VAL ((((red) * (wc->IMAGE->red_mask) \
gkernel.c:   + ( 1 << ( wc->REDMASKPOS -1 ) ) ) /255 ) & ( wc->IMAGE->red_mask ) )
gkernel.c:#define BLUE_VAL  (((val&0x0000ff)*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
gkernel.c:#define GREEN_VAL (((((val>>8)&0x0000ff) * (uiImage->green_mask) \
gkernel.c:   + ( 1 << ( GreenMaskPos -1 ) ) ) /255 ) & ( uiImage->green_mask ) )
gkernel.c:#define RED_VAL (((((val>>16)&0x0000ff) * (uiImage->red_mask) \
gkernel.c:   + ( 1 << ( RedMaskPos -1 ) ) ) /255 ) & ( uiImage->red_mask ) )
gkernel.c:#define Image_BLUE_VAL  ((blue*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
gkernel.c:#define Image_GREEN_VAL (((green * (uiImage->green_mask) \
gkernel.c:   + ( 1 << ( GreenMaskPos -1 ) ) ) /255 ) & ( uiImage->green_mask ) )
gkernel.c:#define Image_RED_VAL (((red * (uiImage->red_mask) \
gkernel.c:   + ( 1 << ( RedMaskPos -1 ) ) ) /255 ) & ( uiImage->red_mask ) )
gkernel.c:#define Img_BLUE_VAL  ((blue*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
gkernel.c:static char FONTSTRF[60]= "-adobe-courier-medium-r-*-*-";
gkernel.c:static char FONTSTRV[60]= "-adobe-courier-medium-r-*-*-";
gkernel.c:static char FONTSTRV[60]= "-adobe-helvetica-bold-r-*-*-";
gkernel.c:  static char FONTSTRF [ 60 ] = "-adobe-courier-bold-r-*-*-";
gkernel.c:  static char FONTSTRV [ 60 ] = "-adobe-helvetica-bold-r-*-*-";
gkernel.c:  static char FONTSTRV1 [ 60 ] = "-adobe-new century schoolbook-medium-r-*-*-";
gkernel.c:  static char FONTSTRV2 [ 60 ] = "-adobe-times-medium-r-*-*-";
gkernel.c:  static char FONTSTRV3 [ 60 ] = "-adobe-utopia-medium-r-*-*-";
gkernel.c:  static char FONTSTR2 [ 20 ] = "-*-*-*-*-*-*-*";
gkernel.c:#define FONT "-adobe-courier-medium-r-*-*-16-*-*-*-*-*-*-*"
gkernel.c:#define icde(i,j) kgIcode[j-1][i-1]
gkernel.c:  static unsigned long clrtbl [ 1024 ] = {0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 254 , 255 , -1 };
gkernel.c:#define uiXDRAW(wc,x1,y1,x2,y2) XDrawLine(wc->Dsp,wc->ActWin,wc->Gc,(short)(x1),(short)(wc->EVGAY-y1),(short)(x2),(short)(wc->EVGAY-y2))
gkernel.c:#define dvXDRAW(wc,x1,y1,x2,y2) XDrawLine(wc->Dsp,wc->ActWin,wc->Gc,(short)(x1),(short)(y1),(short)(x2),(short)(y2))
gkernel.c:#define XCPix(x1,y1,x2,y2) XCreatePixmap(Dsp,Win,(short)(x2-(x1)+1),(short)(y2-(y1)+1),Dpth);
gkernel.c:#define XCPix1(x1,y1,x2,y2) XCreatePixmap(Dsp,Win,(short)(x2-(x1)+1),(short)(y2-(y1)+1),1);
gkernel.c:#define kgXCPix(x1,y1,x2,y2) XCreatePixmap((Display *)WC(D)->Dsp, (Window)WC(D)->Win,(short)(x2-(x1)+1),(short)(y2-(y1)+1),WC(D)->Dpth);
gkernel.c:#define wcXCPix(x1,y1,x2,y2) XCreatePixmap(wc->Dsp, wc->Win,(short)(x2-(x1)+1),(short)(y2-(y1)+1),wc->Dpth);
gkernel.c:  static int Scan_code [ 256 ] = {0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 27 , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , '-' , '=' , '\b' , 0 , 'q' , 'w' , 'e' , 'r' , 't' , 'y' , 'u' , 'i' , 'o' , 'p' , 0 , 0 , '\r' , 0 , 'a' , 's' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' , ';' , '\'' , '`' , 0 , '\\' , 'z' , 'x' , 'c' , 'v' , 'b' , 'n' , 'm' , ',' , '.' , '/' , 0 , 0 , 0 , ' ' , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 103 , 104 , 105 , 106};
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      XSync ( wc->Dsp , False ) ;
gkernel.c:      i = wc->c_color;
gkernel.c:      kgcolors = ( kgColor * ) ( wc->kgcolors ) ;
gkernel.c:      wc->c_color = x;
gkernel.c:      kgcolors = ( kgColor * ) wc->kgcolors;
gkernel.c:      XSetForeground ( wc->Dsp , wc->Gc , ( unsigned int ) \
gkernel.c:      wc->c_color = x;
gkernel.c:      kgcolors = ( kgColor * ) wc->kgcolors;
gkernel.c:      XSetForeground ( ( Display * ) wc->Dsp , ( GC ) wc->Gc , \
gkernel.c:      XCopyArea ( ( Display * ) WC ( D )->Dsp , ( Pixmap ) WC ( D )->DspWin , \
gkernel.c:       ( Pixmap ) WC ( D )->DspWin , ( GC ) WC ( D )->Gc , ( short ) x1 , ( short ) \
gkernel.c:       ( y1 ) , ( short ) ( x2-x1+1 ) , ( short ) ( y2-y1+1 ) , \
gkernel.c:       ( short ) x1 , ( short ) ( y1-width ) ) ;
gkernel.c:      if ( fp == NULL ) return -1;
gkernel.c:      sprintf ( buff , "/tmp/.X11-unix/X%-d" , num ) ;
gkernel.c:      remove ( "/tmp/.X0-lock" ) ;
gkernel.c:      remove ( "/tmp/.X11-unix/X0" ) ;
gkernel.c://	  kgChangeJob( "Xorg :0.0 vt7 -quiet -allowMouseOpenFail -terminate -reset -nopn   -retro  ");
gkernel.c:              kgChangeJob ( "Xorg :0.0 vt7 -quiet -allowMouseOpenFail -reset -nopn   -retro  " ) ;
gkernel.c://		sprintf(command,"Xorg :0.0 vt7 -quiet -allowMouseOpenFail -terminate -reset -nopn   -retro   -logfile %s",logfile);
gkernel.c:              sprintf ( command , "Xorg :0.0 vt7 -quiet -allowMouseOpenFail  -reset -nopn   -retro   -logfile %s" , logfile ) ;
gkernel.c:      kgcolors = ( kgColor * ) ( WC ( D )->kgcolors ) ;
gkernel.c:      Dsp = ( Display * ) WC ( D )->Dsp;
gkernel.c:      Cmap = ( Colormap ) WC ( D )->Cmap;
gkernel.c:      if ( i < 0 ) return -1;
gkernel.c:      XDrawPoint ( wc->Dsp , wc->ActWin , wc->Gc , ( short ) col , ( short ) row ) ;
gkernel.c:      visclass = vis->class;
gkernel.c:      kgcolors = ( kgColor * ) wc->kgcolors;
gkernel.c:      Dsp = ( Display * ) WC ( D )->Dsp;
gkernel.c:      wc = D->wc;
gkernel.c:      D->gc.Font = 18;
gkernel.c:      D->gc.FontSize = size;
gkernel.c://  wc->GuiFont=18;
gkernel.c://  wc->GuiFontSize=size;
gkernel.c:      sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRF , size , FONTSTR2 ) ;
gkernel.c:      gcv.font = fontstruct->fid;
gkernel.c:      XChangeGC ( Dsp , ( GC ) WC ( D )->Gc , GCFont , & gcv ) ;
gkernel.c:      Dsp = ( Display * ) WC ( D )->Dsp;
gkernel.c:      wc = D->wc;
gkernel.c:      D->gc.Font = 35;
gkernel.c:      D->gc.FontSize = size;
gkernel.c://  wc->GuiFont=18;
gkernel.c://  wc->GuiFontSize=size;
gkernel.c:      sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRF , size , FONTSTR2 ) ;
gkernel.c:      gcv.font = fontstruct->fid;
gkernel.c:      XChangeGC ( Dsp , ( GC ) WC ( D )->Gc , GCFont , & gcv ) ;
gkernel.c:      Dsp = ( Display * ) WC ( D )->Dsp;
gkernel.c:      wc = D->wc;
gkernel.c:      D->gc.Font = D->gc.PromptFont;
gkernel.c:      D->gc.FontSize = D->gc.GuiFontSize;
gkernel.c:      sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV , FontSize , FONTSTR2 ) ;
gkernel.c:          sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV1 , FontSize , FONTSTR2 ) ;
gkernel.c:          sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV2 , FontSize , FONTSTR2 ) ;
gkernel.c:          sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV3 , FontSize , FONTSTR2 ) ;
gkernel.c:      gcv.font = fontstruct->fid;
gkernel.c:      XChangeGC ( Dsp , ( GC ) WC ( D )->Gc , GCFont , & gcv ) ;
gkernel.c:      sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV , FontSize , FONTSTR2 ) ;
gkernel.c:          sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV1 , FontSize , FONTSTR2 ) ;
gkernel.c:          sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV2 , FontSize , FONTSTR2 ) ;
gkernel.c:          sprintf ( FONTNEW , "%-s%-2.2d%-s" , FONTSTRV3 , FontSize , FONTSTR2 ) ;
gkernel.c:      gcv.font = fontstruct->fid;
gkernel.c:      status = XSendEvent ( wc->Dsp , DefaultRootWindow ( wc->Dsp ) , False , \
gkernel.c:      k->type = KeyRelease;
gkernel.c:      k->send_event = False;
gkernel.c:      k->display = wc->Dsp;
gkernel.c:      k->window = wc->Win;
gkernel.c:      k->root = DefaultRootWindow ( wc->Dsp ) ;
gkernel.c:      k->subwindow = wc->Win;
gkernel.c:      k->state = state;
gkernel.c:          k->keycode = code;
gkernel.c:          k->same_screen = 1;
gkernel.c:          k->type = KeyPress;
gkernel.c:          k->state = state;
gkernel.c:          status = XSendEvent ( wc->Dsp , wc->Win , True , 0 , e ) ;
gkernel.c:          k->type = KeyRelease;
gkernel.c:          k->state = state;
gkernel.c:          status = XSendEvent ( wc->Dsp , wc->Win , True , 0 , e ) ;
gkernel.c:      if ( ch >= 'a' ) ch = ( ch-'a'+'A' ) ;
gkernel.c:      k->state = ControlMask;
gkernel.c:      k->type = KeyRelease;
gkernel.c:      k->send_event = 1;
gkernel.c:      k->display = wc->Dsp;
gkernel.c:      k->window = wc->Win;
gkernel.c:      k->root = DefaultRootWindow ( wc->Dsp ) ;
gkernel.c:      k->subwindow = wc->Win;
gkernel.c:      k->state = KeyRelease;
gkernel.c:          k->keycode = code;
gkernel.c:          k->same_screen = 1;
gkernel.c:          k->type = KeyPress;
gkernel.c:          status = XSendEvent ( wc->Dsp , wc->Win , False , 0 , e ) ;
gkernel.c:          k->type = KeyRelease;
gkernel.c:          status = XSendEvent ( wc->Dsp , wc->Win , False , 0 , e ) ;
gkernel.c:      mywin = wc->Win;
gkernel.c:      if ( ! XQueryTree ( wc->Dsp , Win , & Root , & Par , & Child , & nChild ) ) {
gkernel.c:      if ( XGetWindowAttributes ( wc->Dsp , win , & xwa ) ) ret = 1;
gkernel.c:      mywin = wc->Win;
gkernel.c:      if ( ! XQueryTree ( wc->Dsp , DefaultRootWindow ( wc->Dsp ) , & Root , & Par , & Child , & nChild ) ) \
gkernel.c:      if ( XGetWindowAttributes ( wc->Dsp , win , & xwa ) ) ret = 1;
gkernel.c:      mywin = wc->Win;
gkernel.c:      k->type = KeyRelease;
gkernel.c:      k->send_event = True;
gkernel.c:      k->send_event = False;
gkernel.c:      k->display = wc->Dsp;
gkernel.c:      k->window = root;
gkernel.c:      k->window = win;
gkernel.c:      k->root = DefaultRootWindow ( wc->Dsp ) ;
gkernel.c:      k->subwindow = mywin;
gkernel.c:      k->state = state;
gkernel.c:          k->keycode = code;
gkernel.c:          k->same_screen = 1;
gkernel.c:          k->type = KeyPress;
gkernel.c:          k->state = state;
gkernel.c://    status= XSendEvent(wc->Dsp,win,False,KeyPress|KeyRelease,e);
gkernel.c://    status= XSendEvent(wc->Dsp,win,False,KeyPress|KeyRelease,e);
gkernel.c:          status = XSendEvent ( wc->Dsp , win , True , 0 , e ) ;
gkernel.c:          k->type = KeyRelease;
gkernel.c:          k->state = state;
gkernel.c://    status= XSendEvent(wc->Dsp,win,False,KeyPress|KeyRelease,e);
gkernel.c:          status = XSendEvent ( wc->Dsp , win , True , 0 , e ) ;
gkernel.c:      if ( ch >= 'a' ) ch = ( ch-'a'+'A' ) ;
gkernel.c:      mywin = wc->Win;
gkernel.c:      k->type = KeyRelease;
gkernel.c:      k->send_event = True;
gkernel.c:      k->display = wc->Dsp;
gkernel.c:      k->window = root;
gkernel.c:      k->window = win;
gkernel.c:      k->root = DefaultRootWindow ( wc->Dsp ) ;
gkernel.c:      k->subwindow = mywin;
gkernel.c:      k->state = state;
gkernel.c:      k->same_screen = 1;
gkernel.c:      k->type = KeyPress;
gkernel.c:      k->state = state;
gkernel.c:      k->keycode = code;
gkernel.c://    status= XSendEvent(wc->Dsp,win,False,KeyPress|KeyRelease,e);
gkernel.c:      status = XSendEvent ( wc->Dsp , win , True , 0 , e ) ;
gkernel.c:      k->type = KeyRelease;
gkernel.c://    status= XSendEvent(wc->Dsp,win,False,KeyPress|KeyRelease,e);
gkernel.c:      status = XSendEvent ( wc->Dsp , win , True , 0 , e ) ;
gkernel.c:      XPutBackEvent ( wc->Dsp , event ) ;
gkernel.c:      XMoveWindow ( wc->Dsp , wc->Win , x , y ) ;
gkernel.c:      d = D->d;
gkernel.c:      Dsp = wc->Dsp;
gkernel.c:      Win = wc->Win;
gkernel.c:      transparency = D->transparency;
gkernel.c:      Dpth = wc->Dpth;
gkernel.c:      XResizeWindow ( wc->Dsp , wc->Win , l , w ) ;
gkernel.c:      _uiTileImage ( wc , wc->Pix , wc->IMAGEBAK , l , w ) ;
gkernel.c:      _uiTileImage ( wc , wc->Piximg , wc->IMAGEBAK , l , w ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      D->evgax = EVGAX;
gkernel.c:      D->evgay = EVGAY;
gkernel.c:      uiset_sup_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
gkernel.c:      uiset_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
gkernel.c:      d = D->d;
gkernel.c:      Dsp = wc->Dsp;
gkernel.c:      Win = wc->Win;
gkernel.c:      transparency = D->transparency;
gkernel.c:      Dpth = wc->Dpth;
gkernel.c://  printf("Adjust: %d %d %d %d\n",l,w,D->xl,D->yl);
gkernel.c:      if ( ( abs ( wc->EVGAX - ( l ) ) > Offset ) \
gkernel.c:       || ( abs ( wc->EVGAY- ( w ) ) > Offset ) ) {
gkernel.c:          _uiTileImage ( wc , wc->Pix , wc->IMAGEBAK , l , w ) ;
gkernel.c:          _uiTileImage ( wc , wc->Piximg , wc->IMAGEBAK , l , w ) ;
gkernel.c:          wc->EVGAX = EVGAX;
gkernel.c:          wc->EVGAY = EVGAY;
gkernel.c:          D->evgax = EVGAX;
gkernel.c:          D->evgay = EVGAY;
gkernel.c:          uiset_sup_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
gkernel.c:          uiset_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
gkernel.c:              if ( d [ i ] .t->code == 'g' ) {
gkernel.c://    printf("Adjust: %d %d %d %d\n",l,w,D->xl,D->yl);
gkernel.c:      XSetInputFocus ( wc->Dsp , PointerRoot , RevertToPointerRoot , CurrentTime ) ;
gkernel.c:          Dsp = ( Display * ) WC ( D )->Dsp;
gkernel.c:      if ( Cw == ( Window ) ( WC ( D )->Win ) ) {
gkernel.c:      XSetInputFocus ( ( Display * ) WC ( D )->Dsp , *win , RevertToPointerRoot , CurrentTime ) ;
gkernel.c:      if ( *win == ( Window ) ( WC ( D )->Win ) ) return 1;
gkernel.c:          if ( strcmp ( png->Sign , "IMG" ) != 0 ) {
gkernel.c:              png = ( GMIMG * ) kgGetInlineImage ( img->image_data , img->size ) ;
gkernel.c:      xoffset = png->xoffset;
gkernel.c:      yoffset = png->yoffset;
gkernel.c://    printf("Calling gm_image :%s\n",png->Sign);
gkernel.c:      w = png->image_width;
gkernel.c:      h = png->image_height;
gkernel.c:      xm = ( w-xoffset ) /2+xoffset;
gkernel.c:      ym = ( h-yoffset ) /2+yoffset;
gkernel.c:      xl = xm -width/2; xu = xm+width-width/2;
gkernel.c:      yl = ym -height/2; yu = ym+height -height/2;
gkernel.c:      dx = xm - xc;
gkernel.c:      dy = ym - yc;
gkernel.c:      xdl = xl-dx;
gkernel.c:      xdu = xu-dx;
gkernel.c:      ydl = yl -dy;
gkernel.c:      ydu = yu -dy;
gkernel.c:      row = -1;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  a = 255 - src->opacity;
gkernel.c:      return WC ( D )->Win;
gkernel.c:      return WC ( D )->Dsp;
gkernel.c:      D = ( DIALOG * ) ( G->D ) ;
gkernel.c:      xpos = G->x1; ypos = G->y1; xres = ( G->x2-G->x1+1 ) ;
gkernel.c:      yres = ( G->y2-G->y1+1 ) ;
gkernel.c:      title = D->name;
gkernel.c:      wc = D->wc;
gkernel.c:      Dsp = wc->Dsp;
gkernel.c:      Parent = WC ( D )->Win;
gkernel.c:      xswa.colormap = wc->Cmap;
gkernel.c:      G->glWindow = ( void * ) sWin;
gkernel.c:      XUnmapWindow ( WC ( D )->Dsp , WC ( D )->Win ) ;
gkernel.c:      XMapWindow ( WC ( D )->Dsp , WC ( D )->Win ) ;
gkernel.c:      Parent = ( DIALOG * ) ( D->parent ) ;
gkernel.c:      xpos = D->xo; ypos = D->yo; xres = D->xl; yres = D->yl;
gkernel.c:      title = D->name;
gkernel.c:      transparency = D->transparency;
gkernel.c:      dec = D->Deco;
gkernel.c:      sticky = D->Sticky;
gkernel.c:      fixpos = D->Fixpos;NoTaskBar = D->NoTaskBar;
gkernel.c:      StackPos = D->StackPos;ShapeXpm = D->Shapexpm;
gkernel.c:      Resize = D->Resize;
gkernel.c:      hints.decorations = dec; // 0 ( false ) means that window decorations should go bye-bye.
gkernel.c:      PARWC = ( kgWC * ) ( Parent->wc ) ;
gkernel.c:      D->wc = wc;
gkernel.c:      Dsp = PARWC->Dsp;
gkernel.c:      if ( clrtbl [ 256 ] == -1 ) {
gkernel.c:      parwin = PARWC->Win;
gkernel.c:      xwmpt->flags = AllHints;
gkernel.c:      xwmpt->initial_state = NormalState;
gkernel.c:      xwmpt->input = True;
gkernel.c:      wc->msg_x = ( EVGAX-316 ) /2;
gkernel.c:      wc->msg_y = EVGAY-24;
gkernel.c:/* added on 8-3-01 */
gkernel.c:          xsh.min_width = D->MinWidth;
gkernel.c:          xsh.min_height = D->MinHeight;
gkernel.c:      wc->Gc = XCreateGC ( Dsp , Win , ( GCForeground | GCBackground ) , & gcv ) ;
gkernel.c:      Gc = wc->Gc;
gkernel.c:      wc->HideCur = XCreatePixmapCursor ( Dsp , CurPix , CurPix , & c0 , & c0 , 0 , 0 ) ;
gkernel.c://  wc->HideCur =  XCreatePixmapCursor(Dsp,CurPix,CurMask,&c15,&c0,1,1);
gkernel.c:      wc->HideCur = XCreatePixmapCursor ( Dsp , CurPix , CurMask , & c0 , & c0 , 0 , 0 ) ;
gkernel.c:      wc->Pix = XCPix ( 0 , 0 , xsh.max_width , xsh.max_height ) ;
gkernel.c:      wc->Piximg = XCPix ( 0 , 0 , xsh.max_width , xsh.max_height ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      wc->Dsp = Dsp;
gkernel.c:      wc->Dpth = Dpth;
gkernel.c:      wc->Win = Win;
gkernel.c:      wc->ActWin = wc->Pix;
gkernel.c:      wc->DspWin = wc->Pix;
gkernel.c:      wc->Cmap = Cmap;
gkernel.c:      wc->Gc = Gc;
gkernel.c:      wc->CurrCur = Curo;
gkernel.c:          case -1:
gkernel.c:      wc->IMAGE = wc->IMAGEBAK = NULL;
gkernel.c://  wc->IMAGE = XGetImage(Dsp,Win,0,0,xsh.min_width,xsh.min_height,0xffffffff,ZPixmap);
gkernel.c://  wc->IMAGEBAK = XGetImage(Dsp,Win,0,0,xsh.min_width,xsh.min_height,0xffffffff,ZPixmap);
gkernel.c:      wc->IMAGE = XGetImage ( Dsp , Win , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      wc->IMAGEBAK = XGetImage ( Dsp , Win , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , transparency ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGEBAK , transparency ) ;
gkernel.c:      XPutImage ( Dsp , wc->Pix , Gc , wc->IMAGE , 0 , 0 , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      XPutImage ( Dsp , wc->Piximg , Gc , wc->IMAGE , 0 , 0 , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      _uiTileImage ( wc , wc->Pix , wc->IMAGE , xresmax , yresmax ) ;
gkernel.c:      _uiTileImage ( wc , wc->Piximg , wc->IMAGE , xresmax , yresmax ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , 0.0 ) ;
gkernel.c:      wc->REDMASKPOS = GetNoOfBits ( wc->IMAGE->red_mask ) ;
gkernel.c:      wc->GREENMASKPOS = GetNoOfBits ( wc->IMAGE->green_mask ) ;
gkernel.c:      wc->BLUEMASKPOS = GetNoOfBits ( wc->IMAGE->blue_mask ) ;
gkernel.c:      wc->DefGuiFontEntry = 0;
gkernel.c:      pthread_mutex_init ( & ( wc->Dsplock ) , NULL ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      wc->Dsp = Dsp;
gkernel.c:      wc->Dpth = Dpth;
gkernel.c:      wc->Win = Win;
gkernel.c:      wc->Gc = Gc;
gkernel.c:      wc->FullScreen = 0;
gkernel.c:      wc->c_color = 0;
gkernel.c:      wc->Clip = Dopen ( ) ;
gkernel.c:      wc->SBlist = Dopen ( ) ;
gkernel.c:      wc->TLIST = Dopen ( ) ;
gkernel.c:      wc->ExposeWin = 0;
gkernel.c:      wc->kgcolors = ( kgColor * ) Malloc ( sizeof ( kgColor ) *1024 ) ;
gkernel.c:      wc->GuiFont = 23;
gkernel.c:      wc->GuiFontSize = 8;
gkernel.c:      kgcolors = ( kgColor * ) wc->kgcolors;
gkernel.c:      wc->Rth = 0;
gkernel.c:      wc->Hlt = 0;
gkernel.c:      wc->Pstr = NULL;
gkernel.c:      wc->Cstr = NULL;
gkernel.c:      wc->cpmenu = NULL;
gkernel.c:      wc->cpCallback = NULL;
gkernel.c://  XGetGeometry(wc->Dsp,wc->Win,Rwin,xo,yo,l,h,borwidth,&depth);
gkernel.c:      XGetWindowAttributes ( wc->Dsp , wc->Win , & xwa ) ;
gkernel.c:      if ( ( *xo == 0 ) && ( *yo == 0 ) ) {*xo = wc->msg_x;*yo = wc->msg_y;}
gkernel.c:      xpos = D->xo; ypos = D->yo; xres = D->xl; yres = D->yl;
gkernel.c:      title = D->name;
gkernel.c:      transparency = D->transparency;
gkernel.c:      dec = D->Deco;
gkernel.c:      sticky = D->Sticky;
gkernel.c:      fixpos = D->Fixpos;NoTaskBar = D->NoTaskBar;
gkernel.c:      StackPos = D->StackPos;ShapeXpm = D->Shapexpm;
gkernel.c:      Resize = D->Resize;
gkernel.c:      NoWinMngr = D->NoWinMngr;
gkernel.c:      hints.decorations = dec; // 0 ( false ) means that window decorations should go bye-bye.
gkernel.c:      D->wc = wc;
gkernel.c:          D->NoWinMngr = 1;
gkernel.c:          D->NoWinMngr = 0;
gkernel.c:      if ( clrtbl [ 256 ] == -1 ) {
gkernel.c:      if ( D->parent != NULL ) {
gkernel.c:          Parent = WC ( D->parent )->Win;
gkernel.c:      if ( D->PWIN != NULL ) {
gkernel.c:          Parent = * ( ( Window * ) ( D->PWIN ) ) ;
gkernel.c:      xwmpt->flags = AllHints;
gkernel.c:      xwmpt->initial_state = NormalState;
gkernel.c:      xwmpt->input = True;
gkernel.c:      wc->msg_x = ( EVGAX-316 ) /2;
gkernel.c:      wc->msg_y = EVGAY-24;
gkernel.c:      wc->msg_x = xpos;
gkernel.c:      wc->msg_y = ypos;
gkernel.c:/* added on 8-3-01 */
gkernel.c:          xsh.min_width = D->MinWidth;
gkernel.c:          xsh.min_height = D->MinHeight;
gkernel.c:      D->Maxl = xsh.max_width;
gkernel.c:      D->Maxw = xsh.max_height;
gkernel.c:      wc->HideCur = XCreatePixmapCursor ( Dsp , CurPix , CurPix , & c0 , & c0 , 0 , 0 ) ;
gkernel.c://  wc->HideCur =  XCreatePixmapCursor(Dsp,CurPix,CurMask,&c15,&c0,1,1);
gkernel.c:      wc->HideCur = XCreatePixmapCursor ( Dsp , CurPix , CurMask , & c0 , & c0 , 0 , 0 ) ;
gkernel.c:      wc->Pix = XCPix ( 0 , 0 , xsh.max_width , xsh.max_height ) ;
gkernel.c:      wc->Piximg = XCPix ( 0 , 0 , xsh.max_width , xsh.max_height ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      wc->Dsp = Dsp;
gkernel.c:      wc->Dpth = Dpth;
gkernel.c:      wc->Win = Win;
gkernel.c:      wc->ActWin = wc->Pix;
gkernel.c:      wc->DspWin = wc->Pix;
gkernel.c:      wc->Cmap = Cmap;
gkernel.c:      wc->Gc = Gc;
gkernel.c:      wc->CurrCur = Curo;
gkernel.c:              case -1:
gkernel.c:          if ( D->fullscreen ) {
gkernel.c:      wc->IMAGE = wc->IMAGEBAK = NULL;
gkernel.c:      wc->IMAGE = XGetImage ( Dsp , Win , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      wc->IMAGEBAK = XGetImage ( Dsp , Win , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      wc->IMAGE = XGetImage ( Dsp , wc->Pix , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      wc->IMAGEBAK = XGetImage ( Dsp , wc->Pix , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , transparency ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGEBAK , transparency ) ;
gkernel.c:      XPutImage ( Dsp , wc->Pix , Gc , wc->IMAGE , 0 , 0 , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      XPutImage ( Dsp , wc->Piximg , Gc , wc->IMAGE , 0 , 0 , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      _uiTileImage ( wc , wc->Pix , wc->IMAGE , xresmax , yresmax ) ;
gkernel.c:      _uiTileImage ( wc , wc->Piximg , wc->IMAGE , xresmax , yresmax ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , 0.0 ) ;
gkernel.c:      wc->REDMASKPOS = GetNoOfBits ( wc->IMAGE->red_mask ) ;
gkernel.c:      wc->GREENMASKPOS = GetNoOfBits ( wc->IMAGE->green_mask ) ;
gkernel.c:      wc->BLUEMASKPOS = GetNoOfBits ( wc->IMAGE->blue_mask ) ;
gkernel.c:      wc->DefGuiFontEntry = 0;
gkernel.c:      pthread_mutex_init ( & ( wc->Dsplock ) , NULL ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      wc->Dsp = Dsp;
gkernel.c:      wc->Dpth = Dpth;
gkernel.c:      wc->Win = Win;
gkernel.c:      wc->Gc = Gc;
gkernel.c:      wc->FullScreen = 0;
gkernel.c:      wc->c_color = 0;
gkernel.c:      wc->Clip = Dopen ( ) ;
gkernel.c:      wc->SBlist = Dopen ( ) ;
gkernel.c:      wc->TLIST = Dopen ( ) ;
gkernel.c:      wc->ExposeWin = 0;
gkernel.c:      wc->kgcolors = ( kgColor * ) Malloc ( sizeof ( kgColor ) *1024 ) ;
gkernel.c:      wc->GuiFont = 23;
gkernel.c:      wc->GuiFontSize = 8;
gkernel.c:      kgcolors = ( kgColor * ) wc->kgcolors;
gkernel.c:          wc->Root = Root;
gkernel.c:          wc->Parent = Par;
gkernel.c:      wc->Rth = 0;
gkernel.c:      wc->Hlt = 0;
gkernel.c:      wc->Pstr = NULL;
gkernel.c:      wc->Cstr = NULL;
gkernel.c:      wc->cpmenu = NULL;
gkernel.c:      wc->cpCallback = NULL;
gkernel.c:      hints.decorations = dec; // 0 ( false ) means that window decorations should go bye-bye.
gkernel.c:      if ( clrtbl [ 256 ] == -1 ) {
gkernel.c:      xwmpt->flags = AllHints;
gkernel.c:      xwmpt->initial_state = NormalState;
gkernel.c:      xwmpt->input = True;
gkernel.c://  xwmpt->input=False;
gkernel.c://  xwmpt->initial_state=WithdrawnState;
gkernel.c:      wc->msg_x = ( EVGAX-316 ) /2;
gkernel.c:      wc->msg_y = EVGAY-24;
gkernel.c:/* added on 8-3-01 */
gkernel.c:/* end of add on 8-3-01 */
gkernel.c:      wc->HideCur = XCreatePixmapCursor ( Dsp , CurPix , CurMask , & c15 , & c0 , 1 , 1 ) ;
gkernel.c:      wc->Pix = XCPix ( 0 , 0 , xsh.max_width , xsh.max_height ) ;
gkernel.c:      wc->Piximg = XCPix ( 0 , 0 , xsh.max_width , xsh.max_height ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      wc->Dsp = Dsp;
gkernel.c:      wc->Dpth = Dpth;
gkernel.c:      wc->Win = Win;
gkernel.c:      wc->ActWin = wc->Pix;
gkernel.c:      wc->DspWin = wc->Pix;
gkernel.c:      wc->Cmap = Cmap;
gkernel.c:      wc->Gc = Gc;
gkernel.c:          case -1:
gkernel.c:      wc->IMAGE = wc->IMAGEBAK = NULL;
gkernel.c:      wc->IMAGE = XGetImage ( Dsp , Win , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      wc->IMAGEBAK = XGetImage ( Dsp , Win , 0 , 0 , 20 , 20 , 0xffffffff , ZPixmap ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , transparency ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGEBAK , transparency ) ;
gkernel.c:      XPutImage ( Dsp , wc->Pix , Gc , wc->IMAGE , 0 , 0 , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      XPutImage ( Dsp , wc->Piximg , Gc , wc->IMAGE , 0 , 0 , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      _uiTileImage ( wc , wc->Pix , wc->IMAGE , xresmax , yresmax ) ;
gkernel.c:      _uiTileImage ( wc , wc->Piximg , wc->IMAGE , xresmax , yresmax ) ;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , 0.0 ) ;
gkernel.c:      wc->DefGuiFontEntry = 0;
gkernel.c:      wc->REDMASKPOS = GetNoOfBits ( wc->IMAGE->red_mask ) ;
gkernel.c:      wc->GREENMASKPOS = GetNoOfBits ( wc->IMAGE->green_mask ) ;
gkernel.c:      wc->BLUEMASKPOS = GetNoOfBits ( wc->IMAGE->blue_mask ) ;
gkernel.c:      pthread_mutex_init ( & ( wc->Dsplock ) , NULL ) ;
gkernel.c:      wc->EVGAX = EVGAX;
gkernel.c:      wc->EVGAY = EVGAY;
gkernel.c:      wc->Dsp = Dsp;
gkernel.c:      wc->Dpth = Dpth;
gkernel.c:      wc->Win = Win;
gkernel.c:      wc->Gc = Gc;
gkernel.c:      wc->FullScreen = 0;
gkernel.c:      wc->c_color = 0;
gkernel.c:      wc->Clip = Dopen ( ) ;
gkernel.c:      wc->SBlist = Dopen ( ) ;
gkernel.c:      wc->TLIST = Dopen ( ) ;
gkernel.c:      wc->ExposeWin = 0;
gkernel.c:      wc->kgcolors = ( kgColor * ) Malloc ( sizeof ( kgColor ) *1024 ) ;
gkernel.c:      wc->GuiFont = 23;
gkernel.c:      wc->GuiFontSize = 8;
gkernel.c:      kgcolors = ( kgColor * ) wc->kgcolors;
gkernel.c:      cEvent.window = wc->Win;
gkernel.c:      cEvent.message_type = XInternAtom ( wc->Dsp , "_NET_WM_ALLOWED_ACTIONS" , True ) ;
gkernel.c:      cEvent.data.l [ 0 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_STICK" , True ) ;
gkernel.c:      cEvent.data.l [ 1 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_ABOVE" , True ) ;
gkernel.c:      cEvent.data.l [ 2 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_BELOW" , True ) ;
gkernel.c:      cEvent.data.l [ 3 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_MOVE" , False ) ;
gkernel.c:      cEvent.data.l [ 4 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_RESIZE" , False ) ;
gkernel.c:      cEvent.window = wc->Win;
gkernel.c:      cEvent.message_type = XInternAtom ( wc->Dsp , "_NET_WM_ALLOWED_ACTIONS" , True ) ;
gkernel.c:      cEvent.data.l [ 0 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_STICK" , True ) ;
gkernel.c:      cEvent.data.l [ 1 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_ABOVE" , True ) ;
gkernel.c:      cEvent.data.l [ 2 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_BELOW" , True ) ;
gkernel.c:      cEvent.data.l [ 3 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_MOVE" , True ) ;
gkernel.c:      cEvent.data.l [ 4 ] = XInternAtom ( wc->Dsp , "_NET_WM_ACTION_RESIZE" , True ) ;
gkernel.c:      XDefineCursor ( wc->Dsp , wc->Win , wc->HideCur ) ;
gkernel.c:      XDefineCursor ( wc->Dsp , wc->Win , wc->CurrCur ) ;
gkernel.c:// XDrawLine(wc->Dsp,wc->WIN,wc->Gc,(short)(x1),(short)(wc->EVGAY-1-y1),(short)(x2),(short)(wc->EVGAY-1-y2));
gkernel.c:      XFillRectangle ( wc->Dsp , wc->ActWin , wc->Gc , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c:      XFillRectangle ( wc->Dsp , wc->ActWin , wc->Gc , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c:      int xp , yp , xl , yl , xpold = -100 , ypold = -100 , count , evnt;
gkernel.c:      EVGAX = D->evgax;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      xl = ( xmax-xmin+1 ) ;
gkernel.c:      yl = ( ymax-ymin+1 ) ;
gkernel.c:      if ( xmax > EVGAX ) {xmin = EVGAX-xl; xmax = EVGAX;}
gkernel.c:      if ( ymax > EVGAY ) {ymin = EVGAY-yl; ymax = EVGAY;}
gkernel.c:      Img = XGetImage ( wc->Dsp , wc->ActWin , xmin , ymin , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:              xp = kbe.x-xl/2;
gkernel.c:              yp = kbe.y-yl/2;
gkernel.c:              if ( ( xp+xl ) > EVGAX ) xp = EVGAX-xl;
gkernel.c:              if ( ( yp+yl ) > EVGAY ) yp = EVGAY-yl;
gkernel.c:                  XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:              bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:              XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:          XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:      int xp , yp , xpold = -100 , ypold = -100 , count , evnt , ret = 0 , no = 0;
gkernel.c:      EVGAX = D->evgax;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      if ( ( xp+xl ) > EVGAX ) xp = EVGAX-xl;
gkernel.c:      if ( ( yp+yl ) > EVGAY ) yp = EVGAY-yl;
gkernel.c:      if ( ( yp+yl ) > ymax ) yp = ymax-yl;
gkernel.c:              xp = kbe.x-xl/2;
gkernel.c:              yp = kbe.y-yl/2;
gkernel.c:              if ( ( xp+xl ) > EVGAX ) xp = EVGAX-xl;
gkernel.c:              if ( ( yp+yl ) > EVGAY ) yp = EVGAY-yl;
gkernel.c:              if ( ( yp+yl ) > ymax ) yp = ymax-yl;
gkernel.c:                  ret = -1;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:                      bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                  return -1;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:                      bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                      bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                  XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:              bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:              XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                      bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:          XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:      int xp , yp , xpold = -100 , ypold = -100 , count , evnt , ret = 0 , no = 0 , ymid;
gkernel.c:      EVGAX = D->evgax;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      if ( ( xp+xl ) > EVGAX ) xp = EVGAX-xl;
gkernel.c:      if ( ( yp+yl ) > EVGAY ) yp = EVGAY-yl;
gkernel.c:          if ( ( yp+yl ) > ymax ) yp = ymax-yl;
gkernel.c:              xp = kbe.x-xl/2;
gkernel.c:              yp = kbe.y-yl/2;
gkernel.c:              if ( ( xp+xl ) > EVGAX ) xp = EVGAX-xl;
gkernel.c:              if ( ( yp+yl ) > EVGAY ) yp = EVGAY-yl;
gkernel.c:                  if ( ( yp+yl ) > ymax ) yp = ymax-yl;
gkernel.c:                      ret = -1;
gkernel.c:                          XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:                      return -1;
gkernel.c:                          XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:                      bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:                      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:                  XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xpold , ypold , xl , yl ) ;
gkernel.c:              bkup = XGetImage ( wc->Dsp , wc->ActWin , xp , yp , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:              XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:          XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , bkup , 0 , 0 , xp , yp , xl , yl ) ;
gkernel.c:      int xp , yp , xl , yl , xpold = -100 , ypold = -100 , count , evnt;
gkernel.c:      EVGAX = D->evgax;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      xl = ( xmax-xmin+1 ) ;
gkernel.c:      yl = ( ymax-ymin+1 ) ;
gkernel.c:      if ( xmax > EVGAX ) {xmin = EVGAX-xl; xmax = EVGAX;}
gkernel.c:      if ( ymax > EVGAY ) {ymin = EVGAY-yl; ymax = EVGAY;}
gkernel.c:      Img = XGetImage ( wc->Dsp , wc->ActWin , xmin , ymin , xl , yl , 0xffffffff , ZPixmap ) ;
gkernel.c:      ALPHA = 255* ( 1.-transparency ) ;
gkernel.c:      XFillRectangle ( wc->Dsp , wc->ActWin , wc->Gc , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c:      Img = XGetImage ( wc->Dsp , wc->ActWin , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 , 0x00ffffff , ZPixmap ) ;
gkernel.c:      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , Img , 0 , 0 , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c:          fac = 1-transparency;
gkernel.c:          Alpha = ( unsigned long ) ( 255* ( 1-transparency*transparency ) ) ;
gkernel.c:          clr = wc->c_color;
gkernel.c:          uiImage = XGetImage ( wc->Dsp , wc->ActWin , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 , 0xffffffff , ZPixmap ) ;
gkernel.c:          Rshift = GetShift ( uiImage->red_mask ) ;
gkernel.c:          Gshift = GetShift ( uiImage->green_mask ) ;
gkernel.c:          Bshift = GetShift ( uiImage->blue_mask ) ;
gkernel.c://     printf("RShift: %d %d %d:%d %d %d %d %d\n",Rshift,Gshift,Bshift,uiImage->xoffset,uiImage->format,uiImage->depth,uiImage->bytes_per_line,uiImage->bits_per_pixel);
gkernel.c:          ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:          Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:          w = uiImage->width;
gkernel.c:          h = uiImage->height;
gkernel.c:          XFillRectangle ( wc->Dsp , wc->ActWin , wc->Gc , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c:          uiImage = XGetImage ( wc->Dsp , wc->ActWin , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 , 0x00ffffff , ZPixmap ) ;
gkernel.c:          XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , uiImage , 0 , 0 , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c:      else XFillRectangle ( wc->Dsp , wc->ActWin , wc->Gc , xmin , ymin , xmax-xmin+1 , ymax-ymin+1 ) ;
gkernel.c://   XDrawString(Dsp,ActWin,Gc,x,y,str,strlen(str)-1);
gkernel.c:      wc = D->wc;
gkernel.c:      ln = uiStringLength ( str , D->gc.FontSize ) +1.0;
gkernel.c:      maxchar = ( ln+wc->GuiFontSize ) /D->gc.FontSize;
gkernel.c:      while ( str [ ln-1 ] <= ' ' ) ln--;
gkernel.c://   img = gphStringToImage(str,ln*10,20,3,wc->c_color);
gkernel.c:      img = kgStringToImage ( str , NULL , ln , 20 , D->gc.Font , wc->c_color , justfic , D->gc.FontSize , -1 ) ;
gkernel.c:          kgImage ( D , img , x , y-16 , ln , 20 , 0.0 , 1.0 ) ;
gkernel.c:      while ( str [ ln-1 ] <= ' ' ) ln--;
gkernel.c:      XDrawText ( ( Display * ) WC ( D )->Dsp , WC ( D )->ActWin , \
gkernel.c:       ( GC ) WC ( D )->Gc , x , y , item , ln ) ;
gkernel.c://   XDrawString(Dsp,ActWin,Gc,x,y,str,strlen(str)-1);
gkernel.c:      wc = D->wc;
gkernel.c:      while ( str [ ln-1 ] <= ' ' ) ln--;
gkernel.c://   img = gphStringToImage(str,ln*10,20,3,wc->c_color);
gkernel.c:      img = gphStringToImage ( str , ln*wc->GuiFontSize , 20 , wc->GuiFont , wc->c_color , -1 , ln ) ;
gkernel.c:          kgImage ( D , img , x , y-16 , ln*10 , 20 , 0.0 , 1.0 ) ;
gkernel.c:      while ( str [ ln-1 ] <= ' ' ) ln--;
gkernel.c:      XDrawText ( ( Display * ) WC ( D )->Dsp , WC ( D )->ActWin , \
gkernel.c:       ( GC ) WC ( D )->Gc , x , y , item , ln ) ;
gkernel.c:      pthread_mutex_unlock ( & ( WC ( D )->Dsplock ) ) ;
gkernel.c:      pthread_mutex_destroy ( & ( WC ( D )->Dsplock ) ) ;
gkernel.c:      if ( WC ( D )->IMAGE != NULL ) {
gkernel.c:          XDestroyImage ( ( XImage * ) ( WC ( D )->IMAGE ) ) ;
gkernel.c:          WC ( D )->IMAGE = NULL;
gkernel.c:          XDestroyImage ( ( XImage * ) ( WC ( D )->IMAGEBAK ) ) ;
gkernel.c:          WC ( D )->IMAGEBAK = NULL;
gkernel.c:      XFreePixmap ( ( Display * ) ( WC ( D )->Dsp ) , \
gkernel.c:       ( Pixmap ) ( WC ( D )->Pix ) ) ;
gkernel.c:      XFreePixmap ( ( Display * ) ( WC ( D )->Dsp ) , \
gkernel.c:       ( Pixmap ) ( WC ( D )->Piximg ) ) ;
gkernel.c:      XFreeGC ( ( Display * ) ( WC ( D )->Dsp ) , ( WC ( D )->Gc ) ) ;
gkernel.c:      XDestroyWindow ( ( Display * ) ( WC ( D )->Dsp ) , \
gkernel.c:       ( Window ) ( WC ( D )->Win ) ) ;
gkernel.c:      XCloseDisplay ( ( Display * ) ( WC ( D )->Dsp ) ) ;
gkernel.c:      WC ( D )->Dsp = NULL;
gkernel.c:      XCopyArea ( wc->Dsp , wc->DspWin , wc->linebuf , wc->Gc , ( short ) xmin , \
gkernel.c:       ( short ) ( ymin ) , ( short ) ( xmax-xmin+1 ) , \
gkernel.c:       ( short ) ( ymax-ymin+1 ) , i*nx , 0 ) ;
gkernel.c:      dx = x2-x1;
gkernel.c:      dy = y2-y1;
gkernel.c:      if ( ny < 0 ) ny -= 2; else ny+= 2;
gkernel.c:      if ( nx < 0 ) nx -= 2; else nx+= 2;
gkernel.c:      wc->linebuf = XCreatePixmap ( wc->Dsp , wc->DspWin , ( short ) \
gkernel.c:       ( length ) , ( short ) ( width ) , wc->Dpth ) ;
gkernel.c:      for ( i = 0;i < ( nb-1 ) ;i++ ) {
gkernel.c:      xl = x1 + ( nb-1 ) *dxx;
gkernel.c:      yl = y1 + ( nb-1 ) *dyy;
gkernel.c:      copy_area ( wc , xl , yl , x2 , y2 , nb-1 , nxp ) ;
gkernel.c:      XCopyArea ( wc->Dsp , wc->linebuf , wc->DspWin , wc->Gc , i*nx , 0 , ( short ) \
gkernel.c:       ( xmax-xmin+1 ) , ( short ) ( ymax-ymin+1 ) , \
gkernel.c:      dx = x2-x1;
gkernel.c:      dy = y2-y1;
gkernel.c:      if ( ny < 0 ) ny -= 2; else ny+= 2;
gkernel.c:      if ( nx < 0 ) nx -= 2; else nx+= 2;
gkernel.c:      for ( i = 0;i < ( nb-1 ) ;i++ ) {
gkernel.c:      xl = x1 + ( nb-1 ) *dxx;
gkernel.c:      yl = y1 + ( nb-1 ) *dyy;
gkernel.c:      rest_area ( wc , xl , yl , x2 , y2 , nb-1 , nxp ) ;
gkernel.c:      XFreePixmap ( wc->Dsp , wc->linebuf ) ;
gkernel.c:      D = ( DIALOG * ) G->D;
gkernel.c:      wc = D->wc;
gkernel.c:      gwc = G->wc;
gkernel.c:      dc = G->dc;
gkernel.c:      EVGAY = wc->EVGAY;
gkernel.c:      EVGAX = wc->EVGAX;
gkernel.c:      if ( dc->DOUBLE ) return;
gkernel.c:      wc->WIN = wcXCPix ( 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      tmpc = wc->c_color;
gkernel.c:      uiMakeImageTransparent ( wc->IMAGE , 0.0 ) ;
gkernel.c://     XPutImage(wc->Dsp,wc->WIN,wc->Gc,wc->IMAGE,0,0,0,0,EVGAX,EVGAY);
gkernel.c:      _uiTileImage ( wc , wc->WIN , wc->IMAGE , EVGAX , EVGAY ) ;
gkernel.c:      wc->ActWin = wc->WIN;
gkernel.c:      wc->DspWin = wc->WIN;
gkernel.c:      gwc->WIN = wc->WIN;
gkernel.c:      gwc->ActWin = wc->WIN;
gkernel.c:      XFillRectangle ( wc->Dsp , wc->ActWin , wc->Gc , 0 , 0 , EVGAX , EVGAY ) ;
gkernel.c:      dc->DOUBLE = 1;
gkernel.c:      D = ( DIALOG * ) G->D;
gkernel.c:      gwc = G->wc;
gkernel.c:      dc = G->dc;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      if ( dc->DOUBLE != 1 ) return;
gkernel.c:      wc->ActWin = wc->DspWin = wc->Pix;
gkernel.c:      gwc->ActWin = gwc->DspWin = wc->Pix;
gkernel.c:      XFreePixmap ( wc->Dsp , wc->WIN ) ;
gkernel.c:      wc->Update = 1; // UpdateOn ( ) need not be used
gkernel.c:      dc->DOUBLE = 0;
gkernel.c:      D = ( DIALOG * ) G->D;
gkernel.c:      dc = G->dc;
gkernel.c:      EVGAX = G->x2-G->x1+1;
gkernel.c:      EVGAY = abs ( G->y2-G->y1 ) +1;
gkernel.c:      x0 = dc->vu_x1* ( float ) EVGAX;
gkernel.c:      y1 = EVGAY-1 - dc->vu_y1* ( float ) EVGAY;
gkernel.c:      x1 = dc->vu_x2* ( float ) EVGAX-1;
gkernel.c:      y0 = EVGAY-1 - dc->vu_y2* ( float ) EVGAY+1;
gkernel.c:      x0 += ( G->x1+D->xo ) ;
gkernel.c:      x1 += ( G->x1+D->xo ) ;
gkernel.c:      y0 += ( G->y1+D->yo ) ;
gkernel.c:      y1 += ( G->y1+D->yo ) ;
gkernel.c:      if ( G->D_ON == 0 ) {
gkernel.c:      XCopyArea ( wc->Dsp , wc->WIN , wc->Pix , wc->Gc , x0 , y0 , \
gkernel.c:       ( short ) ( x1-x0 ) , ( short ) ( y1-y0 ) , x0 , y0 ) ;
gkernel.c:      wc->Update = 0;
gkernel.c:      wc->Update = 1;
gkernel.c:      EVGAX = wc->EVGAX;
gkernel.c:      EVGAY = wc->EVGAY;
gkernel.c:      if ( wc->Update ) {
gkernel.c:          if ( wc->FullScreen ) {
gkernel.c:              XCopyArea ( wc->Dsp , wc->Pix , wc->Win , wc->Gc , 0 , 0 , EVGAX , EVGAY , 0 , 0 ) ;
gkernel.c://       XCopyArea(wc->Dsp,wc->ActWin,wc->Win,wc->Gc,0,0,EVGAX,EVGAY,0,0);
gkernel.c:              XSync ( wc->Dsp , False ) ;
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              XLockDisplay ( wc->Dsp ) ;
gkernel.c:              XCopyArea ( wc->Dsp , wc->Pix , wc->Piximg , wc->Gc , 0 , 0 , EVGAX , EVGAY , 0 , 0 ) ;
gkernel.c:              XCopyArea ( wc->Dsp , wc->Piximg , wc->Win , wc->Gc , 0 , 0 , EVGAX , EVGAY , 0 , 0 ) ;
gkernel.c:              XSync ( wc->Dsp , False ) ;
gkernel.c:              XUnlockDisplay ( wc->Dsp ) ;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:      D = ( DIALOG * ) G->D;
gkernel.c:      dc = G->dc;
gkernel.c:      if ( dc->DOUBLE != 1 ) return;
gkernel.c:      if ( ierr == -1 ) printf ( "ERROR IN  IOCTL\n" ) ;
gkernel.c:      if ( ierr == -1 ) printf ( "ERROR IN IOCTL\n" ) ;
gkernel.c:      if ( ierr == -1 ) printf ( "ERROR IN  IOCTL\n" ) ;
gkernel.c:      keysym = XGetKeyboardMapping ( Dsp , K_min , K_max-K_min+1 , & code ) ;
gkernel.c:      for ( i = 0;i < 256;i++ ) Revscan_code [ i ] = -1;
gkernel.c://      xm->max_keypermod = 1; //should not be done
gkernel.c:      fprintf ( stderr , "Max mod: %d\n" , xm->max_keypermod ) ;
gkernel.c:      for ( i = 0;i < xm->max_keypermod;i++ ) {
gkernel.c:          mpt = ( xm->modifiermap+k ) ;
gkernel.c:      k = ( K_min-1 ) *code;
gkernel.c:      for ( i = K_min;i < ( K_max-160 ) ;i++ ) {
gkernel.c:// For control charactres Cntl-A to Cntl-_
gkernel.c:      for ( i = K_min;i < ( K_max-224 ) ;i++ ) {
gkernel.c:          keysym [ k+224*code ] = 0x0000+ ( ( i-K_min ) +1 ) ;
gkernel.c://    keysym[k+224*code]=0xff00|((i-K_min)+'A');
gkernel.c://    keysym[k+224*code]=0x1008ff00+(i-K_min)+1;
gkernel.c:      XChangeKeyboardMapping ( Dsp , K_min , code , keysym , K_max-K_min+1 ) ;
gkernel.c:      k = ( K_min-1 ) *code;
gkernel.c:      for ( i = 224;i < ( K_max-K_min ) ;i++ ) {
gkernel.c:          if ( k == -1 ) continue;
gkernel.c://    if(k>=128) ch= Scan_sh_code[k-128];
gkernel.c:  short key_press ( int *c ) { /* Modification as on 29-12-99 */
gkernel.c:      int keypress = -1 , i , code;
gkernel.c:      if ( keypress <= 0 ) return ( -1 ) ;
gkernel.c:          if ( ( Shift != 0 ) && ( ch >= 'A' ) && ( ch <= 'Z' ) ) ch+= ( 'a'-'A' ) ;
gkernel.c:          if ( ( Shift == 0 ) && ( ch >= 'a' ) && ( ch <= 'z' ) ) ch-= ( 'a'-'A' ) ;
gkernel.c:      if ( key_press ( & ch ) < 0 ) return ( -1 ) ;
gkernel.c:      if ( ch == 0 ) return ( -1 ) ;
gkernel.c:      wc = D->wc;
gkernel.c:      Cur = XCreateFontCursor ( wc->Dsp , n ) ;
gkernel.c:      wc->CurrCur = Cur;
gkernel.c:      XDefineCursor ( wc->Dsp , wc->Win , Cur ) ;
gkernel.c:       ( -100 ) ;
gkernel.c:      if ( Child != Win ) { return ( -1 ) ; };
gkernel.c:      *x -= ( x0 ) ;*y-= ( y0 ) ;
gkernel.c:      else{ return ( -1 ) ;}
gkernel.c:      if ( wc->eventback.type < 0 ) return;
gkernel.c:      *e = wc->eventback;
gkernel.c:      XPutBackEvent ( wc->Dsp , e ) ;
gkernel.c:      wc->eventback.type = -100;
gkernel.c:      XGetGeometry ( wc->Dsp , wc->Win , & win , & x0 , & y0 , length , height , & bw , & dpth ) ;
gkernel.c:          XWindowEvent ( wc->Dsp , wc->Win , EventMask , & e ) ;
gkernel.c:          wc->event = e;
gkernel.c://          XPeekEvent(wc->Dsp,&eo);
gkernel.c:              while ( XCheckTypedEvent ( wc->Dsp , ResizeRequest , & eo ) ) {
gkernel.c:                      XNextEvent ( wc->Dsp , & eo ) ;
gkernel.c:                      XPeekEvent ( wc->Dsp , & eo ) ;
gkernel.c:              XGetGeometry ( wc->Dsp , wc->Win , & win , & x , & y , & w , & h , & bw , & dpth ) ;
gkernel.c:              while ( XCheckTypedEvent ( wc->Dsp , ConfigureNotify , & eo ) ) {e = eo;}
gkernel.c://          printf("Got Configure Notify %d %d:%d %d \n",D->xl,D->yl,xce.width,xce.height);
gkernel.c://          printf("Got Configure Notify %d %d:%d %d \n",D->xl,D->yl,xce.width,xce.height);
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:                  if ( ( Shift != 0 ) && ( ch >= 'A' ) && ( ch <= 'Z' ) ) ch+= ( 'a'-'A' ) ;
gkernel.c:                  if ( ( Shift == 0 ) && ( ch >= 'a' ) && ( ch <= 'z' ) ) ch-= ( 'a'-'A' ) ;
gkernel.c:                      XPeekEvent ( wc->Dsp , & eo ) ;
gkernel.c:                          XNextEvent ( wc->Dsp , & eo ) ;
gkernel.c:                          XPeekEvent ( wc->Dsp , & eo ) ;
gkernel.c:                          XNextEvent ( wc->Dsp , & e ) ;
gkernel.c:                          if ( XCheckWindowEvent ( wc->Dsp , wc->Win , EventMask , & e ) ) {
gkernel.c:                                  XWindowEvent ( wc->Dsp , wc->Win , EventMask , & e ) ;
gkernel.c:                          if ( ( Btmp.time -time0 ) > 25 ) { break;}
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:          prop = XInternAtom ( wc->Dsp , "XPRI_IN" , True ) ;
gkernel.c:          prop = XInternAtom ( wc->Dsp , "XCLIP_IN" , True ) ;
gkernel.c:      XGetWindowProperty ( wc->Dsp , wc->Win , prop , 0 , 0 , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & txt ) ;
gkernel.c:      XGetWindowProperty ( wc->Dsp , wc->Win , prop , 0 , len , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & txt ) ;
gkernel.c:      XChangeProperty ( wc->Dsp , win , pty , target , 8 , PropModeReplace , \
gkernel.c:      XSendEvent ( wc->Dsp , evt.xselectionrequest.requestor , 0 , 0 , & res ) ;
gkernel.c:      XFlush ( wc->Dsp ) ;
gkernel.c:      if ( ( e->type == SelectionNotify ) || ( e->type == SelectionRequest ) ) return True;
gkernel.c://    XNextEvent(wc->Dsp,&e);
gkernel.c://    if(!XCheckIfEvent(wc->Dsp,&e,_uiselection,NULL)) return -1;
gkernel.c:          while ( ! ( XCheckTypedWindowEvent ( wc->Dsp , wc->Win , SelectionNotify , & e ) ) ) \
gkernel.c:              if ( count > 3 ) return -1;
gkernel.c:          while ( XCheckTypedWindowEvent ( wc->Dsp , wc->Win , SelectionNotify , & e ) ) \
gkernel.c://    XNextEvent(wc->Dsp,&e);
gkernel.c://    if(!XCheckIfEvent(wc->Dsp,&e,_uiselection,NULL)) return -1;
gkernel.c:          if ( ! XCheckTypedWindowEvent ( wc->Dsp , wc->Win , SelectionRequest , & e ) ) \
gkernel.c:              pthread_mutex_lock ( & ( WC ( D )->Rlock ) ) ;
gkernel.c:              pthread_mutex_unlock ( & ( WC ( D )->Rlock ) ) ;
gkernel.c://    if(!XCheckWindowEvent(wc->Dsp,wc->Win,EventMask,&e))return 0;
gkernel.c:          if ( ! XCheckWindowEvent ( wc->Dsp , wc->Win , ButtonMask , & e ) ) return 0;
gkernel.c:          wc->event = e;
gkernel.c:              XGetGeometry ( wc->Dsp , wc->Win , & win , & x , & y , & w , & h , & bw , & dpth ) ;
gkernel.c:              while ( XCheckTypedEvent ( wc->Dsp , ConfigureNotify , & eo ) ) {e = eo;}
gkernel.c://          printf("Got Configure Notify %d %d:%d %d \n",xce.width,xce.height,wc->EVGAX,wc->EVGAY);
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:          if ( ! XCheckWindowEvent ( wc->Dsp , wc->Win , KeyMask , & e ) ) return 0;
gkernel.c:          wc->event = e;
gkernel.c:              XGetGeometry ( wc->Dsp , wc->Win , & win , & x , & y , & w , & h , & bw , & dpth ) ;
gkernel.c:              while ( XCheckTypedEvent ( wc->Dsp , ConfigureNotify , & eo ) ) {e = eo;}
gkernel.c://          printf("Got Configure Notify %d %d:%d %d \n",xce.width,xce.height,wc->EVGAX,wc->EVGAY);
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:                  if ( ( Shift != 0 ) && ( ch >= 'A' ) && ( ch <= 'Z' ) ) ch+= ( 'a'-'A' ) ;
gkernel.c:                  if ( ( Shift == 0 ) && ( ch >= 'a' ) && ( ch <= 'z' ) ) ch-= ( 'a'-'A' ) ;
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:      win = RootWindow ( wc->Dsp , DefaultScreen ( wc->Dsp ) ) ;
gkernel.c:      if ( XQueryPointer ( wc->Dsp , wc->Parent , & Root , & Child , & rx , & ry , & x , & y , & pb ) == False ) \
gkernel.c:          return -1;
gkernel.c:      kbe->rootx = rx;
gkernel.c:      kbe->rooty = ry;
gkernel.c:      kbe->x = x;
gkernel.c:      kbe->y = y;
gkernel.c://  if( Child != wc->Win){ return(-1); };
gkernel.c:      kbe->event = 0;
gkernel.c:      kbe->button = 0;
gkernel.c:          kbe->event = 1;
gkernel.c:          if ( pb & Button1Mask ) kbe->button = 1;
gkernel.c:          if ( pb & Button2Mask ) kbe->button = 2;
gkernel.c:          if ( pb & Button3Mask ) kbe->button = 3;
gkernel.c:          if ( pb & Button4Mask ) kbe->button = 4;
gkernel.c:          if ( pb & Button5Mask ) kbe->button = 5;
gkernel.c:          if ( ( wc->Win == Child ) ) ret = 1;
gkernel.c:          if ( ( wc->Win == Child ) ) ret = 0;
gkernel.c:      if ( ( wc->Win == Child ) ) {
gkernel.c:          XQueryPointer ( wc->Dsp , wc->Win , & Root , & Child , & rx , & ry , & x , & y , & pb ) ;
gkernel.c:          kbe->rootx = rx;
gkernel.c:          kbe->rooty = ry;
gkernel.c:          kbe->x = x;
gkernel.c:          kbe->y = y;
gkernel.c:          if ( ! XCheckWindowEvent ( wc->Dsp , wc->Win , EventMask , & e ) ) return 0;
gkernel.c:          wc->event = e;
gkernel.c://          XPeekEvent(wc->Dsp,&eo);
gkernel.c:              while ( XCheckTypedEvent ( wc->Dsp , ResizeRequest , & eo ) ) {
gkernel.c:                      XNextEvent ( wc->Dsp , & eo ) ;
gkernel.c:                      XPeekEvent ( wc->Dsp , & eo ) ;
gkernel.c:              XGetGeometry ( wc->Dsp , wc->Win , & win , & x , & y , & w , & h , & bw , & dpth ) ;
gkernel.c:              while ( XCheckTypedEvent ( wc->Dsp , ConfigureNotify , & eo ) ) {e = eo;}
gkernel.c://          printf("Got Configure Notify %d %d:%d %d \n",xce.width,xce.height,wc->EVGAX,wc->EVGAY);
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:                  if ( ( Shift != 0 ) && ( ch >= 'A' ) && ( ch <= 'Z' ) ) ch+= ( 'a'-'A' ) ;
gkernel.c:                  if ( ( Shift == 0 ) && ( ch >= 'a' ) && ( ch <= 'z' ) ) ch-= ( 'a'-'A' ) ;
gkernel.c://          while(XCheckWindowEvent(wc->Dsp,wc->Win,EventMask,&e)) {
gkernel.c:                      XPeekEvent ( wc->Dsp , & eo ) ;
gkernel.c:                          XNextEvent ( wc->Dsp , & eo ) ;
gkernel.c:                          XPeekEvent ( wc->Dsp , & eo ) ;
gkernel.c:                          XNextEvent ( wc->Dsp , & e ) ;
gkernel.c:                          XWindowEvent ( wc->Dsp , wc->Win , EventMask , & e ) ;
gkernel.c:                           ( wc->Dsp , wc->Win , EventMask , & e ) ;
gkernel.c:                          if ( ( Btmp.time -time0 ) > 25 ) { break;}
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              wc->ExposeWin = 1;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:      XWarpPointer ( wc->Dsp , wc->Win , wc->Win , 0 , 0 , wc->EVGAX+1 , wc->EVGAY+1 , x , y ) ;
gkernel.c:          default: return -1;
gkernel.c:      col = -1;
gkernel.c:      for ( i = 1023;i >= 0;i-- ) {
gkernel.c:          er = abs ( C.red - DefClrs [ i ] .red ) ;
gkernel.c:          eg = abs ( C.green - DefClrs [ i ] .green ) ;
gkernel.c:          eb = abs ( C.blue - DefClrs [ i ] .blue ) ;
gkernel.c:  /*if( err > 6000 ) col=-col;*/
gkernel.c:      col = -1;
gkernel.c:      for ( i = 1023;i >= 0;i-- ) {
gkernel.c:          er = abs ( C.red - kgcolors [ i ] .red ) ;
gkernel.c:          eg = abs ( C.green - kgcolors [ i ] .green ) ;
gkernel.c:          eb = abs ( C.blue - kgcolors [ i ] .blue ) ;
gkernel.c:  /*if( err > 6000 ) col=-col;*/
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      cEvent.message_type = XInternAtom ( wc->Dsp , "_NET_WM_STATE" , True ) ;
gkernel.c:      cEvent.data.l [ 1 ] = XInternAtom ( wc->Dsp , "_NET_WM_STATE_ABOVE" , True ) ;
gkernel.c:      XRaiseWindow ( wc->Dsp , wc->Win ) ;
gkernel.c:      XSync ( wc->Dsp , False ) ;
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      cEvent.message_type = XInternAtom ( wc->Dsp , "_NET_WM_STATE" , True ) ;
gkernel.c:      cEvent.data.l [ 1 ] = XInternAtom ( wc->Dsp , "_NET_WM_STATE_BELOW" , True ) ;
gkernel.c:      XLowerWindow ( wc->Dsp , wc->Win ) ;
gkernel.c:      XSync ( wc->Dsp , False ) ;
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      cEvent.message_type = XInternAtom ( wc->Dsp , "_NET_WM_STATE" , True ) ;
gkernel.c:      cEvent.data.l [ 1 ] = XInternAtom ( wc->Dsp , "_NET_WM_STATE_ABOVE" , True ) ;
gkernel.c:      XRaiseWindow ( wc->Dsp , wc->Win ) ;
gkernel.c:      XSync ( wc->Dsp , False ) ;
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      cEvent.message_type = XInternAtom ( wc->Dsp , "_NET_WM_STATE" , True ) ;
gkernel.c:      cEvent.data.l [ 1 ] = XInternAtom ( wc->Dsp , "_NET_WM_STATE_BELOW" , True ) ;
gkernel.c:      XLowerWindow ( wc->Dsp , wc->Win ) ;
gkernel.c:      XSync ( wc->Dsp , False ) ;
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      XGetInputFocus ( wc->Dsp , & w , & rev ) ;
gkernel.c:      if ( w == wc->Win ) ret = 1;
gkernel.c:      wc = ( ( DIALOG * ) Tmp )->wc;
gkernel.c:      Curwin = wc->Root;
gkernel.c:      Win = wc->Win;
gkernel.c:      XQueryPointer ( wc->Dsp , Curwin , & Root , & Child , & x1 , & y1 , & x2 , & y2 , & pb ) ;
gkernel.c:          XWarpPointer ( wc->Dsp , Child , Win , 0 , 0 , 0 , 0 , x , y ) ;
gkernel.c:          XWarpPointer ( wc->Dsp , Win , Win , 0 , 0 , 0 , 0 , x , y ) ;
gkernel.c:      XQueryPointer ( wc->Dsp , Curwin , & Root , & Child , & x1 , & y1 , & x2 , & y2 , & pb ) ;
gkernel.c:      XQueryPointer ( wc->Dsp , Child , & Root , & Child , & x1 , & y1 , & x2 , & y2 , & pb ) ;
gkernel.c:#define GREEN_VAL (((((val>>8)&0x0000ff) * ((Image->green_mask)>> \
gkernel.c:   ( BlueMaskPos ) ) + ( 1 << ( ( Image->green_mask >> ( BlueMaskPos ) ) -1 ) ) ) /256 ) << \
gkernel.c:#define RED_VAL (((((val>>16)&0x0000ff) * ((Image->red_mask)>> \
gkernel.c:   ( GreenMaskPos ) ) + ( 1 << ( ( Image->red_mask >> ( GreenMaskPos ) ) -1 ) ) ) /256 ) << \
gkernel.c:      wc = D->wc;
gkernel.c://  IMAGE = XGetImage(wc->Dsp,wc->Win,xo,yo,width,height,0xffffffff,ZPixmap);
gkernel.c:      XPutImage ( wc->Dsp , wc->Pix , wc->Gc , IMAGE , 0 , 0 , xo , yo , width , height ) ;
gkernel.c://  _uiTileImage(wc,wc->WIN,wc->IMAGE,EVGAX,EVGAY);
gkernel.c:      ALPHA = ( 1. -transparency ) *255;
gkernel.c:      ximage_rowbytes = ximage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) ximage->data;
gkernel.c:      for ( j = 0;j < ximage->height;j++ ) {
gkernel.c:          for ( i = 0;i < ximage->width;i++ ) {
gkernel.c:      fac = ( 1-transparency*transparency ) ;
gkernel.c:      fac = ( 1-transparency ) ;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:      for ( j = 0;j < uiImage->height;j++ ) {
gkernel.c:          for ( i = 0;i < uiImage->width;i++ ) {
gkernel.c:      h = ximage->height;
gkernel.c:      w = ximage->width;
gkernel.c:              XPutImage ( wc->Dsp , pix , wc->Gc , ximage , 0 , 0 , xo , yo , w , h ) ;
gkernel.c:          if ( ixr != 0 ) XPutImage ( wc->Dsp , pix , wc->Gc , ximage , 0 , 0 , xo , yo , ixr , h ) ;
gkernel.c:              XPutImage ( wc->Dsp , pix , wc->Gc , ximage , 0 , 0 , xo , yo , w , iyr ) ;
gkernel.c:          if ( ixr != 0 ) XPutImage ( wc->Dsp , pix , wc->Gc , ximage , 0 , 0 , xo , yo , ixr , iyr ) ;
gkernel.c:      free ( png->image_data ) ;
gkernel.c:          L = ( Dlink * ) D->SearchList;
gkernel.c:      my_error_ptr myerr = ( my_error_ptr ) cinfo->err;
gkernel.c://  (*cinfo->err->output_message) (cinfo);
gkernel.c:      longjmp ( myerr->setjmp_buffer , 1 ) ;
gkernel.c:      strcpy ( img->Sign , "JPG" ) ;
gkernel.c:      img->incode = 0;
gkernel.c:      img->col = cinfo.output_width;
gkernel.c:      img->row = cinfo.output_height;
gkernel.c:      img->colors = cinfo.output_components;
gkernel.c:      img->matchcol = ( int * ) Malloc ( sizeof ( int ) *img->row*img->col ) ;
gkernel.c:          pt = img->matchcol+j*img->col;
gkernel.c:          for ( i = 0;i < img->col;i++ ) {
gkernel.c:              bufpt = buffer+ ( i*img->colors ) ;
gkernel.c:              if ( img->colors != 3 ) { r = g = b = bufpt [ 0 ] ;}
gkernel.c:          free ( img->matchcol ) ;
gkernel.c:      if ( wc->FullScreen ) return NULL;
gkernel.c:          if ( wc->ExposeWin ) {
gkernel.c:              pthread_mutex_lock ( & ( wc->Dsplock ) ) ;
gkernel.c:              XLockDisplay ( wc->Dsp ) ;
gkernel.c:              XCopyArea ( wc->Dsp , wc->Piximg , wc->Win , wc->Gc , 0 , 0 , wc->EVGAX , wc->EVGAY , 0 , 0 ) ;
gkernel.c:              XUnlockDisplay ( wc->Dsp ) ;
gkernel.c:              wc->ExposeWin = 0;
gkernel.c:              pthread_mutex_unlock ( & ( wc->Dsplock ) ) ;
gkernel.c:      if ( wc->FullScreen ) return 0;
gkernel.c:      pthread_create ( & ( wc->Pth ) , NULL , RefreshWindow , wc ) ;
gkernel.c:      i--;
gkernel.c:          i--;
gkernel.c:      h = img->row;
gkernel.c:      w = img->col;
gkernel.c:      pt = img->matchcol;
gkernel.c:      fprintf ( fp , "#ifndef D_%-s\n" , name ) ;
gkernel.c:      fprintf ( fp , "#define D_%-s\n" , name ) ;
gkernel.c:      fprintf ( fp , "  static int %-s_data[%d] = {\n  " , name , w*h+1 ) ;
gkernel.c:      rem = ( w*h ) - size*12;
gkernel.c:      fprintf ( fp , "  static JPGIMG  %-s_str = {\n" , name ) ;
gkernel.c:      fprintf ( fp , "    \"JPG\", 1,\"%-s.jpg\",%d,%d,0,NULL,%-s_data \n  };\n" , name , h , w , name ) ;
gkernel.c:      i--;
gkernel.c:          i--;
gkernel.c:      w = img->image_width*img->image_rowbytes;
gkernel.c:      w = img->image_rowbytes;
gkernel.c:      h = img->image_height;
gkernel.c:      pt = img->image_data;
gkernel.c:      fprintf ( fp , "#ifndef D_%-s\n" , name ) ;
gkernel.c:      fprintf ( fp , "#define D_%-s\n" , name ) ;
gkernel.c:      fprintf ( fp , "  static unsigned char %-s_data[%d] = {\n  " , name , w*h+1 ) ;
gkernel.c:      rem = ( w*h ) - size*12;
gkernel.c:      fprintf ( fp , "  static PNGIMG  %-s_str = {\n" , name ) ;
gkernel.c:      fprintf ( fp , "    \"PNG\",1,\"%-s.png\", %ld,%ld,%ld,%d,%-s_data \n  };\n" , name , img->image_width , img->image_height , img->image_rowbytes , img->image_channels , name ) ;
gkernel.c:      if ( ot < 0 ) return -1;
gkernel.c:      if ( ot < 0 ) return -1;
gkernel.c:      i--;
gkernel.c:      while ( flname [ i ] != '/' ) { i--; if ( i < 0 ) break; }
gkernel.c:      i--;
gkernel.c:      while ( flname [ i ] != '/' ) { i--; if ( i < 0 ) break; }
gkernel.c://  sprintf(flname,"%-s.c",infile);
gkernel.c:      fprintf ( fp , "#ifndef D_%-s\n" , basename ) ;
gkernel.c:      fprintf ( fp , "#define D_%-s\n" , basename ) ;
gkernel.c:      fprintf ( fp , "  unsigned char %-s_data[]= {\n" , basename ) ;
gkernel.c:      fprintf ( fp , "  FMGIMG %-s_str = { \"FMG\",1,\"%-s\",%d,%-s_data,NULL};\n" , basename , basename , sum , basename ) ;
gkernel.c:      if ( strcmp ( img->Sign , "JPG" ) == 0 ) {
gkernel.c:          if ( img->incode == 1 ) return;
gkernel.c:          free ( img->matchcol ) ;
gkernel.c:          if ( strcmp ( img->Sign , "PNG" ) == 0 ) {
gkernel.c:              if ( png->incode == 1 ) return;
gkernel.c:              free ( png->image_data ) ;
gkernel.c:              if ( strcmp ( img->Sign , "IMG" ) == 0 ) {
gkernel.c:                  if ( png->incode == 1 ) return;
gkernel.c:              else if ( strcmp ( img->Sign , "FMG" ) == 0 ) {
gkernel.c:                  if ( png->image != NULL ) {uiFreeFmgImage ( tmp ) ;png->image == NULL;}
gkernel.c:                  if ( png->incode == 1 ) return;
gkernel.c:                  free ( png->image_data ) ;
gkernel.c:      ximage = XGetImage ( wc->Dsp , wc->ActWin , xl , yl , w , h , 0xffffffff , ZPixmap ) ;
gkernel.c:      ximage_rowbytes = ximage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) ximage->data;
gkernel.c:      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , ximage , 0 , 0 , xl , yl , w , h ) ;
gkernel.c:      ximage = XGetImage ( wc->Dsp , wc->Pix , xl , yl , w , h , 0xffffffff , ZPixmap ) ;
gkernel.c:      ximage_rowbytes = ximage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) ximage->data;
gkernel.c:      XPutImage ( wc->Dsp , wc->ActWin , wc->Gc , ximage , 0 , 0 , xl , yl , w , h ) ;
gkernel.c:      SBlist = wc->SBlist;
gkernel.c:          wc->SBlist = SBlist;
gkernel.c:      SBlist = wc->SBlist;
gkernel.c:          wc->SBlist = SBlist;
gkernel.c:      SBlist = wc->SBlist;
gkernel.c:          wc->SBlist = SBlist;
gkernel.c:      SBlist = wc->SBlist;
gkernel.c:          XFreePixmap ( wc->Dsp , tmp->buf ) ;
gkernel.c:      SBlist = wc->SBlist;
gkernel.c:              XFreePixmap ( wc->Dsp , tmp->buf ) ;
gkernel.c:          wc->SBlist = NULL;
gkernel.c:      scpt->x1 = x1; scpt->x2 = x2;
gkernel.c:      scpt->y1 = y1; scpt->y2 = y2;
gkernel.c:      scpt->buf = wcXCPix ( x1 , y1 , x2 , y2 ) ;
gkernel.c:      XCopyArea ( wc->Dsp , wc->DspWin , ( scpt->buf ) , wc->Gc , ( short ) x1 , \
gkernel.c:       ( short ) ( y1 ) , ( short ) ( x2-x1+1 ) , ( short ) ( y2-y1+1 ) , 0 , 0 ) ;
gkernel.c:      x1 = scpt->x1; x2 = scpt->x2;
gkernel.c:      y1 = scpt->y1; y2 = scpt->y2;
gkernel.c:      XCopyArea ( wc->Dsp , ( scpt->buf ) , wc->DspWin , wc->Gc , 0 , 0 , ( short ) \
gkernel.c:       ( x2-x1+1 ) , ( short ) ( y2-y1+1 ) , ( short ) x1 , ( short ) y1 ) ;
gkernel.c:      XPutImage ( ( Display * ) ( WC ( D )->Dsp ) , WC ( D )->ActWin , ( GC ) \
gkernel.c:       ( WC ( D )->Gc ) , uiImage , sx , sy , dx , dy , width , height ) ;
gkernel.c:      if ( D->NoWinMngr ) {
gkernel.c:          uiImage = XGetImage ( ( Display * ) WC ( D )->Dsp , scpt->buf , 0 , 0 , width , height , 0xffffffff , ZPixmap ) ;
gkernel.c:          if ( WC ( D )->FullScreen ) {
gkernel.c:              uiImage = XGetImage ( ( Display * ) WC ( D )->Dsp , WC ( D )->ActWin , x , y , width , height , 0xffffffff , ZPixmap ) ;
gkernel.c:              uiImage = XGetImage ( ( Display * ) WC ( D )->Dsp , WC ( D )->Pix , x , y , width , height , 0xffffffff , ZPixmap ) ;
gkernel.c:          if ( WC ( D )->IMAGE != NULL ) {
gkernel.c:              uiImage->red_mask = ( ( XImage * ) ( WC ( D )->IMAGE ) )->red_mask;
gkernel.c:              uiImage->green_mask = ( ( XImage * ) ( WC ( D )->IMAGE ) )->green_mask;
gkernel.c:              uiImage->blue_mask = ( ( XImage * ) ( WC ( D )->IMAGE ) )->blue_mask;
gkernel.c://  uiImage = XGetImage((Display *)(WC(D)->Dsp),WC(D)->ActWin,x,y,width,height,0xffffffff,ZPixmap);
gkernel.c:      EVGAX = WC ( D )->EVGAX;
gkernel.c:      EVGAY = WC ( D )->EVGAY;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0;
gkernel.c:      ALPHA = 255* ( 1.-transparency*transfac ) ;
gkernel.c:      pixels = png->image_data;
gkernel.c:      w = png->image_width;
gkernel.c:      h = png->image_height;
gkernel.c:      xm = ( w-xoffset ) /2+xoffset;
gkernel.c:      ym = ( h-yoffset ) /2+yoffset;
gkernel.c:      xl = xm -width/2; xu = xm+width-width/2;
gkernel.c:      yl = ym -height/2; yu = ym+height -height/2;
gkernel.c:      dx = xm - xc;
gkernel.c:      dy = ym - yc;
gkernel.c:      xdl = xl-dx;
gkernel.c:      xdu = xu-dx;
gkernel.c:      ydl = yl -dy;
gkernel.c:      ydu = yu -dy;
gkernel.c:      uiImage = kg_GetImage ( D , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      RedMaskPos = GetNoOfBits ( uiImage->red_mask ) ;
gkernel.c:      GreenMaskPos = GetNoOfBits ( uiImage->green_mask ) ;
gkernel.c:      BlueMaskPos = GetNoOfBits ( uiImage->blue_mask ) ;
gkernel.c://    uiImage = XGetImage((Display *)WC(D)->Dsp,WC(D)->ActWin,xdl,ydl,xdu-xdl+1,ydu-ydl+1,0xffffffff,ZPixmap);
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line/4;
gkernel.c:      Imgdata = ( unsigned long * ) uiImage->data;
gkernel.c:      row = -1;
gkernel.c:          src = pixels + i*png->image_rowbytes;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                      f1 = 1-f;
gkernel.c://                        f1 = f1*(1.-transparency);
gkernel.c:                      val = val+a* ( 1.-transparency*transfac ) ;
gkernel.c://   XPutImage((Display *)WC(D)->Dsp,WC(D)->ActWin,(GC)WC(D)->Gc,uiImage,0,0,xdl,ydl,xdu,ydu);
gkernel.c:      kgPutImage ( D , uiImage , 0 , 0 , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      wc = D->wc;
gkernel.c:      EVGAX = WC ( D )->EVGAX;
gkernel.c:      EVGAY = WC ( D )->EVGAY;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      if ( png->bkgrclr >= 0 ) {
gkernel.c:          color = wc->c_color;
gkernel.c:          wcset_clr ( wc , png->bkgrclr ) ;
gkernel.c:      ALPHA = 255* ( 1.-transparency ) +0.1;
gkernel.c:      rzfac = png->rzfac;
gkernel.c:      xoffset = png->xoffset;
gkernel.c:      yoffset = png->yoffset;
gkernel.c:      img = png->image;
gkernel.c://    w = png->image_width;
gkernel.c://    h = png->image_height;
gkernel.c:      w = img->columns;
gkernel.c:      h = img->rows;
gkernel.c:      xm = ( w-xoffset ) /2+xoffset;
gkernel.c:      ym = ( h-yoffset ) /2+yoffset;
gkernel.c:      xl = xm -width/2; xu = xm+width-width/2;
gkernel.c:      yl = ym -height/2; yu = ym+height -height/2;
gkernel.c:      dx = xm - xc;
gkernel.c:      dy = ym - yc;
gkernel.c:      xdl = xl-dx;
gkernel.c:      xdu = xu-dx;
gkernel.c:      ydl = yl -dy;
gkernel.c:      ydu = yu -dy;
gkernel.c://    uiImage = XGetImage((Display *)WC(D)->Dsp,WC(D)->ActWin,xdl,ydl,xdu-xdl+1,ydu-ydl+1,0xffffffff,ZPixmap);
gkernel.c:      uiImage = kg_GetImage ( D , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:      row = -1;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  r = src->red;
gkernel.c:                  g = src->green;
gkernel.c:                  b = src->blue;
gkernel.c:                  a = 255 - src->opacity;
gkernel.c://                    a =a*(1.-transparency);
gkernel.c:                      f1 = 1-f;
gkernel.c://   XPutImage((Display *)WC(D)->Dsp,WC(D)->ActWin,(GC)WC(D)->Gc,uiImage,0,0,xdl,ydl,xdu,ydu);
gkernel.c:      kgPutImage ( D , uiImage , 0 , 0 , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:          if ( strcmp ( fmg->Sign , "FMG" ) == 0 ) {
gkernel.c:              strcat ( tmpfile , fmg->flname ) ;
gkernel.c:              uiFmgToFile ( fmg->image_data , fmg->size , tmpfile ) ;
gkernel.c:          if ( strcmp ( fmg->Sign , "FMG" ) == 0 ) {
gkernel.c:              gmimg = ( GMIMG * ) kgGetInlineImage ( fmg->image_data , fmg->size ) ;
gkernel.c:    width is X-direction
gkernel.c:      EVGAX = D->evgax;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      ALPHA = 255* ( 1.-transparency ) ;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      if ( strcmp ( fmg->Sign , "IMG" ) == 0 ) {kg_gm_image ( D , tmp , x0 , y0 , width , height , transparency , highfac ) ;
gkernel.c:      if ( strcmp ( fmg->Sign , "PNG" ) == 0 ) {kg_png_image ( D , tmp , x0 , y0 , width , height , transparency , highfac ) ;
gkernel.c:      if ( strcmp ( fmg->Sign , "FMG" ) == 0 ) {
gkernel.c:          strcat ( tmpfile , img->flname ) ;
gkernel.c:          uiFmgToFile ( img->image_data , img->size , tmpfile ) ;
gkernel.c:          if ( CheckPng ( ( unsigned char * ) ( img->image_data ) ) ) {
gkernel.c:      if ( strcmp ( img->Sign , "JPG" ) != 0 ) {
gkernel.c:      h = img->row;
gkernel.c:      w = img->col;
gkernel.c:          pt = img->matchcol;
gkernel.c:          dx = ( width - w ) /2;
gkernel.c:          dy = ( height - h ) /2;
gkernel.c:          else sx = -dx;
gkernel.c:          else sy = -dy;
gkernel.c:          uiImage = kg_GetImage ( D , x0 , y0 , w-2*sx , h-2*sy ) ;
gkernel.c:          RedMaskPos = GetNoOfBits ( uiImage->red_mask ) ;
gkernel.c:          GreenMaskPos = GetNoOfBits ( uiImage->green_mask ) ;
gkernel.c:          BlueMaskPos = GetNoOfBits ( uiImage->blue_mask ) ;
gkernel.c:          row = -1;
gkernel.c:              pt = img->matchcol+ i*w;
gkernel.c:              if ( i >= ( h-sy ) ) break;
gkernel.c:              k = -1;
gkernel.c:                  if ( ( k ) >= ( w-sx ) ) break;
gkernel.c:          kgPutImage ( D , uiImage , 0 , 0 , x0 , y0 , w-2*sx , h-2*sy ) ;
gkernel.c:          free ( img->matchcol ) ;
gkernel.c:    width is X-direction
gkernel.c:      EVGAX = D->evgax;
gkernel.c:      EVGAY = D->evgay;
gkernel.c:      ALPHA = 255* ( 1.-transparency ) ;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      if ( strcmp ( fmg->Sign , "IMG" ) == 0 ) {kg_gm_image ( D , tmp , x0 , y0 , width , height , transparency , highfac ) ;
gkernel.c:      if ( strcmp ( fmg->Sign , "PNG" ) == 0 ) {kg_png_image ( D , tmp , x0 , y0 , width , height , transparency , highfac ) ;
gkernel.c:      if ( strcmp ( fmg->Sign , "FMG" ) == 0 ) {
gkernel.c:          gmimg = ( GMIMG * ) kgGetInlineImage ( img->image_data , img->size ) ;
gkernel.c:      if ( strcmp ( img->Sign , "JPG" ) != 0 ) {
gkernel.c:      h = img->row;
gkernel.c:      w = img->col;
gkernel.c:          pt = img->matchcol;
gkernel.c:          dx = ( width - w ) /2;
gkernel.c:          dy = ( height - h ) /2;
gkernel.c:          else sx = -dx;
gkernel.c:          else sy = -dy;
gkernel.c:          uiImage = kg_GetImage ( D , x0 , y0 , w-2*sx , h-2*sy ) ;
gkernel.c:          RedMaskPos = GetNoOfBits ( uiImage->red_mask ) ;
gkernel.c:          GreenMaskPos = GetNoOfBits ( uiImage->green_mask ) ;
gkernel.c:          BlueMaskPos = GetNoOfBits ( uiImage->blue_mask ) ;
gkernel.c:          row = -1;
gkernel.c:              pt = img->matchcol+ i*w;
gkernel.c:              if ( i >= ( h-sy ) ) break;
gkernel.c:              k = -1;
gkernel.c:                  if ( ( k ) >= ( w-sx ) ) break;
gkernel.c:          kgPutImage ( D , uiImage , 0 , 0 , x0 , y0 , w-2*sx , h-2*sy ) ;
gkernel.c:          free ( img->matchcol ) ;
gkernel.c:      strcat ( tmpfile , "img->flname" ) ;
gkernel.c:      uiFmgToFile ( img->image_data , img->size , tmpfile ) ;
gkernel.c:      gmimg = ( GMIMG * ) kgGetInlineImage ( img->image_data , img->size ) ;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      ALPHA = 255* ( 1.-transparency ) ;
gkernel.c:      rzfac = png->rzfac;
gkernel.c:      xoffset = png->xoffset;
gkernel.c:      yoffset = png->yoffset;
gkernel.c:      img = png->image;
gkernel.c:      w = img->columns;
gkernel.c:      h = img->rows;
gkernel.c:      xm = ( w-xoffset ) /2+xoffset;
gkernel.c:      ym = ( h-yoffset ) /2+yoffset;
gkernel.c:      xl = xm -width/2; xu = xm+width-width/2;
gkernel.c:      yl = ym -height/2; yu = ym+height -height/2;
gkernel.c:      dx = xm - xc;
gkernel.c:      dy = ym - yc;
gkernel.c:      xdl = xl-dx;
gkernel.c:      xdu = xu-dx;
gkernel.c:      ydl = yl -dy;
gkernel.c:      ydu = yu -dy;
gkernel.c://    uiImage = kg_GetImage(D,xdl,ydl,xdu-xdl+1,ydu-ydl+1);
gkernel.c:      Pix = XCreatePixmap ( Dsp , Root , ( short ) ( xdu-xdl+1 ) , \
gkernel.c:       ( short ) ( ydu-ydl+1 ) , Dpth ) ;
gkernel.c:      uiImage = XGetImage ( Dsp , Pix , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 , 0xffffffff , ZPixmap ) ;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:      row = -1;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  r = src->red;
gkernel.c:                  g = src->green;
gkernel.c:                  b = src->blue;
gkernel.c:                  a = 255 - src->opacity;
gkernel.c://                    a =a*(1.-transparency);
gkernel.c:                      f1 = 1-f;
gkernel.c://   kgPutImage(D,uiImage,0,0,xdl,ydl,xdu-xdl+1,ydu-ydl+1);
gkernel.c:      XPutImage ( Dsp , Pix , Gc , uiImage , 0 , 0 , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      ALPHA = 255* ( 1.-transparency ) ;
gkernel.c:      rzfac = png->rzfac;
gkernel.c:      xoffset = png->xoffset;
gkernel.c:      yoffset = png->yoffset;
gkernel.c:      img = png->image;
gkernel.c:      w = img->columns;
gkernel.c:      h = img->rows;
gkernel.c:      xm = ( w-xoffset ) /2+xoffset;
gkernel.c:      ym = ( h-yoffset ) /2+yoffset;
gkernel.c:      xl = xm -width/2; xu = xm+width-width/2;
gkernel.c:      yl = ym -height/2; yu = ym+height -height/2;
gkernel.c:      dx = xm - xc;
gkernel.c:      dy = ym - yc;
gkernel.c:      xdl = xl-dx;
gkernel.c:      xdu = xu-dx;
gkernel.c:      ydl = yl -dy;
gkernel.c:      ydu = yu -dy;
gkernel.c://    uiImage = kg_GetImage(D,xdl,ydl,xdu-xdl+1,ydu-ydl+1);
gkernel.c:      Pix = XCreatePixmap ( Dsp , Root , ( short ) ( xdu-xdl+1 ) , \
gkernel.c:       ( short ) ( ydu-ydl+1 ) , Dpth ) ;
gkernel.c:      uiImage = XGetImage ( Dsp , Pix , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 , 0xffffffff , ZPixmap ) ;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:      row = -1;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  r = src->red;
gkernel.c:                  g = src->green;
gkernel.c:                  b = src->blue;
gkernel.c:                  a = 255 - src->opacity;
gkernel.c://                    a =a*(1.-transparency);
gkernel.c:                      f1 = 1-f;
gkernel.c://   kgPutImage(D,uiImage,0,0,xdl,ydl,xdu-xdl+1,ydu-ydl+1);
gkernel.c:      XPutImage ( Dsp , Pix , Gc , uiImage , 0 , 0 , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      Parent = ( Window ) D->parent;
gkernel.c:      wc = D->wc;
gkernel.c:      w = ( x2-x1 ) +1;
gkernel.c:      h = ( y2-y1 ) +1;
gkernel.c://   uiImage = XGetImage(wc->Dsp,wc->ActWin,x1,y1,w,h,0xffffffff,ZPixmap);
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:              dest->blue = *src;src++;
gkernel.c:              dest->green = *src;src++;
gkernel.c:              dest->red = *src;src++;
gkernel.c:              dest->opacity = 255- ( *src ) ;src++;
gkernel.c:              dest->red = 255;src++;
gkernel.c:              dest->green = 100;src++;
gkernel.c:              dest->blue = 100;src++;
gkernel.c:              dest->opacity = 125 ;src++;
gkernel.c: * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
gkernel.c: * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
gkernel.c: * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
gkernel.c: * Supercomputing Applications, University of Illinois, Urbana-Champaign.
gkernel.c:      nprbytes = ( bufin - ( const unsigned char * ) bufcoded ) - 1;
gkernel.c:      nprbytes = ( bufin - ( const unsigned char * ) bufcoded ) - 1;
gkernel.c:          nprbytes -= 4;
gkernel.c:      nbytesdecoded -= ( 4 - nprbytes ) & 3;
gkernel.c:      for ( i = 0; i < len - 2; i += 3 ) {
gkernel.c:          if ( i == ( len - 1 ) ) {
gkernel.c:      return p - encoded;
gkernel.c:      for ( i = 0; i < mod_table [ input_length % 3 ] ; i++ ) encoded_data [ output_length - 1 - i ] = '=';
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:              dest->red = *rsrc;rsrc++;
gkernel.c:              dest->green = *rsrc;rsrc++;
gkernel.c:              dest->blue = *rsrc;rsrc++;
gkernel.c:              dest->opacity = 255;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:              dest->blue = *src;src++;
gkernel.c:              dest->green = *src;src++;
gkernel.c:              dest->red = *src;src++;
gkernel.c:              dest->opacity = 255- ( *src ) ;src++;
gkernel.c:      wc = D->wc;
gkernel.c:      EVGAX = WC ( D )->EVGAX;
gkernel.c:      EVGAY = WC ( D )->EVGAY;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      rzfac = png->rzfac;
gkernel.c:      xoffset = png->xoffset;
gkernel.c:      yoffset = png->yoffset;
gkernel.c:      img = png->image;
gkernel.c:      w = img->columns;
gkernel.c:      h = img->rows;
gkernel.c:      xm = ( w-xoffset ) /2+xoffset;
gkernel.c:      ym = ( h-yoffset ) /2+yoffset;
gkernel.c:      xl = xm -width/2; xu = xm+width-width/2;
gkernel.c:      yl = ym -height/2; yu = ym+height -height/2;
gkernel.c:      dx = xm - xc;
gkernel.c:      dy = ym - yc;
gkernel.c:      xdl = xl-dx;
gkernel.c:      xdu = xu-dx;
gkernel.c:      ydl = yl -dy;
gkernel.c:      ydu = yu -dy;
gkernel.c:      uiImage = kg_GetImage ( D , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:      row = -1;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  r = src->red;
gkernel.c:                  g = src->green;
gkernel.c:                  b = src->blue;
gkernel.c:                  a = 255 - src->opacity;
gkernel.c:      kgPutImage ( D , uiImage , 0 , 0 , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      wc = D->wc;
gkernel.c:      EVGAX = WC ( D )->EVGAX;
gkernel.c:      EVGAY = WC ( D )->EVGAY;
gkernel.c:      x0 = x0-xoffset;
gkernel.c:      y0 = y0-yoffset;
gkernel.c:      if ( ( x0+width ) > EVGAX ) width = EVGAX-x0-1;
gkernel.c:      if ( ( y0+height ) > EVGAY ) height = EVGAY-y0-1;
gkernel.c:      rzfac = png->rzfac;
gkernel.c:      img = png->image;
gkernel.c:      w = img->columns;
gkernel.c:      h = img->rows;
gkernel.c:      dx = ( xu -xl ) ;
gkernel.c:      dy = ( yu-yl ) ;
gkernel.c:      uiImage = kg_GetImage ( D , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      ximage_rowbytes = uiImage->bytes_per_line;
gkernel.c:      Imgdata = ( unsigned char * ) uiImage->data;
gkernel.c:      row = -1;
gkernel.c:          k = -1;
gkernel.c:          if ( png->image_channels == 3 ) {
gkernel.c:                  red = src->red;
gkernel.c:                  green = src->green;
gkernel.c:                  blue = src->blue;
gkernel.c:                  r = src->red;
gkernel.c:                  g = src->green;
gkernel.c:                  b = src->blue;
gkernel.c:                  a = 255 - src->opacity;
gkernel.c:      kgPutImage ( D , uiImage , 0 , 0 , xdl , ydl , xdu-xdl+1 , ydu-ydl+1 ) ;
gkernel.c:      if ( ! prop ) prop = XInternAtom ( wc->Dsp , "XPRI_OUT" , False ) ;
gkernel.c://   Inc = XInternAtom(wc->Dsp, "INCR", False);
gkernel.c://   ret = ( unsigned char *) XFetchBuffer(wc->Dsp, (int *) &len, 0);
gkernel.c:      Owner = XGetSelectionOwner ( wc->Dsp , sel ) ;
gkernel.c://   printf("Owner : %d %d %d\n",Owner,wc->Win,wc->Root);
gkernel.c:      if ( XConvertSelection ( wc->Dsp , sel , target , prop , wc->Win , CurrentTime ) == 0 ) \
gkernel.c://     XDeleteProperty(wc->Dsp, wc->Win, prop);
gkernel.c://   if(Owner== wc->Win)  kgWaitSelectionNotify(Tmp);
gkernel.c:      if ( wret == -1 ) return 0;
gkernel.c:          if ( wret == -1 ) return 0;
gkernel.c:      XGetWindowProperty ( wc->Dsp , wc->Win , Val , 0 , 0 , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & buff ) ;
gkernel.c:      XFlush ( wc->Dsp ) ;
gkernel.c:          XGetWindowProperty ( wc->Dsp , wc->Win , Val , 0 , 0 , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & buff ) ;
gkernel.c:          XGetWindowProperty ( wc->Dsp , wc->Win , Val , 0 , ( long ) prop_size , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & buff ) ;
gkernel.c://   XDeleteProperty(wc->Dsp, wc->Win, prop);
gkernel.c:      XFlush ( wc->Dsp ) ;
gkernel.c:      Atom sel = XInternAtom ( wc->Dsp , "CLIPBOARD" , 0 ) ;
gkernel.c:      if ( ! prop ) prop = XInternAtom ( wc->Dsp , "XCLIP_OUT" , False ) ;
gkernel.c:      Owner = XGetSelectionOwner ( wc->Dsp , sel ) ;
gkernel.c://   printf("Owner : %d %d %d\n",Owner,wc->Win,wc->Root);
gkernel.c:      if ( XConvertSelection ( wc->Dsp , sel , target , prop , wc->Win , CurrentTime ) == 0 ) \
gkernel.c://     XDeleteProperty(wc->Dsp, wc->Win, prop);
gkernel.c:      if ( wret == -1 ) return 0;
gkernel.c:          if ( wret == -1 ) return 0;
gkernel.c:      XFlush ( wc->Dsp ) ;
gkernel.c:      XGetWindowProperty ( wc->Dsp , wc->Win , Val , 0 , 0 , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & buff ) ;
gkernel.c:          XGetWindowProperty ( wc->Dsp , wc->Win , Val , 0 , 0 , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & buff ) ;
gkernel.c:          XGetWindowProperty ( wc->Dsp , wc->Win , Val , 0 , ( long ) prop_size , False , AnyPropertyType , & prop_type , & prop_format , & prop_items , & prop_size , & buff ) ;
gkernel.c://   XDeleteProperty(wc->Dsp, wc->Win, prop);
gkernel.c:      XFlush ( wc->Dsp ) ;
gkernel.c:      if ( wc->Rth == 0 ) return 0;
gkernel.c:      if ( ! prop ) prop = XInternAtom ( wc->Dsp , "XPRI_IN" , False ) ;
gkernel.c:      XSetSelectionOwner ( wc->Dsp , sel , wc->Win , CurrentTime ) ;
gkernel.c://   XSetSelectionOwner(wc->Dsp,sel,None,CurrentTime);
gkernel.c://   w = XGetSelectionOwner(wc->Dsp,sel);
gkernel.c:      w = wc->Win;
gkernel.c:      pthread_mutex_lock ( & ( WC ( D )->Rlock ) ) ;
gkernel.c:      XChangeProperty ( wc->Dsp , w , sel , target , 8 , PropModeReplace , data , strlen \
gkernel.c:      XChangeProperty ( wc->Dsp , w , prop , target , 8 , PropModeReplace , data , strlen \
gkernel.c:      pthread_mutex_unlock ( & ( WC ( D )->Rlock ) ) ;
gkernel.c:      if ( wc->Rth == 0 ) return 0;
gkernel.c:      Atom sel = XInternAtom ( wc->Dsp , "CLIPBOARD" , 0 ) ;
gkernel.c:      if ( ! prop ) prop = XInternAtom ( wc->Dsp , "XCLIP_IN" , False ) ;
gkernel.c:      XSetSelectionOwner ( wc->Dsp , sel , wc->Win , CurrentTime ) ;
gkernel.c:      w = wc->Win;
gkernel.c:      pthread_mutex_lock ( & ( WC ( D )->Rlock ) ) ;
gkernel.c:      XChangeProperty ( wc->Dsp , w , sel , target , 8 , PropModeReplace , data , strlen \
gkernel.c:      XChangeProperty ( wc->Dsp , w , prop , target , 8 , PropModeReplace , data , strlen \
gkernel.c:      pthread_mutex_unlock ( & ( WC ( D )->Rlock ) ) ;
gkernel.c:      if ( wc->Rth != 0 ) return 0;
gkernel.c:      pthread_create ( & ( wc->Rth ) , NULL , kgProcessSelectionRequest , Tmp ) ;
gkernel.c:      if ( wc->Rth != 0 ) {
gkernel.c:          pthread_cancel ( WC ( D )->Rth ) ;
gkernel.c:          pthread_join ( WC ( D )->Rth , NULL ) ;
gkernel.c:      wc->Rth = 0;
glExample.c:/* compile: cc -o glxsimple glxsimple.c -lGL -lX11 */
glExample.c:	glVertex3f(-1.0, 1.0, 1.0);
glExample.c:	glVertex3f(1.0, -1.0, 1.0);
glExample.c:	glVertex3f(-1.0, -1.0, 1.0);
glExample.c:	glVertex3f(-1.0, 1.0, -1.0);
glExample.c:	glVertex3f(1.0, 1.0, -1.0);
glExample.c:	glVertex3f(1.0, -1.0, -1.0);
glExample.c:	glVertex3f(-1.0, -1.0, -1.0);
glExample.c:	glVertex3f(-1.0, 1.0, 1.0);
glExample.c:	glVertex3f(1.0, 1.0, -1.0);
glExample.c:	glVertex3f(-1.0, 1.0, -1.0);
glExample.c:	glVertex3f(-1.0, -1.0, 1.0);
glExample.c:	glVertex3f(1.0, -1.0, 1.0);
glExample.c:	glVertex3f(1.0, -1.0, -1.0);
glExample.c:	glVertex3f(-1.0, -1.0, -1.0);
glExample.c:    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 10.0);
glExample.c:	    glTranslatef(0.0, 0.0, -3.0);
glxsimple.c:/* compile: cc -o glxsimple glxsimple.c -lGL -lX11 */
glxsimple.c:	glVertex3f(-1.0, 1.0, 1.0);
glxsimple.c:	glVertex3f(1.0, -1.0, 1.0);
glxsimple.c:	glVertex3f(-1.0, -1.0, 1.0);
glxsimple.c:	glVertex3f(-1.0, 1.0, -1.0);
glxsimple.c:	glVertex3f(1.0, 1.0, -1.0);
glxsimple.c:	glVertex3f(1.0, -1.0, -1.0);
glxsimple.c:	glVertex3f(-1.0, -1.0, -1.0);
glxsimple.c:	glVertex3f(-1.0, 1.0, 1.0);
glxsimple.c:	glVertex3f(1.0, 1.0, -1.0);
glxsimple.c:	glVertex3f(-1.0, 1.0, -1.0);
glxsimple.c:	glVertex3f(-1.0, -1.0, 1.0);
glxsimple.c:	glVertex3f(1.0, -1.0, 1.0);
glxsimple.c:	glVertex3f(1.0, -1.0, -1.0);
glxsimple.c:	glVertex3f(-1.0, -1.0, -1.0);
glxsimple.c:    /* find an OpenGL-capable RGB visual with depth buffer */
glxsimple.c:    if(vi->class != TrueColor) fatalError("TrueColor visual required for this program");
glxsimple.c:    cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen), vi->visual, AllocNone);
glxsimple.c:    win = XCreateWindow(dpy, RootWindow(dpy, vi->screen), 0, 0, 300, 300, 0, vi->depth,
glxsimple.c:                        InputOutput, vi->visual, CWBorderPixel | CWColormap | CWEventMask, &swa);
glxsimple.c:    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 10.0);
glxsimple.c:	    glTranslatef(0.0, 0.0, -3.0);
gminterface.c:      kgUserFrame ( fid , -2. , -2. , ( float ) xl+2 , ( float ) yl+2 ) ;
gminterface.c:      i = strlen ( flname ) -1;
gminterface.c:      while ( ( i >= 0 ) && ( flname [ i ] <= ' ' ) ) flname [ i-- ] = '\0';
gminterface.c:       ( void ) CloneString ( & Image_info->size , size ) ;
gminterface.c:       ( void ) strcpy ( Image_info->filename , flname ) ;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 255;
gminterface.c:      png->image = image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strncpy ( png->flname , flname , 499 ) ;
gminterface.c:      png->image_width = image->columns;
gminterface.c:      png->image_height = image->rows;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = -1;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c://  png->image_channels=4;
gminterface.c:      if ( image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:       ( void ) CloneString ( & Image_info->size , size ) ;
gminterface.c:       ( void ) strcpy ( Image_info->filename , "inline" ) ;
gminterface.c:      QueryColorDatabase ( "#ffffffff" , & Image_info->background_color , Exception ) ;
gminterface.c:          printf ( "kgGetInlineImage : NULL: %s \n" , Image_info->filename ) ;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 255;
gminterface.c:      png->image = image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strcpy ( png->flname , "inline" ) ;
gminterface.c:      png->image_width = image->columns;
gminterface.c:      png->image_height = image->rows;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = -1;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c://  png->image_channels=4;
gminterface.c:      if ( image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      tmpimg->columns = xsize;
gminterface.c:      tmpimg->rows = ysize;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 0xff;
gminterface.c:      image->matte = 1;
gminterface.c:      png->image = image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->image_width = image->columns;
gminterface.c:      png->image_height = image->rows;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = -1;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      if ( image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:       ( void ) CloneString ( & Image_info->size , size ) ;
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 0xff;
gminterface.c:      image->matte = 1;
gminterface.c:      if ( ( image->columns != xsize ) || ( image->rows != ysize ) ) {
gminterface.c:          fprintf ( stderr , "Size of Pixels :%ld:%ld %ld:%ld\n" , image->columns , xsize , image->rows , ysize ) ;
gminterface.c:      png->image = image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->image_width = image->columns;
gminterface.c:      png->image_height = image->rows;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = -1;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      if ( image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:       ( void ) CloneString ( & Image_info->size , size ) ;
gminterface.c:      tmpimg->columns = xsize;
gminterface.c:      tmpimg->rows = ysize;
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 0xff;
gminterface.c:      image->matte = 1;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:                  pixels [ k ] .opacity = 255 -v;
gminterface.c:      png->image = image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->image_width = image->columns;
gminterface.c:      png->image_height = image->rows;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = -1;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      if ( image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:       ( void ) strcpy ( Image_info->filename , "JUNK.png" ) ;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 255;
gminterface.c:      image->matte = 1;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:              pixels [ k ] .opacity = 255 -v;
gminterface.c:      png->image = image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->image_width = image->columns;
gminterface.c:      png->image_height = image->rows;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = -1;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c://  png->image_channels=4;
gminterface.c:      if ( image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = png->image;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:              v = 255 -pixels [ k ] .opacity;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      w = image->columns*fac;
gminterface.c:      h = image->rows*fac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      pixels = GetImagePixels ( resize_image , 0 , 0 , resize_image->columns , resize_image->rows ) ;
gminterface.c:          resize_image->background_color.red = 0;
gminterface.c:          resize_image->background_color.blue = 0;
gminterface.c:          resize_image->background_color.green = 0;
gminterface.c:          resize_image->background_color.opacity = 255;
gminterface.c:          png->image = resize_image;
gminterface.c:          strcpy ( png->Sign , "PNG" ) ;
gminterface.c:          png->incode = 0;
gminterface.c:          png->image_width = resize_image->columns;
gminterface.c:          png->image_height = resize_image->rows;
gminterface.c:          png->image_channels = 4;
gminterface.c:          if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:          else png->image_channels = 4;
gminterface.c:          png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:          png->image_data = ( unsigned char * ) Malloc ( png->image_width*  \
gminterface.c:              ( png->image_height+1 ) *png->image_channels ) ;
gminterface.c:          for ( i = 0;i < ( resize_image->columns*resize_image->rows ) ;i++ ) {
gminterface.c:              png->image_data [ j++ ] = pixels [ i ] .red;
gminterface.c:              png->image_data [ j++ ] = pixels [ i ] .green;
gminterface.c:              png->image_data [ j++ ] = pixels [ i ] .blue;
gminterface.c:              if ( png->image_channels == 4 ) png->image_data [ j++ ] = 255 - pixels [ i ] .opacity;
gminterface.c://     png->image_data[j++]=  pixels[i].opacity;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      w = image->columns*fac;
gminterface.c:      h = image->rows*fac;
gminterface.c:      xoffset = png->xoffset*fac;
gminterface.c:      yoffset = png->yoffset*fac;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = xoffset;
gminterface.c:      png->yoffset = yoffset;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      xoffset = png->xoffset*fac;
gminterface.c:      yoffset = png->yoffset*fac;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      wfac = ( float ) w/png->image_width;
gminterface.c:      hfac = ( float ) h/png->image_height;
gminterface.c:      if ( ( w > png->image_width ) && ( h > png->image_height ) ) {
gminterface.c:          resize_image = ThumbnailImage ( image , png->image_width , png->image_height , Exception ) ;
gminterface.c://       printf("Copying Image:%d:%d  %d:%d\n",w,h,png->image_width,png->image_height);
gminterface.c:          resize_image = ThumbnailImage ( image , ( int ) ( png->image_width*fac ) ,  \
gminterface.c:              ( int ) ( png->image_height*fac ) , Exception ) ;
gminterface.c://    resize_image=SampleImage(image,(int)(png->image_width*fac),(int)(png->image_height*fac),Exception);
gminterface.c://      resize_image=ResizeImage(image,(int)(png->image_width*fac),(int)(png->image_height*fac),TriangleFilter,1.1,Exception);
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = xoffset;
gminterface.c:      png->yoffset = yoffset;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      xoffset = png->xoffset*fac;
gminterface.c:      yoffset = png->yoffset*fac;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      wfac = ( float ) w/image->columns;
gminterface.c:      hfac = ( float ) h/image->rows;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = xoffset;
gminterface.c:      png->yoffset = yoffset;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      xoffset = png->xoffset*fac;
gminterface.c:      yoffset = png->yoffset*fac;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = xoffset;
gminterface.c:      png->yoffset = yoffset;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      w = image->columns*fac;
gminterface.c:      h = image->rows*fac;
gminterface.c:      xoffset = png->xoffset*fac;
gminterface.c:      yoffset = png->yoffset*fac;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = xoffset;
gminterface.c:      png->yoffset = yoffset;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      rect.width = abs ( xu-xl ) +1;
gminterface.c:      rect.height = abs ( yu-yl ) +1;
gminterface.c:      w = png->image_width;
gminterface.c:      h = png->image_height;
gminterface.c:      if ( ( rect.x+rect.width ) > w ) rect.width = w- rect.x;
gminterface.c:      if ( ( rect.y+rect.height ) > h ) rect.height = h- rect.y;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:      dl1 = ( ( double ) ( ( w-xo ) * ( w-xo ) + ( h-yo ) * ( h-yo ) ) ) ;
gminterface.c:      dl1 = ( ( double ) ( ( w-xo ) * ( w-xo ) + ( yo ) * ( yo ) ) ) ;
gminterface.c:      dl1 = ( ( double ) ( ( xo ) * ( xo ) + ( h-yo ) * ( h-yo ) ) ) ;
gminterface.c://  W = 2*W-1;
gminterface.c:      resize_image = dpng->image;
gminterface.c:      W = resize_image->columns;
gminterface.c:      H = resize_image->rows;
gminterface.c:      xm = ( W-1 ) /2;
gminterface.c:      ym = ( H-1 ) /2;
gminterface.c:      pixels = GetImagePixels ( resize_image , 0 , 0 , resize_image->columns , resize_image->rows ) ;
gminterface.c:      spixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:              alpha = 255- opacity;
gminterface.c:              x = + ( i-xo ) +xm;
gminterface.c:              y = H- ( int ) ( ( yo-j ) +ym ) ;
gminterface.c:          nW = tmpimg->image_width;
gminterface.c:          nH = tmpimg->image_height;
gminterface.c:          spixels = GetImagePixels ( tmpimg->image , 0 , 0 , nW , nH ) ;
gminterface.c:          nxm = ( nW-1 ) /2;
gminterface.c:          nym = ( nH-1 ) /2;
gminterface.c:          dx = nxm -xm;
gminterface.c:          dy = nym - ym;
gminterface.c:                  alpha = 255- opacity;
gminterface.c://  printf("L:W: %d %d %d %d\n",L,W,dpng->image_width,dpng->image_height);
gminterface.c:                  alpha = 255- opacity;
gminterface.c:                  x = ( yo-j ) *ss+ ( i-xo ) *cs+xm;
gminterface.c:                  y = H- ( int ) ( ( yo-j ) *cs- ( i-xo ) *ss+ym ) ;
gminterface.c:                  dalpha = ( 255-pixels [ kk ] .opacity ) ;
gminterface.c:                  f1 = 1-f;
gminterface.c:                  opacity = 255 -alpha;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      image->background_color.red = 0;
gminterface.c:      image->background_color.blue = 0;
gminterface.c:      image->background_color.green = 0;
gminterface.c:      image->background_color.opacity = 255;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = NULL;
gminterface.c:      png->exce = NULL;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png1->image ) ;
gminterface.c:      image->next = ( Image * ) ( png2->image ) ;
gminterface.c:      bkgrclr = png1->bkgrclr;
gminterface.c:      rzfac = png2->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image->next = NULL;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = NULL;
gminterface.c:      png->exce = NULL;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      bkgrclr = png->bkgrclr;
gminterface.c:      rzfac = png->rzfac;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      resize_image->background_color.red = 0;
gminterface.c:      resize_image->background_color.blue = 0;
gminterface.c:      resize_image->background_color.green = 0;
gminterface.c:      resize_image->background_color.opacity = 255;
gminterface.c:      png->image = resize_image;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      png->incode = 0;
gminterface.c:      png->xoffset = 0;
gminterface.c:      png->yoffset = 0;
gminterface.c:      png->bkgrclr = bkgrclr;
gminterface.c:      png->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      png->image_width = resize_image->columns;
gminterface.c:      png->image_height = resize_image->rows;
gminterface.c:      png->image_channels = 4;
gminterface.c:      if ( resize_image->matte == 0 ) png->image_channels = 3;
gminterface.c:      else png->image_channels = 4;
gminterface.c:      png->image_rowbytes = png->image_width*png->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      Image_info = ( ImageInfo * ) png->info;
gminterface.c:       ( void ) strcpy ( image->filename , flname ) ;
gminterface.c:      WriteImage ( Image_info , ( Image * ) ( png->image ) ) ;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      Image_info = ( ImageInfo * ) png->info;
gminterface.c:       ( void ) strcpy ( image->filename , flname ) ;
gminterface.c:      WriteImage ( Image_info , ( Image * ) ( png->image ) ) ;
gminterface.c://  DestroyImagePixels((Image *)(img->image));
gminterface.c:      DestroyImage ( ( Image * ) ( img->image ) ) ;
gminterface.c:      if ( img->info != NULL ) DestroyImageInfo ( ( ImageInfo * ) img->info ) ;
gminterface.c:      if ( img->exce != NULL ) {
gminterface.c:          DestroyExceptionInfo ( ( ExceptionInfo * ) img->exce ) ;
gminterface.c:          free ( img->exce ) ;
gminterface.c:      img->info = NULL;
gminterface.c:      img->exce = NULL;
gminterface.c://  DestroyImagePixels((Image *)(img->image));
gminterface.c:      DestroyImage ( ( Image * ) ( img->image ) ) ;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      dimage = ( Image * ) ( shimg->image ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:      pixels = GetImagePixels ( dimage , 0 , 0 , dimage->columns , dimage->rows ) ;
gminterface.c:      spixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = dimage->columns;
gminterface.c:      ysize = dimage->rows;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:      tmpimg->columns = w;
gminterface.c:      tmpimg->rows = h;
gminterface.c:      if ( Exception->severity != UndefinedException ) {
gminterface.c:      dimage->background_color.red = 0;
gminterface.c:      dimage->background_color.blue = 0;
gminterface.c:      dimage->background_color.green = 0;
gminterface.c:      dimage->background_color.opacity = 255;
gminterface.c:      dimage->matte = 1;
gminterface.c:      pixels = GetImagePixels ( dimage , 0 , 0 , dimage->columns , dimage->rows ) ;
gminterface.c:      if ( ( dimage->columns != w ) || ( dimage->rows != h ) ) {
gminterface.c:          printf ( "Size of Pixels :%ld:%d %ld:%d\n" , image->columns , w , image->rows , h ) ;
gminterface.c:      spixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = dimage->columns;
gminterface.c:      ysize = dimage->rows;
gminterface.c:      dpng->image = dimage;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strcpy ( dpng->Sign , "IMG" ) ;
gminterface.c:      dpng->image_width = dimage->columns;
gminterface.c:      dpng->image_height = dimage->rows;
gminterface.c:      dpng->incode = 0;
gminterface.c:      dpng->xoffset = 0;
gminterface.c:      dpng->yoffset = 0;
gminterface.c:      dpng->bkgrclr = -1;
gminterface.c:      dpng->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      if ( dimage->matte == 0 ) dpng->image_channels = 3;
gminterface.c:      else dpng->image_channels = 4;
gminterface.c:      dpng->image_rowbytes = dpng->image_width*dpng->image_channels;
gminterface.c:      image = ( Image * ) ( png1->image ) ;
gminterface.c:      dimage = ( Image * ) ( png2->image ) ;
gminterface.c:      pixels = GetImagePixels ( dimage , 0 , 0 , dimage->columns , dimage->rows ) ;
gminterface.c:      spixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:      xoff = ( xsize - dimage->columns ) *0.5+Xshft;
gminterface.c:      yoff = ( ysize - dimage->rows ) *0.5+Yshft;
gminterface.c:      for ( j = yoff;j < ( yoff+dimage->rows ) ;j++ ) {
gminterface.c:          for ( i = xoff;i < ( xoff+dimage->columns ) ;i++ ) {
gminterface.c:              alpha = 255- opacity;
gminterface.c:              alphas = 255 -opacity;
gminterface.c:                  spixels [ kk ] .opacity = 255 -alpha;
gminterface.c:                  f1 = 1-f;
gminterface.c:      w1 = img1->image_width;
gminterface.c:      h1 = img1->image_height;
gminterface.c:      w2 = img2->image_width;
gminterface.c:      h2 = img2->image_height;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      tmpimg = CloneImage ( image , image->columns , image->rows , 1 , Exception ) ;
gminterface.c:      pixels = SetImagePixels ( tmpimg , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      dpng->image = tmpimg;
gminterface.c:      strcpy ( png->Sign , "IMG" ) ;
gminterface.c:      strcpy ( dpng->Sign , "IMG" ) ;
gminterface.c:      dpng->image_width = tmpimg->columns;
gminterface.c:      dpng->image_height = tmpimg->rows;
gminterface.c:      dpng->incode = 0;
gminterface.c:      dpng->xoffset = 0;
gminterface.c:      dpng->yoffset = 0;
gminterface.c:      dpng->bkgrclr = -1;
gminterface.c:      dpng->rzfac = 1.0;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      if ( tmpimg->matte == 0 ) dpng->image_channels = 3;
gminterface.c:      else dpng->image_channels = 4;
gminterface.c:      dpng->image_rowbytes = dpng->image_width*dpng->image_channels;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      tmpimg = CloneImage ( image , image->columns , image->rows , 1 , Exception ) ;
gminterface.c:      pixels = SetImagePixels ( tmpimg , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      dpng->image = tmpimg;
gminterface.c:      png->info = Image_info;
gminterface.c:      png->exce = Exception;
gminterface.c:      spixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      for ( j = 0;j < ( image->rows ) ;j++ ) {
gminterface.c:          for ( i = 0;i < ( image->columns ) ;i++ ) {
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:      for ( j = 0;j < ( image->rows ) ;j++ ) {
gminterface.c:          for ( i = 0;i < ( image->columns ) ;i++ ) {
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:              kk = ( j*w+w-1-i ) ;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:              kk = ( ( h-1-j ) *w+i ) ;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      dimage = ( Image * ) ( mask->image ) ;
gminterface.c:      tmpimg = uiChangeSizegmImage ( png , dimage->columns , dimage->rows , 1 ) ;
gminterface.c:      image = ( Image * ) ( tmpimg->image ) ;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      spixels = GetImagePixels ( dimage , 0 , 0 , dimage->columns , dimage->rows ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:              kk = ( ( j ) *dimage->columns+i ) ;
gminterface.c:              spixels [ kk ] .opacity = 255 - spixels [ kk ] .red;
gminterface.c:              kk = ( ( j ) *dimage->columns+i ) ;
gminterface.c:      dpng->image = dimage;
gminterface.c:      strcpy ( dpng->Sign , "IMG" ) ;
gminterface.c:      dpng->image_width = dimage->columns;
gminterface.c:      dpng->image_height = dimage->rows;
gminterface.c:      dpng->incode = 0;
gminterface.c:      dpng->xoffset = 0;
gminterface.c:      dpng->yoffset = 0;
gminterface.c:      dpng->bkgrclr = -1;
gminterface.c:      dpng->rzfac = 1.0;
gminterface.c:      dpng->info = NULL;
gminterface.c:      dpng->exce = NULL;
gminterface.c:      if ( dimage->matte == 0 ) dpng->image_channels = 3;
gminterface.c:      else dpng->image_channels = 4;
gminterface.c:      dpng->image_rowbytes = dpng->image_width*dpng->image_channels;
gminterface.c:      channels = png->image_channels;
gminterface.c:      png->image_channels = 4;
gminterface.c:      img = png->image;
gminterface.c:      w = img->columns;
gminterface.c:      h = img->rows;
gminterface.c:      img->matte = 1;
gminterface.c:      img->background_color.opacity = 255;
gminterface.c:              r = dest->red;
gminterface.c:              g = dest->green;
gminterface.c:              b = dest->blue;
gminterface.c:              dest->red = r;
gminterface.c:              dest->green = g;
gminterface.c:              dest->blue = b;
gminterface.c:      channels = png->image_channels;
gminterface.c:      png->image_channels = 4;
gminterface.c:      img = png->image;
gminterface.c:      w = img->columns;
gminterface.c:      h = img->rows;
gminterface.c:      img->matte = 1;
gminterface.c:      img->background_color.opacity = 255;
gminterface.c:              r = dest->red;
gminterface.c:              g = dest->green;
gminterface.c:              b = dest->blue;
gminterface.c:              dest->red = r;
gminterface.c:              dest->green = g;
gminterface.c:              dest->blue = b;
gminterface.c:      channels = png->image_channels;
gminterface.c:      png->image_channels = 4;
gminterface.c:      img = png->image;
gminterface.c:      w = img->columns;
gminterface.c:      h = img->rows;
gminterface.c:      img->matte = 1;
gminterface.c:      img->background_color.opacity = 255;
gminterface.c:              if ( dest->opacity < 255 ) {
gminterface.c:                  opacity = dest->opacity + f+0.5;
gminterface.c:                  dest->opacity = opacity;
gminterface.c:              else dest->opacity = 255;
gminterface.c:      channels = png->image_channels;
gminterface.c:      png->image_channels = 4;
gminterface.c:      img = png->image;
gminterface.c:      w = img->columns;
gminterface.c:      h = img->rows;
gminterface.c:      img->matte = 1;
gminterface.c:      img->background_color.opacity *= f;
gminterface.c:              if ( dest->opacity != 255 ) {
gminterface.c:                  dest->opacity = Opacity;
gminterface.c:                  dest->red = 0;
gminterface.c:                  dest->green = 0;
gminterface.c:                  dest->blue = 0;
gminterface.c:      image = ( Image * ) ( png1->image ) ;
gminterface.c:      dimage = ( Image * ) ( png2->image ) ;
gminterface.c:      pixels = GetImagePixels ( dimage , 0 , 0 , dimage->columns , dimage->rows ) ;
gminterface.c:      spixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      w = image->columns;
gminterface.c:      h = image->rows;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:      xoff = ( xsize - dimage->columns ) *0.5+Xshft;
gminterface.c:      yoff = ( ysize - dimage->rows ) *0.5+Yshft;
gminterface.c:      for ( j = yoff;j < ( yoff+dimage->rows ) ;j++ ) {
gminterface.c:          for ( i = xoff;i < ( xoff+dimage->columns ) ;i++ ) {
gminterface.c:              alpha = 255- opacity;
gminterface.c:              alphas = 255 -opacity;
gminterface.c:                  f1 = 1-f;
gminterface.c:              spixels [ kk ] .opacity = 255 -alpha;
gminterface.c:      w1 = img1->image_width;
gminterface.c:      h1 = img1->image_height;
gminterface.c:      w2 = img2->image_width;
gminterface.c:      h2 = img2->image_height;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      pixels = GetImagePixels ( image , 0 , 0 , image->columns , image->rows ) ;
gminterface.c:      xsize = image->columns;
gminterface.c:      ysize = image->rows;
gminterface.c:      image = ( Image * ) ( png->image ) ;
gminterface.c:      *xsize = image->columns;
gminterface.c:      *ysize = image->rows;
gph2eps.c:   fprintf(fp,"$SL-5\n");
gph2eps.c:   fprintf(fp,"$RG%-s 208 166\n",argv[1]);
gph2eps.c:   sprintf(command,"slide -c -f%-s JunK",outfile);
gph2eps.c:   sprintf(command,"ps2epsi %-s %-s",outfile,out1);
gph2jpg.c:	   printf("Usage: gph2jpg [-r res] <gphfile> \n");
gph2jpg.c:	   printf("       gph2jpg [-r res] <ghpfile> <jpgfile>\n");
gph2jpg.c:	   strcpy(outfile,argv[count-1]);
gph2jpg.c:   fprintf(fp,"$RG%-s 360 270 \n",argv[count-1]);
gph2jpg.c:   sprintf(command,"slide -c -f.JunK1 .JunK");
gph2jpg.c:   sprintf(command,"gs -sDEVICE=bbox  -dBATCH -dNOPAUSE  .JunK1 2>.JunK2>/dev/null");
gph2jpg.c:   sprintf(command,"gs -sDEVICE=jpeg  -r%-d  -dBATCH -dNOPAUSE -sOutputFile=%s .JunK >/dev/null",res,outfile);
gph2ps.c:   fprintf(fp,"$SL-5\n");
gph2ps.c:   fprintf(fp,"$RG%-s 208 166\n",argv[1]);
gph2ps.c:   sprintf(command,"slide -c -f%-s JunK",outfile);
gphimg.c:  dc=G->dc;
gphimg.c:  EVGAX=G->x2 -G->x1+1;
gphimg.c:  EVGAY=G->y2 - G->y1+1;
gphimg.c:  dc->ln_style=0;
gphimg.c:  dc->m_style=0;
gphimg.c:  dc->ln_color = 0x0F;
gphimg.c:  dc->c_bound =4;
gphimg.c:  dc->t_color = 14;
gphimg.c:  dc->t_pattern=15;
gphimg.c:  dc->t_fill = 1;
gphimg.c:  dc->t_font = 0;
gphimg.c:  dc->t_bkgr = 0;
gphimg.c:  dc->t_bodr = 0;
gphimg.c:  dc->fil_color=0;
gphimg.c:  dc->bod_width=11;
gphimg.c:  dc->bod_color=1;
gphimg.c:  dc->icpos = icposf0;dc->icxv=icxvf0;dc->icyv=icyvf0;dc->m_f=m_f0;
gphimg.c:  dc->ln_width=1;
gphimg.c:  dc->pr_txt=1;
gphimg.c:  dc->cost = 1.0;
gphimg.c:  dc->sint = 0.0;
gphimg.c:  dc->txt_ht=20;
gphimg.c:  dc->txt_wt=20;
gphimg.c:  dc->txt_htx=20;
gphimg.c:  dc->txt_wty=20;
gphimg.c:  dc->txt_hty=20;
gphimg.c:  dc->txt_wtx=20;
gphimg.c:  dc->txt_w42 = dc->txt_wt/CFact;
gphimg.c:  dc->txt_h42 = dc->txt_ht/CFact;
gphimg.c:  dc->txt_sp=2;
gphimg.c:  dc->txt_spy=2;
gphimg.c:  dc->txt_spx=2;
gphimg.c:  dc->v_x1=0;
gphimg.c:  dc->v_y1=0;
gphimg.c:  dc->v_x2=EVGAX;
gphimg.c:  dc->v_y2=EVGAY;
gphimg.c:  dc->w_x1=0;
gphimg.c:  dc->w_y1=0;
gphimg.c:  dc->w_x2=1.0;
gphimg.c:  dc->w_y2=1.0;
gphimg.c:  dc->u_x=EVGAX;
gphimg.c:  dc->u_y=EVGAY;
gphimg.c:  dc->V_x=EVGAX;
gphimg.c:  dc->V_y=EVGAY;
gphimg.c:  dc->D_x=0;
gphimg.c:  dc->D_y=0;
gphimg.c:  dc->ZBUFF=dc->SET3D=dc->TIFF=dc->PROJ=1;
gphimg.c:  dc->DBL_BUF=0;
gphimg.c:  dc->D_ON=0;
gphimg.c:  wc->Clip = Dopen();
gphimg.c:  wc->SBlist=Dopen();
gphimg.c:  dc->EVGAX=EVGAX;
gphimg.c:  dc->EVGAY=EVGAY;
gphimg.c:  uiset_sup_clip_limits(wc,0,0,dc->EVGAX-1,dc->EVGAY-1);
gphimg.c:  uiset_clip_limits(wc,0,0,dc->EVGAX-1,dc->EVGAY-1);
gphimg.c:    dc->ln_ptn[i]=ln_ptn[i];
gphimg.c:    dc->st_ptr[i]=st_ptr[i];
gphimg.c:  G->wc = (kgWC *)malloc(sizeof(kgWC));
gphimg.c:  G->dc = dc;
gphimg.c:  G->x1=G->y1=0;
gphimg.c:  G->x2 = (int)(width+0.5);
gphimg.c:  G->y2 = (int)(height+0.5);
gphimg.c:  for(l=0;l<10;l++) dc->st_ptr[l]=0;
gphimg.c:  G->B_min = 10400;
gphimg.c:  G->BACK_UP=0;
gphimg.c:  G->OPEN=1;
gphimg.c:  G->Byte=0;
gphimg.c:  G->R_Byte=0;
gphimg.c:  G->R_max=0;
gphimg.c:  G->D_ON=1;
gphimg.c:  G->MAG=mag;
gphimg.c:  G->img=NULL;
gphimg.c:  G->rzimg=NULL;
gphimg.c:  G->pixels=NULL;
gphimg.c:  dc->ls_list=NULL;
gphimg.c:  dc->No_of_lights=0;
guiclrs.c:  D.df = -1;
guiclrs.c: d[0].b->x1 =11;
guiclrs.c: d[0].b->y1 =13;
guiclrs.c: d[0].b->x2 =328;
guiclrs.c: d[0].b->y2 =190;
guiclrs.c: D.df = -1;
guiclrs.c: ret =  v0-1;
guiclrs.c:  n = D->d[i].n;
guiclrs.c:  df = n->bkgr[code-1]+1;
guiclrs.c:  n->bkgr[code-1]=colorbox(df);
guiclrs.c:  D.df = -1;
half.c:  total.red+=(weight)*(r->red);                 \
half.c:  total.green+=(weight)*(r->green);             \
half.c:  total.blue+=(weight)*(r->blue);               \
half.c:  total.opacity+=(weight)*(r->opacity);         \
half.c:    for (y=0; y < (long) minify_image->rows; y++)
half.c:        p=AcquireImagePixels(image,-2,2*(y-1),image->columns+4,4,exception);
half.c:        q=SetImagePixelsEx(minify_image,0,y,minify_image->columns,1,exception);
half.c:                r=p+(image->columns+4);
half.c:                r=p+2*(image->columns+4);
half.c:                r=p+3*(image->columns+4);
half.c:                q->red=(Quantum) (total.red/128.0+0.5);
half.c:                q->green=(Quantum) (total.green/128.0+0.5);
half.c:                q->blue=(Quantum) (total.blue/128.0+0.5);
half.c:                q->opacity=(Quantum) (total.opacity/128.0+0.5);
half.c:          if (QuantumTick(row_count,image->rows))
half.c:            if (!MagickMonitorFormatted(row_count,image->rows,exception,
half.c:                                        MinifyImageText,image->filename))
half.c:  minify_image->is_grayscale=image->is_grayscale;
hlib.c:#define scr_z(z) (int)((z-clip_min)*CPCONS+0.5);
hlib.c:#define TY(x,y) (cy -(x)*sint+(y)*cost)
hlib.c:#define LPU(x,y) fprintf(hbuf," %d %d m\n",(x),(EVGAY-y))
hlib.c:#define LPD(x,y) fprintf(hbuf," %d %d l\n",(x),(EVGAY-y))
hlib.c:#define PPT(x,y,chr) fprintf(hbuf,"%-d %-d S (%c) W\n",(y),(x),(chr))
hlib.c: fprintf(hbuf," %-d %-d %-d %-d rectclip \n",(y),(x),(h),(w));\
hlib.c: fprintf(hbuf," %-d %-d %-d %-d rectclip \n",(x),(EVGAY-y-h),(w),(h));\
hlib.c:  if(LSCAPE) fprintf(hbuf," %-d %-d %-d %-d rectclip \n", \
hlib.c:       (Clip.x),(EVGAY-Clip.y-Clip.h),(Clip.w),(Clip.h));\
hlib.c:  else fprintf(hbuf," %-d %-d %-d %-d rectclip \n", \
hlib.c:     fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (\\%c) W gr\n",\
hlib.c:     else fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (%c) W gr\n",\
hlib.c:     fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (\\%c) H col%3.3d fill gr\n",\
hlib.c:     if(t_bodr) fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (\\%c) H col%3.3d s gr\n",\
hlib.c:       fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (%c) H col%3.3d fill gr\n",\
hlib.c:       if(t_bodr) fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (%c) H col%3.3d s gr\n",\
hlib.c:     fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (\\%c) H col%3.3d s gr\n",\
hlib.c:     else fprintf(TX_F,"ZTgs %-6.2f %-6.2f S %-6.1f R (%c) H col%3.3d  s gr\n",\
hlib.c:static char FontName[30]={"Times-Roman"};
hlib.c:#define scr_x(x) (int)((x-w_x1)*u_x+D_x+0.5)
hlib.c:#define scr_y(y) (int)((y-w_y1)*u_y+D_y+0.5)
hlib.c:#define usr_x(x) (float)((x-D_x)/u_x+w_x1)
hlib.c:#define usr_y(y) (float)((y-D_y)/u_y+w_y1)
hlib.c:#define cnv_x(x) (x*fx-sx)
hlib.c:#define cnv_y(y) (y*fy-sy)
hlib.c:#define pclr(p)  (float)(((p-pmin)*dfac+0.))
hlib.c:static float xscale=-1,yscale=1;
hlib.c:static int t_font,t_font_o=-1;
hlib.c:#define icde(l,m) icode[m-1][l-1]
hlib.c:     newstr.xstr = -(2.* ze/(oldstr.zstr)) * oldstr.xstr;
hlib.c:     newstr.ystr = -(2.* ze/(oldstr.zstr)) * oldstr.ystr;
hlib.c:  w  = Simg->image_width;
hlib.c:  h  = Simg->image_height;
hlib.c:  channels= Simg->image_channels;
hlib.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,
hlib.c:           ((Image *)(Simg->image))->columns,
hlib.c:           ((Image *)(Simg->image))->rows);
hlib.c:  fprintf(fp,"  /picstr %-d string def\n",3*w);
hlib.c:  fprintf(fp,"  [ %d 0 0 -%-d 0 %d ]\n",w,h,h);
hlib.c:  w  = Simg->image_width;
hlib.c:  h  = Simg->image_height;
hlib.c:  channels= Simg->image_channels;
hlib.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,
hlib.c:           ((Image *)(Simg->image))->columns,
hlib.c:           ((Image *)(Simg->image))->rows);
hlib.c:  fprintf(fp,"   /ImageMatrix [%d 0  0 -%-d 0 %d]\n",w,h,h);
hlib.c:  w  = Simg->image_width;
hlib.c:  h  = Simg->image_height;
hlib.c:  channels= Simg->image_channels;
hlib.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,
hlib.c:           ((Image *)(Simg->image))->columns,
hlib.c:           ((Image *)(Simg->image))->rows);
hlib.c:  fprintf(fp,"  [ %d 0 0 -%-d 0 %d ]\n",w,h,h);
hlib.c:  w  = Simg->image_width;
hlib.c:  h  = Simg->image_height;
hlib.c:  channels= Simg->image_channels;
hlib.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,
hlib.c:           ((Image *)(Simg->image))->columns,
hlib.c:           ((Image *)(Simg->image))->rows);
hlib.c:  fprintf(fp,"  [ %d 0 0 -%-d 0 %d ]\n",w,h,h);
hlib.c:  dc= G->dc;
hlib.c:  wc =G->wc;
hlib.c:  Dimg = G->img;
hlib.c:  iw = Dimg->image_width;
hlib.c:  ih = Dimg->image_height; 
hlib.c:  w  = Simg->image_width;
hlib.c:  h  = Simg->image_height;
hlib.c:  cx0=wc->c_v_x1;
hlib.c:  cx1=wc->c_v_x2;
hlib.c:  cy0=dc->EVGAY-1-wc->c_v_y2;
hlib.c:  cy1=dc->EVGAY-1-wc->c_v_y1;
hlib.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,
hlib.c:           ((Image *)(Simg->image))->columns,
hlib.c:           ((Image *)(Simg->image))->rows);
hlib.c:  w = xu -xl+1;
hlib.c:  h = yu -yl+1;
hlib.c:  lper = (xl-X1)/(float)(X2-X1);
hlib.c:  rper = (X2-xu)/(float)(X2-X1);
hlib.c:  tper = (yl-Y1)/(float)(Y2-Y1);
hlib.c:  bper = (Y2-yu)/(float)(Y2-Y1);
hlib.c:  if(strcmp(img->Sign,"IMG")!=0) return;
hlib.c:  iw = img->image_width;
hlib.c:  ih = img->image_height;
hlib.c:    l= iw*lper+1;r=iw*(1-rper);
hlib.c:    b= ih*bper+1;t=ih*(1-tper);
hlib.c:    fprintf(fp," %f -%-f scale\n",1.0/0.07087,1.0/0.07087);
hlib.c:    fprintf(fp," -90 rotate\n");
hlib.c://    fprintf(fp," -30  -60 translate\n");
hlib.c:         fprintf(fp," %d %d translate\n",EVGAY-yl,xl);
hlib.c:         fprintf(fp,"  %d %d scale\n",(yu-yl),(xu-xl));
hlib.c:         fprintf(fp,"  %d %d scale\n",(xu-xl),(yu-yl));
hlib.c:    if(LSCAPE) fprintf(fp,"  -90 rotate\n");
hlib.c:      fprintf(fp," %f %f scale\n",1.0/(yu-yl),1.0/(xu-xl));
hlib.c:      fprintf(fp," -%-d -%-d translate\n",EVGAY-yl,xl);
hlib.c:      fprintf(fp," %f %f scale\n",1.0/(xu-xl),1.0/(yu-yl));
hlib.c:      fprintf(fp," -%-d -%-d translate\n",xl,yl);
hlib.c:    fprintf(fp,"0.07087 -0.07087 scale\n");
hlib.c:  rd-=xa;
hlib.c:   dx1= x1[1]-x1[0];
hlib.c:   dy1= y1[1]-y1[0];
hlib.c:   dx2= x1[3]-x1[2];
hlib.c:   dy2= y1[3]-y1[2];
hlib.c:     if(ch=='-') {Sign=-1;ch = getc(tmppt);}
hlib.c:     n = n*10+(ch-'0');
hlib.c:     if(TX_F==NULL) printf("Failed to open: %-s\n",TX_HC);
hlib.c:    if(LSCAPE) fprintf(hbuf,"%d %d m\n",x,(EVGAY-y));
hlib.c:    sprintf(&buf1[19],"%-6.1f",T_rot+angle);
hlib.c:     xo=-100;yo=-100;
hlib.c:              fprintf(hbuf,"%-8.2f setlinewidth\n",(x*Ln_width));
hlib.c:              fprintf(hbuf,"%-d setlinecap 0 setlinejoin\n",(x));
hlib.c:              sprintf(&buf1[19],"%-6.1f",T_rot+angle);
hlib.c:                sprintf(&buf1[3],"%-6.2f",xs);
hlib.c:                sprintf(&buf1[10],"%-6.2f",-ys);
hlib.c:                sprintf(&buf1[3],"%-6.2f",ys);
hlib.c:                sprintf(&buf1[10],"%-6.2f",-xs);
hlib.c:     xo=-100;yo=-100;
hlib.c:  xscale=-1,yscale=1;
hlib.c:  t_font_o=-1;
hlib.c:  icpos = pt->icpos;
hlib.c:  icxv = pt->icxv;
hlib.c:  icyv = pt->icyv;
hlib.c:  m_f =  pt->m_f;
hlib.c:  icpos = pt->icpos;
hlib.c:  icxv = pt->icxv;
hlib.c:  icyv = pt->icyv;
hlib.c:  m_f =  pt->m_f;
hlib.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
hlib.c:  v_yt1=(int)(v_y1-txt_ht);
hlib.c:  icpos = pt->icpos;
hlib.c:  icxv = pt->icxv;
hlib.c:  icyv = pt->icyv;
hlib.c:  m_f =  pt->m_f;
hlib.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
hlib.c:  v_yt1=(int)(v_y1-txt_ht);
hlib.c:   V_x=v_x2-v_x1;
hlib.c:   V_y=v_y2-v_y1;
hlib.c:   u_x=(V_x/(w_x2-w_x1));
hlib.c:   u_y=(V_y/(w_y2-w_y1));
hlib.c:   lcur_y=EVGAY-v_y1;
hlib.c:   rcur_y=EVGAY-v_y2;
hlib.c:  u_x=(V_x/(x2-x1));
hlib.c:  u_y=(V_y/(y2-y1));
hlib.c:  r_d=(((x2-x1)*(x2-x1)+
hlib.c:       (y2-y1)*(y2-y1)));
hlib.c:  txt_ht = (w_y2-w_y1)*0.03;
hlib.c:  txt_wt = (w_x2-w_x1)*0.03;
hlib.c:  txt_sp = (w_x2-w_x1)*0.003;
hlib.c:   CPCONS = 65000./(float)(clip_max-clip_min);
hlib.c:       lt->code ='l';
hlib.c:       if( Cz > newstr.zstr ) { lt->zmax = Cz; lt->zmin = newstr.zstr;}
hlib.c:       else { lt->zmin = Cz; lt->zmax = newstr.zstr;}
hlib.c:       lt->clr = c_color; lt->style = ln_style; lt->width = ln_width;
hlib.c:    float zmax=-1.e+20,zmin = 1.e+20;
hlib.c:      pt->code = 'p';
hlib.c:      pt->n = n;
hlib.c:      pt->x = xt, pt->y = yt, pt->z = zt;
hlib.c:      pt->zmax = zmax, pt->zmin = zmin;
hlib.c:      pt->fclr = color;
hlib.c:      pt->bclr = c_color;
hlib.c:      pt->flag = flag;
hlib.c:   float zmax=-1.e+20,zmin = 1.e+20;
hlib.c:      pt->code = 'p';
hlib.c:      pt->n = 4;
hlib.c:      pt->x = xt, pt->y = yt, pt->z = zt;
hlib.c:      pt->zmax = zmax, pt->zmin = zmin;
hlib.c:      pt->fclr = fl;
hlib.c:      pt->bclr = c_color;
hlib.c:      pt->flag = ib;
hlib.c:   float zmax=-1.e+20,zmin = 1.e+20;
hlib.c:      st->code = 's';
hlib.c:      st->n = n;
hlib.c:      st->x = xt, st->y = yt, st->z = zt, st->v = vt;
hlib.c:      st->zmax = zmax, st->zmin = zmin;
hlib.c:      st->bclr = c_color;
hlib.c:   if( (lt2->zmax < lt1->zmax )) return 1;
hlib.c:       switch(lt->code) {
hlib.c:            c_color  = lt->clr;
hlib.c:            ln_style = lt->style;
hlib.c:            ln_width = lt->width;
hlib.c:            t_move(lt->x1,lt->y1);
hlib.c:            t_draw(lt->x2,lt->y2);
hlib.c:            c_color  = pt->bclr;
hlib.c:            t_panel(pt->x,pt->y,pt->fclr,pt->flag,pt->n);
hlib.c:            free(pt->x),free(pt->y),free(pt->z);
hlib.c:            c_color  = st->bclr;
hlib.c:            t_godr_fill(st->n,st->x,st->y,st->v);
hlib.c:            free(st->x),free(st->y),free(st->z),free(st->v);
hlib.c: double Zmax=-1e+20,Zmin=1e+20,dz,zu,zl;
hlib.c:      if(lt->zmax > Zmax ) Zmax = lt->zmax;
hlib.c:      if(lt->zmin < Zmin ) Zmin = lt->zmin;
hlib.c:      dz = (Zmax-Zmin)/n;
hlib.c:          if((lt->zmax < zu) &&( lt->zmax >= zl) ) Dadd(tmp1,lt);
hlib.c:        if( (entry > 5) &&((tmp1->st==NULL)||(tmp2->st==NULL)) ){
hlib.c:          entry--;
hlib.c:      entry--;
hlib.c:                  T_rot=-90.0;
hlib.c:                 _draw_line(x-3*fac,y-3*fac,x+3*fac,y+3*fac);
hlib.c:                 _draw_line(x-3*fac,y+3*fac,x+3*fac,y-3*fac);
hlib.c:                 _box_fill_ps(x-3*fac,y-3*fac,x+3*fac,y+3*fac,(unsigned char)15);
hlib.c:case 3 : draw_line(x,y-4*fac,x,y+4*fac);
hlib.c:draw_line(x-4*fac,y,x+4*fac,y);
hlib.c:draw_line(x-2*fac,y-4*fac,x+2*fac,y-4*fac);
hlib.c:draw_line(x-2*fac,y+4*fac,x+2*fac,y+4*fac);
hlib.c:draw_line(x-4*fac,y-2*fac,x-4*fac,y+2*fac);
hlib.c:draw_line(x+4*fac,y-2*fac,x+4*fac,y+2*fac);
hlib.c:case 4 : draw_line(x-4*fac,y-4*fac,x+4*fac,y+4*fac);
hlib.c:draw_line(x-4*fac,y+4*fac,x+4*fac,y-4*fac);
hlib.c:draw_line(x-4*fac,y,x+4*fac,y);
hlib.c:draw_line(x,y-4*fac,x,y+4*fac);
hlib.c:case 5 : draw_line(x+3*fac,y,x,y-8*fac);
hlib.c:draw_line(x-3*fac,y,x,y-8*fac);
hlib.c:draw_line(x-3*fac,y,x,y+8*fac);
hlib.c:case 6 : draw_line(x-4*fac,y,x+4*fac,y);
hlib.c:draw_line(x,y-4*fac,x,y+4*fac);
hlib.c:draw_line(x+2*fac,y-2*fac,x+2*fac,y+2*fac);
hlib.c:draw_line(x+2*fac,y+2*fac,x-2*fac,y+2*fac);
hlib.c:draw_line(x-2*fac,y+2*fac,x-2*fac,y-2*fac);
hlib.c:draw_line(x-2*fac,y-2*fac,x+2*fac,y-2*fac);
hlib.c:draw_line(x+7*fac,y,x+3*fac,y-3*fac);
hlib.c:draw_line(x+3*fac,y-3*fac,x,y-7*fac);
hlib.c:draw_line(x,y-7*fac,x-3*fac,y-3*fac);
hlib.c:draw_line(x-3*fac,y-3*fac,x-7*fac,y);
hlib.c:draw_line(x-7*fac,y,x-3*fac,y+3*fac);
hlib.c:draw_line(x-3*fac,y+3*fac,x,y+7*fac);
hlib.c:case 8 : draw_line(x-4*fac,y-4*fac,x+4*fac,y+4*fac);
hlib.c:draw_line(x+4*fac,y-4*fac,x-4*fac,y+4*fac);
hlib.c:draw_line(x+4*fac,y-4*fac,x+4*fac,y-2*fac);
hlib.c:draw_line(x+4*fac,y-4*fac,x+2*fac,y-4*fac);
hlib.c:draw_line(x-4*fac,y-4*fac,x-2*fac,y-4*fac);
hlib.c:draw_line(x-4*fac,y-4*fac,x-4*fac,y-2*fac);
hlib.c:draw_line(x-4*fac,y+4*fac,x-4*fac,y+2*fac);
hlib.c:draw_line(x-4*fac,y+4*fac,x-2*fac,y+4*fac);
hlib.c:                 px[0]=x+4*fac;py[0]=y;px[1]=x-4*fac;py[1]=y+4*fac;
hlib.c:                 px[2]=x-4*fac;py[2]=y-4*fac;
hlib.c:                 px[0]=x-4*fac;py[0]=y;px[1]=x+4*fac;py[1]=y+4*fac;
hlib.c:                 px[2]=x+4*fac;py[2]=y-4*fac;
hlib.c:                 px[0]=x;py[0]=y+4*fac;px[1]=x-4*fac;py[1]=y-4*fac;
hlib.c:                 px[2]=x+4*fac;py[2]=y-4*fac;
hlib.c:                 px[0]=x;py[0]=y-4*fac;px[1]=x-4*fac;py[1]=y+4*fac;
hlib.c:                 _draw_line(x-2*fac,y-2*fac,x+2*fac,y+2*fac);
hlib.c:                 _draw_line(x-2*fac,y+2*fac,x+2*fac,y-2*fac);
hlib.c:                 px[0]=x+2*fac;py[0]=y;px[1]=x-2*fac;py[1]=y+2*fac;
hlib.c:                 px[2]=x-2*fac;py[2]=y-2*fac;
hlib.c:                 px[0]=x-2*fac;py[0]=y;px[1]=x+2*fac;py[1]=y+2*fac;
hlib.c:                 px[2]=x+2*fac;py[2]=y-2*fac;
hlib.c:                 px[0]=x;py[0]=y+2*fac;px[1]=x-2*fac;py[1]=y-2*fac;
hlib.c:                 px[2]=x+2*fac;py[2]=y-2*fac;
hlib.c:                 px[0]=x;py[0]=y-2*fac;px[1]=x-2*fac;py[1]=y+2*fac;
hlib.c:  /*fprintf(TX_F,"/%-s findfont %-6.1f scalefont setfont\n",FontName,font_size);*/
hlib.c:  cs = 1. -acos( fabs((double)cost))/1.5708;
hlib.c:  ss = 1.- cs;
hlib.c:  fprintf(TX_F,"ZF%-s findfont %-6.1f scalefont setfont\n",
hlib.c:  cs = 1. -acos( fabs((double)cost))/1.5708;
hlib.c:  ss = 1.- cs;
hlib.c:  theta=-t*rad;
hlib.c:  xfact = (w_x2-w_x1)/x_mulf;
hlib.c:  yfact = (w_y2-w_y1)/y_mulf;
hlib.c:  txt_ht=txt_ht*V_y/((w_y2-w_y1));
hlib.c:  txt_wt=txt_wt*V_x/((w_x2-w_x1));
hlib.c:  txt_sp=txt_sp*V_x/((w_x2-w_x1));
hlib.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
hlib.c:  v_yt1=(int)(v_y1-txt_ht);
hlib.c:         tx = ((*xb)-(*xa));
hlib.c:         ty = ((*yb)-(*ya));
hlib.c:y=(int)(*ya+(c_v_x1-(*xa))*ty/tx);
hlib.c:y=(int)(*ya+(c_v_x2-(*xa))*ty/tx);
hlib.c:x=(int)(*xa+(c_v_y2-(*ya))*tx/ty);
hlib.c:x=(int)(*xa+(c_v_y1-(*ya))*tx/ty);
hlib.c:         tx = ((*xb)-(*xa));
hlib.c:         ty = ((*yb)-(*ya));
hlib.c:y=(int)(*ya+(b_v_x1-(*xa))*ty/tx);
hlib.c:y=(int)(*ya+(b_v_x2-(*xa))*ty/tx);
hlib.c:x=(int)(*xa+(b_v_y2-(*ya))*tx/ty);
hlib.c:x=(int)(*xa+(b_v_y1-(*ya))*tx/ty);
hlib.c:   j=EVGAY-y;
hlib.c:   dx=(xb-xa);
hlib.c:   dy=(yb-ya);
hlib.c:     /*while (abs(c-xb)>5)*/
hlib.c:      } while ( abs(c-xb) > 5);
hlib.c:     /*while (abs(r-yb)>5)*/
hlib.c:      } while ( abs(r-yb) > 5);
hlib.c:  txt_htx=ht/(w_y2-w_y1)*(w_x2-w_x1);
hlib.c:  txt_wty=wt/(w_x2-w_x1)*(w_y2-w_y1);
hlib.c:  txt_spy=sp/(w_x2-w_x1)*(w_y2-w_y1);
hlib.c:  txt_wt= sint*sint*txt_wty*(w_x2-w_x1)/(w_y2-w_y1)+cost*cost*txt_wtx;
hlib.c:  txt_sp= sint*sint*txt_spy*(w_x2-w_x1)/(w_y2-w_y1)+cost*cost*txt_spx;
hlib.c:  txt_ht= sint*sint*txt_htx/(w_x2-w_x1)*(w_y2-w_y1)+cost*cost*txt_hty;
hlib.c:  txt_ht=txt_ht*V_y/((w_y2-w_y1));
hlib.c:  txt_wt=txt_wt*V_x/((w_x2-w_x1));
hlib.c:  txt_sp=txt_sp*V_x/((w_x2-w_x1));
hlib.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
hlib.c:  v_yt1=(int)(v_y1-txt_ht);
hlib.c:  xfact = (w_x2-w_x1)/x_mulf;
hlib.c:  yfact = (w_y2-w_y1)/y_mulf;
hlib.c:  txt_ht=txt_ht*V_y/(w_y2-w_y1);
hlib.c:  txt_wt=txt_wt*V_x/(w_x2-w_x1);
hlib.c:  txt_sp=txt_sp*V_x/(w_x2-w_x1);
hlib.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
hlib.c:  v_yt1=(int)(v_y1-txt_ht);
hlib.c:  pt->icpos = icposf0;
hlib.c:  pt->m_f = m_f0;
hlib.c:  pt->icxv = icxvf0;
hlib.c:  pt->icyv = icyvf0;
hlib.c:  pt->fontname = fontname0;
hlib.c:  pt->icpos = icposf1; pt->m_f = m_f1; pt->icxv = icxvf1;
hlib.c:  pt->icyv = icyvf1; pt->fontname = fontname1;
hlib.c:  pt->icpos = icposf2; pt->m_f = m_f2; pt->icxv = icxvf2;
hlib.c:  pt->icyv = icyvf2; pt->fontname = fontname2;
hlib.c:  pt->icpos = icposf3; pt->m_f = m_f3; pt->icxv = icxvf3;
hlib.c:  pt->icyv = icyvf3; pt->fontname = fontname3;
hlib.c:  pt->icpos = icposf4; pt->m_f = m_f4; pt->icxv = icxvf4;
hlib.c:  pt->icyv = icyvf4; pt->fontname = fontname4;
hlib.c:  pt->icpos = icposf5; pt->m_f = m_f5; pt->icxv = icxvf5;
hlib.c:  pt->icyv = icyvf5; pt->fontname = fontname5;
hlib.c:  pt->icpos = icposf6; pt->m_f = m_f6; pt->icxv = icxvf6;
hlib.c:  pt->icyv = icyvf6; pt->fontname = fontname6;
hlib.c:  pt->icpos = icposf7; pt->m_f = m_f7; pt->icxv = icxvf7;
hlib.c:  pt->icyv = icyvf7; pt->fontname = fontname7;
hlib.c:  pt->icpos = icposf8; pt->m_f = m_f8; pt->icxv = icxvf8;
hlib.c:  pt->icyv = icyvf8; pt->fontname = fontname8;
hlib.c:  pt->icpos = icposf9; pt->m_f = m_f9; pt->icxv = icxvf9;
hlib.c:  pt->icyv = icyvf9; pt->fontname = fontname9;
hlib.c:  pt->icpos = icposf10; pt->m_f = m_f10; pt->icxv = icxvf10;
hlib.c:  pt->icyv = icyvf10; pt->fontname = fontname10;
hlib.c:  pt->icpos = icposf11; pt->m_f = m_f11; pt->icxv = icxvf11;
hlib.c:  pt->icyv = icyvf11; pt->fontname = fontname11;
hlib.c:  pt->icpos = icposf12; pt->m_f = m_f12; pt->icxv = icxvf12;
hlib.c:  pt->icyv = icyvf12; pt->fontname = fontname12;
hlib.c:  pt->icpos = icposf13; pt->m_f = m_f13; pt->icxv = icxvf13;
hlib.c:  pt->icyv = icyvf13; pt->fontname = fontname13;
hlib.c:  pt->icpos = icposf14; pt->m_f = m_f14; pt->icxv = icxvf14;
hlib.c:  pt->icyv = icyvf14; pt->fontname = fontname14;
hlib.c:  pt->icpos = icposf15; pt->m_f = m_f15; pt->icxv = icxvf15;
hlib.c:  pt->icyv = icyvf15; pt->fontname = fontname15;
hlib.c:  pt->icpos = icposf16; pt->m_f = m_f16; pt->icxv = icxvf16;
hlib.c:  pt->icyv = icyvf16; pt->fontname = fontname16;
hlib.c:  pt->icpos = icposf17; pt->m_f = m_f17; pt->icxv = icxvf17;
hlib.c:  pt->icyv = icyvf17; pt->fontname = fontname17;
hlib.c:  pt->icpos = icposf18; pt->m_f = m_f18; pt->icxv = icxvf18;
hlib.c:  pt->icyv = icyvf18; pt->fontname = fontname18;
hlib.c:  pt->icpos = icposf19; pt->m_f = m_f19; pt->icxv = icxvf19;
hlib.c:  pt->icyv = icyvf19; pt->fontname = fontname19;
hlib.c:  pt->icpos = icposf20; pt->m_f = m_f20; pt->icxv = icxvf20;
hlib.c:  pt->icyv = icyvf20; pt->fontname = fontname20;
hlib.c:  pt->icpos = icposf21; pt->m_f = m_f21; pt->icxv = icxvf21;
hlib.c:  pt->icyv = icyvf21; pt->fontname = fontname21;
hlib.c:  pt->icpos = icposf22; pt->m_f = m_f22; pt->icxv = icxvf22;
hlib.c:  pt->icyv = icyvf22; pt->fontname = fontname22;
hlib.c:  pt->icpos = icposf23; pt->m_f = m_f23; pt->icxv = icxvf23;
hlib.c:  pt->icyv = icyvf23; pt->fontname = fontname23;
hlib.c:  pt->icpos = icposf24; pt->m_f = m_f24; pt->icxv = icxvf24;
hlib.c:  pt->icyv = icyvf24; pt->fontname = fontname24;
hlib.c:  pt->icpos = icposf25; pt->m_f = m_f25; pt->icxv = icxvf25;
hlib.c:  pt->icyv = icyvf25; pt->fontname = fontname25;
hlib.c:  pt->icpos = icposf26; pt->m_f = m_f26; pt->icxv = icxvf26;
hlib.c:  pt->icyv = icyvf26; pt->fontname = fontname26;
hlib.c:  pt->icpos = icposf27; pt->m_f = m_f27; pt->icxv = icxvf27;
hlib.c:  pt->icyv = icyvf27; pt->fontname = fontname27;
hlib.c:  pt->icpos = icposf28; pt->m_f = m_f28; pt->icxv = icxvf28;
hlib.c:  pt->icyv = icyvf28; pt->fontname = fontname28;
hlib.c:  pt->icpos = icposf29; pt->m_f = m_f29; pt->icxv = icxvf29;
hlib.c:  pt->icyv = icyvf29; pt->fontname = fontname29;
hlib.c:  pt->icpos = icposf30; pt->m_f = m_f30; pt->icxv = icxvf30;
hlib.c:  pt->icyv = icyvf30; pt->fontname = fontname30;
hlib.c:  pt->icpos = icposf31; pt->m_f = m_f31; pt->icxv = icxvf31;
hlib.c:  pt->icyv = icyvf31; pt->fontname = fontname31;
hlib.c:  pt->icpos = icposf32; pt->m_f = m_f32; pt->icxv = icxvf32;
hlib.c:  pt->icyv = icyvf32; pt->fontname = fontname32;
hlib.c:  pt->icpos = icposf33; pt->m_f = m_f33; pt->icxv = icxvf33;
hlib.c:  pt->icyv = icyvf33; pt->fontname = fontname33;
hlib.c:  pt->icpos = icposf34; pt->m_f = m_f34; pt->icxv = icxvf34;
hlib.c:  pt->icyv = icyvf34; pt->fontname = fontname34;
hlib.c:  pt->icpos = icposf35; pt->m_f = m_f35; pt->icxv = icxvf35;
hlib.c:  pt->icyv = icyvf35; pt->fontname = fontname35;
hlib.c:  pt->icpos = icposf36; pt->m_f = m_f36; pt->icxv = icxvf36;
hlib.c:  pt->icyv = icyvf36; pt->fontname = fontname36;
hlib.c:  icpos = pt->icpos;
hlib.c:  icxv = pt->icxv;
hlib.c:  icyv = pt->icyv;
hlib.c:  m_f =  pt->m_f;
hlib.c:  strcpy(FontName,pt->fontname);
hlib.c:  icpos = pt->icpos;
hlib.c:  icxv = pt->icxv;
hlib.c:  icyv = pt->icyv;
hlib.c:  m_f =  pt->m_f;
hlib.c:  strcpy(FontName,pt->fontname);
hlib.c:  fprintf(TX_F,"ZF%-s findfont %-6.1f scalefont setfont\n",FontName,font_size);
hlib.c:  icpos = pt->icpos;
hlib.c:  icxv = pt->icxv;
hlib.c:  icyv = pt->icyv;
hlib.c:  m_f =  pt->m_f;
hlib.c:  strcpy(FontName,pt->fontname);
hlib.c:  pnt=asc-32+greek;
hlib.c:  else xo -=(1.-fact)*0.5*txt_wt;
hlib.c:  pnt=asc-32+greek;
hlib.c:  /*else xo -=(1.-fact)*0.5*txt_wt;*/
hlib.c:  pnt=asc-32+greek;
hlib.c:  else xo -=(1.-fact)*0.5*txt_wt;
hlib.c:  ya=(cy-(xo)*sint+yo*cost);
hlib.c:     y[i]=(cy+(ydum)*cost-(xdum)*sint);
hlib.c:  pnt=asc-32+greek;
hlib.c:  ya=(cy-(xo)*sint+yo*cost);
hlib.c:       tm=1.-t;
hlib.c:       dist = (x-x1)*(x-x1)+(y-y1)*(y-y1);
hlib.c:      tm=1.-t;
hlib.c:    j1=j-1;
hlib.c:      { if( (x1[i]==x1[i-1]) &&(y1[i]==y1[i-1]))
hlib.c:          { j--; for(k=i;k<j;k++) {x1[k]=x1[k+1];y1[k]=y1[k+1];}}
hlib.c:   for(i=1;i<j;i++){x2[i-1]=x1[i];y2[i-1]=y1[i];}
hlib.c:   x2[j-1]=x1[0];y2[j-1]=y1[0];
hlib.c:    j1=j-1;
hlib.c:      xp = xp -0.5*txt_sp;
hlib.c:       else yp= yp-0.7*txt_ht;
hlib.c:      is = *ishft-((*ishft)/10)*10;
hlib.c:                      *ishft = (*ishft)-1;
hlib.c:                      yp = yp-1.4*txt_ht;
hlib.c:    fprintf(TX_F,"ZF%-s findfont %-6.1f scalefont setfont\n",
hlib.c:                            xp =xp -txt_wt -txt_sp;
hlib.c:                             while( (pt->x2) >=0.) pt=pt->Pr;
hlib.c:                             (pt->x2)=xp-txt_sp;
hlib.c:                             pt=pt->Pr;
hlib.c:                              xp=O_P->x;
hlib.c:                              yp=O_P->y;
hlib.c:                              O_P=O_P->Pr;
hlib.c:                              O_P->Nx=NULL;O_P->Pr=NULL;
hlib.c:                              O_P->Nx=(B_K *) Malloc((int)sizeof(B_K));
hlib.c:                              O_P->Nx->Pr=O_P;
hlib.c:                              O_P=O_P->Nx;
hlib.c:                              O_P->Nx=NULL;
hlib.c:                            (O_P->x) = xp;
hlib.c:                            (O_P->y) = yp;
hlib.c:                            yp -=0.2*txt_ht;
hlib.c:                            yp -=0.9*txt_ht;
hlib.c:                              O_L->Nx=NULL;O_L->Pr=NULL;
hlib.c:                              O_L->Nx=(L_N *) Malloc((int)sizeof(L_N));
hlib.c:                              O_L->Nx->Pr=O_L;
hlib.c:                              O_L=O_L->Nx;
hlib.c:                              O_L->Nx=NULL;
hlib.c:                            (O_L->x1) = xp;
hlib.c:                            (O_L->x2) = -1.0;
hlib.c:                            O_L->ymax = yp+1.4*txt_ht;
hlib.c:                            O_L->ymin = yp-0.4*txt_ht;
hlib.c:                            O_L->p=cntl;
hlib.c:                            Nu= (txt[i+1] -'0')*10+(txt[i+2]-'0');
hlib.c:                            Nu= (txt[i+1] -'0')*10+(txt[i+2]-'0');
hlib.c:                            Nu= (txt[i+1] -'0');
hlib.c:                            De= (txt[i+2] -'0');
hlib.c:                            Nu= (txt[i+1] -'0');
hlib.c:                            De= (txt[i+2] -'0');
hlib.c:                            Nu= (txt[i+1] -'0');
hlib.c:                            De= (txt[i+2] -'0');
hlib.c:        if(pt->x2 <0.) pt->x2=xp;
hlib.c:        if(pt->p =='U') {
hlib.c:         _move(TX((pt->x1),pt->ymin),TY((pt->x1),pt->ymin));
hlib.c:         _draw(TX((pt->x2),pt->ymin),TY((pt->x2),pt->ymin));
hlib.c:         _move(TX((pt->x1),pt->ymax),TY((pt->x1),pt->ymax));
hlib.c:         _draw(TX((pt->x2),pt->ymax),TY((pt->x2),pt->ymax));
hlib.c:        pt=pt->Nx;
hlib.c:       O_P=O_P->Pr;
hlib.c:    fprintf(TX_F,"ZF%-s findfont %-6.1f scalefont setfont\n",
hlib.c:                            xp =xp -txt_wt -txt_sp;
hlib.c:                            Nu= (txt[i+1] -'0');
hlib.c:                            De= (txt[i+2] -'0');
hlib.c:  xup =-100000;
hlib.c:  ygrt=-1239000;
hlib.c:j=i-1;
hlib.c:  j--;
hlib.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
hlib.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
hlib.c:j=i-1;
hlib.c:while(j>=0 && txx < xcord[j]){ xcord[j+1]=xcord[j];j--;}
hlib.c:  GMV(px[n-1],py[n-1]);
hlib.c:  xup =-100000;
hlib.c:  ygrt=-1239000;
hlib.c:j=i-1;
hlib.c:  j--;
hlib.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
hlib.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
hlib.c:j=i-1;
hlib.c:while((j>=0) && (txx < xcord[j])){ xcord[j+1]=xcord[j];j--;}
hlib.c:      fj =0.0; gj = j-1; fact = 1.0;
hlib.c:          { if( pr_txt>0) fact1=m_f[title[i]-32+greek]*fact;
hlib.c:             i=i+1; gj = gj-2;
hlib.c:             if(title[i] == 'b') { fj = fj-fact1; gj=gj-1;};
hlib.c:                            val = title[i+2]-'0';
hlib.c:                            val = (float)(title[i+1]-'0')/val;
hlib.c:                            gj = gj-2;
hlib.c:  xup =-100000;
hlib.c:  ygrt=-1239000;
hlib.c:j=i-1;
hlib.c:  j--;
hlib.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
hlib.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
hlib.c:                   pcord[cnt]=(((float)(pmax[i]-pmin[i])/(ymax[i]-ymin[i])
hlib.c:                              *(scan-ymin[i]) +pmin[i]));
hlib.c:j=i-1;
hlib.c:                     pcord[j+1]=pcord[j];j--;}
hlib.c:  yy = EVGAY-y;
hlib.c:  if(xb != xa) pfac = (pb-pa)/(xb-xa);
hlib.c:      {pval = pa+(c_v_x1-xa)*pfac;
hlib.c:      {pval = pa+(c_v_x2-xa)*pfac;
hlib.c:    tempc=(int)(pa+(i-xa)*pfac+0.5);
hlib.c:  yy = EVGAY-y;
hlib.c:  if ((xb-xa)<10)
hlib.c:   dfac = (n -1)/(pmax-pmin);
hlib.c:   dfac = (n -1)/(pmax-pmin);
hlib.c:    temp->pt= (int *)c_loc;
hlib.c:    temp->cx1=c_v_x1;
hlib.c:    temp->cy1=c_v_y1;
hlib.c:    temp->cx2=c_v_x2;
hlib.c:    temp->cy2=c_v_y2;
hlib.c:     GCLIP(c_v_x1,c_v_y1,(c_v_x2-c_v_x1),(c_v_y2-c_v_y1));
hlib.c:        temp=(CLIP *)c_loc->pt;
hlib.c:        c_v_x1=c_loc->cx1;
hlib.c:        c_v_y1=c_loc->cy1;
hlib.c:        c_v_x2=c_loc->cx2;
hlib.c:        c_v_y2=c_loc->cy2;
hlib.c:        temp=(CLIP *)c_loc->pt;
hlib.c:  fprintf(hbuf,"%%!PS-Adobe-3.0\n");
hlib.c:  fprintf(hbuf,"/T {gsave 1 -1 scale} bind def\n");
hlib.c:   "/graycol {dup dup currentrgbcolor 4 -2 roll mul 4 -2 roll mul ");
hlib.c:  fprintf(hbuf,"4 -2 roll mul setrgbcolor} bind def\n");
hlib.c:  fprintf(hbuf,"/col-1 {} def\n");
hlib.c:  fprintf(hbuf,"30.0 60.0  translate 90 rotate  0.07087 -0.07087 scale\n");
hlib.c:  fprintf(hbuf,"%-10.2f setlinewidth\n",Ln_width);
hlib.c:  fprintf(hbuf,"/Times-Roman findfont 188.0 scalefont setfont\n");
hlib.c:  if(LSCAPE){temp=col,col=EVGAY-row,row=temp;};
hlib.c:  if(LSCAPE){temp=col,col=row,row=evgay-temp;};
hlib.c:  addr = (evgay-row)*MAXB + (col>>3);
hlib.c:   T_rot=-90.0;
hlib.c:  sprintf(TX_HC,"%-s/TX_HC",TmpDir);
hsvclr.c:     f = h-i;
hsvclr.c:     p = v*(1-s);
hsvclr.c:     q = v*(1- (s*f));
hsvclr.c:     t = v*(1-(s*(1-f)));
hsvclr.c:  h -(0-360)
hsvclr.c:  s  (0 -1)
hsvclr.c:  v  (0 - 1)
hsvclr.c:     f = h-i;
hsvclr.c:     p = v*(1-s);
hsvclr.c:     q = v*(1- (s*f));
hsvclr.c:     t = v*(1-(s*(1-f)));
imagetogray.c:  image = (Image *)(png->image);
imagetogray.c:  spixels =GetImagePixels(image,0,0,image->columns,image->rows);
imagetogray.c:  xsize = image->columns;
imagetogray.c:  ysize = image->rows;
junk.c:#define uiset_clip_limits(wc,x1,y1,x2,y2) wc->c_v_x1=x1,wc->c_v_y1=y1,wc->c_v_x2=x2,wc->c_v_y2=y2
junk.c:#define uibkup_clip_limits wc->c_v_x1_o=wc->c_v_x1,wc->c_v_y1_o=wc->c_v_y1,wc->c_v_x2_o=wc->c_v_x2,wc->c_v_y2_o=wc->c_v_y2
junk.c:#define uiset_sup_clip_limits(wc,x1,y1,x2,y2) wc->s_v_x1=x1,wc->s_v_y1=y1,wc->s_v_x2=x2,wc->s_v_y2=y2
junk.c:#define uirest_clip_limits wc->c_v_x1=wc->c_v_x1_o,wc->c_v_y1=wc->c_v_y1_o,wc->c_v_x2=wc->c_v_x2_o,wc->c_v_y2=wc->c_v_y2_o
junk.c:#define IMAGE_BLUE_VAL  (((blue)*(wc->IMAGE->blue_mask)+(1<<(wc->BLUEMASKPOS-1)))/255)
junk.c:#define IMAGE_GREEN_VAL ((((green) * (wc->IMAGE->green_mask) \
junk.c:                  +(1<<(wc->GREENMASKPOS -1)))/255)&(wc->IMAGE->green_mask))
junk.c:#define IMAGE_RED_VAL ((((red) * (wc->IMAGE->red_mask) \
junk.c:                  +(1<<(wc->REDMASKPOS -1)))/255)&(wc->IMAGE->red_mask))
junk.c:#define BLUE_VAL  (((val&0x0000ff)*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
junk.c:#define GREEN_VAL (((((val>>8)&0x0000ff) * (uiImage->green_mask) \
junk.c:                  +(1<<(GreenMaskPos -1)))/255)&(uiImage->green_mask))
junk.c:#define RED_VAL (((((val>>16)&0x0000ff) * (uiImage->red_mask) \
junk.c:                  +(1<<(RedMaskPos -1)))/255)&(uiImage->red_mask))
junk.c:#define Image_BLUE_VAL  ((blue*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
junk.c:#define Image_GREEN_VAL (((green * (uiImage->green_mask) \
junk.c:                  +(1<<(GreenMaskPos -1)))/255)&(uiImage->green_mask))
junk.c:#define Image_RED_VAL (((red * (uiImage->red_mask) \
junk.c:                  +(1<<(RedMaskPos -1)))/255)&(uiImage->red_mask))
junk.c:#define Img_BLUE_VAL  ((blue*(uiImage->blue_mask)+(1<<(BlueMaskPos-1)))/255)
junk.c:static char FONTSTRF[60]= "-adobe-courier-medium-r-*-*-";
junk.c:static char FONTSTRV[60]= "-adobe-courier-medium-r-*-*-";
junk.c:static char FONTSTRV[60]= "-adobe-helvetica-bold-r-*-*-";
junk.c:static char FONTSTRF[60]= "-adobe-courier-bold-r-*-*-";
junk.c:static char FONTSTRV[60]= "-adobe-helvetica-bold-r-*-*-";
junk.c:static char FONTSTRV1[60]= "-adobe-new century schoolbook-medium-r-*-*-";
junk.c:static char FONTSTRV2[60]= "-adobe-times-medium-r-*-*-";
junk.c:static char FONTSTRV3[60]= "-adobe-utopia-medium-r-*-*-";
junk.c:static char FONTSTR2[20]= "-*-*-*-*-*-*-*";
junk.c:#define FONT "-adobe-courier-medium-r-*-*-16-*-*-*-*-*-*-*"
junk1.c:          -1 , 0 , 0 /* bkgr colour */
junk1.c:      -1 , -1 , -1 };
junk1.c:      D.df = -1;
junk1.c:      return ( v0-1 ) ;
junk1.c:      p0 = ( D-> d [ 0 ] ) .p;
junk1.c:      xl = D-> xl;
junk1.c:      yl = D-> yl;
junk1.c:      msg = D-> pt;
junk1.c:      if ( msg-> message != NULL ) {
junk1.c:          fid = kgInitImage ( ( int ) ( w_x2-w_x1 ) +1 , 
junk1.c:              ( int ) ( w_y2-w_y1 ) +1 , 2 ) ;
junk1.c:          kgTextColor ( fid , msg-> fontcolor ) ;
junk1.c:          kgTextFont ( fid , msg-> font ) ;
junk1.c:          strcpy ( buf , ( char * ) msg-> message ) ;
junk1.c://      gphMove2f(fid,40.,yl-j*45.);
junk1.c:              yy = yl - dyl*0.7;
junk1.c:                  kgMove2f ( fid , ( xl-length ) *0.5 , yy ) ;
junk1.c:                  yy -= dyl;
junk1.c:              if ( msg-> message != NULL ) {
junk1.c:                  if ( p0-> xpm != NULL ) {
junk1.c:                      kgImage ( D , p0-> xpm , 0 , 0 , xl , yl , 0.0 , 1.0 ) ;
junk1.c:                      bkcolor = msg-> bkcolor;
junk1.c:                      img1 = kgBorderedRectangle ( xl-3 , yl-3 , bkcolor , 0.05 ) ;
junk1.c:          if ( p0-> xpm != NULL ) kgImage ( D , p0-> xpm , 0 , 0 , xl , yl , 0.0 , 1.0 ) ;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:          -1 , 0 , 0 , 0.005 /* bkgr colour */
junk1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk1.c:              D.xo = ( xres-xl ) /2;
junk1.c:              D.yo = ( yres-yl ) /2;
junk1.c:          p0.x2 = xl-4; p0.y2 = yl-4;
junk1.c:      p0 = ( D-> d [ 0 ] ) .p;
junk1.c:      xl = D-> xl;
junk1.c:      yl = D-> yl;
junk1.c:      msg = D-> pt;
junk1.c:      if ( msg-> message != NULL ) {
junk1.c://    fid = kgInitImage((int)(w_x2-w_x1)+10,(int)(w_y2-w_y1)+10,4);
junk1.c://    kgUserFrame(fid,w_x1-5,w_y1-5,w_x2+5,w_y2+5);
junk1.c:          fid = kgInitImage ( ( int ) ( w_x2-w_x1 ) , ( int ) ( w_y2-w_y1 ) , RESIZE ) ;
junk1.c:          kgUserFrame ( fid , w_x1-3 , w_y1-3 , w_x2+3 , w_y2+3 ) ;
junk1.c:          color = msg-> bkcolor;
junk1.c:          if ( color == -1 ) color = D-> gc.fill_clr;
junk1.c:          if ( color < -1 ) {
junk1.c:              color = -color;
junk1.c:          fcolor = msg-> fontcolor;
junk1.c:          if ( fcolor == -1 ) fcolor = D-> gc.fill_clr;
junk1.c:          if ( fcolor < -1 ) {
junk1.c:              fcolor = -fcolor;
junk1.c:          kgTextFont ( fid , msg-> font ) ;
junk1.c:          kgRoundedRectangleFill ( fid , xo , yo , ( float ) l-4 , 
junk1.c:              ( float ) w-4 , 0 , 151 , rfac ) ;
junk1.c://    kgRoundedRectangleFill(fid,(w_x1+w_x2)*.5+3,(w_y1+w_y2)*.5-2,w_x2-6,w_y2-6,0,0,0.1);
junk1.c://    kgRoundedRectangleFill(fid,(w_x1+w_x2)*.5,(w_y1+w_y2)*.5,w_x2-6,w_y2-6,0,color,0.1);
junk1.c:          strcpy ( buf , ( char * ) msg-> message ) ;
junk1.c://      gphMove2f(fid,40.,yl-j*45.);
junk1.c:              dyl = ( float ) ( yl-6 ) /k;
junk1.c:              fac = ( float ) ( xl-10 ) / ( length ) ;
junk1.c:              yy = yl - dyl*0.7-3;
junk1.c:                  kgMove2f ( fid , ( xl-length ) *0.5 , yy ) ;
junk1.c:                  yy -= dyl;
junk1.c:              if ( msg-> message != NULL ) {
junk1.c:                  if ( p0-> xpm != NULL ) kgImage ( D , p0-> xpm , D-> xo , D-> yo , xl , yl , 0.0 , 1.0 ) ;
junk1.c:                  kgImage ( D , Img , D-> xo , D-> yo , xl , yl , 0.0 , 1.0 ) ;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:          -1 , 0 , 0 /* bkgr colour */
junk1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk1.c:      kgSplashDia ( -1 , -1 , pt-> xsize , pt-> ysize , pt-> xpm , pt-> message , pt-> font , pt-> fontcolor , pt-> bkcolor ) ;
junk1.c:      D-> d = NULL;
junk1.c:      D-> bkup = 1; /* set to 1 for backup */
junk1.c:      D-> bor_type = 4;
junk1.c:      D-> df = 0;
junk1.c:      D-> xo = xo; /* Position of Dialog */
junk1.c:      D-> yo = yo;
junk1.c:      D-> xl = lngth+2; /* Length of Dialog */
junk1.c:      D-> yl = ( size+1 ) *20+0; /* Width of Dialog */
junk1.c:      D-> fullscreen = 0; /* 1 for for fullscreen mode */
junk1.c:      D-> Deco = 0; /* 1 for Window Decorration */
junk1.c:      D-> transparency = 000000; /* float 1.0 for full transparency */
junk1.c:      D-> Newwin = 1; /* 1 for new window not yet implemented */
junk1.c:      D-> DrawBkgr = 1; /* 1 for drawing background */
junk1.c:      D-> Bkpixmap = NULL; /* background image */
junk1.c:      D-> Sticky = 0; /* 1 for stickyness */
junk1.c:      D-> Callback = NULL;
junk1.c:      D-> Fixpos = 1; /* 1 for Fixing Position */
junk1.c:      D-> NoTaskBar = 1; /* 1 for not showing in task bar*/
junk1.c:      D-> StackPos = 1;
junk1.c:      D-> parent = NULL;
junk1.c:      D-> pt = NULL; /* any data to be passed by user*/
junk1.c:      D-> Shapexpm = NULL;
junk1.c:      strcpy ( D-> name , "Kulina Designer ver 1.0" ) ;
junk1.c:      kgDefaultGuiTheme ( & ( D-> gc ) ) ;
junk1.c:      D-> evgay = WC ( D ) -> EVGAY;
junk1.c:      D-> evgax = WC ( D ) -> EVGAX;
junk1.c:          xx1 = -8 , yy1 = 2;
junk1.c:      tempc = wc-> c_color;
junk1.c:      item = br-> df;
junk1.c:      x = br-> menu;
junk1.c:      if ( br-> menu [ 0 ] == NULL ) return 1;
junk1.c:          D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
junk1.c:                  if ( ok == 0 ) br-> df = item;
junk1.c:                  if ( ok == 0 ) br-> df = item;
junk1.c:      if ( ok > 0 ) item = br-> df;
junk1.c:      kg_scr_recover ( D-> wc ) ;
junk1.c:          pthread_cancel ( WC ( D ) -> Pth ) ;
junk1.c:          Dempty ( WC ( D ) -> Clip ) ;
junk1.c://     Dempty(WC(D)->SBlist);
junk1.c:          Dempty ( WC ( D ) -> TLIST ) ;
junk1.c:          free ( WC ( D ) -> kgcolors ) ;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk1.c:      return v0-1;
junk1.c:      kgGetDefaultRGB ( v0-1 , r , g , b ) ;
junk1.c:      return v0-1;
junk1.c:      ioldclr = ( int * ) ( D-> pt ) ;
junk1.c:      if ( ( abs ( r-ioldclr [ 3 ] ) +abs ( g-ioldclr [ 4 ] ) +abs 
junk1.c:          ( b-ioldclr [ 5 ] ) ) < 5 ) return;
junk1.c:      sprintf ( flname , "%-s/Tmp.gph" , tmpdir ) ;
junk1.c:      ioldclr = ( int * ) ( D-> pt ) ;
junk1.c:      sprintf ( flname , "%-s/Tmp.gph" , tmpdir ) ;
junk1.c:      ioldclr = ( int * ) ( D-> pt ) ;
junk1.c:      if ( ( abs ( r-ioldclr [ 3 ] ) +abs ( g-ioldclr [ 4 ] ) +abs 
junk1.c:          ( b-ioldclr [ 5 ] ) ) < 5 ) return;
junk1.c:      uiFreeImage ( p5-> xpm ) ;
junk1.c:          p5-> xpm = img;
junk1.c:      ioldclr = ( int * ) ( D-> pt ) ;
junk1.c:      uiFreeImage ( p4-> xpm ) ;
junk1.c:          p4-> xpm = img;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:      kgGetDefaultRGB ( key-1 , & r , & g , & b ) ;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      n = B-> nx;
junk1.c:          ioldclr = ( int * ) ( ( ( DIALOG * ) Tmp ) -> pt ) ;
junk1.c:      ioldclr = ( int * ) ( D-> pt ) ;
junk1.c:      wc = D-> wc;
junk1.c:      color = wc-> c_color;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:    56, 57, 58, 59, 60, 61, 62, 63, -1
junk1.c:      1,0.000000 /* button type and roundinfg factor(0-0.5) */
junk1.c:    -1,0,0 /* bkgr colour */
junk1.c:    -1,0,0 /* bkgr colour */
junk1.c:    -1, 
junk1.c:    -1, 
junk1.c:    -1
junk1.c:     6,0.250000 /* button type and roundinfg factor(0-0.5) */
junk1.c:  ioldclr[3]=-5;
junk1.c:  ioldclr[4]=-5;
junk1.c:  ioldclr[5]=-5;
junk1.c:  D.StackPos = 1;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
junk1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk1.c:              m [ ln+1 ] = m [ size-3 ] ;
junk1.c:              m [ ln+2 ] = m [ size-2 ] ;
junk1.c:              m [ ln+3 ] = m [ size-1 ] ;
junk1.c:              m [ size-3 ] = '.';
junk1.c:              m [ size-2 ] = '.';
junk1.c:              m [ size-1 ] = '.';
junk1.c:          if ( ( m [ size-3 ] == '.' ) && ( m [ size-2 ] == '.' ) && 
junk1.c:              ( m [ size-1 ] == '.' ) ) {
junk1.c:              m [ size-3 ] = m [ ln+1 ] ;
junk1.c:              m [ size-2 ] = m [ ln+2 ] ;
junk1.c:              m [ size-1 ] = m [ ln+3 ] ;
junk1.c:              m [ k ] [ ln+1 ] = m [ k ] [ size-3 ] ;
junk1.c:              m [ k ] [ ln+2 ] = m [ k ] [ size-2 ] ;
junk1.c:              m [ k ] [ ln+3 ] = m [ k ] [ size-1 ] ;
junk1.c:              m [ k ] [ size-3 ] = '.';
junk1.c:              m [ k ] [ size-2 ] = '.';
junk1.c:              m [ k ] [ size-1 ] = '.';
junk1.c:          if ( ( m [ size-3 ] == '.' ) && ( m [ size-2 ] == '.' ) && 
junk1.c:              ( m [ size-1 ] == '.' ) ) {
junk1.c:              m [ size-3 ] = m [ ln+1 ] ;
junk1.c:              m [ size-2 ] = m [ ln+2 ] ;
junk1.c:              m [ size-1 ] = m [ ln+3 ] ;
junk1.c:          m [ size-3 ] = '.';
junk1.c:          m [ size-2 ] = '.';
junk1.c:          m [ size-1 ] = '.';
junk1.c:          if ( pt-> d_name [ 0 ] == '.' ) continue;
junk1.c:          strcat ( buf , pt-> d_name ) ;
junk1.c:              ln = strlen ( pt-> d_name ) ;
junk1.c:              strcpy ( item , pt-> d_name ) ;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk1.c:      e = T-> elmt;
junk1.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk1.c:      dirs-> file = m;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = m;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk1.c:      if ( strcmp ( dirs-> CurDir , "/" ) != 0 ) strcat ( dirs-> CurDir , "/" ) ;
junk1.c:      strcat ( dirs-> CurDir , folder ) ;
junk1.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp ) -> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk1.c:      m = _uiFolderMenu ( dirs-> CurDir ) ;
junk1.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = m;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = dir;
junk1.c:      dirs-> file = file;
junk1.c:      dirs-> dir = dir;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      n = B-> nx;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:          k = strlen ( dirs-> CurDir ) ;
junk1.c:          while ( ( dirs-> CurDir [ k ] != '/' ) && ( k > 1 ) ) 
junk1.c:              {dirs-> CurDir [ k ] = '\0';k--;}
junk1.c:          dirs-> CurDir [ k ] = '\0';
junk1.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp ) -> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk1.c:          m = _uiFolderMenu ( dirs-> CurDir ) ;
junk1.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = m;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = dir;
junk1.c:      dirs-> file = m;
junk1.c:      dirs-> dir = dir;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:          strcpy ( dirs-> CurDir , dirs-> HomeDir ) ;
junk1.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp ) -> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk1.c:          m = _uiFolderMenu ( dirs-> CurDir ) ;
junk1.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = m;
junk1.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk1.c:      E-> menu = dir;
junk1.c:      dirs-> file = m;
junk1.c:      dirs-> dir = dir;
junk1.c:      dirs = D-> pt;
junk1.c:      I = ( DII * ) ( D-> d [ 1 ] .t ) ;
junk1.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , D-> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk1.c:      i--;
junk1.c:          i--;
junk1.c:      -1 , -1 , -1 };
junk1.c:      -1 , -1 };
junk1.c:      -1 , -1 };
junk1.c:      if ( getcwd ( Dir.HomeDir , 499 ) == NULL ) return -1;
junk1.c:          if ( pt-> d_name [ 0 ] == '.' ) continue;
junk1.c:     type = stat(pt->d_name,&st);
junk1.c:          strcat ( buf , pt-> d_name ) ;
junk1.c:              sprintf ( buf , "%-s" , pt-> d_name ) ;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      m = ( char ** ) ( ( DIALOG * ) Tmp ) -> pt;
junk1.c:      e = T-> elmt;
junk1.c:      kgFreeDouble ( ( void ** ) E-> menu ) ;
junk1.c:      E-> menu = m;
junk1.c:       ( ( DIALOG * ) Tmp ) -> pt = m;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      n = B-> nx;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      -1 , -1 , -1 };
junk1.c:      D.df = -1;
junk1.c:      -1 , -1 };
junk1.c:      D.df = -1;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      e = T-> elmt;
junk1.c:      pt = ( void ** ) D-> pt;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      e = T-> elmt;
junk1.c:      pt = ( void ** ) D-> pt;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      e = T-> elmt;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      e = T-> elmt;
junk1.c:      pt = ( void ** ) D-> pt;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:      pt = ( void ** ) D-> pt;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      e = T-> elmt;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      n = B-> nx*B-> ny;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk1.c:      n = B-> nx;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:      -1 , -1 };
junk1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk1.c:      -1 , -1 };
junk1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk1.c:      -1 , -1 };
junk1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk1.c:      -1 , -1 };
junk1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk1.c:      -1 , -1 };
junk1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk1.c:      -1 , -1 };
junk1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk1.c:      dc = G-> dc;
junk1.c:      v0 = dc-> ln_color;
junk1.c:      v2 = dc-> fil_color;
junk1.c:      v4 = dc-> t_color;
junk1.c:      v12 = dc-> m_style+1;
junk1.c:      v13 = dc-> trot/10+1;
junk1.c:      v8 = dc-> t_font;
junk1.c:      v10 = dc-> ln_style+1;
junk1.c:      v11 = dc-> ln_width;
junk1.c:      v5 = dc-> bod_color;
junk1.c:      LnStyle = v10-1;
junk1.c:      MarkType = v12-1;
junk1.c:      TextAngle = ( v13-1 ) *10;
junk1.c:      dc-> trot = TextAngle;
junk1.c:      dc-> fil_color = v2;
junk1.c:      dc-> t_color = v4;
junk1.c:      dc-> t_font = v8;
junk1.c:      dc-> ln_color = v0;
junk1.c:      dc-> ln_style = LnStyle;
junk1.c:      dc-> m_style = MarkType;
junk1.c:      dc-> ln_width = LnWidth;
junk1.c:      dc-> bod_color = v5;
junk1.c:      kgLineColor ( G , dc-> ln_color ) ;
junk1.c:      kgTextAngle ( G , dc-> trot ) ;
junk1.c:      kgTextFont ( G , dc-> t_font ) ;
junk1.c:      kgMarkerType ( G , dc-> m_style ) ;
junk1.c:      kgLineWidth ( G , dc-> ln_width ) ;
junk1.c:      kgTextColor ( G , dc-> t_color ) ;
junk1.c:      D.df = -1;
junk1.c:      -1 , -1 };
junk1.c:      D.df = -1;
junk1.c:      dc = G-> dc;
junk1.c:      dc-> A_size = size;
junk1.c:      dc = G-> dc;
junk1.c:      dc-> cmds = ( unsigned int * ) Malloc ( sizeof ( int ) *1000L ) ;
junk1.c:      if ( dc-> cmds == NULL ) {
junk1.c:      parent = G-> D;
junk1.c:      if ( dc-> A_size > 10 ) A_fac = ( float ) 
junk1.c:          ( dc-> A_size/10 ) / ( dc-> A_size%10 ) ;
junk1.c:      tww = ( dc-> w_x2-dc-> w_x1 ) /30.0;
junk1.c:      thh = ( dc-> w_y2-dc-> w_y1 ) /25.0;
junk1.c:      x = dc-> w_x1+ ( dc-> w_x2-dc-> w_x1 ) *0.5;
junk1.c:      y = dc-> w_y1+ ( dc-> w_y2-dc-> w_y1 ) *0.5;
junk1.c:      uiwrite_file ( G , & ( G-> rbuf ) , dc-> reviewfile ) ;
junk1.c:      loc = dc-> cmds;
junk1.c:      if ( G-> D_ON == 0 ) {
junk1.c:          MAG = G-> MAG;
junk1.c:      ytwtg = ( tw+tg ) / ( dc-> w_x2-dc-> w_x1 ) * ( dc-> w_y2-dc-> w_y1 ) /0.75;
junk1.c://      while((item=uiMenu(G->D,G->x1,G->y1,1,1,cmenu,17))!=17)
junk1.c:      while ( ( item = kgMenu ( G-> D , parent-> xo+G-> x2-100 , parent-> yo+G-> y1 , 1 , 1 , cmenu , 17 ) ) != 17 ) 
junk1.c:          if ( G-> Byte > ( B_min-100 ) ) {
junk1.c:              uiwrite_file ( G , & ( G-> rbuf ) , dc-> reviewfile ) ;
junk1.c:              loc = dc-> cmds;
junk1.c:              ytwtg = ( tw+tg ) / ( dc-> w_x2-dc-> w_x1 ) * ( dc-> w_y2-dc-> w_y1 ) /0.75;
junk1.c:                      if ( count > 1 ) { loc--;count--;
junk1.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk1.c:              xo = xx-x;yo = yy-y;
junk1.c:                      if ( count > 1 ) { loc--;count--;
junk1.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk1.c:              xo = xx-x;yo = yy-y;
junk1.c:              kgBoxFill ( G , xx , yy , x , y , dc-> fil_color , 0 ) ;
junk1.c:              xo = xx-x;yo = yy-y;
junk1.c:                      if ( count > 1 ) { loc--;count--;
junk1.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk1.c:              xo = xx-x;yo = yy-y;
junk1.c:                  loc--;count--;
junk1.c:                  uiupdate_intr ( G , count , dc-> cmds ) ;
junk1.c:              npoly = uipolygon_fill ( G , xpoly , ypoly , dc-> fil_color ) ;
junk1.c:              if ( dc-> A_size > 10 ) A_fac = ( float ) 
junk1.c:                  ( dc-> A_size/10 ) / ( dc-> A_size%10 ) ;
junk1.c:              xo = xx-x;yo = yy-y;
junk1.c:                  kgBoxFill ( G , xx , yy , x , y , dc-> fil_color , 0 ) ;
junk1.c://                           np = (npoly-26)/8;
junk1.c:                          np = ( npoly-14 ) /8;
junk1.c:                          dx = x-xpoly [ 0 ] ;
junk1.c:                          dy = y-ypoly [ 0 ] ;
junk1.c:                          kgPolyFill ( G , np , xpoly , ypoly , 1L , dc-> fil_color ) ;
junk1.c://                           *(loc++) = npoly-12; count++;
junk1.c:                  uiborder ( G , xx , yy , x , y , dc-> bod_width , dc-> bod_color ) ;
junk1.c:                      if ( count != 0 ) { loc--;count--;
junk1.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk1.c:                      uiborder ( G , xx , yy , x , y , dc-> bod_width , dc-> bod_color ) ;
junk1.c:              uiborder ( G , xx , yy , x , y , dc-> bod_width , dc-> bod_color ) ;
junk1.c:              xo = xx-x;yo = yy-y;
junk1.c:              * ( loc ) = uiProcess_arc_fill ( G , & xx , & yy , dc-> fil_color ) ;
junk1.c:                  kgAntialiasingOn ( G , MAG-1 ) ;
junk1.c:              free ( dc-> cmds ) ;
junk1.c:          kgAntialiasingOn ( G , MAG-1 ) ;
junk1.c:      free ( dc-> cmds ) ;
junk1.c:      G-> Byte = lngth;
junk1.c:      D.df = -1;
junk1.c:      -1 , -1 , -1 };
junk1.c:      D.df = -1;
junk1.c:      D.yl = t0.y2 -t0.y1+20+50; /* Width of Dialog */
junk1.c:      H4.x1 = ( D.xl ) /2 -40;
junk1.c:      H4.y1 = ( D.yl ) -40;
junk1.c:      if ( fp == ( ( void * ) 0 ) ) return -1;
junk1.c:      n = Dcount ( fp-> L ) ;
junk1.c:      Resetlink ( fp-> L ) ;
junk1.c:      while ( ( bf = ( char * ) Getrecord ( fp-> L ) ) != NULL ) {M [ i++ ] = bf;}
junk1.c:      M [ n-1 ] = NULL;
junk1.c:      return n-1;
junk1.c:      -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 };
junk1.c:      width = ( H1.y2-H1.y1 ) ;
junk1.c:      H1.y1 = D.yl - ( width ) -4;
junk1.c:      H1.x1 = ( D.xl-width ) *.5;
junk1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk1.c:      G = D-> d [ i ] .g;
junk1.c://  G->D = (void *)getParentDisplay(Tmp);
junk1.c:      G-> D = D;
junk1.c:      Spos = G-> data;
junk1.c:      xp = D-> xl/2;
junk1.c:      yp = D-> yl/2;
junk1.c://  printf("Gbox Pos: %d %d\n",(int)xp,(int)(D->yl-yp));
junk1.c:      Spos-> xp = xp;
junk1.c:      Spos-> yp = ( int ) ( D-> yl-yp ) ;
junk1.c:      G = D-> d [ 0 ] .g;
junk1.c:      xp = D-> xl/2;
junk1.c:      yp = D-> yl/2;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:          -1 , /* bkgr colour */
junk1.c:      D.StackPos = 0; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk1.c:      G = D-> d [ i ] .g;
junk1.c://  G->D = (void *)getParentDisplay(Tmp);
junk1.c:      G-> D = D;
junk1.c:      Srect = G-> data;
junk1.c:      x1 = D-> xl/2;
junk1.c:      y1 = D-> yl/2;
junk1.c://  printf("Gbox Pos: %d %d\n",(int)xp,(int)(D->yl-yp));
junk1.c:      Srect-> x1 = x1;
junk1.c:      Srect-> y1 = ( int ) ( D-> yl-y1 ) ;
junk1.c:      Srect-> x2 = x2;
junk1.c:      Srect-> y2 = ( int ) ( D-> yl-y2 ) ;
junk1.c:      G = D-> d [ 0 ] .g;
junk1.c:      xp = D-> xl/2;
junk1.c:      yp = D-> yl/2;
junk1.c:      if ( kbe-> event == 1 ) {
junk1.c:          if ( kbe-> button == 1 ) {
junk1.c:          -1 , /* bkgr colour */
junk1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk1.c:      count1 = count-1;
junk1.c:      Dang = 315.0/ ( np-1 ) ;
junk1.c:      ri = size*0.5-2*size1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:          x [ count1-i ] = ro*cs;
junk1.c:          y [ count1-i ] = ro*ss;
junk1.c:      x [ np ] = ( ri-dl ) *cs;
junk1.c:      y [ np ] = ( ri-dl ) *ss;
junk1.c:      ang -= ( sign*dang ) ;
junk1.c:      int r , g , b , np = 120 , i , sign = -1;
junk1.c:      count1 = count-1;
junk1.c:      Dang = 315.0/ ( np-1 ) ;
junk1.c:      ri = size*0.5-2*size1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      ang = ( -0.25 ) *3.14159265;
junk1.c:          x [ count1-i ] = ro*cs;
junk1.c:          y [ count1-i ] = ro*ss;
junk1.c:      x [ np ] = ( ri-dl ) *cs;
junk1.c:      y [ np ] = ( ri-dl ) *ss;
junk1.c:      ang -= ( sign*dang ) ;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 0 ] = -size;
junk1.c:      x [ 1 ] = size-size1;
junk1.c:      x [ 2 ] = size-size1;
junk1.c:      x [ 4 ] = size-size1;
junk1.c:      y [ 4 ] = -size1;
junk1.c:      x [ 5 ] = size-size1;
junk1.c:      y [ 5 ] = -size1*0.5;
junk1.c:      x [ 6 ] = -size;
junk1.c:      y [ 6 ] = -size1*0.5;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 1 ] = - ( size-size1 ) ;
junk1.c:      x [ 2 ] = - ( size-size1 ) ;
junk1.c:      x [ 3 ] = - ( size ) ;
junk1.c:      x [ 4 ] = - ( size-size1 ) ;
junk1.c:      y [ 4 ] = -size1;
junk1.c:      x [ 5 ] = - ( size-size1 ) ;
junk1.c:      y [ 5 ] = -size1*0.5;
junk1.c:      y [ 6 ] = -size1*0.5;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 0 ] = -size;
junk1.c:      x [ 1 ] = size-size1;
junk1.c:      x [ 2 ] = size-size1;
junk1.c:      x [ 4 ] = size-size1;
junk1.c:      y [ 4 ] = -size1;
junk1.c:      x [ 5 ] = size-size1;
junk1.c:      y [ 5 ] = -size1*0.5;
junk1.c:      x [ 6 ] = -size;
junk1.c:      y [ 6 ] = -size1*0.5;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 1 ] = - ( size-size1 ) ;
junk1.c:      x [ 2 ] = - ( size-size1 ) ;
junk1.c:      x [ 3 ] = - ( size ) ;
junk1.c:      x [ 4 ] = - ( size-size1 ) ;
junk1.c:      y [ 4 ] = -size1;
junk1.c:      x [ 5 ] = - ( size-size1 ) ;
junk1.c:      y [ 5 ] = -size1*0.5;
junk1.c:      y [ 6 ] = -size1*0.5;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 0 ] = -size;
junk1.c:      x [ 2 ] = -size;
junk1.c:      y [ 2 ] = -size;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 1 ] = -size;
junk1.c:      y [ 2 ] = -size;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 0 ] = -size;
junk1.c:      x [ 2 ] = -size;
junk1.c:      y [ 2 ] = -size;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 1 ] = -size;
junk1.c:      y [ 2 ] = -size;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R*0.75 , +R , +R*1.25 ) ;
junk1.c:      x [ 1 ] = - ( size-size1 ) ;
junk1.c:      x [ 2 ] = - ( size-size1 ) ;
junk1.c:      x [ 3 ] = - ( size ) ;
junk1.c:      x [ 4 ] = - ( size-size1 ) ;
junk1.c:      y [ 4 ] = -size1;
junk1.c:      x [ 5 ] = - ( size-size1 ) ;
junk1.c:      y [ 5 ] = -size1*0.5;
junk1.c:      y [ 6 ] = -size1*0.5;
junk1.c:      x [ 1 ] = ( size-size1 ) ;
junk1.c:      x [ 2 ] = ( size-size1 ) ;
junk1.c:      y [ 2 ] = -size1*0.5;
junk1.c:      y [ 3 ] = -size1*0.5;
junk1.c:      int r , g , b , np = 8 , i , sign = -1;
junk1.c:      count1 = count-1;
junk1.c:      Dang = 90.0/ ( np-1 ) ;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      x [ 0 ] = -size1;
junk1.c:      x [ 1 ] = -dl;
junk1.c:      y [ 4 ] = -dl;
junk1.c:      y [ 5 ] = -size1;
junk1.c:      x [ 6 ] = -dl;
junk1.c:      y [ 6 ] = -size1;
junk1.c:      x [ 7 ] = -size1;
junk1.c:      y [ 7 ] = -dl;
junk1.c:      count1 = count-1;
junk1.c:      Dang = 300.0/ ( np-1 ) ;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      ri = size*0.5-2*size1;
junk1.c:          x [ count1-i ] = ro*cs;
junk1.c:          y [ count1-i ] = ro*ss;
junk1.c:      x [ 0 ] = -size1*0.5;
junk1.c:      x [ 3 ] = -size1*0.5;
junk1.c:      count1 = count-1;
junk1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk1.c:      y [ 0 ] = -size;
junk1.c:      y [ 1 ] = size-size1;
junk1.c:      y [ 2 ] = size-size1;
junk1.c:      x [ 4 ] = -size;
junk1.c:      y [ 4 ] = size-size1;
junk1.c:      x [ 5 ] = -size1*0.85;
junk1.c:      y [ 5 ] = size-size1;
junk1.c:      x [ 6 ] = -size1*0.85;
junk1.c:      y [ 6 ] = -size;
junk1.c:      x [ 7 ] = -size1*0.3;
junk1.c:      y [ 7 ] = -size;
junk1.c:      x [ 8 ] = -size1*0.3;
junk1.c:      y [ 8 ] = size-size1;
junk1.c:      y [ 9 ] = size-size1;
junk1.c:      y [ 10 ] = -size;
junk1.c:      x [ 0 ] = -size*0.8;
junk1.c:      y [ 0 ] = -size;
junk1.c:      x [ 1 ] = -size*0.8;
junk1.c:      y [ 1 ] = size-2.05*size1;
junk1.c:      y [ 2 ] = size-2.05*size1;
junk1.c:      y [ 3 ] = -size;
junk1.c:      img = pt-> thImg;
junk1.c:          pt-> thImg = ( GMIMG * ) uiThumbnailgmImage ( img , pt-> size , pt-> size ) ;
junk1.c:          pt-> thImg-> image_width = img-> image_width;
junk1.c:          pt-> thImg-> image_height = img-> image_height;
junk1.c:          strcpy ( pt-> thImg-> flname , pt-> flname ) ;
junk1.c:      else pt-> thImg = NULL;
junk1.c:                      sprintf ( name , "(%5d,%5d): %s" , img-> image_width , img-> image_height , flnames [ i ] ) ;
junk1.c:                      strcpy ( thImgs [ k ] -> flname , name ) ;
junk1.c:                      if ( ( thImgs [ k ] -> image_width > size ) 
junk1.c:                          || ( thImgs [ k ] -> image_height > size ) ) {
junk1.c:                          printf ( "%s: %d:%d %d:%d\n" , flnames [ i ] , thImgs [ k ] -> image_width , thImgs [ k ] -> image_height , img-> image_width , img-> image_height ) ;
junk1.c:                      thImgs [ k ] -> image_width = img-> image_width;
junk1.c:                      thImgs [ k ] -> image_height = img-> image_height;
junk1.c://         thImgs[k]->bkgrclr=15;
junk1.c:                      strcpy ( thImgs [ k ] -> flname , flnames [ i ] ) ;
junk1.c:          menu [ no-1 ] = NULL;
junk1.c:          for ( i = 0;i < ( no-1 ) ;i++ ) {
junk1.c:              menu [ i ] = img-> flname;
junk1.c:          for ( i = 0;i < ( no-1 ) ;i++ ) {
junk1.c:      if ( tb-> menu != NULL ) free ( tb-> menu ) ;
junk1.c:      if ( tb-> sw != NULL ) free ( tb-> sw ) ;
junk1.c:      if ( tb-> xpms != NULL ) {
junk1.c:          xpms = tb-> xpms;
junk1.c:      tb-> xpms = NULL;
junk1.c:      tb-> menu = NULL;
junk1.c:      tb-> sw = NULL;
junk1.c:          tb [ n-1 ] = NULL;
junk1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
junk1.c:              tb [ i ] -> img = img;
junk1.c:              tb [ i ] -> name = ( char * ) Malloc ( strlen ( img-> flname ) +1 ) ;
junk1.c:              strcpy ( tb [ i ] -> name , img-> flname ) ;
junk1.c:              tb [ i ] -> sw = 0;
junk1.c:              tb [ i ] -> id = i;
junk1.c:              tb [ i ] -> state = 1;
junk1.c:          tb [ n-1 ] = NULL;
junk1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
junk1.c:              tb [ i ] -> img = NULL;
junk1.c:              tb [ i ] -> name = m [ i ] ;
junk1.c:              tb [ i ] -> sw = 0;
junk1.c:              tb [ i ] -> id = i;
junk1.c:              tb [ i ] -> state = 1;
junk1.c:          tb [ n-1 ] = NULL;
junk1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
junk1.c:              tb [ i ] -> img = NULL;
junk1.c:              tb [ i ] -> name = m [ i ] ;
junk1.c:              tb [ i ] -> sw = 0;
junk1.c:              tb [ i ] -> id = i;
junk1.c:              tb [ i ] -> state = 1;
junk1.c:              if ( tb [ i ] -> img != NULL ) uiFreeImage ( tb [ i ] -> img ) ;
junk1.c:              if ( tb [ i ] -> name != NULL ) free ( tb [ i ] -> name ) ;
junk2.c:    56, 57, 58, 59, 60, 61, 62, 63, -1
junk2.c:      1,0.000000 /* button type and roundinfg factor(0-0.5) */
junk2.c:    -1,0,0 /* bkgr colour */
junk2.c:    -1,0,0 /* bkgr colour */
junk2.c:    -1, 
junk2.c:    -1, 
junk2.c:    -1
junk2.c:     6,0.250000 /* button type and roundinfg factor(0-0.5) */
junk2.c:  ioldclr[3]=-5;
junk2.c:  ioldclr[4]=-5;
junk2.c:  ioldclr[5]=-5;
junk2.c:  D.StackPos = 1;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
junk2.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk2.c:              m [ ln+1 ] = m [ size-3 ] ;
junk2.c:              m [ ln+2 ] = m [ size-2 ] ;
junk2.c:              m [ ln+3 ] = m [ size-1 ] ;
junk2.c:              m [ size-3 ] = '.';
junk2.c:              m [ size-2 ] = '.';
junk2.c:              m [ size-1 ] = '.';
junk2.c:          if ( ( m [ size-3 ] == '.' ) && ( m [ size-2 ] == '.' ) && 
junk2.c:              ( m [ size-1 ] == '.' ) ) {
junk2.c:              m [ size-3 ] = m [ ln+1 ] ;
junk2.c:              m [ size-2 ] = m [ ln+2 ] ;
junk2.c:              m [ size-1 ] = m [ ln+3 ] ;
junk2.c:              m [ k ] [ ln+1 ] = m [ k ] [ size-3 ] ;
junk2.c:              m [ k ] [ ln+2 ] = m [ k ] [ size-2 ] ;
junk2.c:              m [ k ] [ ln+3 ] = m [ k ] [ size-1 ] ;
junk2.c:              m [ k ] [ size-3 ] = '.';
junk2.c:              m [ k ] [ size-2 ] = '.';
junk2.c:              m [ k ] [ size-1 ] = '.';
junk2.c:          if ( ( m [ size-3 ] == '.' ) && ( m [ size-2 ] == '.' ) && 
junk2.c:              ( m [ size-1 ] == '.' ) ) {
junk2.c:              m [ size-3 ] = m [ ln+1 ] ;
junk2.c:              m [ size-2 ] = m [ ln+2 ] ;
junk2.c:              m [ size-1 ] = m [ ln+3 ] ;
junk2.c:          m [ size-3 ] = '.';
junk2.c:          m [ size-2 ] = '.';
junk2.c:          m [ size-1 ] = '.';
junk2.c:          if ( pt-> d_name [ 0 ] == '.' ) continue;
junk2.c:          strcat ( buf , pt-> d_name ) ;
junk2.c:              ln = strlen ( pt-> d_name ) ;
junk2.c:              strcpy ( item , pt-> d_name ) ;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk2.c:      e = T-> elmt;
junk2.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk2.c:      dirs-> file = m;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = m;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk2.c:      if ( strcmp ( dirs-> CurDir , "/" ) != 0 ) strcat ( dirs-> CurDir , "/" ) ;
junk2.c:      strcat ( dirs-> CurDir , folder ) ;
junk2.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp ) -> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk2.c:      m = _uiFolderMenu ( dirs-> CurDir ) ;
junk2.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = m;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = dir;
junk2.c:      dirs-> file = file;
junk2.c:      dirs-> dir = dir;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      n = B-> nx;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:          k = strlen ( dirs-> CurDir ) ;
junk2.c:          while ( ( dirs-> CurDir [ k ] != '/' ) && ( k > 1 ) ) 
junk2.c:              {dirs-> CurDir [ k ] = '\0';k--;}
junk2.c:          dirs-> CurDir [ k ] = '\0';
junk2.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp ) -> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk2.c:          m = _uiFolderMenu ( dirs-> CurDir ) ;
junk2.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = m;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = dir;
junk2.c:      dirs-> file = m;
junk2.c:      dirs-> dir = dir;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      dirs = ( ( DIALOG * ) Tmp ) -> pt;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:          strcpy ( dirs-> CurDir , dirs-> HomeDir ) ;
junk2.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp ) -> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk2.c:          m = _uiFolderMenu ( dirs-> CurDir ) ;
junk2.c:      m = _uiFileMenu ( dirs-> CurDir , filter ) ;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = m;
junk2.c:      kgFreeDouble ( ( void ** ) ( E-> menu ) ) ;
junk2.c:      E-> menu = dir;
junk2.c:      dirs-> file = m;
junk2.c:      dirs-> dir = dir;
junk2.c:      dirs = D-> pt;
junk2.c:      I = ( DII * ) ( D-> d [ 1 ] .t ) ;
junk2.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , D-> d [ 1 ] .i-> twin , dirs-> CurDir ) ;
junk2.c:      i--;
junk2.c:          i--;
junk2.c:      -1 , -1 , -1 };
junk2.c:      -1 , -1 };
junk2.c:      -1 , -1 };
junk2.c:      if ( getcwd ( Dir.HomeDir , 499 ) == NULL ) return -1;
junk2.c:          if ( pt-> d_name [ 0 ] == '.' ) continue;
junk2.c:     type = stat(pt->d_name,&st);
junk2.c:          strcat ( buf , pt-> d_name ) ;
junk2.c:              sprintf ( buf , "%-s" , pt-> d_name ) ;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      m = ( char ** ) ( ( DIALOG * ) Tmp ) -> pt;
junk2.c:      e = T-> elmt;
junk2.c:      kgFreeDouble ( ( void ** ) E-> menu ) ;
junk2.c:      E-> menu = m;
junk2.c:       ( ( DIALOG * ) Tmp ) -> pt = m;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      n = B-> nx;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      -1 , -1 , -1 };
junk2.c:      D.df = -1;
junk2.c:      -1 , -1 };
junk2.c:      D.df = -1;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      e = T-> elmt;
junk2.c:      pt = ( void ** ) D-> pt;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      e = T-> elmt;
junk2.c:      pt = ( void ** ) D-> pt;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      e = T-> elmt;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      e = T-> elmt;
junk2.c:      pt = ( void ** ) D-> pt;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:      pt = ( void ** ) D-> pt;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      e = T-> elmt;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      n = B-> nx*B-> ny;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      D = ( ( DIALOG * ) Tmp ) -> d;
junk2.c:      n = B-> nx;
junk2.c:      if ( kbe-> event == 1 ) {
junk2.c:          if ( kbe-> button == 1 ) {
junk2.c:      -1 , -1 };
junk2.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk2.c:      -1 , -1 };
junk2.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk2.c:      -1 , -1 };
junk2.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk2.c:      -1 , -1 };
junk2.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk2.c:      -1 , -1 };
junk2.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk2.c:      -1 , -1 };
junk2.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
junk2.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk2.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk2.c:      dc = G-> dc;
junk2.c:      v0 = dc-> ln_color;
junk2.c:      v2 = dc-> fil_color;
junk2.c:      v4 = dc-> t_color;
junk2.c:      v12 = dc-> m_style+1;
junk2.c:      v13 = dc-> trot/10+1;
junk2.c:      v8 = dc-> t_font;
junk2.c:      v10 = dc-> ln_style+1;
junk2.c:      v11 = dc-> ln_width;
junk2.c:      v5 = dc-> bod_color;
junk2.c:      LnStyle = v10-1;
junk2.c:      MarkType = v12-1;
junk2.c:      TextAngle = ( v13-1 ) *10;
junk2.c:      dc-> trot = TextAngle;
junk2.c:      dc-> fil_color = v2;
junk2.c:      dc-> t_color = v4;
junk2.c:      dc-> t_font = v8;
junk2.c:      dc-> ln_color = v0;
junk2.c:      dc-> ln_style = LnStyle;
junk2.c:      dc-> m_style = MarkType;
junk2.c:      dc-> ln_width = LnWidth;
junk2.c:      dc-> bod_color = v5;
junk2.c:      kgLineColor ( G , dc-> ln_color ) ;
junk2.c:      kgTextAngle ( G , dc-> trot ) ;
junk2.c:      kgTextFont ( G , dc-> t_font ) ;
junk2.c:      kgMarkerType ( G , dc-> m_style ) ;
junk2.c:      kgLineWidth ( G , dc-> ln_width ) ;
junk2.c:      kgTextColor ( G , dc-> t_color ) ;
junk2.c:      D.df = -1;
junk2.c:      -1 , -1 };
junk2.c:      D.df = -1;
junk2.c:      dc = G-> dc;
junk2.c:      dc-> A_size = size;
junk2.c:      dc = G-> dc;
junk2.c:      dc-> cmds = ( unsigned int * ) Malloc ( sizeof ( int ) *1000L ) ;
junk2.c:      if ( dc-> cmds == NULL ) {
junk2.c:      parent = G-> D;
junk2.c:      if ( dc-> A_size > 10 ) A_fac = ( float ) 
junk2.c:          ( dc-> A_size/10 ) / ( dc-> A_size%10 ) ;
junk2.c:      tww = ( dc-> w_x2-dc-> w_x1 ) /30.0;
junk2.c:      thh = ( dc-> w_y2-dc-> w_y1 ) /25.0;
junk2.c:      x = dc-> w_x1+ ( dc-> w_x2-dc-> w_x1 ) *0.5;
junk2.c:      y = dc-> w_y1+ ( dc-> w_y2-dc-> w_y1 ) *0.5;
junk2.c:      uiwrite_file ( G , & ( G-> rbuf ) , dc-> reviewfile ) ;
junk2.c:      loc = dc-> cmds;
junk2.c:      if ( G-> D_ON == 0 ) {
junk2.c:          MAG = G-> MAG;
junk2.c:      ytwtg = ( tw+tg ) / ( dc-> w_x2-dc-> w_x1 ) * ( dc-> w_y2-dc-> w_y1 ) /0.75;
junk2.c://      while((item=uiMenu(G->D,G->x1,G->y1,1,1,cmenu,17))!=17)
junk2.c:      while ( ( item = kgMenu ( G-> D , parent-> xo+G-> x2-100 , parent-> yo+G-> y1 , 1 , 1 , cmenu , 17 ) ) != 17 ) 
junk2.c:          if ( G-> Byte > ( B_min-100 ) ) {
junk2.c:              uiwrite_file ( G , & ( G-> rbuf ) , dc-> reviewfile ) ;
junk2.c:              loc = dc-> cmds;
junk2.c:              ytwtg = ( tw+tg ) / ( dc-> w_x2-dc-> w_x1 ) * ( dc-> w_y2-dc-> w_y1 ) /0.75;
junk2.c:                      if ( count > 1 ) { loc--;count--;
junk2.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk2.c:              xo = xx-x;yo = yy-y;
junk2.c:                      if ( count > 1 ) { loc--;count--;
junk2.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk2.c:              xo = xx-x;yo = yy-y;
junk2.c:              kgBoxFill ( G , xx , yy , x , y , dc-> fil_color , 0 ) ;
junk2.c:              xo = xx-x;yo = yy-y;
junk2.c:                      if ( count > 1 ) { loc--;count--;
junk2.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk2.c:              xo = xx-x;yo = yy-y;
junk2.c:                  loc--;count--;
junk2.c:                  uiupdate_intr ( G , count , dc-> cmds ) ;
junk2.c:              npoly = uipolygon_fill ( G , xpoly , ypoly , dc-> fil_color ) ;
junk2.c:              if ( dc-> A_size > 10 ) A_fac = ( float ) 
junk2.c:                  ( dc-> A_size/10 ) / ( dc-> A_size%10 ) ;
junk2.c:              xo = xx-x;yo = yy-y;
junk2.c:                  kgBoxFill ( G , xx , yy , x , y , dc-> fil_color , 0 ) ;
junk2.c://                           np = (npoly-26)/8;
junk2.c:                          np = ( npoly-14 ) /8;
junk2.c:                          dx = x-xpoly [ 0 ] ;
junk2.c:                          dy = y-ypoly [ 0 ] ;
junk2.c:                          kgPolyFill ( G , np , xpoly , ypoly , 1L , dc-> fil_color ) ;
junk2.c://                           *(loc++) = npoly-12; count++;
junk2.c:                  uiborder ( G , xx , yy , x , y , dc-> bod_width , dc-> bod_color ) ;
junk2.c:                      if ( count != 0 ) { loc--;count--;
junk2.c:                          uiupdate_intr ( G , count , dc-> cmds ) ;
junk2.c:                      uiborder ( G , xx , yy , x , y , dc-> bod_width , dc-> bod_color ) ;
junk2.c:              uiborder ( G , xx , yy , x , y , dc-> bod_width , dc-> bod_color ) ;
junk2.c:              xo = xx-x;yo = yy-y;
junk2.c:              * ( loc ) = uiProcess_arc_fill ( G , & xx , & yy , dc-> fil_color ) ;
junk2.c:                  kgAntialiasingOn ( G , MAG-1 ) ;
junk2.c:              free ( dc-> cmds ) ;
junk2.c:          kgAntialiasingOn ( G , MAG-1 ) ;
junk2.c:      free ( dc-> cmds ) ;
junk2.c:      G-> Byte = lngth;
junk2.c:      D.df = -1;
junk2.c:      -1 , -1 , -1 };
junk2.c:      D.df = -1;
junk2.c:      D.yl = t0.y2 -t0.y1+20+50; /* Width of Dialog */
junk2.c:      H4.x1 = ( D.xl ) /2 -40;
junk2.c:      H4.y1 = ( D.yl ) -40;
junk2.c:      if ( fp == ( ( void * ) 0 ) ) return -1;
junk2.c:      n = Dcount ( fp-> L ) ;
junk2.c:      Resetlink ( fp-> L ) ;
junk2.c:      while ( ( bf = ( char * ) Getrecord ( fp-> L ) ) != NULL ) {M [ i++ ] = bf;}
junk2.c:      M [ n-1 ] = NULL;
junk2.c:      return n-1;
junk2.c:      -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 };
junk2.c:      width = ( H1.y2-H1.y1 ) ;
junk2.c:      H1.y1 = D.yl - ( width ) -4;
junk2.c:      H1.x1 = ( D.xl-width ) *.5;
junk2.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
junk2.c:      G = D-> d [ i ] .g;
junk2.c://  G->D = (void *)getParentDisplay(Tmp);
junk2.c:      G-> D = D;
junk2.c:      Spos = G-> data;
junk2.c:      xp = D-> xl/2;
junk2.c:      yp = D-> yl/2;
junk2.c://  printf("Gbox Pos: %d %d\n",(int)xp,(int)(D->yl-yp));
junk2.c:      Spos-> xp = xp;
junk2.c:      Spos-> yp = ( int ) ( D-> yl-yp ) ;
junk2.c:      G = D-> d [ 0 ] .g;
junk2.c:      xp = D-> xl/2;
junk2.c:      yp = D-> yl/2;
junk2.c:      if ( kbe-> event == 1 ) {
junk2.c:          if ( kbe-> button == 1 ) {
junk2.c:          -1 , /* bkgr colour */
junk2.c:      D.StackPos = 0; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk2.c:      G = D-> d [ i ] .g;
junk2.c://  G->D = (void *)getParentDisplay(Tmp);
junk2.c:      G-> D = D;
junk2.c:      Srect = G-> data;
junk2.c:      x1 = D-> xl/2;
junk2.c:      y1 = D-> yl/2;
junk2.c://  printf("Gbox Pos: %d %d\n",(int)xp,(int)(D->yl-yp));
junk2.c:      Srect-> x1 = x1;
junk2.c:      Srect-> y1 = ( int ) ( D-> yl-y1 ) ;
junk2.c:      Srect-> x2 = x2;
junk2.c:      Srect-> y2 = ( int ) ( D-> yl-y2 ) ;
junk2.c:      G = D-> d [ 0 ] .g;
junk2.c:      xp = D-> xl/2;
junk2.c:      yp = D-> yl/2;
junk2.c:      if ( kbe-> event == 1 ) {
junk2.c:          if ( kbe-> button == 1 ) {
junk2.c:          -1 , /* bkgr colour */
junk2.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
junk2.c:      count1 = count-1;
junk2.c:      Dang = 315.0/ ( np-1 ) ;
junk2.c:      ri = size*0.5-2*size1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:          x [ count1-i ] = ro*cs;
junk2.c:          y [ count1-i ] = ro*ss;
junk2.c:      x [ np ] = ( ri-dl ) *cs;
junk2.c:      y [ np ] = ( ri-dl ) *ss;
junk2.c:      ang -= ( sign*dang ) ;
junk2.c:      int r , g , b , np = 120 , i , sign = -1;
junk2.c:      count1 = count-1;
junk2.c:      Dang = 315.0/ ( np-1 ) ;
junk2.c:      ri = size*0.5-2*size1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      ang = ( -0.25 ) *3.14159265;
junk2.c:          x [ count1-i ] = ro*cs;
junk2.c:          y [ count1-i ] = ro*ss;
junk2.c:      x [ np ] = ( ri-dl ) *cs;
junk2.c:      y [ np ] = ( ri-dl ) *ss;
junk2.c:      ang -= ( sign*dang ) ;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 0 ] = -size;
junk2.c:      x [ 1 ] = size-size1;
junk2.c:      x [ 2 ] = size-size1;
junk2.c:      x [ 4 ] = size-size1;
junk2.c:      y [ 4 ] = -size1;
junk2.c:      x [ 5 ] = size-size1;
junk2.c:      y [ 5 ] = -size1*0.5;
junk2.c:      x [ 6 ] = -size;
junk2.c:      y [ 6 ] = -size1*0.5;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 1 ] = - ( size-size1 ) ;
junk2.c:      x [ 2 ] = - ( size-size1 ) ;
junk2.c:      x [ 3 ] = - ( size ) ;
junk2.c:      x [ 4 ] = - ( size-size1 ) ;
junk2.c:      y [ 4 ] = -size1;
junk2.c:      x [ 5 ] = - ( size-size1 ) ;
junk2.c:      y [ 5 ] = -size1*0.5;
junk2.c:      y [ 6 ] = -size1*0.5;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 0 ] = -size;
junk2.c:      x [ 1 ] = size-size1;
junk2.c:      x [ 2 ] = size-size1;
junk2.c:      x [ 4 ] = size-size1;
junk2.c:      y [ 4 ] = -size1;
junk2.c:      x [ 5 ] = size-size1;
junk2.c:      y [ 5 ] = -size1*0.5;
junk2.c:      x [ 6 ] = -size;
junk2.c:      y [ 6 ] = -size1*0.5;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 1 ] = - ( size-size1 ) ;
junk2.c:      x [ 2 ] = - ( size-size1 ) ;
junk2.c:      x [ 3 ] = - ( size ) ;
junk2.c:      x [ 4 ] = - ( size-size1 ) ;
junk2.c:      y [ 4 ] = -size1;
junk2.c:      x [ 5 ] = - ( size-size1 ) ;
junk2.c:      y [ 5 ] = -size1*0.5;
junk2.c:      y [ 6 ] = -size1*0.5;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 0 ] = -size;
junk2.c:      x [ 2 ] = -size;
junk2.c:      y [ 2 ] = -size;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 1 ] = -size;
junk2.c:      y [ 2 ] = -size;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 0 ] = -size;
junk2.c:      x [ 2 ] = -size;
junk2.c:      y [ 2 ] = -size;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 1 ] = -size;
junk2.c:      y [ 2 ] = -size;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R*0.75 , +R , +R*1.25 ) ;
junk2.c:      x [ 1 ] = - ( size-size1 ) ;
junk2.c:      x [ 2 ] = - ( size-size1 ) ;
junk2.c:      x [ 3 ] = - ( size ) ;
junk2.c:      x [ 4 ] = - ( size-size1 ) ;
junk2.c:      y [ 4 ] = -size1;
junk2.c:      x [ 5 ] = - ( size-size1 ) ;
junk2.c:      y [ 5 ] = -size1*0.5;
junk2.c:      y [ 6 ] = -size1*0.5;
junk2.c:      x [ 1 ] = ( size-size1 ) ;
junk2.c:      x [ 2 ] = ( size-size1 ) ;
junk2.c:      y [ 2 ] = -size1*0.5;
junk2.c:      y [ 3 ] = -size1*0.5;
junk2.c:      int r , g , b , np = 8 , i , sign = -1;
junk2.c:      count1 = count-1;
junk2.c:      Dang = 90.0/ ( np-1 ) ;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      x [ 0 ] = -size1;
junk2.c:      x [ 1 ] = -dl;
junk2.c:      y [ 4 ] = -dl;
junk2.c:      y [ 5 ] = -size1;
junk2.c:      x [ 6 ] = -dl;
junk2.c:      y [ 6 ] = -size1;
junk2.c:      x [ 7 ] = -size1;
junk2.c:      y [ 7 ] = -dl;
junk2.c:      count1 = count-1;
junk2.c:      Dang = 300.0/ ( np-1 ) ;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      ri = size*0.5-2*size1;
junk2.c:          x [ count1-i ] = ro*cs;
junk2.c:          y [ count1-i ] = ro*ss;
junk2.c:      x [ 0 ] = -size1*0.5;
junk2.c:      x [ 3 ] = -size1*0.5;
junk2.c:      count1 = count-1;
junk2.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
junk2.c:      y [ 0 ] = -size;
junk2.c:      y [ 1 ] = size-size1;
junk2.c:      y [ 2 ] = size-size1;
junk2.c:      x [ 4 ] = -size;
junk2.c:      y [ 4 ] = size-size1;
junk2.c:      x [ 5 ] = -size1*0.85;
junk2.c:      y [ 5 ] = size-size1;
junk2.c:      x [ 6 ] = -size1*0.85;
junk2.c:      y [ 6 ] = -size;
junk2.c:      x [ 7 ] = -size1*0.3;
junk2.c:      y [ 7 ] = -size;
junk2.c:      x [ 8 ] = -size1*0.3;
junk2.c:      y [ 8 ] = size-size1;
junk2.c:      y [ 9 ] = size-size1;
junk2.c:      y [ 10 ] = -size;
junk2.c:      x [ 0 ] = -size*0.8;
junk2.c:      y [ 0 ] = -size;
junk2.c:      x [ 1 ] = -size*0.8;
junk2.c:      y [ 1 ] = size-2.05*size1;
junk2.c:      y [ 2 ] = size-2.05*size1;
junk2.c:      y [ 3 ] = -size;
junk2.c:      img = pt-> thImg;
junk2.c:          pt-> thImg = ( GMIMG * ) uiThumbnailgmImage ( img , pt-> size , pt-> size ) ;
junk2.c:          pt-> thImg-> image_width = img-> image_width;
junk2.c:          pt-> thImg-> image_height = img-> image_height;
junk2.c:          strcpy ( pt-> thImg-> flname , pt-> flname ) ;
junk2.c:      else pt-> thImg = NULL;
junk2.c:                      sprintf ( name , "(%5d,%5d): %s" , img-> image_width , img-> image_height , flnames [ i ] ) ;
junk2.c:                      strcpy ( thImgs [ k ] -> flname , name ) ;
junk2.c:                      if ( ( thImgs [ k ] -> image_width > size ) 
junk2.c:                          || ( thImgs [ k ] -> image_height > size ) ) {
junk2.c:                          printf ( "%s: %d:%d %d:%d\n" , flnames [ i ] , thImgs [ k ] -> image_width , thImgs [ k ] -> image_height , img-> image_width , img-> image_height ) ;
junk2.c:                      thImgs [ k ] -> image_width = img-> image_width;
junk2.c:                      thImgs [ k ] -> image_height = img-> image_height;
junk2.c://         thImgs[k]->bkgrclr=15;
junk2.c:                      strcpy ( thImgs [ k ] -> flname , flnames [ i ] ) ;
junk2.c:          menu [ no-1 ] = NULL;
junk2.c:          for ( i = 0;i < ( no-1 ) ;i++ ) {
junk2.c:              menu [ i ] = img-> flname;
junk2.c:          for ( i = 0;i < ( no-1 ) ;i++ ) {
junk2.c:      if ( tb-> menu != NULL ) free ( tb-> menu ) ;
junk2.c:      if ( tb-> sw != NULL ) free ( tb-> sw ) ;
junk2.c:      if ( tb-> xpms != NULL ) {
junk2.c:          xpms = tb-> xpms;
junk2.c:      tb-> xpms = NULL;
junk2.c:      tb-> menu = NULL;
junk2.c:      tb-> sw = NULL;
junk2.c:          tb [ n-1 ] = NULL;
junk2.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
junk2.c:              tb [ i ] -> img = img;
junk2.c:              tb [ i ] -> name = ( char * ) Malloc ( strlen ( img-> flname ) +1 ) ;
junk2.c:              strcpy ( tb [ i ] -> name , img-> flname ) ;
junk2.c:              tb [ i ] -> sw = 0;
junk2.c:              tb [ i ] -> id = i;
junk2.c:              tb [ i ] -> state = 1;
junk2.c:          tb [ n-1 ] = NULL;
junk2.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
junk2.c:              tb [ i ] -> img = NULL;
junk2.c:              tb [ i ] -> name = m [ i ] ;
junk2.c:              tb [ i ] -> sw = 0;
junk2.c:              tb [ i ] -> id = i;
junk2.c:              tb [ i ] -> state = 1;
junk2.c:          tb [ n-1 ] = NULL;
junk2.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
junk2.c:              tb [ i ] -> img = NULL;
junk2.c:              tb [ i ] -> name = m [ i ] ;
junk2.c:              tb [ i ] -> sw = 0;
junk2.c:              tb [ i ] -> id = i;
junk2.c:              tb [ i ] -> state = 1;
junk2.c:              if ( tb [ i ] -> img != NULL ) uiFreeImage ( tb [ i ] -> img ) ;
junk2.c:              if ( tb [ i ] -> name != NULL ) free ( tb [ i ] -> name ) ;
keybrd.c:int ButClr=-1;
keybrd.c:  sprintf(BUFF,"!z%-s!f%2.2d!c%2.2d%-s",Sfac,Bfont,Bclr,str);
keybrd.c:   kgUserFrame(fid,-2.,-2.,(float)xl+2,(float)yl+2);
keybrd.c:   gc->FontSize =8;
keybrd.c:   gc->Font=23;
keybrd.c:   gc->ButtonFont=24;
keybrd.c:   gc->ButtonFont=16;
keybrd.c:   gc->bodr_clr= 33;
keybrd.c:  p0.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b1.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b2.item = -1;
keybrd.c:  Procpy(butn3[24].title,(char *)"-");
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b3.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b4.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b5.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b6.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b7.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b8.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b9.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b10.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b11.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b12.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b13.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b14.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b15.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b16.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b17.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b18.item = -1;
keybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd.c:  b19.item = -1;
keybrd.c:    -1, /* bkgr colour */ 
keybrd.c:  p20.item = -1;
keybrd.c:    -3, /* bkgr colour */ 
keybrd.c:  p21.item = -1;
keybrd.c:  dtmp = D->d;
keybrd.c:  d[0].p->item = -1;
keybrd.c:  d[1].N->item = -1;
keybrd.c:  d[2].N->item = -1;
keybrd.c:  d[3].N->item = -1;
keybrd.c:  d[4].N->item = -1;
keybrd.c:  d[5].N->item = -1;
keybrd.c:  d[6].N->item = -1;
keybrd.c:  d[7].N->item = -1;
keybrd.c:  d[8].N->item = -1;
keybrd.c:  d[9].N->item = -1;
keybrd.c:  d[10].N->item = -1;
keybrd.c:  d[11].N->item = -1;
keybrd.c:  d[12].N->item = -1;
keybrd.c:  d[13].N->item = -1;
keybrd.c:  d[14].N->item = -1;
keybrd.c:  d[15].N->item = -1;
keybrd.c:  d[16].N->item = -1;
keybrd.c:  d[17].N->item = -1;
keybrd.c:  d[18].N->item = -1;
keybrd.c:  d[19].N->item = -1;
keybrd.c:  d[20].p->item = -1;
keybrd.c:  d[21].p->item = -1;
keybrd.c:  D->d = dtmp;
keybrd.c:     clr = -clr;
keybrd.c:   d = (DIA *)(D->d);
keybrd.c:     if(xm > (d[i].t->x1) ) xm = d[i].t->x1;
keybrd.c:     if(ym > (d[i].t->y1) ) ym = d[i].t->y1;
keybrd.c://   kgShiftGrp(D,GrpId,xo-43,yo-28);
keybrd.c:   kgShiftGrp(D,Kbrd->GrpId,xo-xm,yo-ym);
keybrd.c:   d = D->d;
keybrd.c:   Kbrd->sgrp = kgOpenGrp(D);
keybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[0+offset].t);
keybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[5+offset].t);
keybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[6+offset].t);
keybrd.c:   Kbrd->offgrp = kgOpenGrp(D);
keybrd.c:   kgAddtoGrp(D,Kbrd->offgrp,d[7+offset].t);
keybrd.c:   kgAddtoGrp(D,Kbrd->offgrp,d[19+offset].t);
keybrd.c:   Kbrd->cgrp = kgOpenGrp(D);
keybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[16+offset].t);
keybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[15+offset].t);
keybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[17+offset].t);
keybrd.c:   Kbrd->ongrp = kgOpenGrp(D);
keybrd.c:   kgAddtoGrp(D,Kbrd->ongrp,d[18+offset].t);
keybrd.c:   kgAddtoGrp(D,Kbrd->ongrp,d[20+offset].t);
keybrd.c:   kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd.c:   kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd.c:   Kbrd->Coff = d[7+offset].t;
keybrd.c:   Kbrd->Con = d[18+offset].t;
keybrd.c:   Kbrd->Loff = d[19+offset].t;
keybrd.c:   Kbrd->Lon = d[20+offset].t;
keybrd.c:   Kbrd->CurWid = -1;
keybrd.c:   Kbrd->Vis = Vis;
keybrd.c:   Kbrd->D = D;
keybrd.c:   Kbrd->ShiftPress=0;
keybrd.c:   Kbrd->CapsLock=0;
keybrd.c:    kgSetGrpVisibility(D,Kbrd->GrpId,0);
keybrd.c:   D->Kbrd = (void *) malloc(sizeof(KEYBRD));
keybrd.c:   Kbrd = D->Kbrd;
keybrd.c:   Kbrd->TargetWindow = NULL;
keybrd.c:   Kbrd->kbtype=3;
keybrd.c:   gc = D->gc;
keybrd.c:   Kbrd->Btype=Btype;
keybrd.c:   Kbrd->Rfac = rfac;
keybrd.c:   Kbrd->Bclr = Bclr;
keybrd.c:   Kbrd->FillClr= FillClr;
keybrd.c:   Kbrd->ButClr= ButClr;
keybrd.c:   dtmp = D->d;
keybrd.c:   Gpt->arg= v; // kulina will double free this; you may modify
keybrd.c:   Kbrd->GrpId = GrpId;
keybrd.c:   D->Kbrd = (void *) malloc(sizeof(KEYBRD));
keybrd.c:   Kbrd = D->Kbrd;
keybrd.c:   Kbrd->TargetWindow = NULL;
keybrd.c:   Kbrd->kbtype=3;
keybrd.c:   gc = D->gc;
keybrd.c:   Kbrd->Btype=Btype;
keybrd.c:   Kbrd->Bclr = Bclr;
keybrd.c:   Kbrd->FillClr= FillClr;
keybrd.c:   Kbrd->ButClr= ButClr;
keybrd.c:   dtmp = D->d;
keybrd.c:   kgShiftGrp(D,GrpId,xo-6,yo);
keybrd.c:   Gpt->arg= v; // kulina will double free this; you may modify
keybrd.c:   Kbrd->GrpId = GrpId;
keybrd.c:   Kbrd = D->Kbrd;
keybrd.c:   if(Kbrd->Vis) return 0;
keybrd.c://   D= Kbrd->D;
keybrd.c:   if(Kbrd->kbtype ==3) {
keybrd.c:     kgSetGrpVisibility(D,Kbrd->GrpId,1);
keybrd.c:     kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd.c:     kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd.c:     kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd.c:     kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd.c:     if(D->wc != NULL) {
keybrd.c:       kgUpdateGrp(D,Kbrd->GrpId);
keybrd.c:       kgUpdateGrp(D,Kbrd->sgrp);
keybrd.c:       kgUpdateGrp(D,Kbrd->offgrp);
keybrd.c:   Kbrd->ShiftPress=0;
keybrd.c:   Kbrd->CapsLock=0;
keybrd.c:   Kbrd->Vis = 1;
keybrd.c:   return Kbrd->GrpId;
keybrd.c:   Kbrd = (KEYBRD *)D->Kbrd;
keybrd.c:   if(Kbrd->Vis) return 0;
keybrd.c:    kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd.c:    kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd.c:    kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd.c:    kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd.c:    kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd.c:    kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd.c:    kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd.c:   Kbrd->ShiftPress=0;
keybrd.c:   Kbrd->CapsLock=0;
keybrd.c:   if(D->wc != NULL) {
keybrd.c:     kgUpdateGrp(D,Kbrd->grp1);
keybrd.c:     kgUpdateGrp(D,Kbrd->grp3);
keybrd.c:     kgUpdateGrp(D,Kbrd->sgrp);
keybrd.c:     kgUpdateGrp(D,Kbrd->offgrp);
keybrd.c:   Kbrd->Vis = 1;
keybrd.c:   return Kbrd->GrpId;
keybrd.c:   Kbrd = D->Kbrd;
keybrd.c:   if(Kbrd->Vis) return 0;
keybrd.c:   switch(Kbrd->kbtype) {
keybrd.c:   Kbrd->Vis =1;
keybrd.c:   return Kbrd->GrpId;
keybrd.c:   Kbrd = D->Kbrd;
keybrd.c:   if(Kbrd->Vis==0) return 0;
keybrd.c:   kgSetGrpVisibility(D,Kbrd->GrpId,0);
keybrd.c:   if(D->wc != NULL) {
keybrd.c:     kgUpdateGrp(D,Kbrd->GrpId);
keybrd.c:   Kbrd->ShiftPress=0;
keybrd.c:   Kbrd->CapsLock=0;
keybrd.c:   Kbrd->Vis = 0;
keybrd.c:   return Kbrd->GrpId;
keybrd.c:  Kbrd->sgrp = kgOpenGrp(&D);
keybrd.c:  kgAddtoGrp(&D,Kbrd->sgrp,d[0+offset].t);
keybrd.c:  kgAddtoGrp(&D,Kbrd->sgrp,d[5+offset].t);
keybrd.c:  kgAddtoGrp(&D,Kbrd->sgrp,d[6+offset].t);
keybrd.c:  Kbrd->cgrp = kgOpenGrp(&D);
keybrd.c:  kgAddtoGrp(&D,Kbrd->cgrp,d[16+offset].t);
keybrd.c:  kgAddtoGrp(&D,Kbrd->cgrp,d[15+offset].t);
keybrd.c:  kgAddtoGrp(&D,Kbrd->cgrp,d[17+offset].t);
keybrd.c:  kgSetGrpVisibility(&D,Kbrd->cgrp,0);
keybrd.c:  Kbrd->Coff = d[7+offset].t;
keybrd.c:  Kbrd->Con = d[18+offset].t;
keybrd.c:  Kbrd->Loff = d[19+offset].t;
keybrd.c:  Kbrd->Lon = d[20+offset].t;
keybrd.c:  kgSetWidgetVisibility(Kbrd->Loff,1);
keybrd.c:  kgSetWidgetVisibility(Kbrd->Coff,1);
keybrd.c:  kgSetWidgetVisibility(Kbrd->Lon,0);
keybrd.c:  kgSetWidgetVisibility(Kbrd->Con,0);
keybrd.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
keybrd.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
keybrd0.c:static int ButClr=-1;
keybrd0.c:   Kbrd = D->Kbrd;
keybrd0.c:   if(Kbrd->Vis) return 0;
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd0.c:   kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd0.c:   Kbrd->ShiftPress=0;
keybrd0.c:   Kbrd->CapsLock=0;
keybrd0.c:   if(D->wc != NULL) {
keybrd0.c:     kgUpdateGrp(D,Kbrd->grp3);
keybrd0.c:     kgUpdateGrp(D,Kbrd->sgrp);
keybrd0.c:     kgUpdateGrp(D,Kbrd->offgrp);
keybrd0.c:     kgUpdateGrp(D,Kbrd->grp1);
keybrd0.c:   Kbrd->Vis = 1;
keybrd0.c:   return Kbrd->GrpId;
keybrd0.c:   gc->FontSize =8;
keybrd0.c:   gc->Font=23;
keybrd0.c:  kgGetDefaultRGB(Kbrd->FillClr,&Red,&Green,&Blue);
keybrd0.c:    -1, /* bkgr colour */ 
keybrd0.c:  p0.item = -1;
keybrd0.c:  butn1[0].bkgr=-1;
keybrd0.c:  butn1[1].bkgr=-1;
keybrd0.c:  butn1[2].bkgr=-1;
keybrd0.c:  butn1[3].bkgr=-1;
keybrd0.c:  butn1[4].bkgr=-1;
keybrd0.c:  butn1[5].bkgr=-1;
keybrd0.c:  butn1[6].bkgr=-1;
keybrd0.c:  butn1[7].bkgr=-1;
keybrd0.c:  butn1[8].bkgr=-1;
keybrd0.c:  butn1[9].bkgr=-1;
keybrd0.c:  butn1[10].bkgr=-1;
keybrd0.c:  butn1[11].bkgr=-1;
keybrd0.c:  butn1[12].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b1.item = -1;
keybrd0.c:  butn2[0].bkgr=-1;
keybrd0.c:  butn2[1].bkgr=-1;
keybrd0.c:  butn2[2].bkgr=-1;
keybrd0.c:  butn2[3].bkgr=-1;
keybrd0.c:  butn2[4].bkgr=-1;
keybrd0.c:  butn2[5].bkgr=-1;
keybrd0.c:  butn2[6].bkgr=-1;
keybrd0.c:  butn2[7].bkgr=-1;
keybrd0.c:  butn2[8].bkgr=-1;
keybrd0.c:  butn2[9].bkgr=-1;
keybrd0.c:  butn2[10].bkgr=-1;
keybrd0.c:  butn2[11].bkgr=-1;
keybrd0.c:  butn2[12].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b2.item = -1;
keybrd0.c:  butn3[0].bkgr=-1;
keybrd0.c:  butn3[1].bkgr=-1;
keybrd0.c:  butn3[2].bkgr=-1;
keybrd0.c:  butn3[3].bkgr=-1;
keybrd0.c:  butn3[4].bkgr=-1;
keybrd0.c:  butn3[5].bkgr=-1;
keybrd0.c:  butn3[6].bkgr=-1;
keybrd0.c:  butn3[7].bkgr=-1;
keybrd0.c:  butn3[8].bkgr=-1;
keybrd0.c:  butn3[9].bkgr=-1;
keybrd0.c:  butn3[10].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b3.item = -1;
keybrd0.c:  butn4[0].bkgr=-1;
keybrd0.c:  butn4[1].bkgr=-1;
keybrd0.c:  butn4[2].bkgr=-1;
keybrd0.c:  butn4[3].bkgr=-1;
keybrd0.c:  butn4[4].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b4.item = -1;
keybrd0.c:  butn5[0].bkgr=-1;
keybrd0.c:  butn5[1].bkgr=-1;
keybrd0.c:  butn5[2].bkgr=-1;
keybrd0.c:  butn5[3].bkgr=-1;
keybrd0.c:  butn5[4].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b5.item = -1;
keybrd0.c:  butn6[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b6.item = -1;
keybrd0.c:  butn7[0].bkgr=-1;
keybrd0.c:  butn7[1].bkgr=-1;
keybrd0.c:  butn7[2].bkgr=-1;
keybrd0.c:  butn7[3].bkgr=-1;
keybrd0.c:  butn7[4].bkgr=-1;
keybrd0.c:  butn7[5].bkgr=-1;
keybrd0.c:  butn7[6].bkgr=-1;
keybrd0.c:  butn7[7].bkgr=-1;
keybrd0.c:  butn7[8].bkgr=-1;
keybrd0.c:  butn7[9].bkgr=-1;
keybrd0.c:  butn7[10].bkgr=-1;
keybrd0.c:  butn7[11].bkgr=-1;
keybrd0.c:  butn7[12].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b7.item = -1;
keybrd0.c:  butn8[0].bkgr=-1;
keybrd0.c:  butn8[1].bkgr=-1;
keybrd0.c:  butn8[2].bkgr=-1;
keybrd0.c:  butn8[3].bkgr=-1;
keybrd0.c:  butn8[4].bkgr=-1;
keybrd0.c:  butn8[5].bkgr=-1;
keybrd0.c:  butn8[6].bkgr=-1;
keybrd0.c:  butn8[7].bkgr=-1;
keybrd0.c:  butn8[8].bkgr=-1;
keybrd0.c:  butn8[9].bkgr=-1;
keybrd0.c:  butn8[10].bkgr=-1;
keybrd0.c:  butn8[11].bkgr=-1;
keybrd0.c:  butn8[12].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b8.item = -1;
keybrd0.c:  butn9[0].bkgr=-1;
keybrd0.c:  butn9[1].bkgr=-1;
keybrd0.c:  butn9[2].bkgr=-1;
keybrd0.c:  butn9[3].bkgr=-1;
keybrd0.c:  butn9[4].bkgr=-1;
keybrd0.c:  butn9[5].bkgr=-1;
keybrd0.c:  butn9[6].bkgr=-1;
keybrd0.c:  butn9[7].bkgr=-1;
keybrd0.c:  butn9[8].bkgr=-1;
keybrd0.c:  butn9[9].bkgr=-1;
keybrd0.c:  butn9[10].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b9.item = -1;
keybrd0.c:  butn10[0].bkgr=-1;
keybrd0.c:  butn10[1].bkgr=-1;
keybrd0.c:  butn10[2].bkgr=-1;
keybrd0.c:  butn10[3].bkgr=-1;
keybrd0.c:  butn10[4].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b10.item = -1;
keybrd0.c:  butn11[0].bkgr=-1;
keybrd0.c:  butn11[1].bkgr=-1;
keybrd0.c:  butn11[2].bkgr=-1;
keybrd0.c:  butn11[3].bkgr=-1;
keybrd0.c:  butn11[4].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b11.item = -1;
keybrd0.c:  butn12[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b12.item = -1;
keybrd0.c:  butn13[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b13.item = -1;
keybrd0.c:  butn14[0].bkgr=-1;
keybrd0.c:  butn14[1].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b14.item = -1;
keybrd0.c:  butn15[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b15.item = -1;
keybrd0.c:  butn16[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b16.item = -1;
keybrd0.c:  butn17[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b17.item = -1;
keybrd0.c:  butn18[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b18.item = -1;
keybrd0.c:  butn19[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b19.item = -1;
keybrd0.c:  butn20[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b20.item = -1;
keybrd0.c:  butn21[0].bkgr=-1;
keybrd0.c:    2,0.000000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd0.c:  b21.item = -1;
keybrd0.c:  dtmp = D->d;
keybrd0.c:  d[0].p->item = -1;
keybrd0.c:  d[1].N->item = -1;
keybrd0.c:  d[2].N->item = -1;
keybrd0.c:  d[3].N->item = -1;
keybrd0.c:  d[4].N->item = -1;
keybrd0.c:  d[5].N->item = -1;
keybrd0.c:  d[6].N->item = -1;
keybrd0.c:  d[7].N->item = -1;
keybrd0.c:  d[8].N->item = -1;
keybrd0.c:  d[9].N->item = -1;
keybrd0.c:  d[10].N->item = -1;
keybrd0.c:  d[11].N->item = -1;
keybrd0.c:  d[12].N->item = -1;
keybrd0.c:  d[13].N->item = -1;
keybrd0.c:  d[14].N->item = -1;
keybrd0.c:  d[15].N->item = -1;
keybrd0.c:  d[16].N->item = -1;
keybrd0.c:  d[17].N->item = -1;
keybrd0.c:  d[18].N->item = -1;
keybrd0.c:  d[19].N->item = -1;
keybrd0.c:  d[20].N->item = -1;
keybrd0.c:  d[21].N->item = -1;
keybrd0.c:  D->d = dtmp;
keybrd0.c:   d = (DIA *)(D->d);
keybrd0.c:     if(xm > (d[i].t->x1) ) xm = d[i].t->x1;
keybrd0.c:     if(ym > (d[i].t->y1) ) ym = d[i].t->y1;
keybrd0.c://   kgShiftGrp(D,GrpId,xo-43,yo-28);
keybrd0.c://   kgShiftGrp(D,Kbrd->GrpId,xo-xm,yo-ym);
keybrd0.c:   Kbrd->kbtype=0;
keybrd0.c:   Kbrd->grp3 = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[0+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[13+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[14+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[15+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[16+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[17+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[18+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[19+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[20+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp3,d[21+offset].t);
keybrd0.c:   Kbrd->offgrp = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->offgrp,d[1+offset].t);
keybrd0.c:   Kbrd->ongrp = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->ongrp,d[7+offset].t);
keybrd0.c:   Kbrd->grp1 = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp1,d[6+offset].t);
keybrd0.c:   Kbrd->grp2 = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->grp2,d[12+offset].t);
keybrd0.c:   Kbrd->sgrp = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->sgrp,d[2+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->sgrp,d[3+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->sgrp,d[4+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->sgrp,d[5+offset].t);
keybrd0.c:   Kbrd->cgrp = kgOpenGrp(D);
keybrd0.c:   kgAddtoGrp(D,Kbrd->cgrp,d[8+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->cgrp,d[9+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->cgrp,d[10+offset].t);
keybrd0.c:   kgAddtoGrp(D,Kbrd->cgrp,d[11+offset].t);
keybrd0.c:   Kbrd->CurWid = -1;
keybrd0.c:   Kbrd->Vis = Vis;
keybrd0.c:   Kbrd->D = D;
keybrd0.c:   Kbrd->ShiftPress=0;
keybrd0.c:   Kbrd->CapsLock=0;
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->GrpId,0);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd0.c:    kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd0.c:     clr = -clr;
keybrd0.c:   D->Kbrd = Kbrd;
keybrd0.c:   Kbrd->D = D;
keybrd0.c:   Kbrd->TargetWindow = NULL;
keybrd0.c:   Kbrd->XpmList = NULL;
keybrd0.c:   Kbrd->Thds=NULL;
keybrd0.c:   Kbrd->Brfac =Brfac;
keybrd0.c:   gc = D->gc;
keybrd0.c:   Kbrd->FillClr = ConvertColor(bkgrclr,80);
keybrd0.c:   D->wc=NULL;
keybrd0.c:   Kbrd->trans = transparency;
keybrd0.c:   if (By<30) strcpy(Kbrd->Sfac,"11");
keybrd0.c:   else if(By < 42) strcpy(Kbrd->Sfac,"54");
keybrd0.c:        else strncpy(Kbrd->Sfac,Sfac,3);
keybrd0.c:   Kbrd->Sfac[2]='\0';
keybrd0.c:   Kbrd->Bclr = Bclr;
keybrd0.c:   Kbrd->Bfont = Bfont;
keybrd0.c:   Kbrd->kbtype=0;
keybrd0.c:   Kbrd->Btype=btype;
keybrd0.c:   Kbrd->ButClr = ButClr;
keybrd0.c:   Kbrd->Rfac = rfac;
keybrd0.c:   Kbrd->Bx = Bx;
keybrd0.c:   Kbrd->By = By;
keybrd0.c:   Kbrd->Xg = Xg;
keybrd0.c:   Kbrd->Yg = Yg;
keybrd0.c:   Kbrd->Bodr = Bodr;
keybrd0.c:   Kbrd->Bclr = Bclr;
keybrd0.c:   Kbrd->Bfont = Bfont;
keybrd0.c:   Kbrd->kbtype=0;
keybrd0.c:   Kbrd->Btype=btype;
keybrd0.c:   Kbrd->Rfac = rfac;
keybrd0.c:   dtmp = D->d;
keybrd0.c:   Kbrd->Thds= NULL;
keybrd0.c:   if(Kbrd->Btype ==  0) {
keybrd0.c:     Kbrd->Thds = Thds;
keybrd0.c:     Kbrd->Thds= NULL;
keybrd0.c:   Gpt->arg= v; // kulina will double free this; you may modify
keybrd0.c:   Kbrd->GrpId = GrpId;
keybrd0.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
keybrd0.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
keybrd0Callbacks.c:static char Label1[]="`1234567890-=";
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:     *xl = P->x2 - P->x1;
keybrd0Callbacks.c:     *yl = P->y2 - P->y1;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:     kgShiftGrp(Tmp,Kbrd->GrpId,xs,ys);
keybrd0Callbacks.c:   kgUserFrame(fid,-2.,-2.,(float)xl+2,(float)yl+2);
keybrd0Callbacks.c:     kgUserFrame(fid,-1.0,-1.0,(float)xl+1.0,(float)yl+1.0);
keybrd0Callbacks.c:     kgUserFrame(fid,-1.0,-1.0,(float)xl+1.0,(float)yl+1.0);
keybrd0Callbacks.c:   yp= (yl-h)/2.0;
keybrd0Callbacks.c:   if(ln> (xl-w) ) {
keybrd0Callbacks.c:     fac = (xl-w)/ln;
keybrd0Callbacks.c:   xp = ((float)xl -ln)*0.5;
keybrd0Callbacks.c:     xp= xl-1.5*w;
keybrd0Callbacks.c:     yp= yl -1.2*h;
keybrd0Callbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !c%2.2d!z23!u%-s",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str,Kbrd->Bclr,ustr);
keybrd0Callbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !g",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str);
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c: switch(Kbrd->ShiftPress) {
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd0Callbacks.c:      switch(Kbrd->CapsLock) {
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,1);
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd0Callbacks.c:      kgUpdateGrp(D,Kbrd->offgrp);
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->offgrp,0);
keybrd0Callbacks.c:      switch(Kbrd->CapsLock) {
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,1);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd0Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->ongrp,1);
keybrd0Callbacks.c:      kgUpdateGrp(D,Kbrd->ongrp);
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->ShiftPress=0;
keybrd0Callbacks.c:  switch(Kbrd->CapsLock) {
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd0Callbacks.c:      kgUpdateGrp(D,Kbrd->sgrp);
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd0Callbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd0Callbacks.c:      kgUpdateGrp(D,Kbrd->cgrp);
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  CurWid = Kbrd->CurWid;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:     CurWid = Kbrd->CurWid;
keybrd0Callbacks.c:  ch= Label[butno-1];
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      ch= Label[butno-1];
keybrd0Callbacks.c:      kgSendKeyToWindow(D,Kbrd->TargetWindow,ch);
keybrd0Callbacks.c:  if(Kbrd->ShiftPress) {
keybrd0Callbacks.c:    Kbrd->ShiftPress=0;
keybrd0Callbacks.c:   if(B->type >= 1){
keybrd0Callbacks.c:   xl =B->lngth;
keybrd0Callbacks.c:   yl =B->width;
keybrd0Callbacks.c:   clr =kb->ButClr;
keybrd0Callbacks.c:   if(clr < -1) {
keybrd0Callbacks.c:     clr = -clr;
keybrd0Callbacks.c:     if(clr == -1) clr= 1;
keybrd0Callbacks.c:   return MakeBkgrImage(xl,yl,r,g,b,B->fac);
keybrd0Callbacks.c:   but = B->buts;
keybrd0Callbacks.c:   if(B->type > 1) {
keybrd0Callbacks.c:   xl =B->lngth;
keybrd0Callbacks.c:   yl =B->width;
keybrd0Callbacks.c:   clr =kb->ButClr;
keybrd0Callbacks.c:   img = MakeStringImage(xl,yl,clr,B->fac,kb->Bclr,kb->Bclr,kb->Bfont,str,ustr);
keybrd0Callbacks.c:    B = (DIN *)im->B;
keybrd0Callbacks.c:    kb = (KEYBRD *)im->kb;
keybrd0Callbacks.c:    GetStringImg(B,im->index,kb,im->str,im->ustr);
keybrd0Callbacks.c://    B->nodrawbkgr = NOBKGR;
keybrd0Callbacks.c:    Bx = kb->Bx;
keybrd0Callbacks.c:    By = kb->By;
keybrd0Callbacks.c:    Xg = kb->Xg;
keybrd0Callbacks.c:    Yg = kb->Yg;
keybrd0Callbacks.c:    Bodr = kb->Bodr;
keybrd0Callbacks.c:    B->type = kb->Btype;
keybrd0Callbacks.c:    if(kb->XpmList==NULL) kb->XpmList = Dopen();
keybrd0Callbacks.c:    x1 = B->x1-50,y1 = B->y1-40;
keybrd0Callbacks.c:    B->xgap =Xg;
keybrd0Callbacks.c:    if(B->xgap < 0) B->xgap =0;
keybrd0Callbacks.c:    B->ygap =Yg;
keybrd0Callbacks.c:    x1 = (xoff*(Bx+Xg)*0.5+0.1)-Bxoff+Bodr;
keybrd0Callbacks.c:    y1 = (yoff*(By+Yg)*0.5+0.1)-Byoff+Bodr;
keybrd0Callbacks.c:    B->x1 = x1;
keybrd0Callbacks.c:    B->y1 = y1;
keybrd0Callbacks.c://    yfac = B->width/36.0;
keybrd0Callbacks.c:    xfac = (int)(B->lngth/(Dbx*0.5)+0.05);
keybrd0Callbacks.c:    yfac = (int)(B->width/(Dby*0.5)+0.05);
keybrd0Callbacks.c:    B->lngth = Bx*xfac+0.1;
keybrd0Callbacks.c:    B->width = By*yfac+0.1;
keybrd0Callbacks.c:    if(xfac > 1.0 ) B->lngth += (xfac-1.0)*Xg;
keybrd0Callbacks.c:    if(yfac > 1.0 ) B->width += (yfac-1.0)*Yg;
keybrd0Callbacks.c:    xl = (B->lngth+B->xgap)*B->nx;
keybrd0Callbacks.c:    yl = (B->width+B->ygap)*B->ny;
keybrd0Callbacks.c:    B->x2 = x1+xl-1;
keybrd0Callbacks.c:    B->y2 = y1+yl-1;
keybrd0Callbacks.c:    B->nodrawbkgr = NOBKGR;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   but = B->buts;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:   B->type = Kbrd->Btype;
keybrd0Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd0Callbacks.c:    but[i].bkgr = Kbrd->ButClr;
keybrd0Callbacks.c:    if(B->type >= 1)  {
keybrd0Callbacks.c:      im->B = B;
keybrd0Callbacks.c:      im->kb = Kbrd;
keybrd0Callbacks.c:      strcpy(im->str,but[i].title);
keybrd0Callbacks.c:      im->ustr[0]='\0';
keybrd0Callbacks.c:      im->index = i;
keybrd0Callbacks.c://      DoInAnyThread(Kbrd->Thds,CreateButImage,(void *)im);
keybrd0Callbacks.c://   if(Kbrd->Thds != NULL) WaitThreads(Kbrd->Thds);
keybrd0Callbacks.c:     if( but[i].xpmn!= NULL) Dadd(Kbrd->XpmList,but[i].xpmn);
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:   but = B->buts;
keybrd0Callbacks.c:   B->type = Kbrd->Btype;
keybrd0Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd0Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd0Callbacks.c:      im->B = B;
keybrd0Callbacks.c:      im->kb = Kbrd;
keybrd0Callbacks.c:      strncpy(im->str,buff,80);
keybrd0Callbacks.c:      im->str[80]='\0';
keybrd0Callbacks.c:      im->ustr[0]='\0';
keybrd0Callbacks.c:      im->index = i;
keybrd0Callbacks.c:      if(Kbrd->Thds!=NULL) DoInAnyThread(Kbrd->Thds,CreateButImage,(void *)im);
keybrd0Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd0Callbacks.c:      im->B = B;
keybrd0Callbacks.c:      im->kb = Kbrd;
keybrd0Callbacks.c:      strcpy(im->str,buff);
keybrd0Callbacks.c:      strcpy(im->ustr,buff1);
keybrd0Callbacks.c:      im->index = i;
keybrd0Callbacks.c:      if(Kbrd->Thds!=NULL) DoInAnyThread(Kbrd->Thds,CreateButImage,(void *)im);
keybrd0Callbacks.c:    if(Kbrd->Thds != NULL) WaitThreads(Kbrd->Thds);
keybrd0Callbacks.c:     if( but[i].xpmn!= NULL) Dadd(Kbrd->XpmList,but[i].xpmn);
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:   but = B->buts;
keybrd0Callbacks.c:   B->type = Kbrd->Btype;
keybrd0Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd0Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd0Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd0Callbacks.c:   B->type = Kbrd->Btype;
keybrd0Callbacks.c:   if(B->type > 0 ) kgProcessOtherInit(B,Kbrd,Label,Label1,inx);
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:   kb->TargetWindow = win;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd->CapsLock = (Kbrd->CapsLock+1)%2;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd->CapsLock = (Kbrd->CapsLock+1)%2;
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendBackspaceKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0) {
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendLeftKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendRightKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:  kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendEscapeKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:  kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:   n = B->nx * B->ny;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendEnterKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendTabKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendHomeKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:   kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendEndKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd->ShiftPress = (Kbrd->ShiftPress+1)%2;
keybrd0Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd0Callbacks.c:  n = B->nx*B->ny;
keybrd0Callbacks.c:  Kbrd = D->Kbrd;
keybrd0Callbacks.c:  Kbrd->CurWid =-1;
keybrd0Callbacks.c:  if(D->InputWid >= 0) {
keybrd0Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd0Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd0Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd0Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:      kgSendSpaceKeyToWindow(D,Kbrd->TargetWindow);
keybrd0Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd0Callbacks.c:  pt = D->pt;
keybrd0Callbacks.c:  pt = D->pt;
keybrd0Callbacks.c:  kb = (KEYBRD *)D->Kbrd;
keybrd0Callbacks.c:  Resetlink(kb->XpmList);
keybrd0Callbacks.c:  while ( (img = (void *)Getrecord(kb->XpmList))!= NULL) {
keybrd0Callbacks.c:  Dfree(kb->XpmList);
keybrd0Callbacks.c:  kb->XpmList=NULL;
keybrd0Callbacks.c:  if(kbe->event ==1) {
keybrd0Callbacks.c:    if(kbe->button ==1) {
keybrd0Callbacks.c:  dx = xres - D->xl;
keybrd0Callbacks.c:  dy = yres - D->yl;
keybrd0Callbacks.c:  D->xl= xres;
keybrd0Callbacks.c:  D->yl= yres;
keybrd0Callbacks.c:  d = D->d;
keybrd0Callbacks.c:  kb = (KEYBRD *)D->Kbrd;
keybrd0Callbacks.c:  Bx = kb->Bx;
keybrd0Callbacks.c:  By = kb->By;
keybrd0Callbacks.c:  Xg = kb->Xg;
keybrd0Callbacks.c:  Yg = kb->Yg;
keybrd0Callbacks.c:  Bodr = kb->Bodr;
keybrd0Callbacks.c:  P->x1 = 1;
keybrd0Callbacks.c:  P->y1 = 1;
keybrd0Callbacks.c:  P->x2=  xl-1;
keybrd0Callbacks.c:  P->y2= yl-1;
keybrd0Callbacks.c:  kgGetDefaultRGB(kb->FillClr,&Rd,&Gn,&Bl);
keybrd0Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,Rd,Gn,Bl,kb->Brfac);
keybrd0Callbacks.c:  Dadd(kb->XpmList,P->xpm);
keybrd0Callbacks.c:  P->transparency = kb->trans;
keybrd0Callbacks.c:  P->bordr = 0;
keybrd0Callbacks.c:  if(D->xl < (xl+1)) D->xl = (xl+1);
keybrd0Callbacks.c:  if(D->yl < (yl+1)) D->yl = (yl+1);
keybrd4.c:static int ButClr=-1;
keybrd4.c:   gc->FontSize =8;
keybrd4.c:   gc->Font=23;
keybrd4.c:    -1, /* bkgr colour */ 
keybrd4.c:  p0.item = -1;
keybrd4.c:  p1.item = -1;
keybrd4.c:  p2.item = -1;
keybrd4.c:    -1, /* bkgr colour */ 
keybrd4.c:  p3.item = -1;
keybrd4.c:  butn4[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b4.item = -1;
keybrd4.c:  butn5[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b5.item = -1;
keybrd4.c:  butn6[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b6.item = -1;
keybrd4.c:  butn7[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b7.item = -1;
keybrd4.c:  butn8[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b8.item = -1;
keybrd4.c:  butn9[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b9.item = -1;
keybrd4.c:  butn10[0].bkgr=-1;
keybrd4.c:  butn10[1].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b10.item = -1;
keybrd4.c:  butn11[0].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b11.item = -1;
keybrd4.c:  butn12[0].bkgr=-1;
keybrd4.c:  butn12[1].bkgr=-1;
keybrd4.c:  butn12[2].bkgr=-1;
keybrd4.c:  butn12[3].bkgr=-1;
keybrd4.c:  butn12[4].bkgr=-1;
keybrd4.c:  butn12[5].bkgr=-1;
keybrd4.c:  butn12[6].bkgr=-1;
keybrd4.c:  butn12[7].bkgr=-1;
keybrd4.c:  butn12[8].bkgr=-1;
keybrd4.c:  butn12[9].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b12.item = -1;
keybrd4.c:  butn13[0].bkgr=-1;
keybrd4.c:  butn13[1].bkgr=-1;
keybrd4.c:  butn13[2].bkgr=-1;
keybrd4.c:  butn13[3].bkgr=-1;
keybrd4.c:  butn13[4].bkgr=-1;
keybrd4.c:  butn13[5].bkgr=-1;
keybrd4.c:  butn13[6].bkgr=-1;
keybrd4.c:  butn13[7].bkgr=-1;
keybrd4.c:  butn13[8].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b13.item = -1;
keybrd4.c:  butn14[0].bkgr=-1;
keybrd4.c:  butn14[1].bkgr=-1;
keybrd4.c:  butn14[2].bkgr=-1;
keybrd4.c:  butn14[3].bkgr=-1;
keybrd4.c:  butn14[4].bkgr=-1;
keybrd4.c:  butn14[5].bkgr=-1;
keybrd4.c:  butn14[6].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b14.item = -1;
keybrd4.c:  butn15[0].bkgr=-1;
keybrd4.c:  butn15[1].bkgr=-1;
keybrd4.c:  butn15[2].bkgr=-1;
keybrd4.c:  butn15[3].bkgr=-1;
keybrd4.c:  butn15[4].bkgr=-1;
keybrd4.c:  butn15[5].bkgr=-1;
keybrd4.c:  butn15[6].bkgr=-1;
keybrd4.c:  butn15[7].bkgr=-1;
keybrd4.c:  butn15[8].bkgr=-1;
keybrd4.c:  butn15[9].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b15.item = -1;
keybrd4.c:  butn16[0].bkgr=-1;
keybrd4.c:  butn16[1].bkgr=-1;
keybrd4.c:  butn16[2].bkgr=-1;
keybrd4.c:  butn16[3].bkgr=-1;
keybrd4.c:  butn16[4].bkgr=-1;
keybrd4.c:  butn16[5].bkgr=-1;
keybrd4.c:  butn16[6].bkgr=-1;
keybrd4.c:  butn16[7].bkgr=-1;
keybrd4.c:  butn16[8].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b16.item = -1;
keybrd4.c:  butn17[0].bkgr=-1;
keybrd4.c:  butn17[1].bkgr=-1;
keybrd4.c:  butn17[2].bkgr=-1;
keybrd4.c:  butn17[3].bkgr=-1;
keybrd4.c:  butn17[4].bkgr=-1;
keybrd4.c:  butn17[5].bkgr=-1;
keybrd4.c:  butn17[6].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b17.item = -1;
keybrd4.c:  butn18[0].bkgr=-1;
keybrd4.c:  butn18[1].bkgr=-1;
keybrd4.c:  butn18[2].bkgr=-1;
keybrd4.c:  butn18[3].bkgr=-1;
keybrd4.c:  butn18[4].bkgr=-1;
keybrd4.c:  butn18[5].bkgr=-1;
keybrd4.c:  butn18[6].bkgr=-1;
keybrd4.c:  butn18[7].bkgr=-1;
keybrd4.c:  butn18[8].bkgr=-1;
keybrd4.c:  butn18[9].bkgr=-1;
keybrd4.c:  butn18[10].bkgr=-1;
keybrd4.c:  butn18[11].bkgr=-1;
keybrd4.c:  butn18[12].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b18.item = -1;
keybrd4.c:  butn19[0].bkgr=-1;
keybrd4.c:  butn19[1].bkgr=-1;
keybrd4.c:  butn19[2].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b19.item = -1;
keybrd4.c:  butn20[0].bkgr=-1;
keybrd4.c:  butn20[1].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b20.item = -1;
keybrd4.c:  butn21[0].bkgr=-1;
keybrd4.c:  butn21[1].bkgr=-1;
keybrd4.c:  butn21[2].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b21.item = -1;
keybrd4.c:  butn22[0].bkgr=-1;
keybrd4.c:  butn22[1].bkgr=-1;
keybrd4.c:  butn22[2].bkgr=-1;
keybrd4.c:  butn22[3].bkgr=-1;
keybrd4.c:  butn22[4].bkgr=-1;
keybrd4.c:  butn22[5].bkgr=-1;
keybrd4.c:  butn22[6].bkgr=-1;
keybrd4.c:  butn22[7].bkgr=-1;
keybrd4.c:  butn22[8].bkgr=-1;
keybrd4.c:  butn22[9].bkgr=-1;
keybrd4.c:  butn22[10].bkgr=-1;
keybrd4.c:  butn22[11].bkgr=-1;
keybrd4.c:  butn22[12].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b22.item = -1;
keybrd4.c:  butn23[0].bkgr=-1;
keybrd4.c:  butn23[1].bkgr=-1;
keybrd4.c:  butn23[2].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b23.item = -1;
keybrd4.c:  butn24[0].bkgr=-1;
keybrd4.c:  butn24[1].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b24.item = -1;
keybrd4.c:  butn25[0].bkgr=-1;
keybrd4.c:  butn25[1].bkgr=-1;
keybrd4.c:  butn25[2].bkgr=-1;
keybrd4.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd4.c:  b25.item = -1;
keybrd4.c:  dtmp = D->d;
keybrd4.c:  d[0].p->item = -1;
keybrd4.c:  d[1].p->item = -1;
keybrd4.c:  d[2].p->item = -1;
keybrd4.c:  d[3].p->item = -1;
keybrd4.c:  d[4].N->item = -1;
keybrd4.c:  d[5].N->item = -1;
keybrd4.c:  d[6].N->item = -1;
keybrd4.c:  d[7].N->item = -1;
keybrd4.c:  d[8].N->item = -1;
keybrd4.c:  d[9].N->item = -1;
keybrd4.c:  d[10].N->item = -1;
keybrd4.c:  d[11].N->item = -1;
keybrd4.c:  d[12].N->item = -1;
keybrd4.c:  d[13].N->item = -1;
keybrd4.c:  d[14].N->item = -1;
keybrd4.c:  d[15].N->item = -1;
keybrd4.c:  d[16].N->item = -1;
keybrd4.c:  d[17].N->item = -1;
keybrd4.c:  d[18].N->item = -1;
keybrd4.c:  d[19].N->item = -1;
keybrd4.c:  d[20].N->item = -1;
keybrd4.c:  d[21].N->item = -1;
keybrd4.c:  d[22].N->item = -1;
keybrd4.c:  d[23].N->item = -1;
keybrd4.c:  d[24].N->item = -1;
keybrd4.c:  d[25].N->item = -1;
keybrd4.c:  D->d = dtmp;
keybrd4.c:   d = (DIA *)(D->d);
keybrd4.c:     if(xm > (d[i].t->x1) ) xm = d[i].t->x1;
keybrd4.c:     if(ym > (d[i].t->y1) ) ym = d[i].t->y1;
keybrd4.c://   kgShiftGrp(D,GrpId,xo-43,yo-28);
keybrd4.c:   kgShiftGrp(D,Kbrd->GrpId,xo-xm,yo-ym);
keybrd4.c:   Kbrd->grp1 = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[0+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[3+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[4+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[5+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[6+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[7+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[8+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[9+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[10+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp1,d[11+offset].t);
keybrd4.c:   Kbrd->sgrp = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->sgrp,d[12+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->sgrp,d[13+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->sgrp,d[14+offset].t);
keybrd4.c:   Kbrd->cgrp = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->cgrp,d[15+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->cgrp,d[16+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->cgrp,d[17+offset].t);
keybrd4.c:   Kbrd->grp3 = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp3,d[18+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp3,d[19+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp3,d[20+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp3,d[21+offset].t);
keybrd4.c:   Kbrd->grp2 = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp2,d[22+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp2,d[23+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp2,d[24+offset].t);
keybrd4.c:   kgAddtoGrp(D,Kbrd->grp2,d[25+offset].t);
keybrd4.c:   Kbrd->offgrp = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->offgrp,d[1+offset].t);
keybrd4.c:   Kbrd->ongrp = kgOpenGrp(D);
keybrd4.c:   kgAddtoGrp(D,Kbrd->ongrp,d[2+offset].t);
keybrd4.c:   Kbrd->CurWid = -1;
keybrd4.c:   Kbrd->Vis = Vis;
keybrd4.c:   Kbrd->D = D;
keybrd4.c:   Kbrd->ShiftPress=0;
keybrd4.c:   Kbrd->CapsLock=0;
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->GrpId,0);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd4.c:    kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd4.c:     clr = -clr;
keybrd4.c:   D->Kbrd = Kbrd;
keybrd4.c:   gc = D->gc;
keybrd4.c:   Kbrd->TargetWindow = NULL;
keybrd4.c:   Kbrd->FillClr = ConvertColor(bkgrclr,80);
keybrd4.c:   D->wc=NULL;
keybrd4.c:   if (By<30) strcpy(Kbrd->Sfac,"11");
keybrd4.c:   else if(By < 42) strcpy(Kbrd->Sfac,"54");
keybrd4.c:        else strncpy(Kbrd->Sfac,Sfac,3);
keybrd4.c:   Kbrd->Sfac[2]='\0';
keybrd4.c:   Kbrd->Bclr = Bclr;
keybrd4.c:   Kbrd->Bfont = Bfont;
keybrd4.c:   Kbrd->kbtype=4;
keybrd4.c:   Kbrd->Btype=btype;
keybrd4.c:   Kbrd->ButClr = ButClr;
keybrd4.c:   Kbrd->Rfac = rfac;
keybrd4.c:   Kbrd->Brfac = Brfac;
keybrd4.c:   Kbrd->Bx = Bx;
keybrd4.c:   Kbrd->By = By;
keybrd4.c:   Kbrd->Xg = Xg;
keybrd4.c:   Kbrd->Yg = Yg;
keybrd4.c:   Kbrd->Bodr = Bodr;
keybrd4.c:   gc = D->gc;
keybrd4.c:   D->wc=NULL;
keybrd4.c:   Kbrd->Btype=Btype;
keybrd4.c:   Kbrd->Rfac = Rfac;
keybrd4.c:   Kbrd->trans = transparency;
keybrd4.c:   dtmp = D->d;
keybrd4.c:   Kbrd->Thds=NULL;
keybrd4.c:   if(Kbrd->Btype < 1) {
keybrd4.c:     Kbrd->Thds = Thds;
keybrd4.c:     Kbrd->Thds= NULL;
keybrd4.c:   Kbrd->GrpId= GrpId;
keybrd4.c:   Gpt->arg= v; // kulina will double free this; you may modify
keybrd4.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
keybrd4.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
keybrd4Callbacks.c:static char Label1[]="`1234567890-=";
keybrd4Callbacks.c:   Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:   if(Kbrd->Vis) return 0;
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd4Callbacks.c:    kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd4Callbacks.c:   Kbrd->ShiftPress=0;
keybrd4Callbacks.c:   Kbrd->CapsLock=0;
keybrd4Callbacks.c:   if(D->wc != NULL) {
keybrd4Callbacks.c:     kgUpdateGrp(D,Kbrd->grp1);
keybrd4Callbacks.c:     kgUpdateGrp(D,Kbrd->grp3);
keybrd4Callbacks.c:     kgUpdateGrp(D,Kbrd->sgrp);
keybrd4Callbacks.c:     kgUpdateGrp(D,Kbrd->offgrp);
keybrd4Callbacks.c:   Kbrd->Vis = 1;
keybrd4Callbacks.c:   return Kbrd->GrpId;
keybrd4Callbacks.c:     kgUserFrame(fid,-1.0,-1.0,(float)xl+1.0,(float)yl+1.0);
keybrd4Callbacks.c:     kgUserFrame(fid,-1.0,-1.0,(float)xl+1.0,(float)yl+1.0);
keybrd4Callbacks.c:   yp= (yl-h)/2.0;
keybrd4Callbacks.c:   if(ln> (xl-w) ) {
keybrd4Callbacks.c:     fac = (xl-w)/ln;
keybrd4Callbacks.c:   xp = ((float)xl -ln)*0.5;
keybrd4Callbacks.c:     xp= xl-1.5*w;
keybrd4Callbacks.c:     yp= yl -1.2*h;
keybrd4Callbacks.c://  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !c%2.2d!z23!u%-s",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str,Kbrd->FillClr,ustr);
keybrd4Callbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !c%2.2d!z23!u%-s",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str,Kbrd->Bclr,ustr);
keybrd4Callbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !g",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str);
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c: switch(Kbrd->ShiftPress) {
keybrd4Callbacks.c:      switch(Kbrd->CapsLock) {
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd4Callbacks.c:      switch(Kbrd->CapsLock) {
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,1);
keybrd4Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->ShiftPress=0;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  CurWid = Kbrd->CurWid;
keybrd4Callbacks.c:  if(D->InputWid >= 0) {
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:     CurWid = Kbrd->CurWid;
keybrd4Callbacks.c:    ch= Label[butno-1];
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      ch= Label[butno-1];
keybrd4Callbacks.c:      kgSendKeyToWindow(D,Kbrd->TargetWindow,ch);
keybrd4Callbacks.c:  if(Kbrd->ShiftPress) {
keybrd4Callbacks.c:    Kbrd->ShiftPress=0;
keybrd4Callbacks.c:   if(B->type > 0){
keybrd4Callbacks.c:   xl =B->lngth;
keybrd4Callbacks.c:   yl =B->width;
keybrd4Callbacks.c:   clr =kb->ButClr;
keybrd4Callbacks.c:   if(clr < -1) {
keybrd4Callbacks.c:     clr = -clr;
keybrd4Callbacks.c:     if(clr == -1) clr= 1;
keybrd4Callbacks.c:   return MakeBkgrImage(xl,yl,r,g,b,B->fac);
keybrd4Callbacks.c:   but = (BUT_STR *)B->buts;
keybrd4Callbacks.c:   if(B->type > 0) {
keybrd4Callbacks.c:   xl =B->lngth;
keybrd4Callbacks.c:   yl =B->width;
keybrd4Callbacks.c://   xl = (xl+1)/2*2-1;
keybrd4Callbacks.c://   yl = (yl+1)/2*2-1;
keybrd4Callbacks.c:   clr =kb->ButClr;
keybrd4Callbacks.c://   img = MakeStringImage4(xl,yl,clr,B->fac,kb->Bclr,kb->FillClr,kb->Bfont,str,ustr);
keybrd4Callbacks.c:   img = MakeStringImage4(xl,yl,clr,B->fac,kb->Bclr,kb->Bclr,kb->Bfont,str,ustr);
keybrd4Callbacks.c:    B = (DIN *)im->B;
keybrd4Callbacks.c:    kb = (KEYBRD *)im->kb;
keybrd4Callbacks.c:    GetStringImg4(B,im->index,kb,im->str,im->ustr);
keybrd4Callbacks.c:   but = (BUT_STR *)B->buts;
keybrd4Callbacks.c:   n = B->nx * B->ny;
keybrd4Callbacks.c:   B->type = Kbrd->Btype;
keybrd4Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd4Callbacks.c:    but[i].bkgr = Kbrd->ButClr;
keybrd4Callbacks.c:    if(B->type > 0)  {
keybrd4Callbacks.c:      im->B = B;
keybrd4Callbacks.c:      im->kb = Kbrd;
keybrd4Callbacks.c:      strncpy(im->str,but[i].title,80);
keybrd4Callbacks.c:      im->str[80]='\0';
keybrd4Callbacks.c:      im->ustr[0]='\0';
keybrd4Callbacks.c:      im->index = i;
keybrd4Callbacks.c:      if(Kbrd->Thds != NULL) DoInAnyThread(Kbrd->Thds,CreateButImage4,(void *)im);
keybrd4Callbacks.c:   if(Kbrd->Thds != NULL) WaitThreads(Kbrd->Thds);
keybrd4Callbacks.c:   n = B->nx * B->ny;
keybrd4Callbacks.c:   but = (BUT_STR *)B->buts;
keybrd4Callbacks.c:   B->type = Kbrd->Btype;
keybrd4Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd4Callbacks.c:   if(B->type > 0)  {
keybrd4Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd4Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd4Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd4Callbacks.c:      im->B = B;
keybrd4Callbacks.c:      im->kb = Kbrd;
keybrd4Callbacks.c:      strncpy(im->str,buff,80);
keybrd4Callbacks.c:      im->str[80]='\0';
keybrd4Callbacks.c:      im->ustr[0]='\0';
keybrd4Callbacks.c:      im->index = i;
keybrd4Callbacks.c:      if(Kbrd->Thds != NULL) DoInAnyThread(Kbrd->Thds,CreateButImage4,(void *)im);
keybrd4Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd4Callbacks.c:      im->B = B;
keybrd4Callbacks.c:      im->kb = Kbrd;
keybrd4Callbacks.c:      strcpy(im->str,buff);
keybrd4Callbacks.c:      strcpy(im->ustr,buff1);
keybrd4Callbacks.c:      im->index = i;
keybrd4Callbacks.c:      if(Kbrd->Thds != NULL) DoInAnyThread(Kbrd->Thds,CreateButImage4,(void *)im);
keybrd4Callbacks.c:   if(Kbrd->Thds != NULL) WaitThreads(Kbrd->Thds);
keybrd4Callbacks.c:   kgUserFrame(fid,-2.,-2.,(float)xl+2,(float)yl+2);
keybrd4Callbacks.c:    B->nodrawbkgr = NOBKGR;
keybrd4Callbacks.c://    x1 = B->x1-12,y1 = B->y1-10;
keybrd4Callbacks.c:    x1 = B->x1-13,y1 = B->y1-9;
keybrd4Callbacks.c:    Bx = kb->Bx;
keybrd4Callbacks.c:    By = kb->By;
keybrd4Callbacks.c:    Xg = kb->Xg;
keybrd4Callbacks.c:    Yg = kb->Yg;
keybrd4Callbacks.c:    Bodr = kb->Bodr;
keybrd4Callbacks.c:    B->xgap =kb->Xg;
keybrd4Callbacks.c:    if(B->xgap < 0) B->xgap =0;
keybrd4Callbacks.c:    B->ygap =kb->Yg;
keybrd4Callbacks.c:    x1 = (xoff*(Bx+Xg)*0.5+0.1)-Bxoff+Bodr;
keybrd4Callbacks.c:    y1 = (yoff*(By+Yg)*0.5+0.1)-Byoff+Bodr;
keybrd4Callbacks.c:    B->x1 = x1;
keybrd4Callbacks.c:    B->y1 = y1;
keybrd4Callbacks.c://    yfac = B->width/36.0;
keybrd4Callbacks.c:    xfac = (int)(B->lngth/18.0+0.05);
keybrd4Callbacks.c:    yfac = (int)(B->width/18.0+0.05);
keybrd4Callbacks.c:    B->lngth = Bx*xfac+0.1;
keybrd4Callbacks.c:    B->width = By*yfac+0.1;
keybrd4Callbacks.c:    if(xfac > 1.0 ) B->lngth += (xfac-1.0)*Xg;
keybrd4Callbacks.c:    if(yfac > 1.0 ) B->width += (yfac-1.0)*Yg;
keybrd4Callbacks.c:    xl = (B->lngth+B->xgap)*B->nx;
keybrd4Callbacks.c:    yl = (B->width+B->ygap)*B->ny;
keybrd4Callbacks.c:    B->x2 = x1+xl-1;
keybrd4Callbacks.c:    B->y2 = y1+yl-1;
keybrd4Callbacks.c:    B->nodrawbkgr = NOBKGR;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  if(D->InputWid >= 0) { 
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      kgSendBackspaceKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd4Callbacks.c:    kb->TargetWindow = win;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  if(D->InputWid >= 0) { 
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      kgSendEscapeKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CapsLock = (Kbrd->CapsLock+1)%2;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  if(D->InputWid >= 0) { 
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      kgSendEnterKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd->ShiftPress = (Kbrd->ShiftPress+1)%2;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  if(D->InputWid >= 0) { 
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      kgSendLeftKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  if(D->InputWid >= 0) { 
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:  if(Kbrd->CurWid < 0) {
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      if(butno==1) kgSendHomeKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      else kgSendEndKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Kbrd->CurWid =-1;
keybrd4Callbacks.c:  if(D->InputWid >= 0) { 
keybrd4Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd4Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd4Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd4Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:      kgSendSpaceKeyToWindow(D,Kbrd->TargetWindow);
keybrd4Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd4Callbacks.c:  n = B->nx*B->ny;
keybrd4Callbacks.c:  pt = D->pt;
keybrd4Callbacks.c:  pt = D->pt;
keybrd4Callbacks.c:  d = D->d;
keybrd4Callbacks.c:  kb = (KEYBRD *)D->Kbrd;
keybrd4Callbacks.c:  Bx = kb->Bx;
keybrd4Callbacks.c:  By = kb->By;
keybrd4Callbacks.c:  Xg = kb->Xg;
keybrd4Callbacks.c:  Yg = kb->Yg;
keybrd4Callbacks.c:  Bodr = kb->Bodr;
keybrd4Callbacks.c:  D->xo = 0,D->yo=0;
keybrd4Callbacks.c:  D->xl = 14.5*(Bx+Xg)+2*Bodr+3;
keybrd4Callbacks.c:  D->yl = 4.5*(By+Yg)+2*Bodr;
keybrd4Callbacks.c:    if(B->code == 'n') {
keybrd4Callbacks.c://      fprintf(stderr,"%s : %d\n",B->Wid,i);
keybrd4Callbacks.c:  B->lngth = Bx*1.5;
keybrd4Callbacks.c:  B->lngth = Bx*2+Xg;
keybrd4Callbacks.c:  P->x1= 1;
keybrd4Callbacks.c:  P->y1= 1;
keybrd4Callbacks.c:  P->x2= xl-1;
keybrd4Callbacks.c:  P->y2= yl-1;
keybrd4Callbacks.c:  kgGetDefaultRGB(kb->FillClr,&Rd,&Gn,&Bl);
keybrd4Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,Rd,Gn,Bl,kb->Brfac);
keybrd4Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd4Callbacks.c:  P->transparency = kb->trans;
keybrd4Callbacks.c:  P->bordr = 0;
keybrd4Callbacks.c:  B->y1= (By)*4+4*Yg+Bodr+By/5;
keybrd4Callbacks.c:  B->y1= yl-15;
keybrd4Callbacks.c:  B->x1= Bodr+10;
keybrd4Callbacks.c:  B->y2= B->y1+8;
keybrd4Callbacks.c:  B->x2= B->x1+8;
keybrd4Callbacks.c:  B->y1= (By)*4+4*Yg+Bodr+By/5;
keybrd4Callbacks.c:  B->y1= yl-15;
keybrd4Callbacks.c:  B->x1= Bodr+10;
keybrd4Callbacks.c:  B->y2= B->y1+8;
keybrd4Callbacks.c:  B->x2= B->x1+8;
keybrd4Callbacks.c:  B->y1= (By)*4+4*Yg+Bodr+By/5-5;
keybrd4Callbacks.c:  B->y1= yl-20;
keybrd4Callbacks.c:  B->x1= Bodr+20;
keybrd4Callbacks.c:  B->x2= B->x1+70;
keybrd4Callbacks.c:  B->y2= B->y1+16;
keybrd4Callbacks.c:  P->bordr=0;
keybrd4Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,30,25,30,0.5);
keybrd4Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd4Callbacks.c:  P->bordr=0;
keybrd4Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,220,25,30,0.5);
keybrd4Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd4Callbacks.c:  P->xpm = kgStringToImage((char *)"Caps Lock",NULL,P->x2-P->x1,P->y2-P->y1,16,kb->ButClr,-1,(P->y2-P->y1),kb->FillClr);
keybrd4Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd4Callbacks.c:  P->transparency = kb->trans;
keybrd4Callbacks.c:  if(D->xl < (xl+1)) D->xl = (xl+1);
keybrd4Callbacks.c:  if(D->yl < (yl+1)) D->yl = (yl+1);
keybrd4Callbacks.c:  if(kbe->event ==1) {
keybrd4Callbacks.c:    if(kbe->button ==1) {
keybrd4Callbacks.c:  dx = xres - D->xl;
keybrd4Callbacks.c:  dy = yres - D->yl;
keybrd4Callbacks.c:  D->xl= xres;
keybrd4Callbacks.c:  D->yl= yres;
keybrd5.c:static int ButClr=-1;
keybrd5.c:   gc->FontSize =8;
keybrd5.c:   gc->Font=23;
keybrd5.c:    -1, /* bkgr colour */ 
keybrd5.c:  p0.item = -1;
keybrd5.c:  p1.item = -1;
keybrd5.c:  p2.item = -1;
keybrd5.c:    -1, /* bkgr colour */ 
keybrd5.c:  p3.item = -1;
keybrd5.c:  butn4[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b4.item = -1;
keybrd5.c:  butn5[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b5.item = -1;
keybrd5.c:  butn6[0].bkgr=-1;
keybrd5.c:  butn6[1].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b6.item = -1;
keybrd5.c:  butn7[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b7.item = -1;
keybrd5.c:  butn8[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b8.item = -1;
keybrd5.c:  butn9[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b9.item = -1;
keybrd5.c:  butn10[0].bkgr=-1;
keybrd5.c:  butn10[1].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b10.item = -1;
keybrd5.c:  butn11[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b11.item = -1;
keybrd5.c:  butn12[0].bkgr=-1;
keybrd5.c:  butn12[1].bkgr=-1;
keybrd5.c:  butn12[2].bkgr=-1;
keybrd5.c:  butn12[3].bkgr=-1;
keybrd5.c:  butn12[4].bkgr=-1;
keybrd5.c:  butn12[5].bkgr=-1;
keybrd5.c:  butn12[6].bkgr=-1;
keybrd5.c:  butn12[7].bkgr=-1;
keybrd5.c:  butn12[8].bkgr=-1;
keybrd5.c:  butn12[9].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b12.item = -1;
keybrd5.c:  butn13[0].bkgr=-1;
keybrd5.c:  butn13[1].bkgr=-1;
keybrd5.c:  butn13[2].bkgr=-1;
keybrd5.c:  butn13[3].bkgr=-1;
keybrd5.c:  butn13[4].bkgr=-1;
keybrd5.c:  butn13[5].bkgr=-1;
keybrd5.c:  butn13[6].bkgr=-1;
keybrd5.c:  butn13[7].bkgr=-1;
keybrd5.c:  butn13[8].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b13.item = -1;
keybrd5.c:  butn14[0].bkgr=-1;
keybrd5.c:  butn14[1].bkgr=-1;
keybrd5.c:  butn14[2].bkgr=-1;
keybrd5.c:  butn14[3].bkgr=-1;
keybrd5.c:  butn14[4].bkgr=-1;
keybrd5.c:  butn14[5].bkgr=-1;
keybrd5.c:  butn14[6].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b14.item = -1;
keybrd5.c:  butn15[0].bkgr=-1;
keybrd5.c:  butn15[1].bkgr=-1;
keybrd5.c:  butn15[2].bkgr=-1;
keybrd5.c:  butn15[3].bkgr=-1;
keybrd5.c:  butn15[4].bkgr=-1;
keybrd5.c:  butn15[5].bkgr=-1;
keybrd5.c:  butn15[6].bkgr=-1;
keybrd5.c:  butn15[7].bkgr=-1;
keybrd5.c:  butn15[8].bkgr=-1;
keybrd5.c:  butn15[9].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b15.item = -1;
keybrd5.c:  butn16[0].bkgr=-1;
keybrd5.c:  butn16[1].bkgr=-1;
keybrd5.c:  butn16[2].bkgr=-1;
keybrd5.c:  butn16[3].bkgr=-1;
keybrd5.c:  butn16[4].bkgr=-1;
keybrd5.c:  butn16[5].bkgr=-1;
keybrd5.c:  butn16[6].bkgr=-1;
keybrd5.c:  butn16[7].bkgr=-1;
keybrd5.c:  butn16[8].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b16.item = -1;
keybrd5.c:  butn17[0].bkgr=-1;
keybrd5.c:  butn17[1].bkgr=-1;
keybrd5.c:  butn17[2].bkgr=-1;
keybrd5.c:  butn17[3].bkgr=-1;
keybrd5.c:  butn17[4].bkgr=-1;
keybrd5.c:  butn17[5].bkgr=-1;
keybrd5.c:  butn17[6].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b17.item = -1;
keybrd5.c:  butn18[0].bkgr=-1;
keybrd5.c:  butn18[1].bkgr=-1;
keybrd5.c:  butn18[2].bkgr=-1;
keybrd5.c:  butn18[3].bkgr=-1;
keybrd5.c:  butn18[4].bkgr=-1;
keybrd5.c:  butn18[5].bkgr=-1;
keybrd5.c:  butn18[6].bkgr=-1;
keybrd5.c:  butn18[7].bkgr=-1;
keybrd5.c:  butn18[8].bkgr=-1;
keybrd5.c:  butn18[9].bkgr=-1;
keybrd5.c:  butn18[10].bkgr=-1;
keybrd5.c:  butn18[11].bkgr=-1;
keybrd5.c:  butn18[12].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b18.item = -1;
keybrd5.c:  butn19[0].bkgr=-1;
keybrd5.c:  butn19[1].bkgr=-1;
keybrd5.c:  butn19[2].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b19.item = -1;
keybrd5.c:  butn20[0].bkgr=-1;
keybrd5.c:  butn20[1].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b20.item = -1;
keybrd5.c:  butn21[0].bkgr=-1;
keybrd5.c:  butn21[1].bkgr=-1;
keybrd5.c:  butn21[2].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b21.item = -1;
keybrd5.c:  butn22[0].bkgr=-1;
keybrd5.c:  butn22[1].bkgr=-1;
keybrd5.c:  butn22[2].bkgr=-1;
keybrd5.c:  butn22[3].bkgr=-1;
keybrd5.c:  butn22[4].bkgr=-1;
keybrd5.c:  butn22[5].bkgr=-1;
keybrd5.c:  butn22[6].bkgr=-1;
keybrd5.c:  butn22[7].bkgr=-1;
keybrd5.c:  butn22[8].bkgr=-1;
keybrd5.c:  butn22[9].bkgr=-1;
keybrd5.c:  butn22[10].bkgr=-1;
keybrd5.c:  butn22[11].bkgr=-1;
keybrd5.c:  butn22[12].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b22.item = -1;
keybrd5.c:  butn23[0].bkgr=-1;
keybrd5.c:  butn23[1].bkgr=-1;
keybrd5.c:  butn23[2].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b23.item = -1;
keybrd5.c:  butn24[0].bkgr=-1;
keybrd5.c:  butn24[1].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b24.item = -1;
keybrd5.c:  butn25[0].bkgr=-1;
keybrd5.c:  butn25[1].bkgr=-1;
keybrd5.c:  butn25[2].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b25.item = -1;
keybrd5.c:  butn26[0].bkgr=-1;
keybrd5.c:  strcpy(butn26[1].title,(char *)"Cntl-C");
keybrd5.c:  butn26[1].bkgr=-1;
keybrd5.c:  strcpy(butn26[2].title,(char *)"Cntl-D");
keybrd5.c:  butn26[2].bkgr=-1;
keybrd5.c:  strcpy(butn26[3].title,(char *)"Cntl-S");
keybrd5.c:  butn26[3].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b26.item = -1;
keybrd5.c:  butn27[0].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b27.item = -1;
keybrd5.c:  butn28[0].bkgr=-1;
keybrd5.c:  butn28[1].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b28.item = -1;
keybrd5.c:  butn29[0].bkgr=-1;
keybrd5.c:  butn29[1].bkgr=-1;
keybrd5.c:  butn29[2].bkgr=-1;
keybrd5.c:  butn29[3].bkgr=-1;
keybrd5.c:    2,0.150000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
keybrd5.c:  b29.item = -1;
keybrd5.c:  dtmp = D->d;
keybrd5.c:  d[0].p->item = -1;
keybrd5.c:  d[1].p->item = -1;
keybrd5.c:  d[2].p->item = -1;
keybrd5.c:  d[3].p->item = -1;
keybrd5.c:  d[4].N->item = -1;
keybrd5.c:  d[5].N->item = -1;
keybrd5.c:  d[6].N->item = -1;
keybrd5.c:  d[7].N->item = -1;
keybrd5.c:  d[8].N->item = -1;
keybrd5.c:  d[9].N->item = -1;
keybrd5.c:  d[10].N->item = -1;
keybrd5.c:  d[11].N->item = -1;
keybrd5.c:  d[12].N->item = -1;
keybrd5.c:  d[13].N->item = -1;
keybrd5.c:  d[14].N->item = -1;
keybrd5.c:  d[15].N->item = -1;
keybrd5.c:  d[16].N->item = -1;
keybrd5.c:  d[17].N->item = -1;
keybrd5.c:  d[18].N->item = -1;
keybrd5.c:  d[19].N->item = -1;
keybrd5.c:  d[20].N->item = -1;
keybrd5.c:  d[21].N->item = -1;
keybrd5.c:  d[22].N->item = -1;
keybrd5.c:  d[23].N->item = -1;
keybrd5.c:  d[24].N->item = -1;
keybrd5.c:  d[25].N->item = -1;
keybrd5.c:  d[26].N->item = -1;
keybrd5.c:  d[27].N->item = -1;
keybrd5.c:  d[28].N->item = -1;
keybrd5.c:  d[29].N->item = -1;
keybrd5.c:  D->d = dtmp;
keybrd5.c:   d = (DIA *)(D->d);
keybrd5.c:     if(xm > (d[i].t->x1) ) xm = d[i].t->x1;
keybrd5.c:     if(ym > (d[i].t->y1) ) ym = d[i].t->y1;
keybrd5.c://   kgShiftGrp(D,GrpId,xo-43,yo-28);
keybrd5.c:   kgShiftGrp(D,Kbrd->GrpId,xo-xm,yo-ym);
keybrd5.c:   Kbrd->grp1 = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[0+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[3+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[4+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[5+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[6+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[7+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[8+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[9+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[10+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[11+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[26+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[27+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[28+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp1,d[29+offset].t);
keybrd5.c:   Kbrd->sgrp = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->sgrp,d[12+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->sgrp,d[13+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->sgrp,d[14+offset].t);
keybrd5.c:   Kbrd->cgrp = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->cgrp,d[15+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->cgrp,d[16+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->cgrp,d[17+offset].t);
keybrd5.c:   Kbrd->grp3 = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp3,d[18+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp3,d[19+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp3,d[20+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp3,d[21+offset].t);
keybrd5.c:   Kbrd->grp2 = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp2,d[22+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp2,d[23+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp2,d[24+offset].t);
keybrd5.c:   kgAddtoGrp(D,Kbrd->grp2,d[25+offset].t);
keybrd5.c:   Kbrd->offgrp = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->offgrp,d[1+offset].t);
keybrd5.c:   Kbrd->ongrp = kgOpenGrp(D);
keybrd5.c:   kgAddtoGrp(D,Kbrd->ongrp,d[2+offset].t);
keybrd5.c:   Kbrd->CurWid = -1;
keybrd5.c:   Kbrd->Vis = Vis;
keybrd5.c:   Kbrd->D = D;
keybrd5.c:   Kbrd->ShiftPress=0;
keybrd5.c:   Kbrd->CapsLock=0;
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->GrpId,0);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd5.c:    kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd5.c:     clr = -clr;
keybrd5.c:   D->Kbrd = Kbrd;
keybrd5.c:   gc = D->gc;
keybrd5.c:   Kbrd->TargetWindow = NULL;
keybrd5.c:   Kbrd->FillClr = ConvertColor(bkgrclr,80);
keybrd5.c:   Kbrd->XpmList = NULL;
keybrd5.c:   Kbrd->Thds=NULL;
keybrd5.c:   Kbrd->Brfac =Brfac;
keybrd5.c:   D->wc=NULL;
keybrd5.c:   if (By<30) strcpy(Kbrd->Sfac,"11");
keybrd5.c:   else if(By < 42) strcpy(Kbrd->Sfac,"54");
keybrd5.c:        else strncpy(Kbrd->Sfac,Sfac,3);
keybrd5.c:   Kbrd->Sfac[2]='\0';
keybrd5.c:   Kbrd->Bclr = Bclr;
keybrd5.c:   Kbrd->Bfont = Bfont;
keybrd5.c:   Kbrd->kbtype=5;
keybrd5.c:   Kbrd->Btype=btype;
keybrd5.c:   Kbrd->ButClr = ButClr;
keybrd5.c:   Kbrd->Rfac = rfac;
keybrd5.c:   Kbrd->Bx = Bx;
keybrd5.c:   Kbrd->By = By;
keybrd5.c:   Kbrd->Xg = Xg;
keybrd5.c:   Kbrd->Yg = Yg;
keybrd5.c:   Kbrd->Bodr = Bodr;
keybrd5.c:   gc = D->gc;
keybrd5.c:   D->wc=NULL;
keybrd5.c:   Kbrd->Btype=Btype;
keybrd5.c:   Kbrd->Rfac = Rfac;
keybrd5.c:   Kbrd->trans = transparency;
keybrd5.c:   dtmp = D->d;
keybrd5.c:   Kbrd->Thds=NULL;
keybrd5.c:   if(Kbrd->Btype < 1) {
keybrd5.c:     Kbrd->Thds = Thds;
keybrd5.c:     Kbrd->Thds= NULL;
keybrd5.c:   Kbrd->GrpId= GrpId;
keybrd5.c:   Gpt->arg= v; // kulina will double free this; you may modify
keybrd5.c:  switch(ki->kbtype) {
keybrd5.c:      kgMakeKeybrd5(D,ki->xl,ki->yl,ki->xg,ki->yg,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans,ki->Bodr,ki->Brfac);
keybrd5.c:      kgMakeKeybrd4(D,ki->xl,ki->yl,ki->xg,ki->yg,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans,ki->Bodr,ki->Brfac);
keybrd5.c:      kgMakeKeybrd0(D,ki->xl,ki->yl,ki->xg,ki->yg,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans,ki->Bodr,ki->Brfac);
keybrd5.c:      kgMakeKeybrd1(D,0,0,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans);
keybrd5.c:      kgMakeKeybrd2(D,0,0,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans);
keybrd5.c:      kgMakeKeybrd3(D,0,0,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans);
keybrd5.c:      kgMakeKeybrd5(D,ki->xl,ki->yl,ki->xg,ki->yg,Vis,ki->btype,ki->font,
keybrd5.c:        ki->charclr,ki->butclr,ki->fillclr,ki->rfac,ki->trans,ki->Bodr,ki->Brfac);
keybrd5.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
keybrd5.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
keybrd5Callbacks.c:static char Label1[]="`1234567890-=";
keybrd5Callbacks.c://  KBINFO Ki= {-123132123,-216226216,-49054049,64,44,4,4,0,25,0.300000,0.000000,4,10,0.0};
keybrd5Callbacks.c:  KBINFO Ki= {-216226216,-216226216,-39044039,64,44,4,4,6,25,0.300000,0.000000,4,10,0.0};
keybrd5Callbacks.c:  sprintf(buff,"%-s/.kulina",getenv("HOME"));
keybrd5Callbacks.c:        &(ki->fillclr),&(ki->butclr),&(ki->charclr),
keybrd5Callbacks.c:        &(ki->xl),&(ki->yl),&(ki->xg),&(ki->yg),&(ki->btype),&(ki->font),
keybrd5Callbacks.c:        &(ki->rfac),&(ki->trans),
keybrd5Callbacks.c:        &(ki->kbtype),&(ki->Bodr),&(ki->Brfac));
keybrd5Callbacks.c:     kgUserFrame(fid,-1.0,-1.0,(float)xl+1.0,(float)yl+1.0);
keybrd5Callbacks.c:     kgUserFrame(fid,-1.0,-1.0,(float)xl+1.0,(float)yl+1.0);
keybrd5Callbacks.c:   yp= (yl-h)/2.0;
keybrd5Callbacks.c:   if(ln> (xl-w) ) {
keybrd5Callbacks.c:     fac = (xl-w)/ln;
keybrd5Callbacks.c:   xp = ((float)xl -ln)*0.5;
keybrd5Callbacks.c:     xp= xl-1.5*w;
keybrd5Callbacks.c:     yp= yl -1.2*h;
keybrd5Callbacks.c://  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !c%2.2d!z23!u%-s",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str,Kbrd->FillClr,ustr);
keybrd5Callbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !c%2.2d!z23!u%-s",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str,Kbrd->Bclr,ustr);
keybrd5Callbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s!g !g",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str);
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c: switch(Kbrd->ShiftPress) {
keybrd5Callbacks.c:      switch(Kbrd->CapsLock) {
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,1);
keybrd5Callbacks.c:      switch(Kbrd->CapsLock) {
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp3,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,0);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp1,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->grp2,1);
keybrd5Callbacks.c:          kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->ShiftPress=0;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  CurWid = Kbrd->CurWid;
keybrd5Callbacks.c:  if(D->InputWid >= 0) {
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:     CurWid = Kbrd->CurWid;
keybrd5Callbacks.c:    ch= Label[butno-1];
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      ch= Label[butno-1];
keybrd5Callbacks.c:      kgSendKeyToWindow(D,Kbrd->TargetWindow,ch);
keybrd5Callbacks.c:  if(Kbrd->ShiftPress) {
keybrd5Callbacks.c:    Kbrd->ShiftPress=0;
keybrd5Callbacks.c:   if(B->type > 0){
keybrd5Callbacks.c:   xl =B->lngth;
keybrd5Callbacks.c:   yl =B->width;
keybrd5Callbacks.c:   clr =kb->ButClr;
keybrd5Callbacks.c:   if(clr < -1) {
keybrd5Callbacks.c:     clr = -clr;
keybrd5Callbacks.c:     if(clr == -1) clr= 1;
keybrd5Callbacks.c:   return MakeBkgrImage(xl,yl,r,g,b,B->fac);
keybrd5Callbacks.c:   but = (BUT_STR *)B->buts;
keybrd5Callbacks.c:   if(B->type > 0) {
keybrd5Callbacks.c:   xl =B->lngth;
keybrd5Callbacks.c:   yl =B->width;
keybrd5Callbacks.c://   xl = (xl+1)/2*2-1;
keybrd5Callbacks.c://   yl = (yl+1)/2*2-1;
keybrd5Callbacks.c:   clr =kb->ButClr;
keybrd5Callbacks.c://   img = MakeStringImage4(xl,yl,clr,B->fac,kb->Bclr,kb->FillClr,kb->Bfont,str,ustr);
keybrd5Callbacks.c:   img = MakeStringImage4(xl,yl,clr,B->fac,kb->Bclr,kb->Bclr,kb->Bfont,str,ustr);
keybrd5Callbacks.c:    B = (DIN *)im->B;
keybrd5Callbacks.c:    kb = (KEYBRD *)im->kb;
keybrd5Callbacks.c:    GetStringImg4(B,im->index,kb,im->str,im->ustr);
keybrd5Callbacks.c:   but = (BUT_STR *)B->buts;
keybrd5Callbacks.c:   n = B->nx * B->ny;
keybrd5Callbacks.c:   B->type = Kbrd->Btype;
keybrd5Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd5Callbacks.c:    but[i].bkgr = Kbrd->ButClr;
keybrd5Callbacks.c:    if(B->type > 0)  {
keybrd5Callbacks.c:      im->B = B;
keybrd5Callbacks.c:      im->kb = Kbrd;
keybrd5Callbacks.c:      strncpy(im->str,but[i].title,80);
keybrd5Callbacks.c:      im->str[80]='\0';
keybrd5Callbacks.c:      im->ustr[0]='\0';
keybrd5Callbacks.c:      im->index = i;
keybrd5Callbacks.c:      if(Kbrd->Thds != NULL) DoInAnyThread(Kbrd->Thds,CreateButImage4,(void *)im);
keybrd5Callbacks.c:   if(Kbrd->Thds != NULL) WaitThreads(Kbrd->Thds);
keybrd5Callbacks.c:   n = B->nx * B->ny;
keybrd5Callbacks.c:   but = (BUT_STR *)B->buts;
keybrd5Callbacks.c:   B->type = Kbrd->Btype;
keybrd5Callbacks.c:   B->fac = Kbrd->Rfac;
keybrd5Callbacks.c:   if(B->type > 0)  {
keybrd5Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd5Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd5Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd5Callbacks.c:      im->B = B;
keybrd5Callbacks.c:      im->kb = Kbrd;
keybrd5Callbacks.c:      strncpy(im->str,buff,80);
keybrd5Callbacks.c:      im->str[80]='\0';
keybrd5Callbacks.c:      im->ustr[0]='\0';
keybrd5Callbacks.c:      im->index = i;
keybrd5Callbacks.c:      if(Kbrd->Thds != NULL) DoInAnyThread(Kbrd->Thds,CreateButImage4,(void *)im);
keybrd5Callbacks.c:      but[i].bkgr = Kbrd->ButClr;
keybrd5Callbacks.c:      im->B = B;
keybrd5Callbacks.c:      im->kb = Kbrd;
keybrd5Callbacks.c:      strcpy(im->str,buff);
keybrd5Callbacks.c:      strcpy(im->ustr,buff1);
keybrd5Callbacks.c:      im->index = i;
keybrd5Callbacks.c:      if(Kbrd->Thds != NULL) DoInAnyThread(Kbrd->Thds,CreateButImage4,(void *)im);
keybrd5Callbacks.c:   if(Kbrd->Thds != NULL) WaitThreads(Kbrd->Thds);
keybrd5Callbacks.c:   kgUserFrame(fid,-2.,-2.,(float)xl+2,(float)yl+2);
keybrd5Callbacks.c://    B->nodrawbkgr = NOBKGR;
keybrd5Callbacks.c:    Bx = kb->Bx;
keybrd5Callbacks.c:    By = kb->By;
keybrd5Callbacks.c:    Xg = kb->Xg;
keybrd5Callbacks.c:    Yg = kb->Yg;
keybrd5Callbacks.c:    Bodr = kb->Bodr;
keybrd5Callbacks.c:    x1 = B->x1-13,y1 = B->y1-9;
keybrd5Callbacks.c:    B->xgap =Xg;
keybrd5Callbacks.c:    if(B->xgap < 0) B->xgap =0;
keybrd5Callbacks.c:    B->ygap =Yg;
keybrd5Callbacks.c:    x1 = (xoff*(Bx+Xg)*0.5+0.1)-Bxoff+Bodr;
keybrd5Callbacks.c:    y1 = (yoff*(By+Yg)*0.5+0.1)-Byoff+Bodr;
keybrd5Callbacks.c:    B->x1 = x1;
keybrd5Callbacks.c:    B->y1 = y1;
keybrd5Callbacks.c://    yfac = B->width/36.0;
keybrd5Callbacks.c:    xfac = (int)(B->lngth/(Dbx*0.5)+0.05);
keybrd5Callbacks.c:    yfac = (int)(B->width/(Dby*0.5)+0.05);
keybrd5Callbacks.c:    B->lngth = Bx*xfac+0.1;
keybrd5Callbacks.c:    B->width = By*yfac+0.1;
keybrd5Callbacks.c:    if(xfac > 1.0 ) B->lngth += (xfac-1.0)*Xg;
keybrd5Callbacks.c:    if(yfac > 1.0 ) B->width += (yfac-1.0)*Yg;
keybrd5Callbacks.c:    xl = (B->lngth+B->xgap)*B->nx;
keybrd5Callbacks.c:    yl = (B->width+B->ygap)*B->ny;
keybrd5Callbacks.c:    B->x2 = x1+xl-1;
keybrd5Callbacks.c:    B->y2 = y1+yl-1;
keybrd5Callbacks.c:    B->nodrawbkgr = NOBKGR;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      kgSendBackspaceKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    kb->TargetWindow = win;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      kgSendEscapeKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0) {
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      if(butno==1) kgSendHomeKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      else kgSendEndKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      kgSendEnterKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CapsLock = (Kbrd->CapsLock+1)%2;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      kgSendTabKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0) {
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      if(butno==1) kgSendLeftKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      else kgSendRightKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      kgSendSpaceKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:      kgSendControlKeyToWindow(D,Kbrd->TargetWindow,ch);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:      Kbrd->ShiftPress = (Kbrd->ShiftPress+1)%2;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd->ShiftPress = (Kbrd->ShiftPress+1)%2;
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0){
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c:          kgSendDeleteKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:          kgSendInsertKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:    kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrd5Callbacks.c:  n = B->nx*B->ny;
keybrd5Callbacks.c:  Kbrd = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Kbrd->CurWid =-1;
keybrd5Callbacks.c:  if(D->InputWid >= 0) { 
keybrd5Callbacks.c:     Kbrd->CurWid = D->InputWid;
keybrd5Callbacks.c:  if(Kbrd->CurWid < 0) {
keybrd5Callbacks.c:    if(Kbrd->TargetWindow != NULL) {
keybrd5Callbacks.c://      kgSetInputFocus(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:          kgSendPageupKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:          kgSendPagedownKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:          kgSendUpKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:          kgSendDownKeyToWindow(D,Kbrd->TargetWindow);
keybrd5Callbacks.c:   kgSetCurrentWidget(D,Kbrd->CurWid);
keybrd5Callbacks.c:  pt = D->pt;
keybrd5Callbacks.c:  pt = D->pt;
keybrd5Callbacks.c:  if(kbe->event ==1) {
keybrd5Callbacks.c:    if(kbe->button ==1) {
keybrd5Callbacks.c:  dx = xres - D->xl;
keybrd5Callbacks.c:  dy = yres - D->yl;
keybrd5Callbacks.c:  D->xl= xres;
keybrd5Callbacks.c:  D->yl= yres;
keybrd5Callbacks.c:  d = D->d;
keybrd5Callbacks.c:  kb = (KEYBRD *)D->Kbrd;
keybrd5Callbacks.c:  Bx = kb->Bx;
keybrd5Callbacks.c:  By = kb->By;
keybrd5Callbacks.c:  Xg = kb->Xg;
keybrd5Callbacks.c:  Yg = kb->Yg;
keybrd5Callbacks.c:  Bodr = kb->Bodr;
keybrd5Callbacks.c:  D->xo = 0,D->yo=0;
keybrd5Callbacks.c:  D->xl = 14.5*(Bx+Xg)+2*Bodr+3;
keybrd5Callbacks.c:  D->yl = 4.5*(By+Yg)+2*Bodr;
keybrd5Callbacks.c:    if(B->code == 'n') {
keybrd5Callbacks.c://      fprintf(stderr,"%s : %d\n",B->Wid,i);
keybrd5Callbacks.c:  B->lngth = Bx*1.5;
keybrd5Callbacks.c:  B->lngth = Bx*2+Xg;
keybrd5Callbacks.c:  P->x1= 1;
keybrd5Callbacks.c:  P->y1= 1;
keybrd5Callbacks.c:  P->x2= xl-1;
keybrd5Callbacks.c:  P->y2= yl-1;
keybrd5Callbacks.c:  kgGetDefaultRGB(kb->FillClr,&Rd,&Gn,&Bl);
keybrd5Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,Rd,Gn,Bl,kb->Brfac);
keybrd5Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd5Callbacks.c:  P->transparency = kb->trans;
keybrd5Callbacks.c:  P->bordr = 0;
keybrd5Callbacks.c:  B->y1= (By)*4+4*Yg+Bodr+By/5;
keybrd5Callbacks.c:  B->y1= yl-15;
keybrd5Callbacks.c:  B->x1= Bodr+10;
keybrd5Callbacks.c:  B->y2= B->y1+8;
keybrd5Callbacks.c:  B->x2= B->x1+8;
keybrd5Callbacks.c:  B->y1= (By)*4+4*Yg+Bodr+By/5;
keybrd5Callbacks.c:  B->y1= yl-15;
keybrd5Callbacks.c:  B->x1= Bodr+10;
keybrd5Callbacks.c:  B->y2= B->y1+8;
keybrd5Callbacks.c:  B->x2= B->x1+8;
keybrd5Callbacks.c:  B->y1= (By)*4+4*Yg+Bodr+By/5-5;
keybrd5Callbacks.c:  B->y1= yl-20;
keybrd5Callbacks.c:  B->x1= Bodr+20;
keybrd5Callbacks.c:  B->x2= B->x1+70;
keybrd5Callbacks.c:  B->y2= B->y1+16;
keybrd5Callbacks.c:  P->bordr=0;
keybrd5Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,30,25,30,0.5);
keybrd5Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd5Callbacks.c:  P->bordr=0;
keybrd5Callbacks.c:  P->xpm = MakeLightImage(P->x2-P->x1,P->y2-P->y1,220,25,30,0.5);
keybrd5Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd5Callbacks.c:  P->xpm = kgStringToImage((char *)"Caps Lock",NULL,P->x2-P->x1,P->y2-P->y1,16,kb->ButClr,-1,(P->y2-P->y1),kb->FillClr);
keybrd5Callbacks.c:  Dadd(XpmList,P->xpm);
keybrd5Callbacks.c:  P->transparency = kb->trans;
keybrd5Callbacks.c:  if(D->xl < (xl+1)) D->xl = (xl+1);
keybrd5Callbacks.c:  if(D->yl < (yl+1)) D->yl = (yl+1);
keybrdCallbacks.c:   Kbrd = D->Kbrd;
keybrdCallbacks.c:   Kbrd->CurWid = CurWid;
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  CurWid = Kbrd->CurWid;
keybrdCallbacks.c:  ch= Label[butno-1];
keybrdCallbacks.c:  if(Kbrd->ShiftPress) {
keybrdCallbacks.c:    Kbrd->ShiftPress=0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) {
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  CurWid = Kbrd->CurWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  ch= Label[butno-1];
keybrdCallbacks.c:  if(Kbrd->ShiftPress) {
keybrdCallbacks.c:    Kbrd->ShiftPress=0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  char Label[]="~!@#$%^&*()_+`1234567890-=";
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->ShiftPress=0;
keybrdCallbacks.c:  switch(Kbrd->CapsLock) {
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->ongrp,0);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->offgrp,1);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->offgrp,0);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->ongrp,1);
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c: switch(Kbrd->ShiftPress) {
keybrdCallbacks.c:      switch(Kbrd->CapsLock) {
keybrdCallbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,0);
keybrdCallbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,1);
keybrdCallbacks.c:          kgSetGrpVisibility(D,Kbrd->sgrp,0);
keybrdCallbacks.c:          kgSetGrpVisibility(D,Kbrd->cgrp,1);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CapsLock = (Kbrd->CapsLock+1)%2;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CapsLock = (Kbrd->CapsLock+1)%2;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) {
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) {
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) {
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->ShiftPress = (Kbrd->ShiftPress+1)%2;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  n = B->nx*B->ny;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) {
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
keybrdCallbacks.c:  Kbrd = D->Kbrd;
keybrdCallbacks.c:  Kbrd->CurWid =-1;
keybrdCallbacks.c:  if(D->InputWid >= 0) { 
keybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
keybrdCallbacks.c:  if(Kbrd->CurWid< 0) return 0;
keybrdCallbacks.c:  pt = D->pt;
keybrdCallbacks.c:  pt = D->pt;
keybrdCallbacks.c:  if(kbe->event ==1) {
keybrdCallbacks.c:    if(kbe->button ==1) {
keybrdCallbacks.c:  dx = xres - D->xl;
keybrdCallbacks.c:  dy = yres - D->yl;
keybrdCallbacks.c:  D->xl= xres;
keybrdCallbacks.c:  D->yl= yres;
kgMakeGclr.c:	if(Tmp1 != NULL) gc = &(((DIALOG *)Tmp1)->gc);
kgMakeGclr.c:	else gc = &(((DIALOG *)Tmp)->gc);
kgMakeGclr.c:		th0[i]->img = kgBorderedRectangle(60,50,gcclrs[i].clrno,0.0);
kgMakeGclr.c:	r0->list = (void **)th0;
kgMakeGclr.c:	fprintf(fp,"  gc = &(D->gc);\n");
kgMakeGclr.c:		fprintf(fp,"  gc->%-s = %d;\n",gcclrs[i].vname,gcclrs[i].clrno);
kgMakeGclr.c://	sprintf(buf,"Gclr%-s.c",DiaName);
kgMakeGclr.c:	args = (void **)(D->pt);
kgMakeGclr.c:	sprintf(buf,"Gclr%-s.c",(char *)(args[0]));
kgMakeGclr.c://	sprintf(buf,"void Modify%-sGc(void *Tmp) {",DiaName);
kgMakeGclr.c:	sprintf(buf,"void Modify%-sGc(void *Tmp) {",(char *)(args[0]));
kgMakeGclr.c:	fprintf(fp,"  gc = &(D->gc);\n");
kgMakeGclr.c:		fprintf(fp,"  gc->%-s = %d;\n",gcclrs[i].vname,gcclrs[i].clrno);
kgMakeGclr.c:	fprintf(fp,"//  kgMkgclr(\"%-s\",Tmp);\n",(char *)(args[0]));
kgMakeGclr.c:    i :  Index of Widget  (0 to max_widgets-1) 
kgMakeGclr.c:  n = B->nx;
kgMakeGclr.c:      system("tar xf /usr/share/kulina/demo.tar -C /tmp");
kgMakeGclr.c:      system("make -C /tmp/demo"); 
kgMakeGclr.c:    i :  Index of Widget  (0 to max_widgets-1) 
kgMakeGclr.c:  j = item -1;
kgMakeGclr.c:  pt = D->pt;
kgMakeGclr.c:  th0 = (ThumbNail **) (Y->list);
kgMakeGclr.c:  th0[j]->img = kgBorderedRectangle(60,50,gcclrs[j].clrno,0.0);
kgMakeGclr.c: // One may setup browser list here by setting Y->list
kgMakeGclr.c: // if it need to be freed set it as Y->pt also
kgMakeGclr.c:  pt = D->pt;
kgMakeGclr.c:  pt = D->pt;
kgMakeGclr.c:  d = D->d;
kgMakeGclr.c:  if(kbe->event ==1) {
kgMakeGclr.c:    if(kbe->button ==1) {
kgMakeGclr.c:  dx = xres - D->xl;
kgMakeGclr.c:  dy = yres - D->yl;
kgMakeGclr.c:  D->xl= xres;
kgMakeGclr.c:  D->yl= yres;
kgMakeGclr.c:   gc = &(D->gc);
kgMakeGclr.c:   gc->FontSize =8;
kgMakeGclr.c:   gc->Font=23;
kgMakeGclr.c:  butn0[0].bkgr=-1;
kgMakeGclr.c:  butn0[1].bkgr=-1;
kgMakeGclr.c:  butn0[2].bkgr=-1;
kgMakeGclr.c:    5,0.500000,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
kgMakeGclr.c:  h0.item = -1;
kgMakeGclr.c:  y1.item = -1;
kgMakeGclr.c:  dtmp = D->d;
kgMakeGclr.c:  d[0].h->item = -1;
kgMakeGclr.c:  d[1].y->item = -1;
kgMakeGclr.c:  D->d = dtmp;
kgMakeGclr.c:   Gpt->arg= v; // kulina will double free this; you may modify
kgMakeGclr.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
kgMakeGclr.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgl.c:#define uicnv_x(dc,x) (x*dc->Fx-dc->Sx)
kgl.c:#define uicnv_y(dc,y) (y*dc->Fy-dc->Sy)
kgl.c:#define uicnv_z(dc,z) ( ((z)-dc->clip_min)/(dc->clip_max - dc->clip_min)*ZRES )
kgl.c:   dc->trnstr.xstr = (xp * dc->FM[0]) + (yp * dc->FM[4]) + (zp * dc->FM[8]) + dc->FM[12];\
kgl.c:   dc->trnstr.ystr = (xp * dc->FM[1]) + (yp * dc->FM[5]) + (zp * dc->FM[9]) + dc->FM[13];\
kgl.c:   dc->trnstr.zstr = (xp * dc->FM[2]) + (yp * dc->FM[6]) + (zp * dc->FM[10]) + dc->FM[14];\
kgl.c:     dc->newstr.xstr = -(2.* dc->ze/(oldstr.zstr)) * oldstr.xstr;\
kgl.c:     dc->newstr.ystr = -(2.* dc->ze/(oldstr.zstr)) * oldstr.ystr;\
kgl.c:     dc->newstr.zstr = oldstr.zstr;\
kgl.c: i--;
kgl.c:    if((D->Sticky==1)||(D->Fixpos==1)||(D->NoTaskBar==1)) {
kgl.c:      D->wc =ui_set_graphics_sticky(D->xo,D->yo,D->xl,D->yl,D->name,D->Deco,D->transparency,D->Sticky,D->Fixpos,D->NoTaskBar,D->StackPos,D->Shapexpm);
kgl.c:      WC(D)->D=D;
kgl.c:      D->wc =ui_set_graphics(D->xo,D->yo,D->xl,D->yl,D->name,D->Deco,D->transparency);
kgl.c:      WC(D)->D=D;
kgl.c://    D->wc =ui_set_graphics_sticky(D->xo,D->yo,D->xl,D->yl,D->name,D->Deco,D->transparency,D->Sticky,D->Fixpos,D->NoTaskBar,D->StackPos,D->Shapexpm);
kgl.c:    D->wc = kgSetupGraphics(D);
kgl.c:    WC(D)->D=D;
kgl.c:    WC(D)->Clip=(void *)Dopen();
kgl.c:    WC(D)->GuiFont=D->gc.PromptFont;
kgl.c:    WC(D)->GuiFontSize=D->gc.GuiFontSize;
kgl.c:    WC(D)->event.type=-100;
kgl.c:    WC(D)->eventback.type=-100;
kgl.c:  Gc->fill_clr=44;
kgl.c:  Gc->char_clr=49;
kgl.c:  Gc->bodr_clr=44;
kgl.c:  Gc->cur_clr=  6;
kgl.c:  Gc->high_clr= 45;
kgl.c:  Gc->char_hclr = 47;
kgl.c:  Gc->msg_fill = 45;
kgl.c:  Gc->msg_char = 49;
kgl.c:  Gc->msg_bodr = 47;
kgl.c:  Gc->txt_fill = 43;
kgl.c:  Gc->txt_char = 0;
kgl.c:  Gc->txt_char = 48;
kgl.c:  Gc->txt_pchar  = 49;
kgl.c:  Gc->tabl_fill = 43;
kgl.c:  Gc->tabl_char = 0;
kgl.c:  Gc->tabl_char = 49;
kgl.c:  Gc->tabl_hchar = 47;
kgl.c:  Gc->tabl_line = 41;
kgl.c:  Gc->v_dim= 40;
kgl.c:  Gc->dim =42;
kgl.c:  Gc->bright=46;
kgl.c:  Gc->vbright=47;
kgl.c:  Gc->twin_fill = 45;
kgl.c:  Gc->twin_char = 0;
kgl.c:  Gc->twin_char = 49;
kgl.c:  Gc->twin_bodr = 42;
kgl.c:  Gc->info_fill = 46;
kgl.c:  Gc->info_char = 0;
kgl.c:  Gc->info_char = 49;
kgl.c:  Gc->but_char=49;
kgl.c:  Gc->menu_char=49;
kgl.c:  Gc->c_bound = 46;
kgl.c:  Gc->GuiFontSize =9;
kgl.c:  Gc->GuiFontSize =10;
kgl.c:  Gc->MenuFont = 21;
kgl.c:  Gc->PromptFont = 21;
kgl.c:  Gc->ButtonFont = 23;
kgl.c:  Gc->MsgFont = 21;
kgl.c:  Gc->MenuFont = 20;
kgl.c:  Gc->PromptFont = 21;
kgl.c:  Gc->ButtonFont = 22;
kgl.c:  Gc->FontSize =9;
kgl.c:  Gc->FontSize =10;
kgl.c:  Gc->Font=23;
kgl.c:  Gc->SplashFont=23;
kgl.c:  Gc->SplashFillColor=40;
kgl.c:  Gc->SplashBodrColor=46;
kgl.c:  Gc->SplashCharColor=26;
kgl.c:  Gc->ProgFillColor=46;
kgl.c:  Gc->ProgBodrColor=6;
kgl.c:  Gc->ProgColor=8;
kgl.c:  Gc->ItemHighColor=6;
kgl.c:  Gc->InputFontSize=9;
kgl.c:  Gc->InputFontSize=10;
kgl.c:  Gc->scroll_fill= Gc->fill_clr;
kgl.c:  Gc->scroll_dim= Gc->dim;
kgl.c:  Gc->scroll_bright= Gc->bright;
kgl.c:  Gc->scroll_vbright= Gc->vbright;
kgl.c:  Gc = &(D->gc);
kgl.c://  v = v*(1.05+2*atan(1.-v)/1.57);
kgl.c:    dv = v -vorg;
kgl.c:  Gc->fill_clr=44;
kgl.c:  Gc->char_clr=49;
kgl.c:  Gc->bodr_clr=44;
kgl.c:  Gc->cur_clr=  6;
kgl.c:  Gc->high_clr= 45;
kgl.c:  Gc->char_hclr = 47;
kgl.c:  Gc->msg_fill = 45;
kgl.c:  Gc->msg_char = 49;
kgl.c:  Gc->msg_bodr = 47;
kgl.c:  Gc->txt_fill = 43;
kgl.c:  Gc->txt_char = 48;
kgl.c:  Gc->txt_pchar  = 49;
kgl.c:  Gc->tabl_fill = 43;
kgl.c:  Gc->tabl_char = 48;
kgl.c:  Gc->tabl_hchar = 47;
kgl.c:  Gc->tabl_line = 41;
kgl.c:  Gc->v_dim= 40;
kgl.c:  Gc->dim =42;
kgl.c:  Gc->bright=46;
kgl.c:  Gc->vbright=47;
kgl.c:  Gc->twin_fill = 46;
kgl.c:  Gc->twin_char = 48;
kgl.c:  Gc->twin_bodr = 40;
kgl.c:  Gc->info_fill = 42;
kgl.c:  Gc->info_char = 49;
kgl.c:  Gc->info_fill = 46;
kgl.c:  Gc->but_char=49;
kgl.c:  Gc->menu_char=49;
kgl.c:  Gc->c_bound = 46;
kgl.c:  Gc->GuiFontSize =9;
kgl.c:  Gc->MenuFont = 8;
kgl.c:  Gc->PromptFont = 23;
kgl.c:  Gc->ButtonFont = 23;
kgl.c:  Gc->MsgFont = 24;
kgl.c:  Gc->MenuFont = 8;
kgl.c:  Gc->PromptFont = 32;
kgl.c:  Gc->ButtonFont = 8;
kgl.c:  Gc->MsgFont = 8;
kgl.c:  Gc->FontSize =9;
kgl.c:  Gc->Font=23;
kgl.c:  Gc->SplashFont=4;
kgl.c:  Gc->SplashFillColor=40;
kgl.c:  Gc->SplashBodrColor=46;
kgl.c:  Gc->SplashCharColor=26;
kgl.c:  Gc->ItemHighColor=6;
kgl.c:  Gc->InputFontSize=9;
kgl.c:  Gc->scroll_fill= Gc->fill_clr;
kgl.c:  Gc->scroll_dim= Gc->dim;
kgl.c:  Gc->scroll_bright= Gc->bright;
kgl.c:  Gc->scroll_vbright= Gc->vbright;
kgl.c:  Gc = &(D->gc);
kgl.c:  Gc->v_dim= 61;
kgl.c:  Gc->dim =60;
kgl.c:  Gc->bright=58;
kgl.c:  Gc->vbright=59;
kgl.c:  Gc->fill_clr=54;
kgl.c:  Gc->char_clr=61;
kgl.c:  if(type) Gc->char_clr= 59;
kgl.c:  Gc->bodr_clr=58;
kgl.c:  Gc->cur_clr=  57;
kgl.c:  Gc->high_clr= 59;
kgl.c:  Gc->char_hclr = 61;
kgl.c:  Gc->msg_fill = 55;
kgl.c:  Gc->msg_char = 56;
kgl.c:  Gc->msg_bodr = 58;
kgl.c:  Gc->txt_fill = 62;
kgl.c:  Gc->txt_char = Gc->char_clr;
kgl.c:  Gc->txt_pchar  = Gc->char_clr;
kgl.c:  Gc->tabl_fill = 62;
kgl.c:  Gc->tabl_char = Gc->char_clr;
kgl.c:  Gc->tabl_hchar = 57;
kgl.c:  Gc->tabl_line = 54;
kgl.c:  Gc->twin_fill = 55;
kgl.c:  Gc->twin_char = 56;
kgl.c:  Gc->twin_bodr = 58;
kgl.c:  Gc->info_fill = 55;
kgl.c:  Gc->info_char = 56;
kgl.c:  Gc->but_char=Gc->v_dim;
kgl.c:  if(type) Gc->but_char= vbrt;
kgl.c:  Gc->msg_char = Gc->but_char;
kgl.c:  Gc->menu_char=56;
kgl.c:  Gc->c_bound = 58;
kgl.c:  Gc->GuiFontSize =9;
kgl.c:  Gc->MenuFont = 8;
kgl.c:  Gc->PromptFont = 24;
kgl.c:  Gc->ButtonFont = 16;
kgl.c:  Gc->MsgFont = 1;
kgl.c:  Gc->FontSize =9;
kgl.c:  Gc->Font=16;
kgl.c:  Gc->SplashFont=24;
kgl.c:  Gc->SplashFillColor=55;
kgl.c:  Gc->SplashBodrColor=58;
kgl.c:  Gc->SplashCharColor=56;
kgl.c:  Gc->ProgFillColor=55;
kgl.c:  Gc->ProgBodrColor=58;
kgl.c:  Gc->ProgColor=56;
kgl.c:  Gc->InputFontSize=9;
kgl.c:  Gc->scroll_fill= Gc->fill_clr;
kgl.c:  Gc->scroll_dim= Gc->dim;
kgl.c:  Gc->scroll_bright= Gc->bright;
kgl.c:  Gc->scroll_vbright= Gc->vbright;
kgl.c:  Gc = &(D->gc);
kgl.c:  Gc->v_dim= 61;
kgl.c:  Gc->dim =60;
kgl.c:  Gc->bright=58;
kgl.c:  Gc->vbright=59;
kgl.c:  Gc->fill_clr=54;
kgl.c:  Gc->char_clr=61;
kgl.c:  if(type) Gc->char_clr= 59;
kgl.c:  Gc->bodr_clr=58;
kgl.c:  Gc->cur_clr=  57;
kgl.c:  Gc->high_clr= 59;
kgl.c:  Gc->char_hclr = 61;
kgl.c:  Gc->msg_fill = 55;
kgl.c:  Gc->msg_char = 56;
kgl.c:  Gc->msg_bodr = 58;
kgl.c:  Gc->txt_fill = 62;
kgl.c:  Gc->txt_char = 59;
kgl.c:  if(type) Gc->txt_char = 61;
kgl.c:  Gc->txt_pchar  = Gc->char_clr;
kgl.c:  Gc->tabl_fill = 62;
kgl.c:  Gc->tabl_char = Gc->txt_char;
kgl.c:  Gc->tabl_hchar = 57;
kgl.c:  Gc->tabl_line = 54;
kgl.c:  Gc->twin_fill = 55;
kgl.c:  Gc->twin_char = 56;
kgl.c:  Gc->twin_bodr = 58;
kgl.c:  Gc->info_fill = 55;
kgl.c:  Gc->info_char = 56;
kgl.c:  Gc->but_char=59;
kgl.c:  if(type) Gc->but_char= 61;
kgl.c:  Gc->menu_char=56;
kgl.c:  Gc->c_bound = 58;
kgl.c:  Gc->GuiFontSize =9;
kgl.c:  Gc->MenuFont = 8;
kgl.c:  Gc->PromptFont = 24;
kgl.c:  Gc->ButtonFont = 16;
kgl.c:  Gc->MsgFont = 1;
kgl.c:  Gc->FontSize =9;
kgl.c:  Gc->Font=16;
kgl.c:  Gc->SplashFont=24;
kgl.c:  Gc->SplashFillColor=55;
kgl.c:  Gc->SplashBodrColor=58;
kgl.c:  Gc->SplashCharColor=56;
kgl.c:  Gc->ProgFillColor=55;
kgl.c:  Gc->ProgBodrColor=58;
kgl.c:  Gc->ProgColor=56;
kgl.c:  Gc->InputFontSize=9;
kgl.c:  Gc->scroll_fill= Gc->fill_clr;
kgl.c:  Gc->scroll_dim= Gc->dim;
kgl.c:  Gc->scroll_bright= Gc->bright;
kgl.c:  Gc->scroll_vbright= Gc->vbright;
kgl.c:  Gc->fill_clr=10;
kgl.c:  Gc->char_clr=49;
kgl.c:  Gc->bodr_clr=13;
kgl.c:  Gc->cur_clr=  6;
kgl.c:  Gc->high_clr= 13;
kgl.c:  Gc->char_hclr = 15;
kgl.c:  Gc->msg_fill = 9;
kgl.c:  Gc->msg_char = 14;
kgl.c:  Gc->msg_bodr = 12;
kgl.c:  Gc->txt_fill = 9;
kgl.c:  Gc->txt_char = 48;
kgl.c:  Gc->txt_pchar  = 49;
kgl.c:  Gc->tabl_fill = 11;
kgl.c:  Gc->tabl_char = 8;
kgl.c:  Gc->tabl_hchar = 15;
kgl.c:  Gc->tabl_line = 8;
kgl.c:  Gc->v_dim= 8;
kgl.c:  Gc->dim =9;
kgl.c:  Gc->bright=12;
kgl.c:  Gc->vbright=14;
kgl.c:  Gc->twin_fill = 15;
kgl.c:  Gc->twin_char = 49;
kgl.c:  Gc->twin_bodr = 8;
kgl.c:  Gc->info_fill = 9;
kgl.c:  Gc->info_char = 49;
kgl.c:  Gc->but_char=49;
kgl.c:  Gc->menu_char=49;
kgl.c:  Gc->c_bound = 13;
kgl.c:  Gc->GuiFontSize =9;
kgl.c:  Gc->MenuFont = 8;
kgl.c:  Gc->PromptFont = 32;
kgl.c:  Gc->ButtonFont = 23;
kgl.c:  Gc->MsgFont = 23;
kgl.c:  Gc->FontSize =8;
kgl.c:  Gc->Font=23;
kgl.c:  Gc->SplashFont=4;
kgl.c:  Gc->SplashFillColor=40;
kgl.c:  Gc->SplashBodrColor=46;
kgl.c:  Gc->SplashCharColor=26;
kgl.c:  Gc->ProgFillColor=46;
kgl.c:  Gc->ProgBodrColor=6;
kgl.c:  Gc->ProgColor=8;
kgl.c:  Gc->ItemHighColor=6;
kgl.c:  Gc->InputFontSize=8;
kgl.c:  Gc->scroll_fill= Gc->fill_clr;
kgl.c:  Gc->scroll_dim= Gc->dim;
kgl.c:  Gc->scroll_bright= Gc->bright;
kgl.c:  Gc->scroll_vbright= Gc->vbright;
kgl.c:  G = D->d[i].g;
kgl.c:  G->D= D;
kgl.c:  G->wc = (kgWC *) Malloc(sizeof(kgWC));
kgl.c:  G->dc = dc;
kgl.c:  G->Obj_opn=0;
kgl.c:  dc->Fontlist=NULL;
kgl.c:  for(l=0;l<10;l++) dc->st_ptr[l]=0;
kgl.c:  G->B_min = 10400;
kgl.c:  G->BACK_UP=0;
kgl.c:  G->OPEN=1;
kgl.c:  G->Byte=0;
kgl.c:  G->R_Byte=0;
kgl.c:  G->R_max=0;
kgl.c:  G->D_ON=1;
kgl.c:  G->MAG=1;
kgl.c:  G->img=NULL;
kgl.c:  G->rzimg=NULL;
kgl.c:  G->pixels=NULL;
kgl.c:  kgUserFrame(G,0.,0.,(float)(G->x2-G->x1),(float)(G->y2-G->y1));
kgl.c:  strcpy(flname,D->tmpdir);
kgl.c:  strcpy(dc->objdir,flname);
kgl.c://  printf("%s\n",dc->objdir);
kgl.c:  mkdir(dc->objdir,0700);
kgl.c:  strcpy(dc->reviewfile,dc->objdir);
kgl.c:  strcat(dc->reviewfile,"/reviewdat");
kgl.c:  G->rbuf = open(dc->reviewfile,O_CREAT|O_BINARY|O_TRUNC|O_RDWR,0666);
kgl.c:  strcpy(dc->plotfile,dc->objdir);
kgl.c:  strcat(dc->plotfile,"/plotgph");
kgl.c:  strcpy(dc->cmdsfile,dc->objdir);
kgl.c:  strcat(dc->cmdsfile,"/cmdsfile");
kgl.c:  dc->ls_list=NULL;
kgl.c:  dc->No_of_lights=0;
kgl.c:  G->Rbuff = (unsigned char  *) Malloc(B_max+100);
kgl.c:  G->hbuf =-1;
kgl.c:  /*_______________ESC SEQ BELOW THIS -----------*/
kgl.c:    dc = G->dc;
kgl.c:    if( G->Rbuff == NULL) printf("G->Rbuff= NULL\n");
kgl.c:    for(i = 0; i <n; i++) G->Rbuff[G->Byte++] = *(ch+i);
kgl.c:     if (G->Byte > B_max) {
kgl.c:      if(G->rbuf== -1) {
kgl.c:        G->rbuf = open(dc->reviewfile,O_CREAT|O_BINARY|O_TRUNC|O_RDWR,0666);
kgl.c:        G->OPEN=1;
kgl.c:       WRITE(G->rbuf,(void *)G->Rbuff,B_min);
kgl.c:      j = 0;G->BACK_UP=1;
kgl.c:      for(i=B_min;i<G->Byte;i++)
kgl.c:       G->Rbuff[j++]=G->Rbuff[i];
kgl.c:      G->Byte=j;
kgl.c:     if((G->D != NULL) )ui_vu_port(G,x1,y1,x2,y2);
kgl.c:     if(G->D_ON ==0 ) {
kgl.c:       dc = G->dc;
kgl.c:       if(G->img != NULL) {
kgl.c:        png = G->img;
kgl.c:        if((png->image_width!= dc->EVGAX)||(png->image_height!=dc->EVGAY)){
kgl.c:          uiFreeImage(G->img); 
kgl.c:          if(dc->ZBUFF==1) { ui_release_buf(G); ui_set_zbuf(G); }
kgl.c:          G->img=uiCreateCleangmImage(dc->EVGAX,dc->EVGAY,0,0,0,255);
kgl.c:          png = G->img;
kgl.c:          img = png->image;
kgl.c:          G->pixels=GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
kgl.c:         if(dc->ZBUFF==1) { ui_release_buf(G); ui_set_zbuf(G); }
kgl.c:         G->img=uiCreateCleangmImage(dc->EVGAX,dc->EVGAY,0,0,0,255);
kgl.c:         png = G->img;
kgl.c:         img = png->image;
kgl.c:         G->pixels=GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
kgl.c:       dc = G->dc;
kgl.c:       if(dc->ZBUFF==1) { ui_release_buf(G); ui_set_zbuf(G); }
kgl.c:  dc = G->dc;
kgl.c:  if(G->D == NULL) return;
kgl.c:     if(G->D_ON==0) return;
kgl.c:     G->D_ON=0;
kgl.c:  else G->D_ON= 1;
kgl.c:  if(G->D_ON ==0 ) {
kgl.c:     G->MAG = MAG;
kgl.c:     dc->MAG=MAG;
kgl.c:     if(dc->ZBUFF==1) { ui_release_buf(G); ui_set_zbuf(G); }
kgl.c:     img_viewport(G,dc->vu_x1,dc->vu_y1,dc->vu_x2,dc->vu_y2);
kgl.c:     G->img=uiCreateCleangmImage(dc->EVGAX,dc->EVGAY,0,0,0,255);
kgl.c:     png = G->img;
kgl.c:     G->pixels=GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
kgl.c:    G->MAG=1;
kgl.c:    kgViewport(G,dc->vu_x1,dc->vu_y1,dc->vu_x2,dc->vu_y2);
kgl.c:    if(G->img != NULL) {uiFreeImage(G->img); G->img=NULL;}
kgl.c:    if(G->rzimg != NULL) {uiFreeImage(G->rzimg); G->rzimg=NULL;}
kgl.c:  dc = G->dc;
kgl.c:  if(G->D == NULL) return;
kgl.c:  if(G->D_ON==0) {
kgl.c:    if(G->img != NULL) {uiFreeImage(G->img); G->img=NULL;}
kgl.c:    if(G->rzimg != NULL) {uiFreeImage(G->rzimg); G->rzimg=NULL;}
kgl.c:  G->D_ON= 0;
kgl.c:  G->MAG = MAG;
kgl.c:  dc->MAG=MAG;
kgl.c:  if(dc->ZBUFF==1) { ui_release_buf(G); ui_set_zbuf(G); }
kgl.c:  img_viewport(G,dc->vu_x1,dc->vu_y1,dc->vu_x2,dc->vu_y2);
kgl.c:  G->img=uiCreateCleangmImage(dc->EVGAX,dc->EVGAY,0,0,0,255);
kgl.c:  png = G->img;
kgl.c:  G->pixels=GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
kgl.c:    if(G->D == NULL) return;
kgl.c:    dc = G->dc;
kgl.c:    G->D_ON= 1;
kgl.c:    G->MAG=1;
kgl.c:    kgViewport(G,dc->vu_x1,dc->vu_y1,dc->vu_x2,dc->vu_y2);
kgl.c:    if(G->img != NULL) {uiFreeImage(G->img); G->img=NULL;}
kgl.c:    if(G->rzimg != NULL) {uiFreeImage(G->rzimg); G->rzimg=NULL;}
kgl.c:  dc = G->dc;
kgl.c:  *x1= dc->w_x1; *y1= dc->w_y1;
kgl.c:  *x2= dc->w_x2; *y2= dc->w_y2;
kgl.c:  dc = G->dc;
kgl.c:  *x1= dc->vu_x1; *y1= dc->vu_y1;
kgl.c:  *x2= dc->vu_x2; *y2= dc->vu_y2;
kgl.c:     dc= G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_move(G,x,y);
kgl.c:     dc= G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_smmark(G,mtype);
kgl.c:     dc->m_style=mtype;
kgl.c:     dc= G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_draw(G,x,y);
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_circle(G,x,y,r);
kgl.c:    if(G->Rbuff != NULL) {
kgl.c:    if(G->D_ON)ui_marker(G,x,y);
kgl.c:    if(G->Rbuff != NULL) {
kgl.c:     dc = G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_ln_clr(G,colr);
kgl.c:     else{ dc->ln_color=colr;dc->c_color=colr;}
kgl.c:     dc = G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_txt_clr(G,tcolr);
kgl.c:     else dc->t_color=tcolr;
kgl.c:     dc = G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     txt_htx=h/(dc->w_y2-dc->w_y1)*(dc->w_x2-dc->w_x1);
kgl.c:     txt_wty=w/(dc->w_x2-dc->w_x1)*(dc->w_y2-dc->w_y1);
kgl.c:     txt_spy=g/(dc->w_x2-dc->w_x1)*(dc->w_y2-dc->w_y1);
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     txt_htx=h/(w_y2-w_y1)*(w_x2-w_x1);
kgl.c:     txt_wty=w/(w_x2-w_x1)*(w_y2-w_y1);
kgl.c:     txt_spy=g/(w_x2-w_x1)*(w_y2-w_y1);
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_txt_wr(G,n,c);
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_panel(G,x,y,(int)color,flag,n);
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_box_fill(G,x1,y1,x2,y2,fl,ib);
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON)ui_godr_fill(G,n,x,y,v);
kgl.c:     D = G->D;
kgl.c:     if(G->D_ON) { 
kgl.c:     if(G->D != NULL) {
kgl.c:     if(G->D_ON==0)uiCleangmImage(G->img);
kgl.c:      dc = G->dc;
kgl.c:      wc = G->wc;
kgl.c:        if(G->D != NULL) {
kgl.c:          ans=kgCheckMenu(G->D,G->x1,(G->y1+G->y2)/2,
kgl.c:      fx = (gx2-gx1)/(w[2]-w[0]);
kgl.c:      sx = -(gx1-w[0]*fx);
kgl.c:      fy = (gy2-gy1)/(w[3]-w[1]);
kgl.c:      sy = -(gy1-w[1]*fy);
kgl.c:      if(dc->ZBUFF) {
kgl.c:      if(G->D != NULL) kgUpdateOn(G->D);
kgl.c:   D = G->D;
kgl.c:   dc = G->dc;
kgl.c:   wc = G->wc;
kgl.c:   if(G->Rbuff== NULL) {
kgl.c:   if(dc->PROJ){
kgl.c://     printf( "PROJ = %d\n",dc->PROJ);
kgl.c://     printf( "PROJ = %d\n",dc->PROJ);
kgl.c:     ans=kgCheckMenu(D,D->xo+G->x1,D->yo+(G->y1+G->y2)/2,
kgl.c:   WRITE(pf,(void *)&dc->w_x1,4);
kgl.c:   WRITE(pf,(void *)&dc->w_y1,4);
kgl.c:   WRITE(pf,(void *)&dc->w_x2,4);
kgl.c:   WRITE(pf,(void *)&dc->w_y2,4);
kgl.c:   if(dc->PROJ) {
kgl.c:     WRITE(pf,(void *)&dc->w_x1,4);
kgl.c:     WRITE(pf,(void *)&dc->w_y1,4);
kgl.c:     WRITE(pf,(void *)&dc->w_x2,4);
kgl.c:     WRITE(pf,(void *)&dc->w_y2,4);
kgl.c:     WRITE(pf,(void *)dc->FM,64);
kgl.c:     WRITE(pf,(void *)&(dc->xe),4);
kgl.c:     WRITE(pf,(void *)&(dc->ye),4);
kgl.c:     WRITE(pf,(void *)&(dc->ze),4);
kgl.c:     WRITE(pf,(void *)&(dc->zc),4);
kgl.c:     WRITE(pf,(void *)&(dc->clip_min),4);
kgl.c:     WRITE(pf,(void *)&(dc->clip_max),4);
kgl.c:     if(dc->ZBUFF) WRITE(pf,(void *)&Z,1);
kgl.c:   G->BACK_UP=1;
kgl.c:   uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:   G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY, S_IREAD|S_IWRITE);
kgl.c:   if( G->rbuf<0) return;
kgl.c:   uiread_file(G,G->rbuf); 
kgl.c:   while(G->Byte==G->B_min){
kgl.c:    WRITE(pf,(void *)G->Rbuff,G->Byte);
kgl.c:    uiread_file(G,G->rbuf);
kgl.c:   WRITE(pf,(void *)G->Rbuff,G->Byte);
kgl.c:   G->OPEN=1;
kgl.c:   G->R_Byte=0;
kgl.c:   G->Byte=0;G->R_max=0;
kgl.c:   G = D->d[gindex].g;
kgl.c:   dc = G->dc;
kgl.c:   strcpy(dc->backup,flname);
kgl.c:   for updating 3d-calls to current rotation and clipping
kgl.c:   dc= G->dc;
kgl.c:   strcpy(JunkFile,dc->objdir);
kgl.c:   G->BACK_UP=1;
kgl.c:   uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:   G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY, S_IREAD|S_IWRITE);
kgl.c:   if( G->rbuf<0) return 0;
kgl.c:   uiread_file(G,G->rbuf); 
kgl.c:   while(G->Byte==B_min){WRITE(pf,(void *)G->Rbuff,G->Byte); uiread_file(G,G->rbuf); }
kgl.c:   WRITE(pf,(void *)G->Rbuff,G->Byte);
kgl.c:   G->OPEN=1;
kgl.c:   G->R_Byte=0;
kgl.c:   G->Byte=0;G->R_max=0;
kgl.c:   zbuff = dc->ZBUFF; set3d = dc->SET3D;
kgl.c:   G->D_ON = 0;
kgl.c:   dc->ZBUFF = zbuff, dc->SET3D = set3d;
kgl.c:   kgViewport(G,dc->vu_x1,dc->vu_y1,dc->vu_x2,dc->vu_y2);
kgl.c:   kgUserFrame(G,dc->w_x1,dc->w_y1,dc->w_x2,dc->w_y2);
kgl.c:   G->D_ON = 1;
kgl.c:   if(G->Rbuff != NULL) {
kgl.c:    n = fabs(a2-a1)/th+0.5;
kgl.c:    th = (a2-a1)/n;
kgl.c:    gscanf(G->D,"Give Arc Radius=%10f",&m_radius);
kgl.c:    ang1= atan2( (double)(y1-*yo),(double)(x1-*xo))/3.14159265*180.0; 
kgl.c:    r = sqrt((*xo-x1)*(*xo-x1)+(*yo-y1)*(*yo-y1)); 
kgl.c:    ang1= atan2( (double)(y1-*yo),(double)(x1-*xo))/3.14159265*180.0; 
kgl.c:    ang2= atan2( (double)(y2-*yo),(double)(x2-*xo))/3.14159265*180.0; 
kgl.c:    if( fabs((double)(ang1-ang2))> 359.0) full=1;
kgl.c:    n = fabs(a2-a1)/th+0.5;
kgl.c:    th = (a2-a1)/n;
kgl.c:    if( fabs((double)(ang1-ang2))> 359.0) full=1;
kgl.c:    n = fabs(a2-a1)/th+0.5;
kgl.c:    th = (a2-a1)/n;
kgl.c:     emax = sqrtf((xsize+ysize)*(xsize-ysize))/xsize;
kgl.c:     ba = sqrtf(1-e*e);
kgl.c:     xp = xsize -a;
kgl.c:     dx = xx/(n-1);
kgl.c:       xx -=dx;
kgl.c:       y[i]= ba*sqrtf((a+xx)*(a-xx));
kgl.c:     emax = sqrtf((xsize+ysize)*(ysize-xsize))/ysize;
kgl.c:     ba = sqrtf(1-e*e);
kgl.c:     yp = ysize -a;
kgl.c:     dy = a/(n-1);
kgl.c:       xx = ba*sqrtf((a+yy)*(a-yy));
kgl.c:       y[n+1]= ysize -a;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:   vmin=vv+(vmax -vv)*.2;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-bordrsize,yl-bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, x, y, vd,vv,vmax, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:   vmin=vv+(vmax -vv)*.6;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-bordrsize,yl-bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-bordrsize,yl-bordrsize,fac1, x, y, v,vmin,vmax, count);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, xd1, yd1, vd1,vv,vv, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:   vmin=vv+(vmax -vv)*.6;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-1.8*bordrsize,yl-1.8*bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-1.8*bordrsize,yl-1.8*bordrsize,fac1, x, y, v,vmin,vmax, count);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, xd1, yd1, vd1,vv,vv, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-bordrsize,yl-bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-bordrsize,yl-bordrsize,fac1, x, y, v,vmax,vmax, count);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, xd1, yd1, vd1,vlow,vlow, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:     x[count+i]= -x[count1-i];
kgl.c:     y[count+i] = y[count1-i];
kgl.c:     x[2*count+1+i]= x[2*count1-i];
kgl.c:     y[2*count+1+i] = -y[2*count1-i];
kgl.c:   gphSetShadeParams(fid,yl*0.5, -yl*0.5,200, 16, 0);
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:   vv = (vmin+0.4*(vmax-vmin));
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vmid, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   gphSetShadeParams(fid,yl*0.5, -yl*0.5,200, 128, 0);
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     v[i] = yl*0.5 - fabsf(y[i]);
kgl.c:     x[i] =2*xo-x[i];
kgl.c:     y[i] =2*yo-y[i];
kgl.c:     x[i] =2*xo-x[i];
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     v[i] = 1.0 -dis/D;
kgl.c:     x[i] =2*xo-x[i];
kgl.c:     y[i] =2*yo-y[i];
kgl.c:     x[i] =2*xo-x[i];
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:   vv =vorg +(1.-vorg)*0.9;
kgl.c:   vmid = vorg +(1-vorg)*0.5;
kgl.c:   vmid1 = vorg +(1-vorg)*0.45;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vlow1, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[3]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[1]= x[np2-1];
kgl.c:   yd[1]=  y[np2-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   dv = vmax-vmin;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:     x[count1+i]= -x[count-i];
kgl.c:     y[count1+i] = y[count-i];
kgl.c:     x[2*count1+i]= x[2*count1-1-i];
kgl.c:     y[2*count1+i] = -y[2*count1-1-i];
kgl.c:     v[2*count1+i]= v[count-i];
kgl.c:     x[3*count1+i]=  -x[3*count1-1-i];
kgl.c:     y[3*count1+i] = y[3*count1-1-i];
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:     np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vlow1, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c://   vv = vorg*(1.05+2*atan(1.-vorg)/1.57);
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vlow1, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[3]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[1]= x[np2-1];
kgl.c:   yd[1]=  y[np2-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   vv =vorg +(1.-vorg)*0.6;
kgl.c:   vmid = vorg +(1-vorg)*0.55;
kgl.c:   vmid1 = vorg +(1-vorg)*0.45;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 3;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count1+i]= -x[count-i];
kgl.c:     y[count1+i] = y[count-i];
kgl.c:     x[2*count1+i]= x[2*count1-1-i];
kgl.c:     y[2*count1+i] = -y[2*count1-1-i];
kgl.c:   vv =vorg +(1.-vorg)*0.95;
kgl.c:   vv =vorg +(1.-vorg)*0.65;
kgl.c:   vmid = vorg +(1-vorg)*0.55;
kgl.c:   vmid1 = vorg +(1-vorg)*0.5;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   hcount = (count2-2)/2;
kgl.c:   for(i=hcount+2;i<count2-1;i++) {
kgl.c:   for(i=count2-1;i<2*count2+2;i++) {
kgl.c:   np = 3*count2-1-(2*count2+2+hcount);
kgl.c:   for(i=2*count2+2+hcount;i<3*count2-1-np;i++) {
kgl.c:   for(i=3*count2-1-np;i<3*count2-1;i++) {
kgl.c:   for(i=3*count2-1;i<count;i++) {
kgl.c:   vv =vorg +(1.-vorg)*0.75;
kgl.c:   vmid = vorg +(1-vorg)*0.3;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   hcount = (count2-2)/2;
kgl.c:   for(i=hcount+2;i<count2-1;i++) {
kgl.c:   for(i=count2-1;i<2*count2+2;i++) {
kgl.c:   for(i=2*count2+2+hcount;i<3*count2-1;i++) {
kgl.c:   for(i=3*count2-1;i<count;i++) {
kgl.c:   vv =vorg +(1.-vorg)*0.75;
kgl.c:   vmid = vorg +(1-vorg)*0.3;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   hcount = (count2-2)/2;
kgl.c:   for(i=hcount+2;i<count2-1;i++) {
kgl.c:   for(i=count2-1;i<2*count2+2;i++) {
kgl.c:   for(i=2*count2+2+hcount;i<3*count2-1;i++) {
kgl.c:   for(i=3*count2-1;i<count;i++) {
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:     x[count+i]= -x[count1-i];
kgl.c:     y[count+i] = y[count1-i];
kgl.c:     x[count+count1+i]= x[2*count1-i];
kgl.c:     y[count+count1+i] = -y[2*count1-i];
kgl.c:    if( fabs((double)(ang1-ang2))> 359.0) full=1;
kgl.c:    n = fabs(a2-a1)/th+0.5;
kgl.c:    th = (a2-a1)/n;
kgl.c:    gscanf(G->D,"Give Arc Radius=%10f",&m_radius);
kgl.c:    ang1= atan2( (double)(y1-*yo),(double)(x1-*xo))/3.14159265*180.0; 
kgl.c:    ang2= atan2( (double)(y2-*yo),(double)(x2-*xo))/3.14159265*180.0; 
kgl.c:  dc= G->dc;
kgl.c:  if (!G->D_ON) return;
kgl.c:  if (dc->ZBUFF == 1) 
kgl.c:     dc = G->dc;
kgl.c:     if (!G->D_ON) return;
kgl.c:     if (dc->ZBUFF == 1)
kgl.c:     dc = G->dc;
kgl.c:     if (!G->D_ON) return;
kgl.c:     if (dc->ZBUFF == 1)
kgl.c:     dc = G->dc;
kgl.c:  if (!G->D_ON) return;
kgl.c:  if (dc->ZBUFF == 1) ui_3_godr_fill(G,n,x,y,z,v);
kgl.c:     dc = G->dc;
kgl.c:  if (!G->D_ON) return;
kgl.c:  if (dc->ZBUFF == 1) ui_3_panel(G,x,y,z,(int)color,flag,n);
kgl.c:     dc = G->dc;
kgl.c:      if (!G->D_ON) return;
kgl.c:      if (dc->ZBUFF == 1)
kgl.c:    dc = G->dc;
kgl.c:    wc = G->wc;
kgl.c:    dc->Sx=sx,dc->Sy=sy,dc->Fx=fx,dc->Fy=fy;
kgl.c:    for(i=0;i<16;i++) FMO[i]=dc->FM[i];
kgl.c:    for(i=0;i<16;i++) dc->FM[i]=0;
kgl.c:    xeo= dc->xe,yeo = dc->ye,zeo = dc->ze,clip_mino= dc->clip_min, clip_maxo = dc->clip_max;
kgl.c:        for(i=0;i<16;i++) dc->FM[i]=0; dc->FM[0]=1,dc->FM[5]=1,dc->FM[10]=1,dc->FM[15]=1;
kgl.c:        dc->clip_min=0; dc->clip_max=65000;
kgl.c:        ui_clip_const(G,dc->clip_min,dc->clip_max);
kgl.c:        dc->TIFF=1;
kgl.c:        dc->PROJ=0;
kgl.c://                printf("Drawing Image: %-s\n",imgfile);
kgl.c:                Clips--;
kgl.c:    for(i=0;i<16;i++) dc->FM[i]=FMO[i];
kgl.c:    dc->xe= xeo,dc->ye = yeo,dc->ze = zeo,dc->clip_min= clip_mino, dc->clip_max = clip_maxo;
kgl.c:     dc = G->dc;
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     x = uicnv_x(dc,dc->newstr.xstr);
kgl.c:     y = uicnv_y(dc,dc->newstr.ystr);
kgl.c:     z = uicnv_z(dc,dc->newstr.zstr);
kgl.c:     if (!G->D_ON) return;
kgl.c:     dc = G->dc;
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     x = uicnv_x(dc,dc->newstr.xstr);
kgl.c:     y = uicnv_y(dc,dc->newstr.ystr);
kgl.c:     z = uicnv_z(dc,dc->newstr.zstr);
kgl.c:     if (!G->D_ON) return;
kgl.c:  dc = G->dc;
kgl.c:    kgprojection(dc,dc->trnstr);
kgl.c:    *(x+i) = uicnv_x(dc,dc->newstr.xstr);
kgl.c:    *(y+i) = uicnv_y(dc,dc->newstr.ystr);
kgl.c:    *(z+i) = uicnv_z(dc,dc->newstr.zstr);
kgl.c:  if (!G->D_ON) return;
kgl.c:  dc = G->dc;
kgl.c:    *(x+i) = dc->trnstr.xstr;
kgl.c:    *(y+i) = dc->trnstr.ystr;
kgl.c:    *(z+i) = dc->trnstr.zstr;
kgl.c:    dc->trnstr.xstr = x[i];
kgl.c:    dc->trnstr.ystr = y[i];
kgl.c:    dc->trnstr.zstr = z[i];
kgl.c:    kgprojection(dc,dc->trnstr);
kgl.c:    *(x+i) = uicnv_x(dc,dc->newstr.xstr);
kgl.c:    *(y+i) = uicnv_y(dc,dc->newstr.ystr);
kgl.c:    *(z+i) = uicnv_z(dc,dc->newstr.zstr);
kgl.c:  if (!G->D_ON) return;
kgl.c:  dc = G->dc;
kgl.c:       kgprojection(dc,dc->trnstr);
kgl.c:       *(x+i) = uicnv_x(dc,dc->newstr.xstr);
kgl.c:       *(y+i) = uicnv_y(dc,dc->newstr.ystr);
kgl.c:       *(z+i) = uicnv_z(dc,dc->newstr.zstr);
kgl.c:  if (!G->D_ON) return;
kgl.c:   dc = G->dc;
kgl.c:      kgprojection(dc,dc->trnstr);
kgl.c:      x1 = uicnv_x(dc,dc->newstr.xstr);
kgl.c:      y1 = uicnv_y(dc,dc->newstr.ystr);
kgl.c:      z1 = uicnv_z(dc,dc->newstr.zstr);
kgl.c:      kgprojection(dc,dc->trnstr);
kgl.c:      x2 = uicnv_x(dc,dc->newstr.xstr);
kgl.c:      y2 = uicnv_y(dc,dc->newstr.ystr);
kgl.c:      z2 = uicnv_z(dc,dc->newstr.zstr);
kgl.c:      if (!G->D_ON) return;
kgl.c:    dc = G->dc;
kgl.c:    wc = G->wc;
kgl.c:    dc->Sx=0.,dc->Sy=0.,dc->Fx=1.,dc->Fy=1.;
kgl.c:    for(i=0;i<16;i++) FMO[i]=dc->FM[i];
kgl.c:    xeo= dc->xe,yeo = dc->ye,zeo = dc->ze,clip_mino= dc->clip_min, clip_maxo = dc->clip_max;
kgl.c:    for(i=0;i<16;i++) dc->FM[i]=FMO[i];
kgl.c:   dc = G->dc;
kgl.c:   if(G->Byte != 0) {
kgl.c:     if(*rbuf== -1) {
kgl.c:        G->OPEN=1;
kgl.c:     G->BACK_UP=1;
kgl.c:     WRITE(*rbuf,(void *)G->Rbuff,G->Byte);
kgl.c:   G->Byte=0;G->R_max=0;
kgl.c:   *rbuf=-1;
kgl.c://    printf("G->R_Byte:G->R_max: %d %d\n",G->R_Byte,G->R_max);
kgl.c:       if ( G->R_Byte>=G->R_max){ G->R_max=read(G->review,(void *)G->Rbuff,B_min);G->R_Byte=0;}
kgl.c:       if(G->R_max ==0) {
kgl.c:       *(ptr+i)=G->Rbuff[G->R_Byte++];
kgl.c:   dc = G->dc;
kgl.c:   if(*rbuf== -1) {
kgl.c:        G->OPEN=1;
kgl.c:   if(G->Byte!=0){
kgl.c://     printf("Write: %s : %d\n",flname,G->Byte);
kgl.c:     WRITE(*rbuf,(void *)G->Rbuff,G->Byte);
kgl.c:   G->Byte=0;G->R_max=0;
kgl.c:   G->BACK_UP=1;
kgl.c:   dc = G->dc;
kgl.c:   G->cmdbuf = open(dc->cmdsfile,O_CREAT|O_BINARY|O_TRUNC|O_RDWR,0666);
kgl.c:   if(G->Byte!=0){
kgl.c:     WRITE(G->cmdbuf,(void *)G->Rbuff,G->Byte);
kgl.c:   G->Byte=0;G->R_max=0;
kgl.c:   G->Byte=read(rbuf,(void *)G->Rbuff,B_min);
kgl.c:  dc = G->dc;
kgl.c:  if(G->OPEN){close(G->rbuf);remove(dc->reviewfile);}
kgl.c:  G->rbuf=-1;
kgl.c:  G->OPEN=1;
kgl.c:  G->rbuf=open(dc->reviewfile,O_CREAT|O_RDWR|O_TRUNC|O_BINARY, S_IREAD|S_IWRITE);
kgl.c:  G->Byte=0;
kgl.c:  G->BACK_UP=0;
kgl.c://  G->SET3D=0;
kgl.c:  dc->TIFF = 0;
kgl.c://  if(G->D_ON)ui_clrbuf(G);
kgl.c:  dc = G->dc;
kgl.c:  if(G->Obj_opn==obj) return;
kgl.c:  sprintf(flname,"%-s/%-d",dc->objdir,obj);
kgl.c://      rev_obj_file(pf,-sx,fx,-sy,fy);
kgl.c:      uirev_file(pf,G,-sx,fx,-sy,fy);
kgl.c:   dc = G->dc;
kgl.c:   if(G->Obj_opn==obj) return;
kgl.c:   sprintf(flname,"%-s/%-d",dc->objdir,obj);
kgl.c:   uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:   G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY|O_APPEND, S_IREAD|S_IWRITE);
kgl.c:   while( (bytes=read(in,buf,1024))==1024) WRITE(G->rbuf,buf,1024);
kgl.c:   WRITE(G->rbuf,buf,bytes);
kgl.c:  dc = G->dc;
kgl.c:  if(G->Obj_opn) kgCloseObject(G);
kgl.c:  G->Obj_opn=obj;
kgl.c:  sprintf(flname,"%-s/%-d",dc->objdir,obj);
kgl.c:  uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:  G->rbuf=open(flname,O_CREAT|O_TRUNC|O_BINARY|O_RDWR, S_IREAD|S_IWRITE);
kgl.c:  dc = G->dc;
kgl.c:  if(G->Obj_opn) kgCloseObject(G);
kgl.c:  G->Obj_opn=obj;
kgl.c:  sprintf(flname,"%-s/%-d",dc->objdir,obj);
kgl.c:  uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:  G->rbuf=open(flname,O_CREAT|O_APPEND|O_BINARY|O_RDWR, S_IREAD|S_IWRITE);
kgl.c:  dc = G->dc;
kgl.c:  if(G->Obj_opn==0) return;
kgl.c:  obj = G->Obj_opn;
kgl.c:  sprintf(flname,"%-s/%-d",dc->objdir,obj);
kgl.c:  uiclose_file(G,&(G->rbuf),flname);
kgl.c:  G->Obj_opn=0;
kgl.c:  G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY|O_APPEND, S_IREAD|S_IWRITE);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_move(G,x,y);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_draw(G,x,y);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_drawimage(G,buff,x1,y1,x2,y2);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_marker(G,x,y);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_box_fill(G,x1,y1,x2,y2,color,ib);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c://  if(G->D_ON)ui_circle(G,x1,y1,r);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_panel(G,x,y,(int)color,(int)flag,(int)n);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_godr_fill(G,n,x,y,p);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc->t_color=t_color;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  if(G->D_ON)ui_txt_wr(G,n,tx);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:    kgprojection(dc,dc->trnstr);
kgl.c:    if (!G->D_ON) return;
kgl.c:    if (dc->ZBUFF == 1)
kgl.c:     ui_3_move(G,dc->newstr.xstr,dc->newstr.ystr,dc->newstr.zstr);
kgl.c:    ui_move(G,dc->newstr.xstr,dc->newstr.ystr);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:    kgprojection(dc,dc->trnstr);
kgl.c:    if (!G->D_ON) return;
kgl.c:    if (dc->ZBUFF == 1)
kgl.c:     ui_3_draw(G,dc->newstr.xstr,dc->newstr.ystr,dc->newstr.zstr);
kgl.c:    ui_draw(G,dc->newstr.xstr,dc->newstr.ystr);
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     *(x+i) = dc->newstr.xstr;
kgl.c:     *(y+i) = dc->newstr.ystr;
kgl.c:     *(z+i) = dc->newstr.zstr;
kgl.c:    if (!G->D_ON) return;
kgl.c:    if (dc->ZBUFF == 1)
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:   kgprojection(dc,dc->trnstr);
kgl.c:   x1 = dc->newstr.xstr;
kgl.c:   y1 = dc->newstr.ystr;
kgl.c:   z1 = dc->newstr.zstr;
kgl.c:   kgprojection(dc,dc->trnstr);
kgl.c:   x2 = dc->newstr.xstr;
kgl.c:   y2 = dc->newstr.ystr;
kgl.c:   z2 = dc->newstr.zstr;
kgl.c:   if (!G->D_ON) return;
kgl.c:   if (dc->ZBUFF == 1)
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     *(x+i) = dc->newstr.xstr;
kgl.c:     *(y+i) = dc->newstr.ystr;
kgl.c:     *(z+i) = dc->newstr.zstr;
kgl.c: if (!G->D_ON) return;
kgl.c: if (dc->ZBUFF == 1)
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  dc=G->dc;
kgl.c:  wc = G->wc;
kgl.c:  uichng_clr(G->D,(int)no,(int)ir,(int)ig,(int)ib);
kgl.c:  dc = G->dc;
kgl.c:  G->review=open(str,O_RDWR|O_BINARY, S_IREAD|S_IWRITE);
kgl.c:  uiread_file(G,G->review); 
kgl.c:  G->R_Byte=0;
kgl.c:  G->R_max=G->Byte;
kgl.c:  while ( G->R_max>0)
kgl.c: close(G->review);
kgl.c: G->review=-1;
kgl.c:// G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY|O_APPEND, S_IREAD|S_IWRITE);
kgl.c:      dc = G->dc;
kgl.c:      wc = G->wc;
kgl.c:      wxd = dc->w_x2-dc->w_x1;
kgl.c:      wyd = dc->w_y2-dc->w_y1;
kgl.c:      dxx = x2-x1;
kgl.c:      dyy = y2-y1;
kgl.c:      s3 = -s2*ct+s1*0.5*st;
kgl.c:      s4 = -s2*st-s1*0.5*ct;
kgl.c:      s5 = -s2*ct-s1*0.5*st;
kgl.c:      s6 = -s2*st+s1*0.5*ct;
kgl.c:      kgPolyFill(G,(int)4,ax,ay,(int)1,dc->fil_color);
kgl.c:  xx=x1;yy=y2-(y1-y2);
kgl.c:  x =x1+(x1-x2);y=y2;
kgl.c:  dc = G->dc;
kgl.c:  wc = G->wc;
kgl.c:  w[0]=dc->w_x1;
kgl.c:  w[1]=dc->w_y1;
kgl.c:  w[2]=dc->w_x2;
kgl.c:  w[3]=dc->w_y2;
kgl.c:  dx= (w[2]-w[0])/120.0*fac;
kgl.c:  dy= (w[3]-w[1])/90.0*fac;
kgl.c:  kgBoxFill(G,xmax,ymin,xmax-dx,ymax,clr,0);
kgl.c:  kgBoxFill(G,xmin,ymax,xmax,ymax-dy,clr,0);
kgl.c:   dc = G->dc;
kgl.c:   angle=dc->trot;
kgl.c:   _ui_setattrib(G->D,G->x1,G->y1, &(dc->ln_style), &(dc->ln_color), &(dc->ln_width), &(dc->m_style), 
kgl.c:     &(dc->fil_color), &(dc->t_color), &(dc->t_font), &(angle), 
kgl.c:     &(dc->bod_color) );
kgl.c:     dc->trot=angle;
kgl.c:     ui_ln_clr(G,dc->ln_color);
kgl.c:     ui_txt_rot(G,dc->trot);
kgl.c:     ui_txt_font(G,dc->t_font);
kgl.c:     ui_smmark(G,dc->m_style);
kgl.c:     kgLineColor(G,dc->ln_color);
kgl.c:     kgTextAngle(G,dc->trot);
kgl.c:     kgTextFont(G,dc->t_font);
kgl.c:     kgMarkerType(G,dc->m_style);
kgl.c:     kgLineWidth(G,dc->ln_width);
kgl.c:  dc = G->dc;
kgl.c:  D= (DIALOG *)G->D;
kgl.c:  dc = G->dc;
kgl.c:  if(G->D_ON)ui_clr_vu(G); 
kgl.c:  if (G->BACK_UP == 1) { 
kgl.c:      uiwrite_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:      lseek(G->rbuf,0L,0);
kgl.c:      G->review= G->rbuf;
kgl.c:      uiread_file(G,G->review); 
kgl.c:  else G->review= G->rbuf;
kgl.c:  G->R_Byte=0;
kgl.c:  G->R_max=G->Byte;
kgl.c:  while ( G->R_max>0)
kgl.c:  if( G->BACK_UP ==1) {  G->Byte=0;G->R_max=0;}
kgl.c:  G->review= -1;
kgl.c://   uiwrite_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:   uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:   uireview_file(G,dc->reviewfile);
kgl.c:   if( G->BACK_UP ==1) {  G->Byte=0;G->R_max=0;}
kgl.c:  dc = G->dc;
kgl.c:  G->cmdbuf=open(dc->cmdsfile,O_CREAT|O_TRUNC|O_BINARY|O_RDWR, S_IREAD|S_IWRITE);
kgl.c:  G->Byte=0;G->R_max=0;
kgl.c:  if(G->D_ON)ui_clr_vu(G);
kgl.c:  uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:  uireview_file(G,dc->reviewfile);
kgl.c:  G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY|O_APPEND, S_IREAD|S_IWRITE);
kgl.c:  lseek(G->cmdbuf,(int)0,0);
kgl.c:  uiread_file(G,G->cmdbuf);
kgl.c:  G->R_max=G->Byte;;
kgl.c:  G->R_Byte=0;
kgl.c:  G->review= G->cmdbuf;
kgl.c:  close(G->cmdbuf);
kgl.c:  remove(dc->cmdsfile);
kgl.c:  G->review=-1;
kgl.c:  close(G->cmdbuf);
kgl.c:  G->Byte=0;G->R_max=0;
kgl.c:  uireview_file(G,dc->cmdsfile);
kgl.c:  remove(dc->cmdsfile);
kgl.c:  dc = G->dc;
kgl.c:  G->R_Byte=0;
kgl.c:  if(G->Byte== 0) return;
kgl.c:  G->R_max=B_max;
kgl.c:  while ( G->R_Byte<G->Byte)
kgl.c:   printf("uireview_cmds:R_Byte: %d\n",G->R_Byte);
kgl.c:   dc = G->dc;
kgl.c://   ysize = xsize*(float)(dc->EVGAY)/(float)( dc->EVGAX);
kgl.c:   gscanf(G->D,"Dimension in X direction %6d",&xdim);
kgl.c:   dc->TIFF =0;
kgl.c:   if(dc->ZBUFF) dc->TIFF=1;
kgl.c:   WRITE(G->hbuf,(void *)&ch,1);
kgl.c:   close(G->hbuf);
kgl.c:      sprintf(pngfile,"%-s/gph.png",dir);
kgl.c:      kgBackupGph(G,dc->plotfile);
kgl.c:      png=kgGphtoAntialiasedImage(dc->plotfile,dc->EVGAX*2,dc->EVGAY*2,0,4);
kgl.c:      sprintf(command,"mv %-s %-s",pngfile,flname);
kgl.c:   dc->TIFF=0;
kgl.c:   remove(dc->plotfile);
kgl.c:   G->hbuf =-1;
kgl.c:      sprintf(pngfile,"%-s/gph.png",dir);
kgl.c:      kgBackupGph(G,dc->plotfile);
kgl.c:      png=kgGphtoAntialiasedImage(dc->plotfile,xsize,ysize,0,4);
kgl.c:      sprintf(command,"mv %-s %-s",pngfile,flname);
kgl.c:   dc = G->dc;
kgl.c:   dc->TIFF =0;
kgl.c:   if(dc->ZBUFF) dc->TIFF=1;
kgl.c:   WRITE(G->hbuf,(void *)&ch,1);
kgl.c:   close(G->hbuf);
kgl.c:   if(dc->TIFF != 1){
kgl.c://      sprintf(command,"kgpscript  -i%-s -o%-s",dc->plotfile,flname);
kgl.c:      pscript(dc->plotfile,flname);
kgl.c:      sprintf(pngfile,"%-s/gph.png",dir);
kgl.c:      kgBackupGph(G,dc->plotfile);
kgl.c:      png=kgGphtoAntialiasedImage(dc->plotfile,dc->EVGAX,dc->EVGAY,0,4);
kgl.c:      sprintf(command,"mv %-s %-s",pngfile,flname);
kgl.c:   dc->TIFF=0;
kgl.c:   remove(dc->plotfile);
kgl.c:   G->hbuf =-1;
kgl.c:   dc = G->dc;
kgl.c:   dc->TIFF =0;
kgl.c:   if(dc->ZBUFF) dc->TIFF=1;
kgl.c:   WRITE(G->hbuf,(void *)&ch,1);
kgl.c:   close(G->hbuf);
kgl.c:   if(dc->TIFF != 1){
kgl.c://      sprintf(command,"kgpscript   -i%-s -o%-s",dc->plotfile,flname);
kgl.c:      pscript(dc->plotfile,flname);
kgl.c:      sprintf(pngfile,"%-s/gph.png",dir);
kgl.c:      kgBackupGph(G,dc->plotfile);
kgl.c:      png=kgGphtoAntialiasedImage(dc->plotfile,dc->EVGAX,dc->EVGAY,0,4);
kgl.c:      sprintf(command,"mv %-s %-s",pngfile,flname);
kgl.c:   dc->TIFF=0;
kgl.c:   remove(dc->plotfile);
kgl.c:   G->hbuf =-1;
kgl.c:   dc = G->dc;
kgl.c:   dc->TIFF =0;
kgl.c:   if(dc->ZBUFF) dc->TIFF=1;
kgl.c:   WRITE(G->hbuf,(void *)&ch,1);
kgl.c:   close(G->hbuf);
kgl.c:   if(dc->TIFF != 1){
kgl.c://      sprintf(command,"kgpscript  -i%-s -o%-s",dc->plotfile,flname);
kgl.c:      pscript(dc->plotfile,flname);
kgl.c:      sprintf(pngfile,"%-s/gph.png",dir);
kgl.c:      kgBackupGph(G,dc->plotfile);
kgl.c:      png=kgGphtoAntialiasedImage(dc->plotfile,dc->EVGAX,dc->EVGAY,0,4);
kgl.c:      sprintf(command,"mv %-s %-s",pngfile,flname);
kgl.c:   dc->TIFF=0;
kgl.c:   remove(dc->plotfile);
kgl.c:   G->hbuf =-1;
kgl.c:   dc = G->dc;
kgl.c:   if(G->hbuf<0) G->hbuf=open(dc->plotfile,O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0666);
kgl.c:   pf=G->hbuf;
kgl.c:   WRITE(pf,(void *)&dc->vu_x1,4);
kgl.c:   WRITE(pf,(void *)&dc->vu_y1,4);
kgl.c:   WRITE(pf,(void *)&dc->vu_x2,4);
kgl.c:   WRITE(pf,(void *)&dc->vu_y2,4);
kgl.c:   WRITE(pf,(void *)&dc->w_x1,4);
kgl.c:   WRITE(pf,(void *)&dc->w_y1,4);
kgl.c:   WRITE(pf,(void *)&dc->w_x2,4);
kgl.c:   WRITE(pf,(void *)&dc->w_y2,4);
kgl.c:   if((dc->ZBUFF)||(dc->TIFF)) {
kgl.c:     if(dc->PROJ) update_gr_info(G);
kgl.c:   G->BACK_UP=1;
kgl.c:   uiclose_file(G,&(G->rbuf),dc->reviewfile);
kgl.c:   G->rbuf=open(dc->reviewfile,O_RDWR|O_BINARY, S_IREAD|S_IWRITE);
kgl.c:   if( G->rbuf<0) return;
kgl.c:   uiread_file(G,G->rbuf); 
kgl.c:   while(G->Byte==B_min){WRITE(pf,(void *)G->Rbuff,G->Byte); uiread_file(G,G->rbuf); }
kgl.c:   WRITE(pf,(void *)G->Rbuff,G->Byte);
kgl.c:   G->OPEN=1;
kgl.c:   G->R_Byte=0;
kgl.c:   G->Byte=0;G->R_max=0;
kgl.c:   dc = G->dc;
kgl.c:   G->hbuf=open(dc->plotfile,O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0666);
kgl.c:   pf=G->hbuf;
kgl.c:   dc = G->dc;
kgl.c:   G->hbuf=open(dc->plotfile,O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0666);
kgl.c:   pf=G->hbuf;
kgl.c:   n--;
kgl.c:   while((n>=0)&&( *(ch+n) == ' '))  *(ch+n--)='\0';
kgl.c:   FM = dc->FM;
kgl.c:   dc->trnstr.xstr = (xp * FM[0]) + (yp * FM[4]) + (zp * FM[8]) + FM[12];
kgl.c:   dc->trnstr.ystr = (xp * FM[1]) + (yp * FM[5]) + (zp * FM[9]) + FM[13];
kgl.c:   dc->trnstr.zstr = (xp * FM[2]) + (yp * FM[6]) + (zp * FM[10]) + FM[14];
kgl.c:    dc->TR[12] = -tx; dc->TR[13] = -ty; dc->TR[14] = -tz;
kgl.c:    mul_matrix(dc->TM,dc->TR,dc->T1);
kgl.c:    for(i=0;i<16;i++) dc->TM[i] = dc->T1[i];
kgl.c:    mul_matrix(dc->TC,dc->TM,dc->T1);
kgl.c:    mul_matrix(dc->T1,dc->TE,dc->FM);
kgl.c:    dc = G->dc;
kgl.c:    dc->TR[12] = +tx; dc->TR[13] = +ty; dc->TR[14] = +tz;
kgl.c:    mul_matrix(dc->TM,dc->TR,dc->T1);
kgl.c:    for(i=0;i<16;i++) dc->TM[i] = dc->T1[i];
kgl.c:    mul_matrix(dc->TC,dc->TM,dc->T1);
kgl.c:    mul_matrix(dc->T1,dc->TE,dc->FM);
kgl.c:    dc->TX[5] = cos(ang); dc->TX[6] = sin(ang); dc->TX[9] = -(dc->TX[6]);
kgl.c:    dc->TX[10] = dc->TX[5];
kgl.c:    mul_matrix(dc->TM,dc->TX,dc->T1);
kgl.c:    for(i=0;i<16;i++) dc->TM[i] = dc->T1[i]; 
kgl.c:    dc->TY[0] = cos(ang); dc->TY[2] = -(sin(ang)); dc->TY[8] = sin(ang);
kgl.c:    dc->TY[10] = dc->TY[0];
kgl.c:    mul_matrix(dc->TM,dc->TY,dc->T1); 
kgl.c:    for(i=0;i<16;i++) dc->TM[i] = dc->T1[i]; 
kgl.c:    dc->TZ[0] = cos(ang); dc->TZ[1] = sin(ang); dc->TZ[4] = -dc->TZ[1];
kgl.c:    dc->TZ[5] = dc->TZ[0];
kgl.c:    mul_matrix(dc->TM,dc->TZ,dc->T1); 
kgl.c:    for(i=0;i<16;i++) dc->TM[i] = dc->T1[i]; 
kgl.c:    mul_matrix(dc->TC,dc->TM,dc->T1);
kgl.c:    mul_matrix(dc->T1,dc->TE,dc->FM);
kgl.c:    dc = G->dc;
kgl.c:    mul_matrix(dc->TC,dc->TM,dc->T1);
kgl.c:    mul_matrix(dc->T1,dc->TE,dc->FM);
kgl.c:   if(dc->PROJ) {
kgl.c:     dc->newstr.xstr = -(2.0* dc->ze/(oldstr.zstr)) * oldstr.xstr;
kgl.c:     dc->newstr.ystr = -(2.0* dc->ze/(oldstr.zstr)) * oldstr.ystr;
kgl.c:     dc->newstr.zstr = oldstr.zstr;
kgl.c:     dc->newstr.xstr =  oldstr.xstr;
kgl.c:     dc->newstr.ystr =  oldstr.ystr;
kgl.c:     dc->newstr.zstr =  oldstr.zstr;
kgl.c:     dc= G->dc;
kgl.c:     dc->SET3D=1;
kgl.c:     dc->PROJ =1;
kgl.c:     dc->xe = (x_max + x_min) / 2;
kgl.c:     dc->ye = (y_max + y_min) / 2;
kgl.c:     /*ze = z_max+20.0*(z_max-z_min);*/
kgl.c:     dc->zc = (z_max + z_min)/2;
kgl.c:     dc->ze = (z_max - z_min)*3.0;
kgl.c:      dc->TM[i] = TI[i];
kgl.c:      dc->TR[i] = TI[i];
kgl.c:      dc->TX[i] = TI[i];
kgl.c:      dc->TY[i] = TI[i];
kgl.c:      dc->TZ[i] = TI[i];
kgl.c:      dc->FM[i] = TI[i];
kgl.c:      dc->TE[i] = TI[i];
kgl.c:      dc->TC[i] = TI[i];
kgl.c:     dc->TE[12] = 0;dc->TE[13] = 0;dc->TE[14] = -dc->ze;
kgl.c:     dc->TC[12] = -dc->xe;dc->TC[13] = -dc->ye;dc->TC[14] =-dc->zc;
kgl.c:     mul_matrix(dc->TC,dc->TE,dc->FM);
kgl.c:     dc->clip_min=dc->trnstr.zstr;
kgl.c:     dc->clip_max=dc->trnstr.zstr;
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     x1=dc->newstr.xstr;
kgl.c:     y1=dc->newstr.ystr;
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     x2=dc->newstr.xstr;
kgl.c:     y2=dc->newstr.ystr;
kgl.c://     dc->PROJ =1;
kgl.c:     ui_clip_const(G,dc->clip_min,dc->clip_max);
kgl.c:     dc->box3d.xmin =  x_min;
kgl.c:     dc->box3d.ymin =  y_min;
kgl.c:     dc->box3d.zmin =  z_min;
kgl.c:     dc->box3d.xmax =  x_max;
kgl.c:     dc->box3d.ymax =  y_max;
kgl.c:     dc->box3d.zmax =  z_max;
kgl.c:     dc->box3d.xe   =  dc->xe;
kgl.c:     dc->box3d.ye   =  dc->ye;
kgl.c:     dc->box3d.ze   =  dc->ze;
kgl.c:     dc->box3d.xc   =  dc->xe;
kgl.c:     dc->box3d.yc   =  dc->ye;
kgl.c:     dc->box3d.zc   =  dc->zc;
kgl.c:     dc->box3d.d = (x_max -x_min)*(x_max- x_min) +
kgl.c:               (y_max -y_min)*(y_max- y_min) +
kgl.c:               (z_max -z_min)*(z_max- z_min) ;
kgl.c:     dc->box3d.d = sqrt(dc->box3d.d);
kgl.c:     dc = G->dc;
kgl.c:   if(G->Rbuff != NULL) {
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     if (!G->D_ON) {
kgl.c:       if (dc->ZBUFF == 1) img_move3f(G,dc->newstr.xstr , dc->newstr.ystr , dc->newstr.zstr);
kgl.c:       else  img_move(G,dc->newstr.xstr , dc->newstr.ystr);
kgl.c:       if (dc->ZBUFF == 1) ui_3_move(G,dc->newstr.xstr , dc->newstr.ystr , dc->newstr.zstr);
kgl.c:       else ui_move(G,dc->newstr.xstr , dc->newstr.ystr);
kgl.c:     dc = G->dc;
kgl.c:     D = G->D;
kgl.c:   if(G->Rbuff != NULL) {
kgl.c:     kgprojection(dc,dc->trnstr);
kgl.c:     if (!G->D_ON) {
kgl.c:       if (dc->ZBUFF == 1) { img_draw3f(G,dc->newstr.xstr , dc->newstr.ystr , dc->newstr.zstr); }
kgl.c:       else      img_draw(G,dc->newstr.xstr , dc->newstr.ystr);
kgl.c:       if (dc->ZBUFF == 1) { ui_3_draw(G,dc->newstr.xstr , dc->newstr.ystr , dc->newstr.zstr); }
kgl.c:       else { ui_draw(G,dc->newstr.xstr,dc->newstr.ystr); }
kgl.c:     dc = G->dc;
kgl.c:   if(G->Rbuff != NULL) {
kgl.c:         kgprojection(dc,dc->trnstr);
kgl.c:         *(x1+i) = dc->newstr.xstr;
kgl.c:         *(y1+i) = dc->newstr.ystr;
kgl.c:         *(z1+i) = dc->newstr.zstr;
kgl.c:      if (!G->D_ON) {
kgl.c:          if (dc->ZBUFF == 1) img_polyfill3f(G,n,x1,y1,z1,flag,color);
kgl.c:        if (dc->ZBUFF == 1) ui_3_panel(G,x1,y1,z1,(int)color,flag,n);
kgl.c:     dc = G->dc;
kgl.c:   if(G->Rbuff != NULL) {
kgl.c:      if (!G->D_ON) return;
kgl.c:      kgprojection(dc,dc->trnstr);
kgl.c:      x1 = dc->newstr.xstr;
kgl.c:      y1 = dc->newstr.ystr;
kgl.c:      z1 = dc->newstr.zstr;
kgl.c:      kgprojection(dc,dc->trnstr);
kgl.c:      x2 = dc->newstr.xstr;
kgl.c:      y2 = dc->newstr.ystr;
kgl.c:      z2 = dc->newstr.zstr;
kgl.c:      if (!G->D_ON) {
kgl.c:        if (dc->ZBUFF == 1) img_boxfill3f(G,x1,y1,z1,x2,y2,z2,ib,fl);
kgl.c:        if (dc->ZBUFF == 1) ui_3_box_fill(G,x1,y1,z1,x2,y2,z2,fl,ib);
kgl.c:  dc = G->dc;
kgl.c:  if(G->Rbuff != NULL) {
kgl.c:    kgprojection(dc,dc->trnstr);
kgl.c:    *(x+i) = dc->newstr.xstr;
kgl.c:    *(y+i) = dc->newstr.ystr;
kgl.c:    *(z+i) = dc->newstr.zstr;
kgl.c:  if (!G->D_ON) {
kgl.c:    if (dc->ZBUFF == 1) img_godrfill3f(G,n,x,y,z,v);
kgl.c:    if (dc->ZBUFF == 1) ui_3_godr_fill(G,n,x,y,z,v);
kgl.c:  dc= G->dc;
kgl.c:  if(G->D==NULL) return;
kgl.c:  if(dc->DOUBLE== 1) ui_swapbuffers(G);
kgl.c:  else kgUpdateOn(G->D);
kgl.c:  if(G->D==NULL) return;
kgl.c:  dc= G->dc;
kgl.c:  D = G->D;
kgl.c:  dc->DOUBLE=1;
kgl.c:  dc->DOUBLE=0;
kgl.c:  if(G->D_ON!= 0) kgAntialiasingOn(G,0);
kgl.c:  dc= G->dc;
kgl.c:  if(G->D==NULL) return;
kgl.c:  if(G->MAG <=1 ) kgAntialiasingOff(G);
kgl.c:  if(dc->DOUBLE== 1)ui_singlebuffer(G);
kgl.c:  dc->DOUBLE=0;
kgl.c:    dc = G->dc;
kgl.c:     if( dc->ZBUFF==val){
kgl.c:       if(dc->ZBUFF==1) {dc->TIFF =1;ui_set_zbuf(G);}
kgl.c:     dc->ZBUFF = val;
kgl.c:     if (dc->ZBUFF == 1)
kgl.c:       dc->TIFF=1;
kgl.c:       dc->TIFF=0;
kgl.c:    val = -val;
kgl.c:    val = -val;
kgl.c:  if(G->Rbuff != NULL) {
kgl.c:  if(G->Rbuff != NULL) {
kgl.c:  wc = (kgWC *)(G->wc);
kgl.c:  kgcolors = wc->kgcolors;
kgl.c:   if(G->Rbuff != NULL) {
kgl.c:   if(G->D_ON)uichng_clr(G->D,(int) no,(int) ir,(int) ig,(int) ib);
kgl.c: kgSkipEvents(G->D);
kgl.c: if(G->D_ON== 0) {
kgl.c: D_ON = G->D_ON;
kgl.c: kgSkipEvents(G->D);
kgl.c: dz = (box3d.zmax - box3d.zmin)/100.;
kgl.c:    if(G->D == NULL) return;
kgl.c:    if(G->D_ON==0) {
kgl.c:    D = (DIALOG *)G->D;
kgl.c:    EVGAY=D->evgay;
kgl.c:    wc = G->wc;
kgl.c:    dc = G->dc;
kgl.c:    v[0]=dc->D_x;
kgl.c:    v[1] = EVGAY - (dc->D_y+dc->V_y);
kgl.c:    v[2] = dc->D_x+dc->V_x;
kgl.c:    v[3]=  EVGAY - dc->D_y;
kgl.c:    if(dc->ZBUFF==1) {uiclear_zbuf(G);}
kgl.c:    if (dc->DOUBLE!=1) uiUpdateOn(D);
kgl.c:  wc = G->wc;
kgl.c:  dc = G->dc;
kgl.c:  EVGAX= G->x2-G->x1+1;
kgl.c:  EVGAY= abs(G->y2-G->y1)+1;
kgl.c:  v_x1=dc->vu_x1*(float)EVGAX;
kgl.c:  v_y1= dc->vu_y1*(float)EVGAY;
kgl.c:  v_x2=dc->vu_x2*(float)EVGAX-1;
kgl.c:  v_y2= dc->vu_y2*(float)EVGAY-1;
kgl.c:  V_x=v_x2-v_x1+1;
kgl.c:  V_y=v_y2-v_y1+1;
kgl.c:  if(G->D==NULL) return;
kgl.c:    D= G->D;
kgl.c:    D_x=G->x1+D->xo+v_x1;
kgl.c:    D_y = D->yo+G->y1+EVGAY-1-v_y2;
kgl.c:    kgImage(D,png,D_x,D_y,png->image_width,png->image_height,0.0,1.0);
kgl.c:    D = G->D;
kgl.c:    wc = G->wc;
kgl.c:    dc = G->dc;
kgl.c:    Evgay=D->evgay;
kgl.c:    if(dc->ZBUFF==1) {uiclear_zbuf(G);}
kgl.c:    v[0]=dc->D_x;
kgl.c:    v[1] = Evgay - (dc->D_y+dc->V_y-1);
kgl.c:    v[2] = dc->D_x+dc->V_x-1;
kgl.c:    v[3]=  Evgay - dc->D_y;
kgl.c:    yl = v[1]-1;
kgl.c:    w = (v[2]-v[0]);
kgl.c:    h = (v[3] -v[1]+1);
kgl.c:    EVGAX= G->x2-G->x1+1;
kgl.c:    EVGAY= abs(G->y2-G->y1)+1;
kgl.c:    v_x1=dc->vu_x1*(float)EVGAX;
kgl.c:    v_y1= dc->vu_y1*(float)EVGAY;
kgl.c:    v_x2=dc->vu_x2*(float)EVGAX-1;
kgl.c:    v_y2= dc->vu_y2*(float)EVGAY-1;
kgl.c:    V_x=v_x2-v_x1+1;
kgl.c:    V_y=v_y2-v_y1+1;
kgl.c:    D_x=G->x1+D->xo+v_x1;
kgl.c:    D_y = D->yo+G->y1+EVGAY-1-v_y2;
kgl.c:    tpt = D->tmpdir;
kgl.c:   img = uiGetAntialiasedImage(flname,w,h,dc->ls_list,G->MAG);
kgl.c:     ((GMIMG *)img)->bkgrclr=0;
kgl.c://   if (dc->DOUBLE!=1) kgUpdateOn(D);
kgl.c:  d = ((DIALOG *)D)->d;
kgl.c:    if(g->code!='g') continue;
kgl.c:    if(g->D_ON==0) {
kgl.c:     dc= G->dc;
kgl.c:     if(G->Rbuff != NULL) {
kgl.c:     if(G->D_ON){
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:        case -1:
kgl.c:         gphMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:         gphMove2f(fid,(xsize-length-tw*0.5),0.25*ysize);
kgl.c:         gphMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c://      gphRoundedRectangleFill(fid,(float)xsize*0.5-0.5,(float)ysize*0.5+0.5,(float)xsize-1,(float)ysize-1,0,252,rfac);
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0+1.0,0.5*ysize-th*.5-1.0);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5+1.0,0.5*ysize-th*.5-1.0);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5)+1.0,0.5*ysize-th*.5-1.0);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5+1.0,0.5*ysize-th*0.5-1.0);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   if(state == -1) {
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:      if(state==-1)
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   if(state == -1) {
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:      if(state==-1)
kgl.c://      gphRoundedRectangleRaised(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-1,(float)ysize-1,fillcolor,rfac);
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c://   v =(v*v*2.0)*(2-v);
kgl.c:      gphUserFrame(fid,-2.,-2.,(float)xsize+2.,(float)ysize+2.);
kgl.c:      if(state==-1) {
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-0.5,-0.5,(float)xsize+0.5,(float)ysize+0.5);
kgl.c:      if(state==-1) {
kgl.c:      gphRoundedRectangle(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-1,(float)ysize-1,252,rfac,1.0);
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:        case -1:
kgl.c:         gphMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:         gphMove2f(fid,(xsize-length-tw*0.5),0.25*ysize);
kgl.c:         gphMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:      fj =0.0; gj = -1; fact = 1.0;
kgl.c:                         fj = fj-fact1;fjl-=1.; gj=gj-1;
kgl.c:                         Nu= (title[i+1] -'0');
kgl.c:                         De= (title[i+2] -'0');
kgl.c:                         Nu= (title[i+1] -'0');
kgl.c:                         De= (title[i+2] -'0');
kgl.c:                         Nu= (title[i+1] -'0');
kgl.c:                         De= (title[i+2] -'0');
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-0.,-0.,(float)xsize+0.,(float)ysize+0.);
kgl.c:      gphRoundedRectangleFill(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-3,(float)ysize-3,0,fillcolor,rfac);
kgl.c:      gphRoundedRectanglePressed(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-3,(float)ysize-3,bodrcolor,rfac,5.0);
kgl.c:        gphTextSize(fid,th,tw,0.0,0.0,0.0,(float)xsize-2,(float)ysize-2);
kgl.c:          gphTextSize(fid,th,tw*fac,0.0,0.0,0.0,(float)xsize-2,(float)ysize-2);
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-0.,-0.,(float)xsize+0.,(float)ysize+0.);
kgl.c:      gphRoundedRectangleFill(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-1,(float)ysize-1,0,252,rfac);
kgl.c:        gphTextSize(fid,th,tw,0.0,0.0,0.0,(float)xsize-2,(float)ysize-2);
kgl.c:          gphTextSize(fid,th,tw*fac,0.0,0.0,0.0,(float)xsize-2,(float)ysize-2);
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:      gphUserFrame(fid,-1.,-1.,(float)xsize+1.,(float)ysize+1.);
kgl.c:      x[1]=-2.0; x[2]=xsize+2,x[5]=xsize+2,x[4]=xsize-2;x[3]=xsize-2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=-2.0,y[5]=ysize+2,y[4]=ysize-2;y[3]=2;y[0]=2;
kgl.c:      x[1]=-2.0; x[2]=xsize+2,x[3]=xsize+2,x[4]=xsize-2;x[5]=xsize-2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=-2.0,y[3]=ysize+2,y[4]=ysize-2;y[5]=2;y[0]=2;
kgl.c:      x[1]=-2.0; x[2]=-2,x[5]=xsize+2,x[4]=xsize-2;x[3]=+2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=ysize+2.0,y[5]=ysize+2,y[4]=ysize-2;y[3]=ysize-2;y[0]=2;
kgl.c:      x[1]=-2.0; x[2]=-2,x[3]=xsize+2,x[4]=xsize-2;x[5]=+2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=ysize+2.0,y[3]=ysize+2,y[4]=ysize-2;y[5]=ysize-2;y[0]=2;
kgl.c:          case -1:
kgl.c:           if(aspc) gphMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) gphMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     gphMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:   sprintf(flname,"%-s/Tmp.gph",tmpdir);
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:   vmin=vv+(vmax -vv)*.2;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-bordrsize,yl-bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, x, y, vd,vv,vmax, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:   vmin=vv+(vmax -vv)*.6;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-bordrsize,yl-bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-bordrsize,yl-bordrsize,fac1, x, y, v,vmin,vmax, count);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, xd1, yd1, vd1,vv,vv, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:   vmin=vv+(vmax -vv)*.6;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-1.8*bordrsize,yl-1.8*bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-1.8*bordrsize,yl-1.8*bordrsize,fac1, x, y, v,vmin,vmax, count);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, xd1, yd1, vd1,vv,vv, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize*0.5;
kgl.c:   fac1 = dl1/(size-bordrsize);
kgl.c:   dl2 = dl -bordrsize;
kgl.c:   fac2 = dl2/(size-2*bordrsize);
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,xd,yd) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-bordrsize,yl-bordrsize,fac1, count,x, y)-2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, count,xd1, yd1)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-bordrsize,yl-bordrsize,fac1, x, y, v,vmax,vmax, count);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac2, xd1, yd1, vd1,vlow,vlow, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:         clr = -clr;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:         clr = -clr;
kgl.c:         clr = -clr;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:     x[count+i]= -x[count1-i];
kgl.c:     y[count+i] = y[count1-i];
kgl.c:     x[2*count+1+i]= x[2*count1-i];
kgl.c:     y[2*count+1+i] = -y[2*count1-i];
kgl.c:   kgSetShadeParams(fid,yl*0.5, -yl*0.5,200, 16, 0);
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:         clr = -clr;
kgl.c:   vv = (vmin+0.4*(vmax-vmin));
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vmid, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:         clr = -clr;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   kgSetShadeParams(fid,yl*0.5, -yl*0.5,200, 128, 0);
kgl.c:         clr = -clr;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     v[i] = yl*0.5 - fabsf(y[i]);
kgl.c:     x[i] =2*xo-x[i];
kgl.c:     y[i] =2*yo-y[i];
kgl.c:     x[i] =2*xo-x[i];
kgl.c:         clr = -clr;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     v[i] = 1.0 -dis/D;
kgl.c:     x[i] =2*xo-x[i];
kgl.c:     y[i] =2*yo-y[i];
kgl.c:     x[i] =2*xo-x[i];
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:         clr = -clr;
kgl.c:   vv =vorg +(1.-vorg)*0.9;
kgl.c:   vmid = vorg +(1-vorg)*0.5;
kgl.c:   vmid1 = vorg +(1-vorg)*0.45;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vlow1, count);
kgl.c:     npj = np-1-i;
kgl.c:         clr = -clr;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[3]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[1]= x[np2-1];
kgl.c:   yd[1]=  y[np2-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:         clr = -clr;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:     np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vlow1, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[1]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   vd[3]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:   dl1 = dl -bordrsize;
kgl.c:   fac1 = dl1/(size-2*bordrsize);
kgl.c:         clr = -clr;
kgl.c://   vv = vorg*(1.05+2*atan(1.-vorg)/1.57);
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       fac1 = (fac1-0.5)/0.5;
kgl.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
kgl.c:       dv = (vmax-vmin);
kgl.c:       dv1 = (vmax1-vmin1);
kgl.c:       Dang = 90.0/(np-1);
kgl.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vlow,vv, count);
kgl.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vlow1, count);
kgl.c:     npj = np-1-i;
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:   vd[3]= v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     vd[i] = v[np-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:   xd[0]= -x[0];
kgl.c:   vd[0]= v[np-1];
kgl.c:   xd[1]= -x[0];
kgl.c:   yd[1]= -y[0];
kgl.c:   vd[1]= v[np-1];
kgl.c:   xd[2]= -x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   xd[3]= -x[np2-1];
kgl.c:   yd[3]=  y[np2-1];
kgl.c:   yd[3]= -y[0];
kgl.c:   xd[2]= x[np2-1];
kgl.c:   yd[2]= -y[np2-1];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[1]= x[np2-1];
kgl.c:   yd[1]=  y[np2-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:     xd[i] = -x[i]+xo;
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[i]= v[np-1-i];
kgl.c:     vd[np+i]= v[np2-1-i];
kgl.c:     yd[i] = -y[i] +yo;
kgl.c:     vd[np+i]= v[np2-1];
kgl.c:   xd[0]= x[np-1];
kgl.c:   yd[0]= y[np-1];
kgl.c:   vd[1]= v[np2-1];
kgl.c:   xd[2]= -x[np];
kgl.c:   vd[2]= v[np2-1];
kgl.c:   xd[3]= -x[np-1];
kgl.c:   yd[3]= y[np-1];
kgl.c:     yd[i] = -yd[i] +yo;
kgl.c:         clr = -clr;
kgl.c:   vv =vorg +(1.-vorg)*0.6;
kgl.c:   vmid = vorg +(1-vorg)*0.55;
kgl.c:   vmid1 = vorg +(1-vorg)*0.45;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 3;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count1+i]= -x[count-i];
kgl.c:     y[count1+i] = y[count-i];
kgl.c:     x[2*count1+i]= x[2*count1-1-i];
kgl.c:     y[2*count1+i] = -y[2*count1-1-i];
kgl.c:         clr = -clr;
kgl.c:   vv =vorg +(1.-vorg)*0.95;
kgl.c:   vv =vorg +(1.-vorg)*0.65;
kgl.c:   vmid = vorg +(1-vorg)*0.55;
kgl.c:   vmid1 = vorg +(1-vorg)*0.5;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   hcount = (count2-2)/2;
kgl.c:   for(i=hcount+2;i<count2-1;i++) {
kgl.c:   for(i=count2-1;i<2*count2+2;i++) {
kgl.c:   np = 3*count2-1-(2*count2+2+hcount);
kgl.c:   for(i=2*count2+2+hcount;i<3*count2-1-np;i++) {
kgl.c:   for(i=3*count2-1-np;i<3*count2-1;i++) {
kgl.c:   for(i=3*count2-1;i<count;i++) {
kgl.c:         clr = -clr;
kgl.c:   vv =vorg +(1.-vorg)*0.75;
kgl.c:   vmid = vorg +(1-vorg)*0.3;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   hcount = (count2-2)/2;
kgl.c:   for(i=hcount+2;i<count2-1;i++) {
kgl.c:   for(i=count2-1;i<2*count2+2;i++) {
kgl.c:   for(i=2*count2+2+hcount;i<3*count2-1;i++) {
kgl.c:   for(i=3*count2-1;i<count;i++) {
kgl.c:         clr = -clr;
kgl.c:   vv =vorg +(1.-vorg)*0.75;
kgl.c:   vmid = vorg +(1-vorg)*0.3;
kgl.c:       fac = (fac-0.5)/0.5;
kgl.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
kgl.c:       count2 = count -1;
kgl.c:       count1=  count2-1;
kgl.c:     xp = xl*0.5 -dl;
kgl.c:     yp = yl*0.5 - dl;
kgl.c:     x[count2+i]= -x[count2-i];
kgl.c:     y[count2+i] = y[count2-i];
kgl.c:     x[2*count2+i]= x[2*count2-i];
kgl.c:     y[2*count2+i] = -y[2*count2-i];
kgl.c:   hcount = (count2-2)/2;
kgl.c:   for(i=hcount+2;i<count2-1;i++) {
kgl.c:   for(i=count2-1;i<2*count2+2;i++) {
kgl.c:   for(i=2*count2+2+hcount;i<3*count2-1;i++) {
kgl.c:   for(i=3*count2-1;i<count;i++) {
kgl.c:         clr = -clr;
kgl.c:   xp = xl*0.5 -dl;
kgl.c:   yp = yl*0.5 - dl;
kgl.c:     x[count+i]= -x[count1-i];
kgl.c:     y[count+i] = y[count1-i];
kgl.c:     x[count+count1+i]= x[2*count1-i];
kgl.c:     y[count+count1+i] = -y[2*count1-i];
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:        case -1:
kgl.c:         kgMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:         kgMove2f(fid,(xsize-length-tw*0.5),0.25*ysize);
kgl.c:         kgMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:         fillcolor = -fillcolor;
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0+1.0,0.5*ysize-th*.5-1.0);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5+1.0,0.5*ysize-th*.5-1.0);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5)+1.0,0.5*ysize-th*.5-1.0);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5+1.0,0.5*ysize-th*0.5-1.0);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:      if(state==-1) {
kgl.c:      if(state != -1) {
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:      if(state==-1)
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:      if(state==-1) {
kgl.c:      kgRoundedRectangleRaised(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-4,(float)ysize-4,fillcolor,rfac,depthfac*0.3);
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0-2,3.0-2,xsize-3.,ysize-3.);
kgl.c://                         (float)xsize-2,(float)ysize-2,0,rfac,0.25);
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:         fillcolor = -fillcolor;
kgl.c:   if(state==-1) { v=0.6*v; }
kgl.c:      kgUserFrame(fid,-3.,-3.,(float)xsize+3.,(float)ysize+3.);
kgl.c:      if(state==-1) {
kgl.c://      kgRoundedRectangleFill(fid,(float)xsize*0.5-1.0,(float)ysize*0.5+0.5,(float)xsize,(float)ysize,0,148,rfac);
kgl.c:      kgRoundedRectangleFill(fid,(float)xsize*0.5+1.0,(float)ysize*0.5-1.0,(float)xsize,(float)ysize,0,0,rfac);
kgl.c://      kgRoundedRectangleFill(fid,(float)xsize*0.5+1,(float)ysize*0.5+1,(float)xsize-1,(float)ysize-1,0,152,rfac);
kgl.c://      xsize -=2.0;
kgl.c://      ysize -=2.0;
kgl.c:      xsize-=2.0;
kgl.c:      ysize-=2.0;
kgl.c:         kgRoundedRectangleFill(fid,(float)xsize*0.5-1.0,(float)ysize*0.5+1.0,(float)xsize,(float)ysize,0,15,rfac);
kgl.c:         kgRoundedRectangleFill(fid,(float)xsize*0.5-1.0,(float)ysize*0.5+1.0,(float)xsize,(float)ysize,0,15,rfac);
kgl.c:         kgRoundedRectangleFill(fid,(float)xsize*0.5-1.0,(float)ysize*0.5+1.0,(float)xsize,(float)ysize,0,15,rfac);
kgl.c:         kgRoundedRectangleFill(fid,(float)xsize*0.5-1.0,(float)ysize*0.5+0.5,(float)xsize,(float)ysize,0,15,rfac);
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c://           else     kgMove2f(fid,xm-th*0.5,ym-length*0.5+th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+tw*0.4,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-0.5,-0.5,(float)xsize+0.5,(float)ysize+0.5);
kgl.c:         border = -border;
kgl.c:      if(state==-1) {
kgl.c:      kgRoundedRectangle(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-1,(float)ysize-1,252,rfac,1.0);
kgl.c:      if(image != NULL) kgDrawImage(fid,image,3.0,3.0,xsize-3.,ysize-3.);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:        case -1:
kgl.c:         kgMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:         kgMove2f(fid,(xsize-length-tw*0.5),0.25*ysize);
kgl.c:         kgMove2f(fid,(xsize-length)*.5,0.25*ysize);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-0.,-0.,(float)xsize+0.,(float)ysize+0.);
kgl.c:      kgRoundedRectangleFill(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-3,(float)ysize-3,0,fillcolor,rfac);
kgl.c:      kgRoundedRectanglePressed(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-3,(float)ysize-3,bodrcolor,rfac,5.0);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c://      kgUserFrame(fid,-0.,-0.,(float)xsize+0.,(float)ysize+0.);
kgl.c:      kgUserFrame(fid,-1.0,-1.0,(float)xsize+1.0,(float)ysize+1.0);
kgl.c:         color = -color;
kgl.c:         bodrcolor = -bodrcolor;
kgl.c:         fillcolor = -fillcolor;
kgl.c:      kgRoundedRectangleFill(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-4,(float)ysize-4,0,fillcolor,rfac);
kgl.c://      kgRoundedRectangleFill(fid,(float)xsize*0.5,(float)ysize*0.5,(float)xsize-6,(float)ysize-6,0,fillcolor,rfac);
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.35);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.35);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.35);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.35);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:      kgUserFrame(fid,-1.,-1.,(float)xsize+1.,(float)ysize+1.);
kgl.c:         fillcolor = -fillcolor;
kgl.c:      x[1]=-2.0; x[2]=xsize+2,x[5]=xsize+2,x[4]=xsize-2;x[3]=xsize-2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=-2.0,y[5]=ysize+2,y[4]=ysize-2;y[3]=2;y[0]=2;
kgl.c:      x[1]=-2.0; x[2]=xsize+2,x[3]=xsize+2,x[4]=xsize-2;x[5]=xsize-2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=-2.0,y[3]=ysize+2,y[4]=ysize-2;y[5]=2;y[0]=2;
kgl.c:      x[1]=-2.0; x[2]=-2,x[5]=xsize+2,x[4]=xsize-2;x[3]=+2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=ysize+2.0,y[5]=ysize+2,y[4]=ysize-2;y[3]=ysize-2;y[0]=2;
kgl.c:      x[1]=-2.0; x[2]=-2,x[3]=xsize+2,x[4]=xsize-2;x[5]=+2;x[0]=+2;
kgl.c:      y[1]=-2.0; y[2]=ysize+2.0,y[3]=ysize+2,y[4]=ysize-2;y[5]=ysize-2;y[0]=2;
kgl.c:          case -1:
kgl.c:           if(aspc) kgMove2f(fid,0.0,0.5*ysize-th*.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length-tw*0.5),0.5*ysize-th*.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length));
kgl.c:           if(aspc) kgMove2f(fid,(xsize-length)*.5,0.5*ysize-th*0.5);
kgl.c:           else     kgMove2f(fid,0.5*xsize+th*0.5,(ysize-length)*0.5);
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:/* -1 left justification ; 0 center ;1 right */
kgl.c:     L = (Dlink *)(D->SearchList);
kgl.c:       D->SearchList=L;
kgl.c:      kgUserFrame(fid,-3.0,-3.0,(float)l+3,(float)w+3);
kgl.c:         fillclr =-fillclr;
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-3,(float)w-3,0,151,rfac);
kgl.c:      kgRoundedRectangleFill(fid,xo,yo,(float)l-3,(float)w-3,0,151,rfac);
kgl.c:      kgUserFrame(fid,-0.5,-0.5,(float)l+0.5,(float)w+0.5);
kgl.c:         fillclr =-fillclr;
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-1.5,(float)w-1.5,0,253,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-1.0,(float)w-1.0,0,253,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-0.5,(float)w-0.5,0,253,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-2,(float)w-2,0,251,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-1.5,(float)w-1.5,0,253,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-1.0,(float)w-1.0,0,253,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-0.5,(float)w-0.5,0,253,rfac);
kgl.c:      kgSmallRectangleFill(fid,xo,yo,(float)l-2,(float)w-2,0,251,rfac);
kgl.c:    D = G->D;
kgl.c:    wc = G->wc;
kgl.c:    dc = G->dc;
kgl.c:    Evgay=D->evgay;
kgl.c:    if(dc->ZBUFF==1) {uiclear_zbuf(G);}
kgl.c:    EVGAX= G->x2-G->x1+1;
kgl.c:    EVGAY= abs(G->y2-G->y1)+1;
kgl.c:    v_x1=dc->vu_x1*(float)EVGAX;
kgl.c:    v_y1= dc->vu_y1*(float)EVGAY;
kgl.c:    v_x2=dc->vu_x2*(float)EVGAX-1;
kgl.c:    v_y2= dc->vu_y2*(float)EVGAY-1;
kgl.c:    V_x=v_x2-v_x1+1;
kgl.c:    V_y=v_y2-v_y1+1;
kgl.c:    D_x=G->x1+D->xo+v_x1;
kgl.c:    D_y = D->yo+G->y1+EVGAY-1-v_y2;
kgl.c:    tpt = D->tmpdir;
kgl.c:    img = uiGetAntialiasedImage(flname,w,h,dc->ls_list,4);
kgui.c:          while ( pt [ l ] != '/' ) l--;
kgui.c:  if returns -1 for search failed
kgui.c:      int ch , ln , ret = -1 , ln1 , i = 0;
kgui.c:      if ( ln1 < ln ) ret = -1;
kgui.c:          for ( i = 0;i <= ( ln1-ln ) ;i++ ) {
kgui.c:          while ( isdigit ( s1 [ i ] ) ) {n1 = n1*10+ ( s1 [ i ] -'0' ) ;i++;}
kgui.c:          while ( isdigit ( s2 [ i ] ) ) {n2 = n2*10+ ( s2 [ i ] -'0' ) ;i++;}
kgui.c:          while ( pt [ l ] != '/' ) l--;
kgui.c:      while ( pt [ i ] <= ' ' ) {pt [ i ] = '\0'; i--;if ( i == 0 ) break;}
kgui.c:          ptmp = strstr ( Icon , "-" ) ;
kgui.c:      ret = br->df;
kgui.c:      D = br->D;
kgui.c:      ret = kgMenu ( br->D , br->x1 , br->y1 , ret , ret , br->menu , br->size ) ;
kgui.c:      br->df = ret;
kgui.c://   ui_draw_browser((DIW *)br->wid);
kgui.c:      _uiMake_W ( ( DIW * ) br->wid ) ;
kgui.c:      uiUpdateOn ( br->D ) ;
kgui.c:                  size = size*10+ ( *cpt -'0' ) ;
kgui.c:                  sprintf ( dfmt , "%%-%-dd" , fln [ it ] -1 ) ;
kgui.c:                  wrk [ fln [ it ] -1 ] = '\0';
kgui.c:                  sprintf ( ffmt , "%%-%-df" , fln [ it ] -1 ) ;
kgui.c:                  wrk [ fln [ it ] -1 ] = '\0';
kgui.c:                  sprintf ( ffmt , "%%-%-dlf" , fln [ it ] -1 ) ;
kgui.c:                  wrk [ fln [ it ] -1 ] = '\0';
kgui.c:                  sprintf ( sfmt , "%%-%-ds" , fln [ it ] -1 ) ;
kgui.c:                  wrk [ fln [ it ] -1 ] = '\0';
kgui.c:      for ( i = 0;i < n-1;i++ ) {
kgui.c:      D = ( DIALOG * ) ( d [ i ] .t->D ) ;
kgui.c:      if ( d [ i ] .t->Update != NULL ) ret = d [ i ] .t->Update ( code , i , d ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      D = ( DIALOG * ) ( d [ i ] .b->D ) ;
kgui.c:      if ( d [ i ] .b->Update != NULL ) ret = d [ i ] .b->Update ( code , i , d ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .f->Update != NULL ) ret = d [ i ] .f->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .d->Update != NULL ) ret = d [ i ] .d->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .B->Update != NULL ) ret = d [ i ] .B->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .t->Update != NULL ) ret = d [ i ] .t->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .t->Update != NULL ) ret = d [ i ] .t->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .y->Update != NULL ) ret = d [ i ] .y->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .b->Update != NULL ) ret = d [ i ] .b->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .N->Update != NULL ) ret = d [ i ] .N->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .h->Update != NULL ) ret = d [ i ] .h->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .H->Update != NULL ) ret = d [ i ] .H->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .w->Update != NULL ) ret = d [ i ] .w->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .e->Update != NULL ) ret = d [ i ] .e->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      d = D->d;
kgui.c:      if ( d [ i ] .x->Update != NULL ) ret = d [ i ] .x->Update ( code , i , D ) ;
kgui.c:      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
kgui.c:      if ( D->PON_X < D->xo ) return 0;
kgui.c:      if ( D->PON_X > ( D->xo+D->xl ) ) return 0;
kgui.c:      if ( D->PON_Y < D->yo ) return 0;
kgui.c:      if ( D->PON_Y > ( D->yo+D->yl ) ) return 0;
kgui.c:      if ( D->PON_X < D->xo ) return -1;
kgui.c:      if ( D->PON_X > ( D->xo+D->xl ) ) return -1;
kgui.c:      if ( D->PON_Y < D->yo ) return -1;
kgui.c:      if ( D->PON_Y > ( D->yo+D->yl ) ) return -1;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .t->x1+x1 , d [ i ] .t->y1+y1 , d [ i ] .t->x2+x1 , d [ i ] .t->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .y->x1+x1 , d [ i ] .y->y1+y1 , d [ i ] .y->x2+x1 , d [ i ] .y->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .c->x1+x1 , d [ i ] .c->y1+y1 , d [ i ] .c->x2+x1 , d [ i ] .c->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .r->x1+x1 , d [ i ] .r->y1+y1 , d [ i ] .r->x2+x1 , d [ i ] .r->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .h->x1+x1 , d [ i ] .h->y1+y1 , d [ i ] .h->x2+x1 , d [ i ] .h->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .b->x1+x1 , d [ i ] .b->y1+y1 , d [ i ] .b->x2+x1 , d [ i ] .b->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .f->x1+x1 , d [ i ] .f->y1+y1 , d [ i ] .f->x2+x1 , d [ i ] .f->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .d->x1+x1 , d [ i ] .d->y1+y1 , d [ i ] .d->x2+x1 , d [ i ] .d->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .B->x1+x1 , d [ i ] .B->y1+y1 , d [ i ] .B->x2+x1 , d [ i ] .B->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .w->x1+x1 , d [ i ] .w->y1+y1 , d [ i ] .w->x2+x1 , d [ i ] .w->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .x->x1+x1 , d [ i ] .x->y1+y1 , d [ i ] .x->x2+x1 , d [ i ] .x->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .e->x1+x1 , d [ i ] .e->y1+y1 , d [ i ] .e->x2+x1 , d [ i ] .e->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .s->x1+x1 , d [ i ] .s->y1+y1 , d [ i ] .s->x2+x1 , d [ i ] .s->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .v->x1+x1 , d [ i ] .v->y1+y1 , d [ i ] .v->x2+x1 , d [ i ] .v->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:              if ( uiCheckClickPosition ( d [ i ] .z->x1+x1 , d [ i ] .z->y1+y1 , d [ i ] .z->x2+x1 , d [ i ] .z->y2+y1 , D->PON_X , D->PON_Y ) == 1 ) return i%n;
kgui.c:      return -1;
kgui.c:      if ( ! D->kbattn ) return 0;
kgui.c:      x1 = D->xo;
kgui.c:      y1 = D->yo;
kgui.c:      d = D->d;
kgui.c:      ch = ( d [ i ] .t->code ) ;
kgui.c:          X1 = d [ i ] .t->x1+x1;
kgui.c:          Y1 = d [ i ] .t->y1+y1;
kgui.c:          X2 = d [ i ] .t->x2+x1;
kgui.c:          Y2 = d [ i ] .t->y2+y1;
kgui.c:          X1 = d [ i ] .t->x1+x1;
kgui.c:          Y1 = d [ i ] .t->y1+y1;
kgui.c:          X2 = d [ i ] .t->x2+x1;
kgui.c:          Y2 = d [ i ] .t->y2+y1;
kgui.c:          X1 = d [ i ] .v->x1+x1;
kgui.c:          Y1 = d [ i ] .v->y1+y1;
kgui.c:          X2 = d [ i ] .v->x2+x1;
kgui.c:          Y2 = d [ i ] .v->y2+y1;
kgui.c:          X1 = d [ i ] .z->x1+x1;
kgui.c:          Y1 = d [ i ] .z->y1+y1;
kgui.c:          X2 = d [ i ] .z->x2+x1;
kgui.c:          Y2 = d [ i ] .z->y2+y1;
kgui.c:          X1 = d [ i ] .x->x1+x1;
kgui.c:          Y1 = d [ i ] .x->y1+y1;
kgui.c:          X2 = d [ i ] .x->x2+x1;
kgui.c:          Y2 = d [ i ] .x->y2+y1;
kgui.c:          X1 = d [ i ] .y->x1+x1;
kgui.c:          Y1 = d [ i ] .x->y1+y1;
kgui.c:          X2 = d [ i ] .y->x2+x1;
kgui.c:          Y2 = d [ i ] .y->y2+y1;
kgui.c:          X1 = d [ i ] .r->x1+x1;
kgui.c:          Y1 = d [ i ] .r->y1+y1;
kgui.c:          X2 = d [ i ] .r->x2+x1;
kgui.c:          Y2 = d [ i ] .r->y2+y1;
kgui.c:          X1 = d [ i ] .c->x1+x1;
kgui.c:          Y1 = d [ i ] .c->y1+y1;
kgui.c:          X2 = d [ i ] .c->x2+x1;
kgui.c:          Y2 = d [ i ] .c->y2+y1;
kgui.c:          X1 = d [ i ] .h->x1+x1;
kgui.c:          Y1 = d [ i ] .h->y1+y1;
kgui.c:          X2 = d [ i ] .h->x2+x1;
kgui.c:          Y2 = d [ i ] .h->y2+y1;
kgui.c:          X1 = d [ i ] .b->x1+x1;
kgui.c:          Y1 = d [ i ] .b->y1+y1;
kgui.c:          X2 = d [ i ] .b->x2+x1;
kgui.c:          Y2 = d [ i ] .b->y2+y1;
kgui.c:          X1 = d [ i ] .f->x1+x1;
kgui.c:          Y1 = d [ i ] .f->y1+y1;
kgui.c:          X2 = d [ i ] .f->x2+x1;
kgui.c:          Y2 = d [ i ] .f->y2+y1;
kgui.c:          X1 = d [ i ] .d->x1+x1;
kgui.c:          Y1 = d [ i ] .d->y1+y1;
kgui.c:          X2 = d [ i ] .d->x2+x1;
kgui.c:          Y2 = d [ i ] .d->y2+y1;
kgui.c:          X1 = d [ i ] .B->x1+x1;
kgui.c:          Y1 = d [ i ] .B->y1+y1;
kgui.c:          X2 = d [ i ] .B->x2+x1;
kgui.c:          Y2 = d [ i ] .B->y2+y1;
kgui.c:          X1 = d [ i ] .w->x1+x1;
kgui.c:          Y1 = d [ i ] .w->y1+y1;
kgui.c:          X2 = d [ i ] .w->x2+x1;
kgui.c:          Y2 = d [ i ] .w->y2+y1;
kgui.c:          X1 = d [ i ] .e->x1+x1;
kgui.c:          Y1 = d [ i ] .e->y1+y1;
kgui.c:          X2 = d [ i ] .e->x2+x1;
kgui.c:          Y2 = d [ i ] .e->y2+y1;
kgui.c:          X1 = d [ i ] .s->x1+x1;
kgui.c:          Y1 = d [ i ] .s->y1+y1;
kgui.c:          X2 = d [ i ] .s->x2+x1;
kgui.c:          Y2 = d [ i ] .s->y2+y1;
kgui.c:          return -1;
kgui.c:      switch ( D->kbattn ) {
kgui.c:      return -1;
kgui.c:      if ( ! D->kbattn ) return 0;
kgui.c:      x1 = D->xo;
kgui.c:      y1 = D->yo;
kgui.c:      d = D->d;
kgui.c:      ch = ( d [ i ] .t->code ) ;
kgui.c:          X1 = d [ i ] .t->x1+x1;
kgui.c:          Y1 = d [ i ] .t->y1+y1;
kgui.c:          X2 = d [ i ] .t->x2+x1;
kgui.c:          Y2 = d [ i ] .t->y2+y1;
kgui.c:          X1 = d [ i ] .t->x1+x1;
kgui.c:          Y1 = d [ i ] .t->y1+y1;
kgui.c:          X2 = d [ i ] .t->x2+x1;
kgui.c:          Y2 = d [ i ] .t->y2+y1;
kgui.c:          X1 = d [ i ] .v->x1+x1;
kgui.c:          Y1 = d [ i ] .v->y1+y1;
kgui.c:          X2 = d [ i ] .v->x2+x1;
kgui.c:          Y2 = d [ i ] .v->y2+y1;
kgui.c:          X1 = d [ i ] .z->x1+x1;
kgui.c:          Y1 = d [ i ] .z->y1+y1;
kgui.c:          X2 = d [ i ] .z->x2+x1;
kgui.c:          Y2 = d [ i ] .z->y2+y1;
kgui.c:          X1 = d [ i ] .x->x1+x1;
kgui.c:          Y1 = d [ i ] .x->y1+y1;
kgui.c:          X2 = d [ i ] .x->x2+x1;
kgui.c:          Y2 = d [ i ] .x->y2+y1;
kgui.c:          X1 = d [ i ] .y->x1+x1;
kgui.c:          Y1 = d [ i ] .y->y1+y1;
kgui.c:          X2 = d [ i ] .y->x2+x1;
kgui.c:          Y2 = d [ i ] .y->y2+y1;
kgui.c:          X1 = d [ i ] .r->x1+x1;
kgui.c:          Y1 = d [ i ] .r->y1+y1;
kgui.c:          X2 = d [ i ] .r->x2+x1;
kgui.c:          Y2 = d [ i ] .r->y2+y1;
kgui.c:          X1 = d [ i ] .c->x1+x1;
kgui.c:          Y1 = d [ i ] .c->y1+y1;
kgui.c:          X2 = d [ i ] .c->x2+x1;
kgui.c:          Y2 = d [ i ] .c->y2+y1;
kgui.c:          X1 = d [ i ] .h->x1+x1;
kgui.c:          Y1 = d [ i ] .h->y1+y1;
kgui.c:          X2 = d [ i ] .h->x2+x1;
kgui.c:          Y2 = d [ i ] .h->y2+y1;
kgui.c:          X1 = d [ i ] .b->x1+x1;
kgui.c:          Y1 = d [ i ] .b->y1+y1;
kgui.c:          X2 = d [ i ] .b->x2+x1;
kgui.c:          Y2 = d [ i ] .b->y2+y1;
kgui.c:          X1 = d [ i ] .f->x1+x1;
kgui.c:          Y1 = d [ i ] .f->y1+y1;
kgui.c:          X2 = d [ i ] .f->x2+x1;
kgui.c:          Y2 = d [ i ] .f->y2+y1;
kgui.c:          X1 = d [ i ] .d->x1+x1;
kgui.c:          Y1 = d [ i ] .d->y1+y1;
kgui.c:          X2 = d [ i ] .d->x2+x1;
kgui.c:          Y2 = d [ i ] .d->y2+y1;
kgui.c:          X1 = d [ i ] .B->x1+x1;
kgui.c:          Y1 = d [ i ] .B->y1+y1;
kgui.c:          X2 = d [ i ] .B->x2+x1;
kgui.c:          Y2 = d [ i ] .B->y2+y1;
kgui.c:          X1 = d [ i ] .w->x1+x1;
kgui.c:          Y1 = d [ i ] .w->y1+y1;
kgui.c:          X2 = d [ i ] .w->x2+x1;
kgui.c:          Y2 = d [ i ] .w->y2+y1;
kgui.c:          X1 = d [ i ] .e->x1+x1;
kgui.c:          Y1 = d [ i ] .e->y1+y1;
kgui.c:          X2 = d [ i ] .e->x2+x1;
kgui.c:          Y2 = d [ i ] .e->y2+y1;
kgui.c:          X1 = d [ i ] .s->x1+x1;
kgui.c:          Y1 = d [ i ] .s->y1+y1;
kgui.c:          X2 = d [ i ] .s->x2+x1;
kgui.c:          Y2 = d [ i ] .s->y2+y1;
kgui.c:          return -1;
kgui.c:      switch ( D->kbattn ) {
kgui.c:      return -1;
kgui.c:      int n , i , controls = 0 , item , ch , oldi = -1;
kgui.c:      d = D->d;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              g->D = D;
kgui.c:              if ( g->initgraph != NULL ) {
kgui.c:                  g->initgraph ( i , D ) ;
kgui.c://       D->df=0;
kgui.c:      int n , i , controls = 0 , item , ch , oldi = -1;
kgui.c:      d = D->d;
kgui.c:      D->df = 0;
kgui.c:      if ( D->DrawBkgr == 1 ) _ui_Draw_Dialog_Area_Transparent ( D ) ;
kgui.c:      if ( D->Bkpixmap != NULL ) kgImage ( ( D ) , D->Bkpixmap , 0 , 0 , D->xl , D->yl , D->transparency , 1.0 ) ;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  if ( D->InputWid < 0 ) D->InputWid = i;
kgui.c:                  D->df = i;
kgui.c:                  if ( D->InputWid < 0 ) D->InputWid = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:                  D->df = i;
kgui.c:      D->controls = controls;
kgui.c:      D->TotWid = i;
kgui.c:      int i , k , ret = -1;
kgui.c:      d = D->d;
kgui.c:      int n , controls = 0 , item , ch , oldi = -1 , ret = 0 , i , k;
kgui.c:      d = D->d;
kgui.c:      if ( k != -1 ) {
kgui.c:          ch = ( t->code ) ;
kgui.c:              if ( d [ i ] .o->item == -1 ) _uiDrawO ( D , i ) ;
kgui.c:              if ( d [ i ] .p->item == -1 ) _uiDrawP ( D , i ) ;
kgui.c:              if ( d [ i ] .i->item == -1 ) _uiDrawI ( D , i ) ;
kgui.c:              if ( d [ i ] .x->item == -1 ) _uiDrawX ( D , i ) ;
kgui.c:              if ( d [ i ] .v->item == -1 ) _uiDrawV ( D , i ) ;
kgui.c:              if ( d [ i ] .z->item == -1 ) _uiDrawZ ( D , i ) ;
kgui.c:              if ( d [ i ] .y->item == -1 ) _uiDrawY ( D , i ) ;
kgui.c:              if ( d [ i ] .r->item == -1 ) _uiDrawRadioButton ( D , i ) ;
kgui.c:              if ( d [ i ] .c->item == -1 ) _uiDrawCheckBox ( D , i ) ;
kgui.c:              if ( d [ i ] .t->item == -1 ) _uiDrawTextBox ( D , i ) ;
kgui.c:              if ( d [ i ] .t->item == -1 ) _uiDrawTableBox ( D , i ) ;
kgui.c:              if ( d [ i ] .h->item == -1 ) _uiDrawN ( D , i ) ;
kgui.c:              if ( d [ i ] .H->item == -1 ) _uiDrawHoriButtons ( D , i ) ;
kgui.c:              if ( d [ i ] .N->item == -1 ) _uiDrawN ( D , i ) ;
kgui.c:              if ( d [ i ] .b->item == -1 ) _uiDrawB ( D , i ) ;
kgui.c:              if ( d [ i ] .f->item == -1 ) _uiDrawSlideFloat ( D , i ) ;
kgui.c:              if ( d [ i ] .B->item == -1 ) _uiDrawHbar ( D , i ) ;
kgui.c:              if ( d [ i ] .d->item == -1 ) _uiDrawSlideInteger ( D , i ) ;
kgui.c:              if ( d [ i ] .w->item == -1 ) _uiDrawBrowser ( D , i ) ;
kgui.c:              if ( d [ i ] .e->item == -1 ) _uiDrawE ( D , i ) ;
kgui.c:              if ( d [ i ] .s->item == -1 ) _uiDrawScrollMsgItem ( D , i ) ;
kgui.c:              if ( d [ i ] .g->item == -1 ) _uiDrawGraphicsArea ( D , i ) ;
kgui.c:              if ( d [ i ] .m->item == -1 ) _uiDrawMessage ( D , i ) ;
kgui.c:              ret = -1;
kgui.c:      int n , i , controls = 0 , item , ch , oldi = -1;
kgui.c:      d = D->d;
kgui.c:      D->df = 0;
kgui.c:      if ( D->DrawBkgr == 1 ) _ui_Draw_Dialog_Area_Transparent ( D ) ;
kgui.c:      if ( D->Bkpixmap != NULL ) kgImage ( ( D ) , D->Bkpixmap , 0 , 0 , D->xl , D->yl , D->transparency , 1.0 ) ;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              if ( d [ i ] .o->hide != 1 ) break;
kgui.c:              item = d [ i ] .o->item;
kgui.c:              if ( d [ i ] .o->item == -1 ) _uiDrawO ( D , i ) ;
kgui.c:              if ( d [ i ] .p->hide != 1 ) break;
kgui.c:              item = d [ i ] .p->item;
kgui.c:              if ( d [ i ] .p->item == -1 ) _uiDrawP ( D , i ) ;
kgui.c:              if ( d [ i ] .i->hide != 1 ) break;
kgui.c:              item = d [ i ] .i->item;
kgui.c:              if ( d [ i ] .i->item == -1 ) _uiDrawI ( D , i ) ;
kgui.c:              if ( d [ i ] .x->hide != 1 ) break;
kgui.c:              item = d [ i ] .x->item;
kgui.c:              if ( d [ i ] .x->item == -1 ) _uiDrawX ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .v->hide != 1 ) break;
kgui.c:              item = d [ i ] .v->item;
kgui.c:              if ( d [ i ] .v->item == -1 ) _uiDrawV ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .z->hide != 1 ) break;
kgui.c:              item = d [ i ] .z->item;
kgui.c:              if ( d [ i ] .z->item == -1 ) _uiDrawZ ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .y->hide != 1 ) break;
kgui.c:              item = d [ i ] .y->item;
kgui.c:              if ( d [ i ] .y->item == -1 ) _uiDrawY ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .r->hide != 1 ) break;
kgui.c:              item = d [ i ] .r->item;
kgui.c:              if ( d [ i ] .r->item == -1 ) _uiDrawRadioButton ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .c->hide != 1 ) break;
kgui.c:              item = d [ i ] .c->item;
kgui.c:              if ( d [ i ] .c->item == -1 ) _uiDrawCheckBox ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .t->hide != 1 ) break;
kgui.c:              item = d [ i ] .t->item;
kgui.c:              if ( d [ i ] .t->item == -1 ) _uiDrawTextBox ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .t->hide != 1 ) break;
kgui.c:              item = d [ i ] .t->item;
kgui.c:              if ( d [ i ] .t->item == -1 ) _uiDrawTableBox ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .h->hide != 1 ) break;
kgui.c:              item = d [ i ] .h->item;
kgui.c:              if ( d [ i ] .h->item == -1 ) _uiDrawN ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .H->hide != 1 ) break;
kgui.c:              item = d [ i ] .H->item;
kgui.c:              if ( d [ i ] .H->item == -1 ) _uiDrawHoriButtons ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .N->hide != 1 ) break;
kgui.c:              item = d [ i ] .N->item;
kgui.c:              if ( d [ i ] .N->item == -1 ) _uiDrawN ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .b->hide != 1 ) break;
kgui.c:              item = d [ i ] .b->item;
kgui.c:              if ( d [ i ] .b->item == -1 ) _uiDrawB ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .f->hide != 1 ) break;
kgui.c:              item = d [ i ] .f->item;
kgui.c:              if ( d [ i ] .f->item == -1 ) _uiDrawSlideFloat ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .B->hide != 1 ) break;
kgui.c:              item = d [ i ] .B->item;
kgui.c:              if ( d [ i ] .B->item == -1 ) _uiDrawHbar ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .d->hide != 1 ) break;
kgui.c:              item = d [ i ] .d->item;
kgui.c:              if ( d [ i ] .d->item == -1 ) _uiDrawSlideInteger ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .w->hide != 1 ) break;
kgui.c:              item = d [ i ] .w->item;
kgui.c:              if ( d [ i ] .w->item == -1 ) _uiDrawBrowser ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .e->hide != 1 ) break;
kgui.c:              item = d [ i ] .e->item;
kgui.c:              if ( d [ i ] .e->item == -1 ) _uiDrawE ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .s->hide != 1 ) break;
kgui.c:              item = d [ i ] .s->item;
kgui.c:              if ( d [ i ] .s->item == -1 ) _uiDrawScrollMsgItem ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .g->hide != 1 ) break;
kgui.c:              item = d [ i ] .g->item;
kgui.c:              if ( d [ i ] .g->item == -1 ) _uiDrawGraphicsArea ( D , i ) ;
kgui.c:              if ( d [ i ] .m->hide != 1 ) break;
kgui.c:              item = d [ i ] .m->item;
kgui.c:              if ( d [ i ] .m->item == -1 ) _uiDrawMessage ( D , i ) ;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              if ( d [ i ] .o->hide == 1 ) break;
kgui.c:              item = d [ i ] .o->item;
kgui.c:              if ( d [ i ] .o->item == -1 ) _uiDrawO ( D , i ) ;
kgui.c:              if ( d [ i ] .p->hide == 1 ) break;
kgui.c:              item = d [ i ] .p->item;
kgui.c:              if ( d [ i ] .p->item == -1 ) _uiDrawP ( D , i ) ;
kgui.c:              if ( d [ i ] .i->hide == 1 ) break;
kgui.c:              item = d [ i ] .i->item;
kgui.c:              if ( d [ i ] .i->item == -1 ) _uiDrawI ( D , i ) ;
kgui.c:              if ( d [ i ] .x->hide == 1 ) break;
kgui.c:              item = d [ i ] .x->item;
kgui.c:              if ( d [ i ] .x->item == -1 ) _uiDrawX ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .v->hide == 1 ) break;
kgui.c:              item = d [ i ] .v->item;
kgui.c:              if ( d [ i ] .v->item == -1 ) _uiDrawV ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .z->hide == 1 ) break;
kgui.c:              item = d [ i ] .z->item;
kgui.c:              if ( d [ i ] .z->item == -1 ) _uiDrawZ ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .y->hide == 1 ) break;
kgui.c:              item = d [ i ] .y->item;
kgui.c:              if ( d [ i ] .y->item == -1 ) _uiDrawY ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .r->hide == 1 ) break;
kgui.c:              item = d [ i ] .r->item;
kgui.c:              if ( d [ i ] .r->item == -1 ) _uiDrawRadioButton ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .c->hide == 1 ) break;
kgui.c:              item = d [ i ] .c->item;
kgui.c:              if ( d [ i ] .c->item == -1 ) _uiDrawCheckBox ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .t->hide == 1 ) break;
kgui.c:              item = d [ i ] .t->item;
kgui.c:              if ( d [ i ] .t->item == -1 ) _uiDrawTextBox ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .t->hide == 1 ) break;
kgui.c:              item = d [ i ] .t->item;
kgui.c:              if ( d [ i ] .t->item == -1 ) _uiDrawTableBox ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .h->hide == 1 ) break;
kgui.c:              item = d [ i ] .h->item ;
kgui.c:              if ( d [ i ] .h->item == -1 ) _uiDrawN ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .H->hide == 1 ) break;
kgui.c:              item = d [ i ] .H->item;
kgui.c:              if ( d [ i ] .H->item == -1 ) _uiDrawHoriButtons ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .N->hide == 1 ) break;
kgui.c:              item = d [ i ] .N->item;
kgui.c:              if ( d [ i ] .N->item == -1 ) _uiDrawN ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .b->hide == 1 ) break;
kgui.c:              item = d [ i ] .b->item;
kgui.c:              if ( d [ i ] .b->item == -1 ) _uiDrawB ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .f->hide == 1 ) break;
kgui.c:              item = d [ i ] .f->item;
kgui.c:              if ( d [ i ] .f->item == -1 ) _uiDrawSlideFloat ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .B->hide == 1 ) break;
kgui.c:              item = d [ i ] .B->item;
kgui.c:              if ( d [ i ] .B->item == -1 ) _uiDrawHbar ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .d->hide == 1 ) break;
kgui.c:              item = d [ i ] .d->item;
kgui.c:              if ( d [ i ] .d->item == -1 ) _uiDrawSlideInteger ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .w->hide == 1 ) break;
kgui.c:              item = d [ i ] .w->item;
kgui.c:              if ( d [ i ] .w->item == -1 ) _uiDrawBrowser ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .e->hide == 1 ) break;
kgui.c:              item = d [ i ] .e->item;
kgui.c:              if ( d [ i ] .e->item == -1 ) _uiDrawE ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .s->hide == 1 ) break;
kgui.c:              item = d [ i ] .s->item;
kgui.c:              if ( d [ i ] .s->item == -1 ) _uiDrawScrollMsgItem ( D , i ) ;
kgui.c:              D->df = i;
kgui.c:              if ( d [ i ] .g->hide == 1 ) break;
kgui.c:              item = d [ i ] .g->item;
kgui.c:              if ( d [ i ] .g->item == -1 ) _uiDrawGraphicsArea ( D , i ) ;
kgui.c:              if ( d [ i ] .m->hide == 1 ) break;
kgui.c:              item = d [ i ] .m->item;
kgui.c:              if ( d [ i ] .m->item == -1 ) _uiDrawMessage ( D , i ) ;
kgui.c:      D->controls = controls;
kgui.c:      D->TotWid = i;
kgui.c:      d = D->d;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              FreeImg ( ( ( DIV * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIZ * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIO * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  kgFreeImage ( p->Bimg ) ;
kgui.c:                  p->Bimg = NULL;
kgui.c:                  Free ( I->twin ) ;
kgui.c:              FreeImg ( ( ( DII * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c://         free(((TX_STR *)(t->tstr))->tit);
kgui.c://         free(((TX_STR *)(t->tstr))->ln);
kgui.c:                  Free ( t->tstr ) ;
kgui.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c://          free(((TX_STR *)(T->tstr))->ln);
kgui.c:                  Free ( T->tstr ) ;
kgui.c:                  T->tstr = NULL;
kgui.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  butn = ( BUT_STR * ) b->buts;
kgui.c:                  if ( b->buts != NULL ) {
kgui.c:                      n = b->nx*b->ny;
kgui.c:                      Free ( b->buts ) ;
kgui.c:                      b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIL * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( h->buts ) ;
kgui.c:                  h->buts = NULL;
kgui.c:              FreeImg ( ( ( DILN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  butn = ( BUT_STR * ) b->buts;
kgui.c:                  if ( b->buts != NULL ) {
kgui.c:                      n = b->nx*b->ny;
kgui.c:                      Free ( b->buts ) ;
kgui.c:                      b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  buts = n->buts;
kgui.c:                      Free ( buts->sw ) ;
kgui.c:                      n->buts = NULL;
kgui.c:              FreeImg ( ( ( DIBN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  if ( b->buts != NULL ) {
kgui.c:                      Free ( b->buts ) ;
kgui.c:                      b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIB * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( f->sptr ) ;
kgui.c:                  f->sptr = NULL;
kgui.c:              FreeImg ( ( ( DIF * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  pt = B->sptr;
kgui.c:                      kgFreeImage ( pt->bimg ) ;
kgui.c:                      kgFreeImage ( pt->fimg ) ;
kgui.c:                      Free ( B->sptr ) ;
kgui.c:                      B->sptr = NULL;
kgui.c:              FreeImg ( ( ( DIHB * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( di->sptr ) ;
kgui.c:                  di->sptr = NULL;
kgui.c:              FreeImg ( ( ( DID * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIX * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIY * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DICH * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIRA * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIW * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIE * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIS * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  wc = g->wc;
kgui.c://          Dempty(wc->SBlist);
kgui.c:                  Dempty ( wc->Clip ) ;
kgui.c:                  if ( g->img != NULL ) uiFreeImage ( g->img ) ;
kgui.c:                  if ( g->rzimg != NULL ) uiFreeImage ( g->rzimg ) ;
kgui.c:                  g->img = NULL;
kgui.c:                  g->rzimg = NULL;
kgui.c:                  if ( g->dc != NULL ) {
kgui.c:                      dc = ( kgDC * ) ( g->dc ) ;
kgui.c://            Dfree(dc->Fontlist);
kgui.c:                      Dempty ( dc->Fontlist ) ;
kgui.c:                      Free ( g->dc ) ;
kgui.c:                  if ( g->wc != NULL ) Free ( g->wc ) ;
kgui.c:              FreeImg ( ( ( DIG * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:      Dempty ( ( Dlink * ) ( D->SearchList ) ) ;
kgui.c:      D->SearchList = NULL;
kgui.c:      d = D->d;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              FreeImg ( ( ( DIV * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIZ * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIO * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIP * ) ( d [ i ] .p ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DII * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIL * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DILN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIBN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIB * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIF * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIHB * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DID * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIX * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIY * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DICH * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIRA * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIW * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIE * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIS * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIG * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:          ch = ( t->code ) ;
kgui.c:              FreeImg ( ( ( DIV * ) ( t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIZ * ) ( t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIO * ) ( t ) )->Bimg ) ;
kgui.c:                  uiFreeXpm ( p->xpm ) ;
kgui.c:                  p->xpm = NULL;
kgui.c:              FreeImg ( ( ( DIP * ) ( t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DII * ) ( t ) )->Bimg ) ;
kgui.c:                  e = t->elmt;
kgui.c:                  n = t->nx*t->ny;
kgui.c:                      t->elmt = NULL;
kgui.c:                  if ( t->pt != NULL ) kgFreeDouble ( t->pt ) ;
kgui.c:                  t->pt = NULL;
kgui.c:              FreeImg ( ( ( DIT * ) ( t ) )->Bimg ) ;
kgui.c:                  e = T->elmt;
kgui.c:                  n = T->nx*T->ny;
kgui.c:                      T->elmt = NULL;
kgui.c:                  if ( T->pt != NULL ) kgFreeDouble ( T->pt ) ;
kgui.c:                  T->pt = NULL;
kgui.c:              FreeImg ( ( ( DIT * ) ( t ) )->Bimg ) ;
kgui.c:                  butn = ( BUT_STR * ) b->buts;
kgui.c:                      b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIL * ) ( t ) )->Bimg ) ;
kgui.c:                  if ( h->xpm != NULL ) {
kgui.c:                      n = h->nx*h->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) uiFreeXpm ( h->xpm [ j ] ) ;
kgui.c:                      Free ( h->xpm ) ;
kgui.c:                  Free ( h->sw ) ;
kgui.c:                  Free ( h->bkgr ) ;
kgui.c:                  if ( h->butncode != NULL ) Free ( h->butncode ) ;
kgui.c:                  if ( h->titles != NULL ) {
kgui.c:                      n = h->nx*h->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) if ( h->titles [ j ] != NULL ) Free \
kgui.c:                       ( h->titles [ j ] ) ;
kgui.c:                      Free ( h->titles ) ;
kgui.c:              FreeImg ( ( ( DILN * ) ( t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIBN * ) ( t ) )->Bimg ) ;
kgui.c:                  butn = ( BUT_STR * ) b->buts;
kgui.c:                      Free ( b->buts ) ;
kgui.c:                      b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIN * ) ( t ) )->Bimg ) ;
kgui.c:                  if ( b->xpm != NULL ) {
kgui.c:                      n = b->nx*b->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) uiFreeXpm ( b->xpm [ j ] ) ;
kgui.c:                      Free ( b->xpm ) ;
kgui.c:                  Free ( b->sw ) ;
kgui.c:                  Free ( b->bkgr ) ;
kgui.c:                  if ( b->butncode != NULL ) Free ( b->butncode ) ;
kgui.c:                  if ( b->titles != NULL ) {
kgui.c:                      n = b->nx*b->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) if ( b->titles [ j ] != NULL ) Free \
kgui.c:                       ( b->titles [ j ] ) ;
kgui.c:                      Free ( b->titles ) ;
kgui.c:              FreeImg ( ( ( DIB * ) ( t ) )->Bimg ) ;
kgui.c:                  pt = w->sptr;
kgui.c:                  Free ( w->sptr ) ;
kgui.c:              FreeImg ( ( ( DIF * ) ( t ) )->Bimg ) ;
kgui.c:                  pt = w->sptr;
kgui.c:                      kgFreeImage ( pt->bimg ) ;
kgui.c:                      kgFreeImage ( pt->fimg ) ;
kgui.c:                  w->sptr = NULL;
kgui.c:              FreeImg ( ( ( DIHB * ) ( t ) )->Bimg ) ;
kgui.c:                  Free ( w->sptr ) ;
kgui.c:              FreeImg ( ( ( DID * ) ( t ) )->Bimg ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) ( w->pt ) ) ;
kgui.c:                  w->pt = NULL;
kgui.c:              FreeImg ( ( ( DIX * ) ( t ) )->Bimg ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) ( w->pt ) ) ;
kgui.c:                  w->pt = NULL;
kgui.c:              FreeImg ( ( ( DIY * ) ( t ) )->Bimg ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) ( w->list ) ) ;
kgui.c:                  w->list = NULL;
kgui.c:              FreeImg ( ( ( DICH * ) ( t ) )->Bimg ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) ( w->list ) ) ;
kgui.c:                  w->list = NULL;
kgui.c:              FreeImg ( ( ( DIRA * ) ( t ) )->Bimg ) ;
kgui.c:                  if ( w->prompt != NULL ) Free ( w->prompt ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) w->menu ) ;
kgui.c:                  w->menu = NULL;
kgui.c:              FreeImg ( ( ( DIW * ) ( t ) )->Bimg ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) w->menu ) ;
kgui.c:                  w->menu = NULL;
kgui.c:              FreeImg ( ( ( DIE * ) ( t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIS * ) ( t ) )->Bimg ) ;
kgui.c:                  uiFreeXpm ( g->xpm ) ;
kgui.c:                  g->xpm = NULL;
kgui.c:              FreeImg ( ( ( DIG * ) ( t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( t ) )->Bimg ) ;
kgui.c:      d = D->d;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              FreeImg ( ( ( DIV * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIZ * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIO * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  uiFreeXpm ( p->xpm ) ;
kgui.c:                  p->xpm = NULL;
kgui.c:              FreeImg ( ( ( DIP * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DII * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  e = t->elmt;
kgui.c:                      n = t->nx*t->ny;
kgui.c:                      t->elmt = NULL;
kgui.c:                  if ( t->pt != NULL ) kgFreeDouble ( t->pt ) ;
kgui.c:                  t->pt = NULL;
kgui.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  e = T->elmt;
kgui.c:                      n = T->nx*T->ny;
kgui.c:                      T->elmt = NULL;
kgui.c:                  if ( T->pt != NULL ) kgFreeDouble ( T->pt ) ;
kgui.c:                  T->pt = NULL;
kgui.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  butn = ( BUT_STR * ) b->buts;
kgui.c:                  b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIL * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  if ( h->xpm != NULL ) {
kgui.c:                      n = h->nx*h->ny;
kgui.c:                      if ( h->xpm != NULL ) for ( j = 0;j < n;j++ ) uiFreeXpm ( h->xpm [ j ] ) ;
kgui.c:                      Free ( h->xpm ) ;
kgui.c:                      h->xpm = NULL;
kgui.c:                  Free ( h->sw ) ;
kgui.c:                  Free ( h->bkgr ) ;
kgui.c:                  if ( h->butncode != NULL ) Free ( h->butncode ) ;
kgui.c:                  if ( h->titles != NULL ) {
kgui.c:                      n = h->nx*h->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) if ( h->titles [ j ] != NULL ) Free \
kgui.c:                       ( h->titles [ j ] ) ;
kgui.c:                      Free ( h->titles ) ;
kgui.c:                      h->titles = NULL;
kgui.c:              FreeImg ( ( ( DILN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  butn = ( BUT_STR * ) b->buts;
kgui.c:                  b->buts = NULL;
kgui.c:              FreeImg ( ( ( DIN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIBN * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  if ( b->xpm != NULL ) {
kgui.c:                      n = b->nx*b->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) uiFreeXpm ( b->xpm [ j ] ) ;
kgui.c:                      Free ( b->xpm ) ;
kgui.c:                      b->xpm = NULL;
kgui.c:                  Free ( b->sw ) ;
kgui.c:                  b->sw = NULL;
kgui.c:                  Free ( b->bkgr ) ;
kgui.c:                  b->bkgr = NULL;
kgui.c:                  if ( b->butncode != NULL ) Free ( b->butncode ) ;
kgui.c:                  b->butncode = NULL;
kgui.c:                  if ( b->titles != NULL ) {
kgui.c:                      n = b->nx*b->ny;
kgui.c:                      for ( j = 0;j < n;j++ ) if ( b->titles [ j ] != NULL ) Free \
kgui.c:                       ( b->titles [ j ] ) ;
kgui.c:                      Free ( b->titles ) ;
kgui.c:                      b->titles = NULL;
kgui.c:              FreeImg ( ( ( DIB * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( f->sptr ) ;
kgui.c:                  f->sptr = NULL;
kgui.c:              FreeImg ( ( ( DIF * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  pt = B->sptr;
kgui.c:                      kgFreeImage ( pt->bimg ) ;
kgui.c:                      kgFreeImage ( pt->fimg ) ;
kgui.c:                  B->sptr = NULL;
kgui.c:              FreeImg ( ( ( DIHB * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( di->sptr ) ;
kgui.c:                  di->sptr = NULL;
kgui.c:              FreeImg ( ( ( DID * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  if ( ( D->VerId == 1401010200 ) || ( D->VerId == 2107030000 ) ) {
kgui.c:                      kgFreeDouble ( ( void ** ) ( w->pt ) ) ;
kgui.c:                      w->pt = NULL;
kgui.c:              FreeImg ( ( ( DIX * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  if ( ( D->VerId == 1401010200 ) || ( D->VerId == 2107030000 ) ) {
kgui.c:                      kgFreeDouble ( ( void ** ) ( w->pt ) ) ;
kgui.c:                      w->pt = NULL;
kgui.c:              FreeImg ( ( ( DIY * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c://         kgFreeDouble((void **)(w->list));
kgui.c:                  w->list = NULL;
kgui.c:              FreeImg ( ( ( DICH * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c://         kgFreeDouble((void **)(w->list));
kgui.c:                  w->list = NULL;
kgui.c:              FreeImg ( ( ( DIRA * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  if ( w->prompt != NULL ) Free ( w->prompt ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) w->menu ) ;
kgui.c:                  w->menu = NULL;
kgui.c:              FreeImg ( ( ( DIW * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  kgFreeDouble ( ( void ** ) w->menu ) ;
kgui.c:                  w->menu = NULL;
kgui.c:              FreeImg ( ( ( DIE * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  Free ( w->bwsr ) ;
kgui.c:              FreeImg ( ( ( DIS * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:                  uiFreeXpm ( g->xpm ) ;
kgui.c:                  g->xpm = NULL;
kgui.c:              FreeImg ( ( ( DIG * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) )->Bimg ) ;
kgui.c:      D = B->D;
kgui.c:      wd = B->width;
kgui.c:      ln = B->lngth;
kgui.c:      xgap = B->xgap;
kgui.c:      ygap = B->ygap;
kgui.c:      sw = B->sw;
kgui.c:      if ( B->code == 'N' ) code = 0;
kgui.c:      for ( j = 0;j < ( B->ny ) ;j++ ) {
kgui.c:          yy = B->y1+D->yo+ygap/2+j* ( ygap+wd ) ;
kgui.c:          for ( i = 0; i < ( B->nx ) ;i++ ) {
kgui.c:              xx = B->x1+D->xo+xgap/2+i* ( ln+xgap ) ;
kgui.c:              xd = xpo-xx;yd = ypo-yy;
kgui.c:              if ( ( ( xd* ( xd-ln ) ) <= 0 ) && ( ( yd* ( yd-wd ) ) <= 0 ) ) {
kgui.c:                  _dv_draw_newbutton ( B , k , -1 ) ;
kgui.c:                  * ( B->df ) = df;
kgui.c:      if ( df == 0 ) { return -1; }
kgui.c:      D = B->D;
kgui.c:      wd = B->width;
kgui.c:      ln = B->lngth;
kgui.c:      xgap = B->xgap;
kgui.c:      ygap = B->ygap;
kgui.c:      butn = B->buts;
kgui.c:      nb = -1;
kgui.c:      for ( j = 0;j < ( B->ny ) ;j++ ) {
kgui.c://     yy=B->y1+D->yo+ygap/2+j*(ygap+wd);
kgui.c:          for ( i = 0; i < ( B->nx ) ;i++ ) {
kgui.c://         xx=B->x1+D->xo+xgap/2+i*(ln+xgap);
kgui.c:                  xd = xpo-xx;yd = ypo-yy;
kgui.c:                  if ( ( ( xd* ( xd-ln ) ) <= 0 ) && ( ( yd* ( yd-wd ) ) <= 0 ) ) {
kgui.c:                      _dv_draw_button ( B , nb , -1 ) ;
kgui.c:                       ( B->bval ) = df;
kgui.c:      if ( df == 0 ) { return -1; }
kgui.c:      df = -1;
kgui.c:      df = -1;
kgui.c:      df = -1;
kgui.c:          df = * ( B->df ) ;
kgui.c:      df = -1;
kgui.c:          df = ( B->bval ) ;
kgui.c:      df = -1;
kgui.c:          df = * ( B->df ) ;
kgui.c:      D = ( DIALOG * ) ( w->D ) ;
kgui.c:      x1 = w->x2-w->width-w->offset+D->xo;
kgui.c:      yoff = ( w->y2+w->y1 ) *0.5;
kgui.c:      y1 = D->yo+yoff-w->width*.5;
kgui.c:      x2 = x1+w->width;
kgui.c:      y2 = y1+w->width;
kgui.c:       ( PON_Y ) ) || ( y2 < ( PON_Y ) ) ) ) {return -1;}
kgui.c:      y1 = D->evgay-y1;y2 = D->evgay-y2;
kgui.c:      gc = D->gc;
kgui.c:      br = w->bwsr;
kgui.c:      m = br->menu;
kgui.c:      * ( w->df ) = br->df;
kgui.c:      return ( br->df ) ;
kgui.c:      df = -1;
kgui.c:          df = * ( w->df ) ;
kgui.c:      df = -1;
kgui.c:          df = sptr->df;
kgui.c:      df = -1;
kgui.c:          df = sptr->df;
kgui.c:      sptr = B->sptr;
kgui.c:      df = -1;
kgui.c:          df = sptr->df;
kgui.c:      int ok = -1 , NOK = 1 , item;
kgui.c:      int ans , df = -1;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item;
kgui.c:      int ans , df = -1;
kgui.c:      br = x->bwsr;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item;
kgui.c:      int ans , df = -1;
kgui.c:      br = x->bwsr;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item;
kgui.c:      int ans , df = -1;
kgui.c:      br = x->bwsr;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item , ret = -1;
kgui.c:      int ans , df = -1;
kgui.c:      br = y->bwsr;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item , ret = -1 , k;
kgui.c:      int ans , df = -1;
kgui.c:      D = t->D;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:      elmt = t->elmt;
kgui.c:      tx = t->tstr;
kgui.c:      k = tx->row*tx->nx+tx->col;
kgui.c:                      elmt [ k ] .hxs = xo-elmt [ k ] .x1;
kgui.c:                      elmt [ k ] .hxe = xe-elmt [ k ] .x1;
kgui.c:                      elmt [ k ] .hxs = xe-elmt [ k ] .x1;
kgui.c:                      elmt [ k ] .hxe = xo-elmt [ k ] .x1;
kgui.c:              if ( WC ( D )->Pstr != NULL ) free ( WC ( D )->Pstr ) ;
kgui.c:              WC ( D )->Pstr = str;
kgui.c:      int ok = -1 , NOK = 1 , item , ret = -1;
kgui.c:      int ans , df = -1;
kgui.c:      D = y->D;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:      int ok = -1 , NOK = 1 , item , ret = -1;
kgui.c:      int ans , df = -1;
kgui.c:      D = y->D;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:      int ok = -1 , NOK = 1 , item , ret = -1;
kgui.c:      int ans , df = -1;
kgui.c:      br = y->bwsr;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item , ret = -1;
kgui.c:      int ans , df = -1;
kgui.c:      br = y->bwsr;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c:              if ( ok == 0 ) br->df = item;
kgui.c://  if(item!=br->df) ok = br->df;
kgui.c:      int ok = -1 , NOK = 1 , item;
kgui.c:      int ans , df = -1;
kgui.c:      D = br->D;
kgui.c:      if ( br->menu == NULL ) return ok;
kgui.c:      if ( br->menu [ 0 ] == NULL ) return ok;
kgui.c:      item = br->df;
kgui.c:      D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:      if ( kb->event == 1 ) {
kgui.c:          switch ( kb->button ) {
kgui.c:      d = D->d;
kgui.c:          ch = D->d [ i ] .t->code;
kgui.c:              df = MousePressInButtonBox ( ( D->d [ i ] .h ) , kbevent ) ;
kgui.c:                  _uiDrawButtons_n ( ( D->d [ i ] .h ) ) ;
kgui.c:              else if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInButtonBox ( ( D->d [ i ] .N ) , kbevent ) ;
kgui.c:                  uperr = Up_D_Btn_Box ( ( D->d [ i ] .N->bval ) , i , D ) ;
kgui.c:                  _uiDrawButtons_n ( ( D->d [ i ] .b ) ) ;
kgui.c:              else if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInNewButtonBox ( ( D->d [ i ] .b ) , kbevent ) ;
kgui.c:                  uperr = Up_D_Bt_Box ( * ( D->d [ i ] .b->df ) , i , D ) ;
kgui.c:                  _uiDrawButtons ( ( D->d [ i ] .b ) ) ;
kgui.c:              else if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInHBar ( ( D->d [ i ] .H ) , kbevent ) ;
kgui.c:                  _uiDrawButtons ( ( D->d [ i ] .b ) ) ;
kgui.c:              else if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInBrowser ( ( DIW * ) ( D->d [ i ] .w ) , kbevent ) ;
kgui.c:              else if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              ret = EventInNewMenu ( D->d [ i ] .x , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .x->df ) ;
kgui.c:              else if ( ( ret == -1 ) && ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = EventInV ( D->d [ i ] .v , kbevent ) ;
kgui.c:              df = EventInZ ( D->d [ i ] .z , kbevent ) ;
kgui.c:              ret = EventInY ( D->d [ i ] .y , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .y->df ) ;
kgui.c:              else if ( ( ret == -1 ) && ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              ret = EventInCheckBox ( D->d [ i ] .c , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .c->df ) ;
kgui.c:              else if ( ( ret == -1 ) && ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              ret = EventInRadioButton ( D->d [ i ] .r , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .r->df ) ;
kgui.c:              else if ( ( ret == -1 ) && ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInFslide ( ( S_STR * ) ( D->d [ i ] .f->sptr ) , kbevent ) ;
kgui.c:                   ( D->d [ i ] .f->sptr ) ) , i , D ) ;
kgui.c:              else if ( ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInDslide ( ( S_STR * ) ( D->d [ i ] .d->sptr ) , kbevent ) ;
kgui.c:                   ( D->d [ i ] .d->sptr ) ) , i , D ) ;
kgui.c:              else if ( ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInHslideBar ( ( D->d [ i ] .B ) , kbevent ) ;
kgui.c:                   ( D->d [ i ] .B->sptr ) ) , i , D ) ;
kgui.c://       _ui_getdslidevalue((S_STR *)(D->d[i].B->sptr));
kgui.c:              else if ( ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = MousePressInTextBox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) , kbevent ) ;
kgui.c:              df = MousePressInTableBox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) , kbevent ) ;
kgui.c:              ret = EventInE ( ( D->d [ i ] .e ) , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .e->df ) ;
kgui.c:              else if ( ( ret == -1 ) && ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              df = EventInMS ( D->d [ i ] .s , kbevent ) ;
kgui.c:              else if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:              if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ; // Not tested yet
kgui.c:          if ( D->Callback != NULL ) OK = D->Callback ( D , & kbevent ) ;
kgui.c:      df = -1;
kgui.c:          df = sptr->df;
kgui.c:      df = -1;
kgui.c:          df = sptr->df;
kgui.c:      sptr = B->sptr;
kgui.c:      B->item = i;
kgui.c:      D = ( DIALOG * ) B->D;
kgui.c:      df = -1;
kgui.c:          df = sptr->df;
kgui.c:          if ( B->Update == NULL ) {
kgui.c:              if ( D->Callback != NULL ) D->Callback ( D , & ( D->kb ) ) ;
kgui.c:          d = D->d;
kgui.c:          ch = D->d [ i ] .t->code;
kgui.c:              df = EventInTextBox ( D->d [ i ] .t , kbevent ) ;
kgui.c:              df = EventInV ( D->d [ i ] .v , kbevent ) ;
kgui.c:              df = EventInZ ( D->d [ i ] .z , kbevent ) ;
kgui.c:              df = EventInNewMenu ( D->d [ i ] .x , kbevent ) ;
kgui.c:                  bwsr = ( BRW_STR * ) ( D->d [ i ] .x->bwsr ) ;
kgui.c:                  uperr = Up_D_NewMenu_Box ( bwsr->df , i , D ) ;
kgui.c:              df = EventInY ( D->d [ i ] .y , kbevent ) ;
kgui.c:                  bwsr = ( BRW_STR * ) ( D->d [ i ] .y->bwsr ) ;
kgui.c:                  uperr = Up_D_Y_Box ( bwsr->df , i , D ) ;
kgui.c:              df = EventInRadioButton ( D->d [ i ] .r , kbevent ) ;
kgui.c:                  bwsr = ( BRW_STR * ) ( D->d [ i ] .r->bwsr ) ;
kgui.c:                  uperr = Up_D_Y_Box ( bwsr->df , i , D ) ;
kgui.c:              df = EventInCheckBox ( D->d [ i ] .c , kbevent ) ;
kgui.c:                  bwsr = ( BRW_STR * ) ( D->d [ i ] .c->bwsr ) ;
kgui.c:                  uperr = Up_D_Y_Box ( bwsr->df , i , D ) ;
kgui.c:              df = MouseDragInFslide ( ( S_STR * ) ( D->d [ i ] .f->sptr ) , kbevent ) ;
kgui.c://         Up_Fsld_Bar(_ui_getfslidevalue((S_STR *)(D->d[i].f->sptr)),i,D);
kgui.c:              df = MouseDragInDslide ( ( S_STR * ) ( D->d [ i ] .d->sptr ) , kbevent ) ;
kgui.c://         Up_Isld_Bar(_ui_getdslidevalue((S_STR *)(D->d[i].d->sptr)),i,D);
kgui.c:              df = MouseDragInHslide ( ( D->d [ i ] .B ) , kbevent , i ) ;
kgui.c://         Up_Hsld_Bar(_ui_getdslidevalue((S_STR *)(D->d[i].B->sptr)),i,D);
kgui.c:              df = EventInE ( ( D->d [ i ] .e ) , kbevent ) ;
kgui.c:                  bwsr = ( BRW_STR * ) ( D->d [ i ] .e->bwsr ) ;
kgui.c:                  uperr = Up_D_Menu_Box ( bwsr->df , i , D ) ;
kgui.c:              df = EventInMS ( D->d [ i ] .s , kbevent ) ;
kgui.c:          d = D->d;
kgui.c:          ch = D->d [ i ] .t->code;
kgui.c: //      df = EventInMenu((BRW_STR *)(D->d[i].x->bwsr),kbevent);
kgui.c: //      df = EventInMenu((BRW_STR *)(D->d[i].e->bwsr),kbevent);
kgui.c://       df = EventInMsg((BRW_STR *)(D->d[i].s->bwsr),kbevent);
kgui.c:      df = * ( B->df ) ;
kgui.c:      nbx = B->nx;
kgui.c:      nby = B->ny;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          dfmt--;if ( dfmt < 0 ) dfmt = nby-1;
kgui.c:          while ( ( B->sw [ df-1 ] < 1 ) ) {
kgui.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
kgui.c:          * ( B->df ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          while ( ( B->sw [ df-1 ] < 1 ) ) {
kgui.c:          * ( B->df ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          dfrm--;if ( dfrm < 1 ) dfrm = nbx;
kgui.c:          while ( ( B->sw [ df-1 ] < 1 ) ) {
kgui.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
kgui.c:          * ( B->df ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          while ( ( B->sw [ df-1 ] < 1 ) ) {
kgui.c:          * ( B->df ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:      df = B->bval;
kgui.c:      butn = ( BUT_STR * ) B->buts;
kgui.c:      nbx = B->nx;
kgui.c:      nby = B->ny;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          dfmt--;if ( dfmt < 0 ) dfmt = nby-1;
kgui.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
kgui.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
kgui.c:           ( B->bval ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
kgui.c:           ( B->bval ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          dfrm--;if ( dfrm < 1 ) dfrm = nbx;
kgui.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
kgui.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
kgui.c:           ( B->bval ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:          dfmt = ( df-1 ) /nbx;
kgui.c:          dfrm = ( df-1 ) %nbx+1;
kgui.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
kgui.c:           ( B->bval ) = df;
kgui.c:          uiUpdateOn ( B->D ) ;
kgui.c:          return -1;
kgui.c:                       ( B->bval ) = df;
kgui.c:                      uiUpdateOn ( B->D ) ;
kgui.c:      return -1;
kgui.c:      df = -1;
kgui.c:          df = * ( B->df ) ;
kgui.c:      df = -1;
kgui.c:          df = ( B->bval ) ;
kgui.c:      df = -1;
kgui.c:          df = bt->df;
kgui.c:              uiUpdateOn ( bt->D ) ;
kgui.c:      int ans , df = -1;
kgui.c:          D = ( DIALOG * ) ( w->D ) ;
kgui.c:          evgay = D->evgay;
kgui.c:          x1 = w->x2-w->width-w->offset+D->xo;
kgui.c:          y1 = w->y1+D->yo;
kgui.c:          x2 = x1+w->width;
kgui.c:          y2 = y1+w->width;
kgui.c:          br = w->bwsr;
kgui.c:          gc = D->gc;
kgui.c:          m = br->menu;
kgui.c:          return ( br->df ) ;
kgui.c:          d = D->d;
kgui.c:          ch = D->d [ i ] .t->code;
kgui.c:              df = KeyReleaseInButtonBox ( ( D->d [ i ] .h ) , kbevent ) ;
kgui.c:                  _uiDrawButtons_n ( ( D->d [ i ] .H ) ) ;
kgui.c:              df = KeyReleaseInButtonBox ( ( D->d [ i ] .N ) , kbevent ) ;
kgui.c:                  uperr = Up_D_Btn_Box ( ( D->d [ i ] .N->bval ) , i , D ) ;
kgui.c:                  _uiDrawButtons_n ( ( D->d [ i ] .n ) ) ;
kgui.c:              df = KeyReleaseInNewButtonBox ( ( D->d [ i ] .n ) , kbevent ) ;
kgui.c:                  uperr = Up_D_Bt_Box ( ( ( BUTS * ) D->d [ i ] .n->buts )->df , i , D ) ;
kgui.c:                  _uiDrawButtons ( ( D->d [ i ] .n ) ) ;
kgui.c:              df = KeyReleaseInHBar ( ( BUTS* ) ( D->d [ i ] .H->buts ) , kbevent ) ;
kgui.c:                  _uiDrawButtons ( ( D->d [ i ] .n ) ) ;
kgui.c:              df = EventInV ( D->d [ i ] .v , kbevent ) ;
kgui.c:              df = EventInZ ( D->d [ i ] .z , kbevent ) ;
kgui.c:              ret = EventInNewMenu ( D->d [ i ] .x , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .x->df ) ;
kgui.c:              ret = EventInY ( D->d [ i ] .y , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .y->df ) ;
kgui.c:              ret = EventInCheckBox ( D->d [ i ] .c , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .c->df ) ;
kgui.c:              ret = EventInRadioButton ( D->d [ i ] .r , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .r->df ) ;
kgui.c:              ret = EventInE ( ( D->d [ i ] .e ) , kbevent ) ;
kgui.c:                  df = * ( D->d [ i ] .e->df ) ;
kgui.c:              df = EventInMS ( D->d [ i ] .s , kbevent ) ;
kgui.c:              df = KeyReleaseInFslide ( ( S_STR * ) ( D->d [ i ] .f->sptr ) , kbevent ) ;
kgui.c:                   ( D->d [ i ] .f->sptr ) ) , i , D ) ;
kgui.c:              df = KeyReleaseInDslide ( ( S_STR * ) ( D->d [ i ] .d->sptr ) , kbevent ) ;
kgui.c:                   ( D->d [ i ] .d->sptr ) ) , i , D ) ;
kgui.c:              df = KeyReleaseInHslide ( ( D->d [ i ] .B ) , kbevent ) ;
kgui.c:                   ( D->d [ i ] .B->sptr ) ) , i , D ) ;
kgui.c:              df = KeyReleaseInTextBox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) , kbevent ) ;
kgui.c:                  if ( _ui_readtextbox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) ) < 0 ) {
kgui.c:              df = KeyReleaseInTableBox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) , kbevent ) ;
kgui.c:              if ( df != -1 ) {
kgui.c:                  if ( _ui_readtextbox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) ) < 0 ) {
kgui.c:      ch = D->d [ i ] .t->code;
kgui.c:      sprintf ( pidstr , "%-d" , pid ) ;
kgui.c:          sprintf ( tmpdir , "/dev/shm/%-d*" , PID ) ;
kgui.c:      else sprintf ( tmpdir , "/tmp/%-d*" , PID ) ;
kgui.c:      sprintf ( pidstr , "%-d" , pid ) ;
kgui.c:      d = D->d;
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              * ( d [ i ] .r->df ) = ( ( BRW_STR * ) d [ i ] .r->bwsr )->df;
kgui.c:              * ( d [ i ] .c->df ) = ( ( BRW_STR * ) d [ i ] .c->bwsr )->df;
kgui.c:              * ( d [ i ] .y->df ) = ( ( BRW_STR * ) d [ i ] .y->bwsr )->df;
kgui.c:              * ( d [ i ] .x->df ) = ( ( BRW_STR * ) d [ i ] .x->bwsr )->df;
kgui.c:              ret = ( d [ i ] .h->bval ) ;
kgui.c:              ret = * ( d [ i ] .H->df ) ;
kgui.c:              * ( d [ i ] .f->df ) = _ui_getfslidevalue \
kgui.c:               ( ( S_STR * ) ( d [ i ] .f->sptr ) ) ;
kgui.c:              * ( d [ i ] .d->df ) = _ui_getdslidevalue \
kgui.c:               ( ( S_STR * ) ( d [ i ] .d->sptr ) ) ;
kgui.c:              * ( d [ i ] .d->df ) = _ui_getdslidevalue \
kgui.c:               ( ( S_STR * ) ( d [ i ] .B->sptr ) ) ;
kgui.c:              * ( d [ i ] .w->df ) = ( ( BRW_STR * ) d [ i ] .w->bwsr )->df;
kgui.c:              * ( d [ i ] .e->df ) = ( ( BRW_STR * ) d [ i ] .e->bwsr )->df;
kgui.c:      D->xo = D->yo = 10;
kgui.c:      D->xl = D->yl = 300;
kgui.c:      D->bkup = 0;
kgui.c:      D->bor_type = 4;
kgui.c:      D->tw = D->bw = D->lw = D->rw = 4;
kgui.c:      D->df = 0;
kgui.c:      D->Initfun = NULL;
kgui.c:      D->Cleanupfun = NULL;
kgui.c:      D->ResizeCallback = NULL;
kgui.c:      D->WaitCallback = NULL;
kgui.c:      D->Callback = NULL;
kgui.c:      D->kbattn = D->butattn = 0;
kgui.c:      kgDefaultGuiTheme ( & ( D->gc ) ) ;
kgui.c:      D->fullscreen = 0;
kgui.c:      D->KILL = 0;
kgui.c:      D->SUBWIN = 0;
kgui.c:      D->PWIN = NULL;
kgui.c:      D->NoWinMngr = 0;
kgui.c:      D->Maxl = 0;
kgui.c:      D->Maxw = 0;
kgui.c:      D->ThInfo = NULL;
kgui.c:// D->VerId=VER;  //yymmvvss
kgui.c:// strcpy(D->name,"Kulina Designer");
kgui.c:      sprintf ( D->name , "Kulina Designer Ver. %d.%2.2d" , \
kgui.c:       ( ( D->VerId%10000 ) /100 ) , ( ( D->VerId%100 ) ) ) ;
kgui.c:      D->Deco = D->DrawBkgr = D->Newwin = 1;
kgui.c:      D->Sticky = 0;
kgui.c:      D->Fixpos = D->NoTaskBar = 0;
kgui.c:      D->transparency = 0.0;
kgui.c:      D->StackPos = 0;
kgui.c:      D->Resize = 0;
kgui.c:      D->MinWidth = 100;
kgui.c:      D->MinHeight = 100;
kgui.c:      D->wc = D->parent = D->pt = D->Shapexpm = D->SearchList = D->GrpList = NULL;
kgui.c:      D->TotWid = 0;
kgui.c:      D->CurWid = 0;
kgui.c:      D->InputWid = -1;
kgui.c:      D->Kbrd = NULL;
kgui.c:      D->wc = wc;
kgui.c:      wc->Dsp = ( Display * ) Dsp;
kgui.c:      wc->Win = ( Window ) Win;
kgui.c:      wc->Cmap = ( Colormap ) cmap;
kgui.c:      if ( Dtmp->wc != NULL ) Free ( Dtmp->wc ) ;
kgui.c:      if ( D->SearchList != NULL ) Dempty ( ( Dlink * ) D->SearchList ) ;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:              if ( pt->CleanupGrp != NULL ) pt->CleanupGrp ( D ) ;
kgui.c:              Dfree ( ( Dlink * ) pt->wlist ) ;
kgui.c:              if ( pt->arg != NULL ) kgFreeDouble ( pt->arg ) ;
kgui.c:              pt->arg = NULL;
kgui.c:          D->GrpList = NULL;
kgui.c:      D->SearchList = D->GrpList = NULL;
kgui.c:      switch ( D->VerId ) {
kgui.c:          kgFreeDouble ( ( void ** ) ( D->d ) ) ;
kgui.c:          D->d = NULL;
kgui.c:          if ( D->Cleanupfun != NULL ) D->Cleanupfun ( D ) ;
kgui.c:          kgFreeDouble ( ( void ** ) ( D->d ) ) ;
kgui.c:          D->d = NULL;
kgui.c:          if ( D->Cleanupfun != NULL ) D->Cleanupfun ( D ) ;
kgui.c:          Free ( ( D->Kbrd ) ) ;
kgui.c:          kgFreeDouble ( ( void ** ) ( D->d ) ) ;
kgui.c:          D->d = NULL;
kgui.c:          if ( D->Cleanupfun != NULL ) D->Cleanupfun ( D ) ;
kgui.c:          kgFreeDouble ( ( void ** ) ( D->d ) ) ;
kgui.c:          D->d = NULL;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:          D->GrpList = Grp;
kgui.c:      pt->wlist = ( void * ) Gpt;
kgui.c:      pt->arg = NULL;
kgui.c:      pt->hide = 0;
kgui.c:      pt->CleanupGrp = NULL;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      pt->CleanupGrp = Cleanup;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      d = D->d;
kgui.c:      d [ i-1 ] .t = ( DIT * ) Widget;
kgui.c:      D->d = d;
kgui.c:      d = D->d;
kgui.c:          D->KILL = 1000;
kgui.c:      if ( D->InputWid < 0 ) return;
kgui.c:      i = D->InputWid;
kgui.c:      code = D->d [ i ] .t->code;
kgui.c:          df = KeyReleaseInTextBox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) , kbevent ) ;
kgui.c:              if ( _ui_readtextbox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) ) < 0 ) {
kgui.c:          df = KeyReleaseInTableBox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) , kbevent ) ;
kgui.c:          if ( df != -1 ) {
kgui.c:              if ( _ui_readtextbox ( ( TX_STR * ) ( D->d [ i ] .t->tstr ) ) < 0 ) {
kgui.c:      d = D->d;
kgui.c:      D->tmpdir = ui_mktmpdir ( ) ;
kgui.c:      D->df = 0;
kgui.c:      pthread_mutex_init ( & ( D->Lock ) , NULL ) ;
kgui.c:      D->ThInfo = OpenThreads ( getCores ( ) ) ;
kgui.c://   D->ThInfo = OpenThreads(1);
kgui.c:      if ( ( D->Newwin == 1 ) || ( D->parent == NULL ) ) {
kgui.c:          D->Newwin = 1;
kgui.c:          D->bkup = 0;
kgui.c:          D->name [ 299 ] = '\0';
kgui.c:          if ( D->Resize ) {
kgui.c:              if ( D->xl < D->MinWidth ) { D->MinWidth = D->xl/2; }
kgui.c:              if ( D->yl < D->MinHeight ) { D->MinHeight = D->yl/2; }
kgui.c:          D->xo = 0 , D->yo = 0;
kgui.c:      else D->bkup = 1;
kgui.c:      if ( D->Newwin != 1 ) {
kgui.c:          wc = Parent->wc;
kgui.c:          D->wc = Parent->wc;
kgui.c:          tempc = wc->c_color;
kgui.c:      pthread_mutex_init ( & ( wc->Rlock ) , NULL ) ;
kgui.c:      D->evgax = WC ( Parent )->EVGAX;
kgui.c:      D->evgay = WC ( Parent )->EVGAY;
kgui.c:      if ( D->SearchList == NULL ) D->SearchList = ( void * ) Dopen ( ) ;
kgui.c://   if(n <= 0 ) {return -1;}
kgui.c:      x2 = D->xo+D->xl , y2 = D->yo+D->yl;
kgui.c:      D->Hsize = Hsize;
kgui.c:      if ( D->StackPos == 1 ) kgRaiseWindow ( D ) ;
kgui.c:      if ( D->bkup == 1 ) kg_scr_back ( D->wc , D->xo-1 , D->yo-1 , D->xo+D->xl+1 , D->yo+D->yl+1 ) ;
kgui.c:      if ( D->Initfun != NULL ) {
kgui.c:          OK = ( D->Initfun ( D ) ) ;
kgui.c:          if ( D->Callback == NULL ) {
kgui.c:      else {if ( D->Initfun == NULL ) OK = 1;else OK = 0;}
kgui.c:      oldi = D->df;
kgui.c:      D->df = -1;
kgui.c:      if ( D->controls > 1 ) {
kgui.c:          ch = ( d [ i ] .t->code ) ;
kgui.c:              if ( ( d [ j ] .t->code == 'H' ) || ( d [ j ] .t->code == 'h' ) ) \
kgui.c://   if(D->controls>0){OK=0; kbevent = kgGetEvent(Parent);} // skipping one event to clean
kgui.c:      if ( D->controls > 0 ) {OK = 0; kgSkipEvents ( D ) ;} // skipping one event to clean
kgui.c:      D->CurWid = i;
kgui.c:      WaitThreads ( D->ThInfo ) ;
kgui.c:      pthread_mutex_lock ( & ( D->Lock ) ) ;
kgui.c:          if ( D->KILL == 1000 ) {OK = 1002;break;}
kgui.c:          pthread_mutex_unlock ( & ( D->Lock ) ) ;
kgui.c:          if ( D->WaitCallback != NULL ) {
kgui.c:                  OK = D->WaitCallback ( D ) ;
kgui.c:                  pthread_mutex_lock ( & ( D->Lock ) ) ;
kgui.c:          pthread_mutex_lock ( & ( D->Lock ) ) ;
kgui.c:          D->kb = kbevent;
kgui.c:          D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui.c:          wc->eventback = wc->event;
kgui.c:              if ( D->ResizeCallback == NULL ) {
kgui.c:                  D->xl = kbevent.x;
kgui.c:                  D->yl = kbevent.y;
kgui.c:                  D->xl = xres;
kgui.c:                  D->yl = yres;
kgui.c:                  D->ResizeCallback ( D ) ;
kgui.c:              if ( ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ;
kgui.c:          if ( D->controls > 0 ) {
kgui.c:                  ProcessMouseMovement ( D , kbevent , i , D->controls ) ;
kgui.c:                  click = check_pointer_click ( D , & n , D->xo , D->yo , d ) ;
kgui.c:                      D->CurWid = i;
kgui.c:                      if ( ( i != oldi ) && ( D->controls > 1 ) ) {
kgui.c:                          ch = ( d [ oldi ] .t->code ) ;
kgui.c:                              _ui_readtextbox ( ( TX_STR * ) ( d [ oldi ] .t->tstr ) ) ;
kgui.c:                              D->InputWid = oldi;
kgui.c:                      OK = ProcessMousePress ( D , kbevent , i , hcontrols , D->controls ) ;
kgui.c:                      if ( ( D->Callback != NULL ) ) {
kgui.c:                          OK = D->Callback ( D , & kbevent ) ;
kgui.c:                  OK = ProcessMousePressDrag ( D , kbevent , i , hcontrols , D->controls ) ;
kgui.c:                      n = D->TotWid;
kgui.c:                      D->CurWid = i;
kgui.c:                      if ( ( i != oldi ) && ( D->controls > 1 ) ) {
kgui.c:                          ch = ( d [ oldi ] .t->code ) ;
kgui.c:                           ( ( TX_STR * ) ( d [ oldi ] .t->tstr ) ) ;}
kgui.c:                          D->InputWid = oldi;
kgui.c:                  i = D->CurWid;
kgui.c:                  if ( ( i != oldi ) && ( D->controls > 1 ) ) {
kgui.c:                  OK = ProcessKeyRelease ( D , kbevent , i , hcontrols , D->controls ) ;
kgui.c:                  n = D->TotWid;
kgui.c:                      ch = ( d [ j ] .t->code ) ;
kgui.c:                          if ( d [ j ] .t->hide != 1 ) {
kgui.c:                              if ( _ui_readtextbox ( ( TX_STR * ) ( d [ j ] .t->tstr ) ) < 0 ) {
kgui.c:                                  OK = -1;
kgui.c:              if ( ( D->Callback != NULL ) ) OK = D->Callback ( D , & kbevent ) ;
kgui.c:      pthread_mutex_unlock ( & ( D->Lock ) ) ;
kgui.c:      pthread_mutex_destroy ( & ( D->Lock ) ) ;
kgui.c:      if ( D->bkup == 1 ) {
kgui.c:          kg_scr_recover ( D->wc ) ;
kgui.c:      if ( D->Newwin == 1 ) {
kgui.c:              ui_cleandir ( D->tmpdir ) ;
kgui.c:              kgCheckAndRemoveParent ( D->tmpdir ) ;
kgui.c:      if ( D->Newwin ) {
kgui.c:          if ( ! WC ( D )->FullScreen ) {
kgui.c:              pthread_cancel ( WC ( D )->Pth ) ;
kgui.c:              pthread_join ( WC ( D )->Pth , NULL ) ;
kgui.c:          Dempty ( WC ( D )->Clip ) ;
kgui.c://     Dempty(WC(D)->SBlist);
kgui.c:          Dempty ( WC ( D )->TLIST ) ;
kgui.c:          free ( WC ( D )->kgcolors ) ;
kgui.c:          if ( WC ( D )->Pstr != NULL ) free ( WC ( D )->Pstr ) ;
kgui.c:          if ( WC ( D )->Cstr != NULL ) free ( WC ( D )->Cstr ) ;
kgui.c:      ui_cleandir ( D->tmpdir ) ;
kgui.c:      kgCheckAndRemoveParent ( D->tmpdir ) ;
kgui.c:      Free ( D->tmpdir ) ;
kgui.c:      CloseThreads ( D->ThInfo ) ;
kgui.c:      D->ThInfo = NULL;
kgui.c:      for ( i = 0;i < ( ls-lchk+1 ) ;i++ ) {
kgui.c:      i = ln-1;
kgui.c:      while ( ( i > 0 ) && ( buff [ i ] != '/' ) ) i--;
kgui.c:      sprintf ( filter , "%-d_*" , pid ) ;
kgui.c:              sprintf ( dir , "/dev/shm/%-d" , pid ) ;
kgui.c:              sprintf ( dir , "/tmp/%-d" , pid ) ;
kgui.c:          sprintf ( dirname , "%-s/%-d" , dir , entry ) ;
kgui.c:      sprintf ( dir , "/tmp/%-d" , pid ) ;
kgui.c:      sprintf ( dirname , "%-s_%-d" , dir , entry ) ;
kgui.c:              while ( isdigit ( *cpt ) || ( *cpt == '.' ) || ( *cpt == '-' ) ) { cpt++; }
kgui.c:       /*value.c= va_arg(ad,char );*/ /* 14-2-2001 */
kgui.c:                  value.c = va_arg ( ad , int ) ; /* 14-2-2001 */
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      Ti = Tstr->tit;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      e = T->elmt;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      e = T->elmt;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      e = T->elmt;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      e = T->elmt;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      e = T->elmt;
kgui.c:      Tstr = ( TX_STR * ) ( T->tstr ) ;
kgui.c:      e = T->elmt;
kgui.c:      e = T->elmt;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , I->twin , str ) ;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      if ( I->code == 'i' ) {
kgui.c:          if ( I->hide == 1 ) return 0;
kgui.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , I->twin , str ) ;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return E->menu [ B->df-1 ] ;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return B->df;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      B->df = df;
kgui.c:      return B->df;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return B->menu;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      B->menu = list;
kgui.c:      E->menu = list;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      S->menu = list;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( S->bwsr ) ;
kgui.c:      return B->menu;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      E->menu = list;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return E->menu;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      E->xpm = img;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      cpt = ( char * ) E->xpm;
kgui.c:      img = ( JPGIMG * ) E->xpm;
kgui.c:      p->xpm = img;
kgui.c:      cpt = ( char * ) p->xpm;
kgui.c:      uiFreeImage ( p->xpm ) ;
kgui.c:      p->xpm = NULL;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      v [ 0 ] = G->vxmin;
kgui.c:      v [ 1 ] = G->vymin;
kgui.c:      v [ 2 ] = G->vxmax;
kgui.c:      v [ 3 ] = G->vymax;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c://  m->msg = msg;
kgui.c:      strncpy ( m->msg , msg , 499 ) ;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c://  m->msg = msg;
kgui.c:      if ( m->hide == 1 ) return 0;
kgui.c:      if ( ( m->code == 'M' ) || ( m->code == 'm' ) || ( m->code == 'B' ) ) {
kgui.c:          strncpy ( m->msg , msg , 499 ) ;
kgui.c:      switch ( m->code ) {
kgui.c:          if ( m->hide == 1 ) return 0;
kgui.c:          strncpy ( m->msg , msg , 499 ) ;
kgui.c:          kgUpdateOn ( m->D ) ;
kgui.c:              menu = s->menu;
kgui.c:              s->menu = menu;
kgui.c:              kgUpdateOn ( s->D ) ;
kgui.c:          if ( I->hide == 1 ) return 0;
kgui.c:          uiinfo_wprintf ( ( DIALOG * ) I->D , I->twin , msg ) ;
kgui.c:          kgUpdateOn ( I->D ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          df = * ( X->df ) ;
kgui.c:          df = * ( E->df ) ;
kgui.c:          df = * ( W->df ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          * ( X->df ) = val;;
kgui.c:          df = * ( X->df ) ;
kgui.c:          * ( E->df ) = val;
kgui.c:          df = * ( E->df ) ;
kgui.c:          * ( W->df ) = val;
kgui.c:          df = * ( W->df ) ;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      list = ( ThumbNail ** ) E->list;
kgui.c:      return list [ B->df-1 ]->name;
kgui.c:      switch ( X->code ) {
kgui.c:          df = * ( X->df ) -1;
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:              return list [ df ]->name;
kgui.c:          df = * ( E->df ) -1;
kgui.c:          m = ( char ** ) ( ( DIE * ) E )->menu;
kgui.c:          df = * ( W->df ) -1;
kgui.c:          m = ( char ** ) W->menu;
kgui.c:      switch ( X->code ) {
kgui.c:          df = * ( X->df ) -1;
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          df = * ( E->df ) -1;
kgui.c:          m = ( char ** ) ( ( DIE * ) E )->menu;
kgui.c:          df = * ( W->df ) -1;
kgui.c:          m = ( char ** ) W->menu;
kgui.c:      switch ( X->code ) {
kgui.c:          X->list = list;
kgui.c:          X->nitems = nitems;
kgui.c:          * ( X->df ) = 0;
kgui.c:          X->list = list;
kgui.c:          X->nitems = nitems;
kgui.c:          X->list = list;
kgui.c:          X->nitems = nitems;
kgui.c:          * ( X->df ) = 0;
kgui.c:          E->menu = ( char ** ) list;
kgui.c:          W->menu = ( char ** ) list;
kgui.c:      switch ( X->code ) {
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:      switch ( X->code ) {
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          return list [ item ]->name;
kgui.c:      switch ( X->code ) {
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          return list [ item ]->img;
kgui.c:      switch ( X->code ) {
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          list [ item ]->img = img;
kgui.c:      switch ( X->code ) {
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          list [ item ]->name = ( char * ) malloc ( strlen ( name ) +1 ) ;
kgui.c:          strcpy ( list [ item ]->name , name ) ;
kgui.c:      thret->name = NULL;
kgui.c:      thret->img = NULL;
kgui.c:      thret->sw = th->sw;
kgui.c:      thret->id = th->id;
kgui.c:      thret->state = th->state;
kgui.c:      if ( th->name != NULL ) {
kgui.c:          thret->name = ( char * ) malloc ( strlen ( th->name ) +1 ) ;
kgui.c:          strcpy ( thret->name , th->name ) ;
kgui.c:      if ( th->img != NULL ) {
kgui.c:          thret->img = kgCopyImage ( th->img ) ;
kgui.c:      if ( th->img != NULL ) uiFreeImage ( th->img ) ;
kgui.c:      if ( th->name != NULL ) free ( th->name ) ;
kgui.c:          if ( th->img != NULL ) uiFreeImage ( th->img ) ;
kgui.c:          if ( th->name != NULL ) free ( th->name ) ;
kgui.c:          kgAddThumbNail ( wid , kgPickThumbNail ( wid , item ) , pos-1 ) ;
kgui.c:      if ( p->code != 'p' ) return NULL;
kgui.c:      p->xpm = img;
kgui.c:      if ( p->code != 'p' ) return NULL;
kgui.c:      img = p->xpm;
kgui.c:      ret = strcmp ( th1->name , th2->name ) ;
kgui.c://	printf("%s : %s :ret = %d\n",th1->name,th2->name,ret);
kgui.c:      ret = strcmp ( th1->name , th2->name ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          df = * ( X->df ) -1;
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          df = list [ item ]->sw;
kgui.c:      switch ( X->code ) {
kgui.c:          if ( ( ( X->type ) %10 ) > 0 ) {
kgui.c:              df = * ( X->df ) -1;
kgui.c:              list = ( ThumbNail ** ) X->list;
kgui.c:              list [ item ]->sw = val;
kgui.c:              df = list [ item ]->sw;
kgui.c:              list = ( ThumbNail ** ) X->list;
kgui.c:              list [ item ]->sw = val;
kgui.c:          if ( ( ( X->type ) %10 ) > 0 ) {
kgui.c:              df = * ( X->df ) -1;
kgui.c:              list = ( ThumbNail ** ) X->list;
kgui.c:              list [ item ]->sw = val;
kgui.c:              df = list [ item ]->sw;
kgui.c:              list = ( ThumbNail ** ) X->list;
kgui.c:              list [ item ]->sw = val;
kgui.c:          df = * ( X->df ) -1;
kgui.c:          list = ( ThumbNail ** ) X->list;
kgui.c:          list [ item ]->sw = val;
kgui.c:          df = list [ item ]->sw;
kgui.c:      switch ( V->code ) {
kgui.c:          V->ds = percent;
kgui.c:      switch ( V->code ) {
kgui.c:          V->df = percent;
kgui.c:      switch ( V->code ) {
kgui.c:          return V->df;
kgui.c:      switch ( V->code ) {
kgui.c:          return V->ds;
kgui.c:      *xsize = T->x2 -T->x1;
kgui.c:      *ysize = T->y2 -T->y1;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return B->df;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      if ( df > E->nitems ) df = E->nitems;
kgui.c:      B->df = df;
kgui.c:      * ( E->df ) = df;
kgui.c:      return B->df;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      return E->list;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      E->list = list;
kgui.c:      if ( E->nx < 1 ) E->nx = 1;
kgui.c:      E->ny = ny/E->nx;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      if ( E->nx < 1 ) E->nx = 1;
kgui.c:      return E->nitems;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      switch ( E->code ) {
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      uiFreeThumbNails ( ( ThumbNail ** ) E->list ) ;
kgui.c:      E->list = NULL;
kgui.c:      return ( void * ) ( D->d [ id ] .x ) ;
kgui.c:      return ( void * ) ( D->d [ id ] .x ) ;
kgui.c:      return kgGetWidget ( Tmp , D->CurWid ) ;
kgui.c:      if ( ret ) D->CurWid = Wid;
kgui.c:      if ( ret ) D->df = Wid;
kgui.c:      return kgGetWidgetName ( Tmp , D->CurWid ) ;
kgui.c:      kb = D->kb;
kgui.c:      d = D->d;
kgui.c:      if ( x1 < D->xo ) return NULL;
kgui.c:      if ( x1 > ( D->xo+D->xl ) ) return NULL;
kgui.c:      if ( y1 < D->yo ) return NULL;
kgui.c:      if ( y1 > ( D->yo+D->yl ) ) return NULL;
kgui.c:      xo = D->xo;
kgui.c:      yo = D->yo;
kgui.c:          if ( uiCheckClickPosition ( d [ i ] .t->x1+xo , d [ i ] .t->y1+yo , d [ i ] .t->x2+xo , d [ i ] .t->y2+yo , x1 , y1 ) == 1 ) \
kgui.c:      kb = D->kb;
kgui.c:      d = D->d;
kgui.c:      *x = -1;*y = -1;
kgui.c:      *x = x1 - D->xo;
kgui.c:      *y = y1 - D->yo;
kgui.c:          *x1 = T->x1;
kgui.c:          *y1 = T->y1;
kgui.c:      kb = D->kb;
kgui.c:      d = D->d;
kgui.c:      if ( x1 < D->xo ) return NULL;
kgui.c:      if ( x1 > ( D->xo+D->xl ) ) return NULL;
kgui.c:      if ( y1 < D->yo ) return NULL;
kgui.c:      if ( y1 > ( D->yo+D->yl ) ) return NULL;
kgui.c:      xo = D->xo;
kgui.c:      yo = D->yo;
kgui.c:      for ( i = n-1;i >= 0;i-- ) {
kgui.c:          if ( uiCheckClickPosition ( d [ i ] .t->x1+xo , d [ i ] .t->y1+yo , d [ i ] .t->x2+xo , d [ i ] .t->y2+yo , x1 , y1 ) == 1 ) \
kgui.c:      switch ( x->code ) {
kgui.c:          x->hide = hide;
kgui.c:           ( ( DIO * ) x )->hide = hide;
kgui.c:      switch ( x->code ) {
kgui.c:          hide = x->hide;
kgui.c:          hide = ( ( DIO * ) x )->hide;
kgui.c:      switch ( x->code ) {
kgui.c:          hide = x->hide;
kgui.c:          hide = ( ( DIV * ) x )->hide;
kgui.c:          hide = ( ( DIZ * ) x )->hide;
kgui.c:          hide = ( ( DIO * ) x )->hide;
kgui.c:          hide = ( ( DIP * ) x )->hide;
kgui.c:          hide = ( ( DII * ) x )->hide;
kgui.c:          hide = ( ( DIT * ) x )->hide;
kgui.c:          hide = ( ( DIL * ) x )->hide;
kgui.c:          hide = ( ( DILN * ) x )->hide;
kgui.c:          hide = ( ( DIN * ) x )->hide;
kgui.c:          hide = ( ( DIBN * ) x )->hide;
kgui.c:          hide = ( ( DIF * ) x )->hide;
kgui.c:          hide = ( ( DIHB * ) x )->hide;
kgui.c:          hide = ( ( DID * ) x )->hide;
kgui.c:          hide = ( ( DIW * ) x )->hide;
kgui.c:          hide = ( ( DIE * ) x )->hide;
kgui.c:          hide = ( ( DIS * ) x )->hide;
kgui.c:          hide = ( ( DIG * ) x )->hide;
kgui.c:          hide = ( ( DIM * ) x )->hide;
kgui.c:      switch ( x->code ) {
kgui.c:          hideo = x->hide;
kgui.c:          x->hide = hide;
kgui.c:          D = ( DIALOG * ) ( x->D ) ;
kgui.c:          hideo = ( ( DIV * ) x )->hide;
kgui.c:           ( ( DIV * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIV * ) x )->D ) ;
kgui.c:          hideo = ( ( DIZ * ) x )->hide;
kgui.c:           ( ( DIZ * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIZ * ) x )->D ) ;
kgui.c:          hideo = ( ( DIO * ) x )->hide;
kgui.c:           ( ( DIO * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DID * ) x )->D ) ;
kgui.c:          hideo = ( ( DIP * ) x )->hide;
kgui.c:           ( ( DIP * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIP * ) x )->D ) ;
kgui.c:          hideo = ( ( DII * ) x )->hide;
kgui.c:           ( ( DII * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DII * ) x )->D ) ;
kgui.c:          hideo = ( ( DIT * ) x )->hide;
kgui.c:           ( ( DIT * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIT * ) x )->D ) ;
kgui.c:          hideo = ( ( DIL * ) x )->hide;
kgui.c:           ( ( DIL * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIL * ) x )->D ) ;
kgui.c:          hideo = ( ( DILN * ) x )->hide;
kgui.c:           ( ( DILN * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DILN * ) x )->D ) ;
kgui.c:          hideo = ( ( DIN * ) x )->hide;
kgui.c:           ( ( DIN * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIN * ) x )->D ) ;
kgui.c:          hideo = ( ( DIB * ) x )->hide;
kgui.c:           ( ( DIB * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIB * ) x )->D ) ;
kgui.c:          hideo = ( ( DIBN * ) x )->hide;
kgui.c:           ( ( DIBN * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIBN * ) x )->D ) ;
kgui.c:          hideo = ( ( DIF * ) x )->hide;
kgui.c:           ( ( DIF * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIF * ) x )->D ) ;
kgui.c:          hideo = ( ( DIHB * ) x )->hide;
kgui.c:           ( ( DIHB * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIHB * ) x )->D ) ;
kgui.c:          hideo = ( ( DID * ) x )->hide;
kgui.c:           ( ( DID * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DID * ) x )->D ) ;
kgui.c:          hideo = ( ( DIW * ) x )->hide;
kgui.c:           ( ( DIW * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIW * ) x )->D ) ;
kgui.c:          hideo = ( ( DIE * ) x )->hide;
kgui.c:           ( ( DIE * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIE * ) x )->D ) ;
kgui.c:          hideo = ( ( DIS * ) x )->hide;
kgui.c:           ( ( DIS * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIS * ) x )->D ) ;
kgui.c:          hideo = ( ( DIG * ) x )->hide;
kgui.c:           ( ( DIG * ) x )->hide = hide;
kgui.c:          hideo = ( ( DIM * ) x )->hide;
kgui.c:           ( ( DIM * ) x )->hide = hide;
kgui.c:          D = ( DIALOG * ) ( ( ( DIM * ) x )->D ) ;
kgui.c:      switch ( x->code ) {
kgui.c:          return x->Wid ;
kgui.c:          return ( ( DIV * ) x )->Wid ;
kgui.c:          return ( ( DIZ * ) x )->Wid ;
kgui.c:          return ( ( DIO * ) x )->Wid ;
kgui.c:          return ( ( DIP * ) x )->Wid ;
kgui.c:          return ( ( DII * ) x )->Wid ;
kgui.c:          return ( ( DIT * ) x )->Wid ;
kgui.c:          return ( ( DIL * ) x )->Wid ;
kgui.c:          return ( ( DILN * ) x )->Wid ;
kgui.c:          return ( ( DIBN * ) x )->Wid ;
kgui.c:          return ( ( DIB * ) x )->Wid ;
kgui.c:          return ( ( DIF * ) x )->Wid;
kgui.c:          return ( ( DIHB * ) x )->Wid ;
kgui.c:          return ( ( DID * ) x )->Wid ;
kgui.c:          return ( ( DIW * ) x )->Wid ;
kgui.c:          return ( ( DIE * ) x )->Wid ;
kgui.c:          return ( ( DIS * ) x )->Wid ;
kgui.c:          return ( ( DIG * ) x )->Wid ;
kgui.c:          return ( ( DIM * ) x )->Wid ;
kgui.c:      d = D->d;
kgui.c:          switch ( x->code ) {
kgui.c:              if ( strcmp ( x->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIV * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIZ * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIO * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIP * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DII * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIT * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIL * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DILN * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIN * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIB * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIF * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIHB * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DID * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIW * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIE * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIS * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIG * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:              if ( strcmp ( ( ( DIM * ) x )->Wid , id ) == 0 ) return ( void * ) x;
kgui.c:      switch ( x->code ) {
kgui.c:          if ( strcmp ( x->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIV * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIZ * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIO * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIP * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DII * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIT * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIL * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DILN * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIN * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIB * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIF * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIHB * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DID * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIW * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIE * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIS * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIG * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:          if ( strcmp ( ( ( DIM * ) x )->Wid , name ) == 0 ) return 1;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:      pt->hide = hide;
kgui.c://  printf("Code = %c\n",x->code);
kgui.c:          switch ( x->code ) {
kgui.c:              hideo = x->hide;
kgui.c:              x->hide = hide;
kgui.c:              hideo = x->hide;
kgui.c:              x->hide = hide;
kgui.c:              hideo = x->hide;
kgui.c:              x->hide = hide;
kgui.c:              hideo = x->hide;
kgui.c:              x->hide = hide;
kgui.c:              hideo = ( ( DIV * ) x )->hide;
kgui.c:               ( ( DIV * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIZ * ) x )->hide;
kgui.c:               ( ( DIZ * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIO * ) x )->hide;
kgui.c:               ( ( DIO * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIP * ) x )->hide;
kgui.c:               ( ( DIP * ) x )->hide = hide;
kgui.c:              hideo = ( ( DII * ) x )->hide;
kgui.c:               ( ( DII * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIT * ) x )->hide;
kgui.c:               ( ( DIT * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIT * ) x )->hide;
kgui.c:               ( ( DIT * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIL * ) x )->hide;
kgui.c:               ( ( DIL * ) x )->hide = hide;
kgui.c:              hideo = ( ( DILN * ) x )->hide;
kgui.c:               ( ( DILN * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIN * ) x )->hide;
kgui.c:               ( ( DIN * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIB * ) x )->hide;
kgui.c:               ( ( DIB * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIBN * ) x )->hide;
kgui.c:               ( ( DIB * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIF * ) x )->hide;
kgui.c:               ( ( DIF * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIHB * ) x )->hide;
kgui.c:               ( ( DIHB * ) x )->hide = hide;
kgui.c:              hideo = ( ( DID * ) x )->hide;
kgui.c:               ( ( DID * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIW * ) x )->hide;
kgui.c:               ( ( DIW * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIE * ) x )->hide;
kgui.c:               ( ( DIE * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIS * ) x )->hide;
kgui.c:               ( ( DIS * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIG * ) x )->hide;
kgui.c:               ( ( DIG * ) x )->hide = hide;
kgui.c:              hideo = ( ( DIM * ) x )->hide;
kgui.c:               ( ( DIM * ) x )->hide = hide;
kgui.c:          if ( ( D->wc != NULL ) && ( D->TotWid > 0 ) ) {
kgui.c:   xl = x->x2 - x->x1;\
kgui.c:       yl = x->y2 - x->y1;\
kgui.c:       x->x1 = x1; x->y1 = y1;\
kgui.c:       x->x2 = x1+xl; x->y2 = y1+yl;\
kgui.c:       x->hide = 0;\
kgui.c:   xl = x->x2 - x->x1;\
kgui.c:       yl = x->y2 - x->y1;\
kgui.c:       x->x1 = x1; x->y1 = y1;\
kgui.c:       x->x2 = x1+xl; x->y2 = y1+yl;\
kgui.c:   x->x1 += xl; x->y1+= yl;\
kgui.c:       x->x2 += xl; x->y2 += yl;\
kgui.c:      if ( T->item == -1 ) return;
kgui.c:      n = T->nx*T->ny;
kgui.c:      elmt = T->elmt;
kgui.c:      if ( b->item == -1 ) return;
kgui.c:      n = b->nx*b->ny;
kgui.c:      buts = ( BUT_STR * ) ( b->buts ) ;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:          if ( x->D != Tmp ) {WMOVE_ ( x ) ;continue;}
kgui.c:          switch ( x->code ) {
kgui.c:              x->hide = 1;
kgui.c:              FreeImg ( ( ( DIX * ) ( x ) )->Bimg ) ;
kgui.c:              r->hide = 1;
kgui.c:              FreeImg ( ( ( DIRA * ) ( x ) )->Bimg ) ;
kgui.c:              c->hide = 1;
kgui.c:              FreeImg ( ( ( DICH * ) ( x ) )->Bimg ) ;
kgui.c:              y->hide = 1;
kgui.c:              FreeImg ( ( ( DIY * ) ( x ) )->Bimg ) ;
kgui.c:              v->hide = 1;
kgui.c:              FreeImg ( ( ( DIV * ) ( x ) )->Bimg ) ;
kgui.c:              z->hide = 1;
kgui.c:              FreeImg ( ( ( DIZ * ) ( x ) )->Bimg ) ;
kgui.c:              o->hide = 1;
kgui.c:              FreeImg ( ( ( DIO * ) ( x ) )->Bimg ) ;
kgui.c:              p->hide = 1;
kgui.c:              FreeImg ( ( ( DIP * ) ( x ) )->Bimg ) ;
kgui.c:              I->hide = 1;
kgui.c:              FreeImg ( ( ( DII * ) ( x ) )->Bimg ) ;
kgui.c:              T->hide = 1;
kgui.c:              FreeImg ( ( ( DIT * ) ( x ) )->Bimg ) ;
kgui.c:              T->hide = 1;
kgui.c:              FreeImg ( ( ( DIT * ) ( x ) )->Bimg ) ;
kgui.c:              H->hide = 1;
kgui.c:              FreeImg ( ( ( DIL * ) ( x ) )->Bimg ) ;
kgui.c:              h->hide = 1;
kgui.c:              FreeImg ( ( ( DILN * ) ( x ) )->Bimg ) ;
kgui.c:              n->hide = 1;
kgui.c:              FreeImg ( ( ( DIBN * ) ( x ) )->Bimg ) ;
kgui.c:              N->hide = 1;
kgui.c:              FreeImg ( ( ( DIN * ) ( x ) )->Bimg ) ;
kgui.c:              b->hide = 1;
kgui.c:              FreeImg ( ( ( DIBN * ) ( x ) )->Bimg ) ;
kgui.c:              f->hide = 1;
kgui.c:              FreeImg ( ( ( DIF * ) ( x ) )->Bimg ) ;
kgui.c:              P->hide = 1;
kgui.c:              FreeImg ( ( ( DIHB * ) ( x ) )->Bimg ) ;
kgui.c:              d->hide = 1;
kgui.c:              FreeImg ( ( ( DID * ) ( x ) )->Bimg ) ;
kgui.c:              w->hide = 1;
kgui.c:              FreeImg ( ( ( DIW * ) ( x ) )->Bimg ) ;
kgui.c:              e->hide = 1;
kgui.c:              FreeImg ( ( ( DIE * ) ( x ) )->Bimg ) ;
kgui.c:              s->hide = 1;
kgui.c:              FreeImg ( ( ( DIS * ) ( x ) )->Bimg ) ;
kgui.c:              g->hide = 1;
kgui.c:              FreeImg ( ( ( DIG * ) ( x ) )->Bimg ) ;
kgui.c:              m->hide = 1;
kgui.c:              FreeImg ( ( ( DIM * ) ( x ) )->Bimg ) ;
kgui.c:   x->x2 = x->x1+xl; x->y2 = x->y1+yl;\
kgui.c:       x->hide = 0;\
kgui.c:   x->x2 = x->x1+xl; x->y2 = x->y1+yl;\
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:          if ( x->D != Tmp ) {WRESIZE_ ( x ) ;continue;}
kgui.c:          switch ( x->code ) {
kgui.c:              x->hide = 1;
kgui.c:              r->hide = 1;
kgui.c:              c->hide = 1;
kgui.c:              y->hide = 1;
kgui.c:              v->hide = 1;
kgui.c:              z->hide = 1;
kgui.c:              o->hide = 1;
kgui.c:              p->hide = 1;
kgui.c:              I->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              H->hide = 1;
kgui.c:              h->hide = 1;
kgui.c:              n->hide = 1;
kgui.c:              N->hide = 1;
kgui.c:              b->hide = 1;
kgui.c:              f->hide = 1;
kgui.c:              P->hide = 1;
kgui.c:              d->hide = 1;
kgui.c:              w->hide = 1;
kgui.c:              e->hide = 1;
kgui.c:              s->hide = 1;
kgui.c:              g->hide = 1;
kgui.c:              m->hide = 1;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:          x->x1 += xs;
kgui.c:          x->y1 += ys;
kgui.c:          x->x2 += xs;
kgui.c:          x->y2 += ys;
kgui.c:      if ( x->D != Tmp ) {
kgui.c:          switch ( x->code ) {
kgui.c:              x->hide = 1;
kgui.c:              r->hide = 1;
kgui.c:              c->hide = 1;
kgui.c:              y->hide = 1;
kgui.c:              v->hide = 1;
kgui.c:              z->hide = 1;
kgui.c:              o->hide = 1;
kgui.c:              p->hide = 1;
kgui.c:              I->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              H->hide = 1;
kgui.c:              h->hide = 1;
kgui.c:              n->hide = 1;
kgui.c:              N->hide = 1;
kgui.c:              b->hide = 1;
kgui.c:              f->hide = 1;
kgui.c:              P->hide = 1;
kgui.c:              d->hide = 1;
kgui.c:              w->hide = 1;
kgui.c:              e->hide = 1;
kgui.c:              s->hide = 1;
kgui.c:              g->hide = 1;
kgui.c:              m->hide = 1;
kgui.c:      x1 = x->x1+xs;
kgui.c:      y1 = x->y1+ys;
kgui.c:      if ( x->D != Tmp ) {
kgui.c:          switch ( x->code ) {
kgui.c:              x->hide = 1;
kgui.c:              r->hide = 1;
kgui.c:              c->hide = 1;
kgui.c:              y->hide = 1;
kgui.c:              v->hide = 1;
kgui.c:              z->hide = 1;
kgui.c:              o->hide = 1;
kgui.c:              p->hide = 1;
kgui.c:              I->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              H->hide = 1;
kgui.c:              h->hide = 1;
kgui.c:              n->hide = 1;
kgui.c:              N->hide = 1;
kgui.c:              b->hide = 1;
kgui.c:              f->hide = 1;
kgui.c:              P->hide = 1;
kgui.c:              d->hide = 1;
kgui.c:              w->hide = 1;
kgui.c:              e->hide = 1;
kgui.c:              s->hide = 1;
kgui.c:              g->hide = 1;
kgui.c:              m->hide = 1;
kgui.c:          if ( x->D != Tmp ) {
kgui.c:          switch ( x->code ) {
kgui.c:              x->hide = 1;
kgui.c:              r->hide = 1;
kgui.c:              c->hide = 1;
kgui.c:              y->hide = 1;
kgui.c:              v->hide = 1;
kgui.c:              z->hide = 1;
kgui.c:              o->hide = 1;
kgui.c:              p->hide = 1;
kgui.c:              I->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              T->hide = 1;
kgui.c:              H->hide = 1;
kgui.c:              h->hide = 1;
kgui.c:              n->hide = 1;
kgui.c:              N->hide = 1;
kgui.c:              b->hide = 1;
kgui.c:              f->hide = 1;
kgui.c:              P->hide = 1;
kgui.c:              d->hide = 1;
kgui.c:              w->hide = 1;
kgui.c:              e->hide = 1;
kgui.c:              s->hide = 1;
kgui.c:              g->hide = 1;
kgui.c:              m->hide = 1;
kgui.c:      Grp = ( Dlink * ) D->GrpList;
kgui.c:      Gpt = ( Dlink * ) pt->wlist;
kgui.c:      if ( pt->hide == 0 ) {
kgui.c:              switch ( x->code ) {
kgui.c:              switch ( x->code ) {
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return B->df;
kgui.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui.c:      B = ( BRW_STR * ) ( E->bwsr ) ;
kgui.c:      return B->menu;
kgui.c:      o = D->d [ id ] .o;
kgui.c:      o->percent = val;
kgui.c:      o = D->d [ id ] .o;
kgui.c:      if ( hide == o->hide ) return;
kgui.c:      o->hide = hide;
kgui.c:      D = ( DIALOG * ) o->D;
kgui.c:      if ( o->hide ) return;
kgui.c:      if ( val == o->oldval ) return;
kgui.c:      o->percent = val;
kgui.c:      buts = ( BUT_STR * ) B->buts;
kgui.c:      color = -color;
kgui.c:      if ( B->item != -1 ) {
kgui.c:      buts = ( BUT_STR * ) B->buts;
kgui.c:      if ( B->item != -1 ) {
kgui.c:      buts = ( BUT_STR * ) B->buts;
kgui.c:      if ( B->item != -1 ) {
kgui.c:      buts = ( BUT_STR * ) B->buts;
kgui.c:      if ( B->item != -1 ) {
kgui.c:      buts = ( BUT_STR * ) B->buts;
kgui.c:      if ( B->item != -1 ) {
kgui.c:      buts = ( BUT_STR * ) B->buts;
kgui.c:      switch ( X->code ) {
kgui.c:          sptr = X->sptr;
kgui.c:          * ( X->df ) = df;
kgui.c:          df = * ( X->df ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          if ( val < X->min ) val = X->min;
kgui.c:          if ( val > X->max ) val = X->max;
kgui.c:          * ( X->df ) = val;;
kgui.c:          df = * ( X->df ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          sptr = X->sptr;
kgui.c:          * ( X->df ) = df;
kgui.c:          df = * ( X->df ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          if ( val < X->min ) val = X->min;
kgui.c:          if ( val > X->max ) val = X->max;
kgui.c:          * ( X->df ) = val;;
kgui.c:          df = * ( X->df ) ;
kgui.c:      switch ( X->code ) {
kgui.c:          sptr = X->sptr;
kgui.c://    *(X->df)= df;
kgui.c://    df = *(X->df);
kgui.c:      switch ( X->code ) {
kgui.c:          if ( val < X->min ) val = X->min;
kgui.c:          if ( val > X->max ) val = X->max;
kgui.c:          * ( X->df ) = val;;
kgui.c:          df = * ( X->df ) ;
kgui.c:      pthread_mutex_lock ( & ( D->Lock ) ) ;
kgui.c:      pthread_mutex_unlock ( & ( D->Lock ) ) ;
kgui.c:      e = T->elmt;
kgui.c:          ch = ( t->code ) ;
kgui.c:              Bimg = ( ( ( DIV * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIZ * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIO * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIP * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DII * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIT * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIT * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIL * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DILN * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIBN * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIN * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIB * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIF * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIHB * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DID * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIX * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIY * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DICH * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIRA * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIW * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIE * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIS * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIG * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIM * ) ( t ) )->Bimg ) ;
kgui.c:              Bimg = ( ( ( DIM * ) ( t ) )->Bimg ) ;
kgui.c:      wc->cpCallback = cpCallback;
kgui.c:      wc->cpmenu = menu;
kgui.c:      kb = D->kb;
kgui.c:      d = D->d;
kgui.c:      for ( i = n-1;i >= 0;i-- ) {
kgui.c:          if ( T->code == 't' ) {
kgui.c:              elmt = T->elmt;
kgui.c:              tx = T->tstr;
kgui.c:              k = tx->row*tx->nx+tx->col;
kgui.c:      if ( wc->Rth == 0 ) return 0;
kgui.c:          nsize = rsize* ( 0.65+ ( ( rfac-0.5 ) /0.5 ) *0.35 ) ;
kgui.c:      if ( nsize > ( rsize-8 ) ) nsize = rsize-8;
kgui.c:      nsize = ( nsize/2 ) *2-1;
kgui.c:          if ( ( img->image_width > ( nsize ) ) || ( img->image_height > ( nsize ) ) ) {
kgui.c:          kgUserFrame ( fid , -l , -w , l , w ) ;
kgui.c:          fid = kgInitImage ( rsize-2 , rsize-2 , 8 ) ;
kgui.c:          kgUserFrame ( fid , -l-2 , -w-2 , l+2 , w+2 ) ;
kgui.c:          kgRoundedRectangleFill ( fid , 0. , 0. , 2*l-4. , 2*l-4. , 0 , 151 , rfac ) ;
kgui.c:          kgRoundedRectangleFill ( fid , 0. , 0. , 2*l-4. , 2*l-4. , 0 , 151 , rfac ) ;
kgui.c:      return ( ( DIALOG * ) Tmp )->pt;
kgui.c:      T_ELMT *E = T->elmt;
kgui.c:      if ( T->code != 'T' ) {
kgui.c:      col = cell%T->nx;
kgui.c:      row = cell/T->nx;
kgui.c:      if ( ( col < 0 ) || ( col >= T->nx ) ) {
kgui.c:      if ( ( row < 0 ) || ( row >= T->ny ) ) {
kgui.c:      if ( T->code != 'T' ) {
kgui.c:      col = cell%T->nx;
kgui.c:      row = cell/T->nx;
kgui.c:      if ( ( col < 0 ) || ( col >= T->nx ) ) {
kgui.c:      if ( ( row < 0 ) || ( row >= T->ny ) ) {
kgui.c:      T_ELMT *E = T->elmt;
kgui.c:      if ( T->code != 'T' ) {
kgui.c:          return -1;
kgui.c:      TX_STR *Tx = ( TX_STR * ) T->tstr;
kgui.c:      T_ELMT *E = T->elmt;
kgui.c://	  printf("Tx->row: %d\n",Tx->row);
kgui.c:      return Tx->row;
kgui.c:      if ( T->code != 'T' ) {
kgui.c:          return -1;
kgui.c:      TX_STR *Tx = ( TX_STR * ) T->tstr;
kgui.c:      T_ELMT *E = T->elmt;
kgui.c:      return Tx->col;
kgui.c:      if ( T->code != 'T' ) {
kgui.c:          return -1;
kgui.c:      TX_STR *Tx = ( TX_STR * ) T->tstr;
kgui.c:      T_ELMT *E = T->elmt;
kgui.c:      return Tx->row*Tx->nx+Tx->col;
kgui.c:      if ( T->code != 'T' ) {
kgui.c:      TX_STR *Tx = ( TX_STR * ) T->tstr;
kgui.c:      col = cell%T->nx;
kgui.c:      row = cell/T->nx;
kgui.c:      if ( ( col < 0 ) || ( col >= T->nx ) ) {
kgui.c:      if ( ( row < 0 ) || ( row >= T->ny ) ) {
kgui.c:      T_ELMT *E = T->elmt;
kgui.c:      box = row*Tx->nx+col;
kgui.c:          Tx->col = col;
kgui.c:          Tx->row = row;
kgui.c:          T->col = col;
kgui.c:          T->row = row;
kgui1.c:          -1 , 0 , 0 /* bkgr colour */
kgui1.c:      -1 , -1 , -1 };
kgui1.c:      D.df = -1;
kgui1.c:      return ( v0-1 ) ;
kgui1.c:      p0 = ( D->d [ 0 ] ) .p;
kgui1.c:      xl = D->xl;
kgui1.c:      yl = D->yl;
kgui1.c:      msg = D->pt;
kgui1.c:      if ( msg->message != NULL ) {
kgui1.c:          fid = kgInitImage ( ( int ) ( w_x2-w_x1 ) +1 ,  \
kgui1.c:              ( int ) ( w_y2-w_y1 ) +1 , 2 ) ;
kgui1.c:          kgTextColor ( fid , msg->fontcolor ) ;
kgui1.c:          kgTextFont ( fid , msg->font ) ;
kgui1.c:          strcpy ( buf , ( char * ) msg->message ) ;
kgui1.c://      gphMove2f(fid,40.,yl-j*45.);
kgui1.c:              yy = yl - dyl*0.7;
kgui1.c:                  kgMove2f ( fid , ( xl-length ) *0.5 , yy ) ;
kgui1.c:                  yy -= dyl;
kgui1.c:              if ( msg->message != NULL ) {
kgui1.c:                  if ( p0->xpm != NULL ) {
kgui1.c:                      kgImage ( D , p0->xpm , 0 , 0 , xl , yl , 0.0 , 1.0 ) ;
kgui1.c:                      bkcolor = msg->bkcolor;
kgui1.c:                      img1 = kgBorderedRectangle ( xl-3 , yl-3 , bkcolor , 0.05 ) ;
kgui1.c:          if ( p0->xpm != NULL ) kgImage ( D , p0->xpm , 0 , 0 , xl , yl , 0.0 , 1.0 ) ;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:          -1 , 0 , 0 , 0.005 /* bkgr colour */
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:              D.xo = ( xres-xl ) /2;
kgui1.c:              D.yo = ( yres-yl ) /2;
kgui1.c:          p0.x2 = xl-4; p0.y2 = yl-4;
kgui1.c:      p0 = ( D->d [ 0 ] ) .p;
kgui1.c:      xl = D->xl;
kgui1.c:      yl = D->yl;
kgui1.c:      msg = D->pt;
kgui1.c:      if ( msg->message != NULL ) {
kgui1.c://    fid = kgInitImage((int)(w_x2-w_x1)+10,(int)(w_y2-w_y1)+10,4);
kgui1.c://    kgUserFrame(fid,w_x1-5,w_y1-5,w_x2+5,w_y2+5);
kgui1.c:          fid = kgInitImage ( ( int ) ( w_x2-w_x1 ) , ( int ) ( w_y2-w_y1 ) , RESIZE ) ;
kgui1.c:          kgUserFrame ( fid , w_x1-3 , w_y1-3 , w_x2+3 , w_y2+3 ) ;
kgui1.c:          color = msg->bkcolor;
kgui1.c:          if ( color == -1 ) color = D->gc.fill_clr;
kgui1.c:          if ( color < -1 ) {
kgui1.c:              color = -color;
kgui1.c:          fcolor = msg->fontcolor;
kgui1.c:          if ( fcolor == -1 ) fcolor = D->gc.fill_clr;
kgui1.c:          if ( fcolor < -1 ) {
kgui1.c:              fcolor = -fcolor;
kgui1.c:          kgTextFont ( fid , msg->font ) ;
kgui1.c:          kgRoundedRectangleFill ( fid , xo , yo , ( float ) l-4 ,  \
kgui1.c:              ( float ) w-4 , 0 , 151 , rfac ) ;
kgui1.c://    kgRoundedRectangleFill(fid,(w_x1+w_x2)*.5+3,(w_y1+w_y2)*.5-2,w_x2-6,w_y2-6,0,0,0.1);
kgui1.c://    kgRoundedRectangleFill(fid,(w_x1+w_x2)*.5,(w_y1+w_y2)*.5,w_x2-6,w_y2-6,0,color,0.1);
kgui1.c:          strcpy ( buf , ( char * ) msg->message ) ;
kgui1.c://      gphMove2f(fid,40.,yl-j*45.);
kgui1.c:              dyl = ( float ) ( yl-6 ) /k;
kgui1.c:              fac = ( float ) ( xl-10 ) / ( length ) ;
kgui1.c:              yy = yl - dyl*0.7-3;
kgui1.c:                  kgMove2f ( fid , ( xl-length ) *0.5 , yy ) ;
kgui1.c:                  yy -= dyl;
kgui1.c:              if ( msg->message != NULL ) {
kgui1.c:                  if ( p0->xpm != NULL ) kgImage ( D , p0->xpm , D->xo , D->yo , xl , yl , 0.0 , 1.0 ) ;
kgui1.c:                  kgImage ( D , Img , D->xo , D->yo , xl , yl , 0.0 , 1.0 ) ;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:          -1 , 0 , 0 /* bkgr colour */
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      kgSplashDia ( -1 , -1 , pt->xsize , pt->ysize , pt->xpm , pt->message , pt->font , pt->fontcolor , pt->bkcolor ) ;
kgui1.c:      D->d = NULL;
kgui1.c:      D->bkup = 1; /* set to 1 for backup */
kgui1.c:      D->bor_type = 4;
kgui1.c:      D->df = 0;
kgui1.c:      D->xo = xo; /* Position of Dialog */
kgui1.c:      D->yo = yo;
kgui1.c:      D->xl = lngth+2; /* Length of Dialog */
kgui1.c:      D->yl = ( size+1 ) *20+0; /* Width of Dialog */
kgui1.c:      D->fullscreen = 0; /* 1 for for fullscreen mode */
kgui1.c:      D->Deco = 0; /* 1 for Window Decorration */
kgui1.c:      D->transparency = 000000; /* float 1.0 for full transparency */
kgui1.c:      D->Newwin = 1; /* 1 for new window not yet implemented */
kgui1.c:      D->DrawBkgr = 1; /* 1 for drawing background */
kgui1.c:      D->Bkpixmap = NULL; /* background image */
kgui1.c:      D->Sticky = 0; /* 1 for stickyness */
kgui1.c:      D->Callback = NULL;
kgui1.c:      D->Fixpos = 1; /* 1 for Fixing Position */
kgui1.c:      D->NoTaskBar = 1; /* 1 for not showing in task bar*/
kgui1.c:      D->StackPos = 1;
kgui1.c:      D->parent = NULL;
kgui1.c:      D->pt = NULL; /* any data to be passed by user*/
kgui1.c:      D->Shapexpm = NULL;
kgui1.c:      strcpy ( D->name , "Kulina Designer ver 1.0" ) ;
kgui1.c:      kgDefaultGuiTheme ( & ( D->gc ) ) ;
kgui1.c:      D->evgay = WC ( D )->EVGAY;
kgui1.c:      D->evgax = WC ( D )->EVGAX;
kgui1.c:          xx1 = -8 , yy1 = 2;
kgui1.c:      tempc = wc->c_color;
kgui1.c:      item = br->df;
kgui1.c:      x = br->menu;
kgui1.c:      if ( br->menu [ 0 ] == NULL ) return 1;
kgui1.c:          D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
kgui1.c:                  if ( ok == 0 ) br->df = item;
kgui1.c:                  if ( ok == 0 ) br->df = item;
kgui1.c:      if ( ok > 0 ) item = br->df;
kgui1.c:      kg_scr_recover ( D->wc ) ;
kgui1.c:          pthread_cancel ( WC ( D )->Pth ) ;
kgui1.c:          Dempty ( WC ( D )->Clip ) ;
kgui1.c://     Dempty(WC(D)->SBlist);
kgui1.c:          Dempty ( WC ( D )->TLIST ) ;
kgui1.c:          free ( WC ( D )->kgcolors ) ;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      return v0-1;
kgui1.c:      0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , -1 };
kgui1.c:          1 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      kgGetDefaultRGB ( v0-1 , r , g , b ) ;
kgui1.c:      return v0-1;
kgui1.c:      ioldclr = ( int * ) ( D->pt ) ;
kgui1.c:      if ( ( abs ( r-ioldclr [ 3 ] ) +abs ( g-ioldclr [ 4 ] ) +abs  \
kgui1.c:          ( b-ioldclr [ 5 ] ) ) < 5 ) return;
kgui1.c:      sprintf ( flname , "%-s/Tmp.gph" , tmpdir ) ;
kgui1.c:      ioldclr = ( int * ) ( D->pt ) ;
kgui1.c:      sprintf ( flname , "%-s/Tmp.gph" , tmpdir ) ;
kgui1.c:      ioldclr = ( int * ) ( D->pt ) ;
kgui1.c:      if ( ( abs ( r-ioldclr [ 3 ] ) +abs ( g-ioldclr [ 4 ] ) +abs  \
kgui1.c:          ( b-ioldclr [ 5 ] ) ) < 5 ) return;
kgui1.c:      uiFreeImage ( p5->xpm ) ;
kgui1.c:          p5->xpm = img;
kgui1.c:      ioldclr = ( int * ) ( D->pt ) ;
kgui1.c:      uiFreeImage ( p4->xpm ) ;
kgui1.c:          p4->xpm = img;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      kgGetDefaultRGB ( key-1 , & r , & g , & b ) ;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx;
kgui1.c:          ioldclr = ( int * ) ( ( ( DIALOG * ) Tmp )->pt ) ;
kgui1.c:      ioldclr = ( int * ) ( D->pt ) ;
kgui1.c:      wc = D->wc;
kgui1.c:      color = wc->c_color;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:      0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , -1 };
kgui1.c:          1 , 0.000000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:          -1 , 0 , 0 /* bkgr colour */
kgui1.c:          -1 , 0 , 0 /* bkgr colour */
kgui1.c:      -1 , -1 , -1 };
kgui1.c:          6 , 0.250000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      ioldclr [ 3 ] = -5;
kgui1.c:      ioldclr [ 4 ] = -5;
kgui1.c:      ioldclr [ 5 ] = -5;
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:              m [ ln+1 ] = m [ size-3 ] ;
kgui1.c:              m [ ln+2 ] = m [ size-2 ] ;
kgui1.c:              m [ ln+3 ] = m [ size-1 ] ;
kgui1.c:              m [ size-3 ] = '.';
kgui1.c:              m [ size-2 ] = '.';
kgui1.c:              m [ size-1 ] = '.';
kgui1.c:          if ( ( m [ size-3 ] == '.' ) && ( m [ size-2 ] == '.' ) &&  \
kgui1.c:              ( m [ size-1 ] == '.' ) ) {
kgui1.c:              m [ size-3 ] = m [ ln+1 ] ;
kgui1.c:              m [ size-2 ] = m [ ln+2 ] ;
kgui1.c:              m [ size-1 ] = m [ ln+3 ] ;
kgui1.c:              m [ k ] [ ln+1 ] = m [ k ] [ size-3 ] ;
kgui1.c:              m [ k ] [ ln+2 ] = m [ k ] [ size-2 ] ;
kgui1.c:              m [ k ] [ ln+3 ] = m [ k ] [ size-1 ] ;
kgui1.c:              m [ k ] [ size-3 ] = '.';
kgui1.c:              m [ k ] [ size-2 ] = '.';
kgui1.c:              m [ k ] [ size-1 ] = '.';
kgui1.c:          if ( ( m [ size-3 ] == '.' ) && ( m [ size-2 ] == '.' ) &&  \
kgui1.c:              ( m [ size-1 ] == '.' ) ) {
kgui1.c:              m [ size-3 ] = m [ ln+1 ] ;
kgui1.c:              m [ size-2 ] = m [ ln+2 ] ;
kgui1.c:              m [ size-1 ] = m [ ln+3 ] ;
kgui1.c:          m [ size-3 ] = '.';
kgui1.c:          m [ size-2 ] = '.';
kgui1.c:          m [ size-1 ] = '.';
kgui1.c:          if ( pt->d_name [ 0 ] == '.' ) continue;
kgui1.c:          strcat ( buf , pt->d_name ) ;
kgui1.c:              ln = strlen ( pt->d_name ) ;
kgui1.c:              strcpy ( item , pt->d_name ) ;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      dirs = ( ( DIALOG * ) Tmp )->pt;
kgui1.c:      e = T->elmt;
kgui1.c:      m = _uiFileMenu ( dirs->CurDir , filter ) ;
kgui1.c:      dirs->file = m;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = m;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      dirs = ( ( DIALOG * ) Tmp )->pt;
kgui1.c:      if ( strcmp ( dirs->CurDir , "/" ) != 0 ) strcat ( dirs->CurDir , "/" ) ;
kgui1.c:      strcat ( dirs->CurDir , folder ) ;
kgui1.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp )->d [ 1 ] .i->twin , dirs->CurDir ) ;
kgui1.c:      m = _uiFolderMenu ( dirs->CurDir ) ;
kgui1.c:      m = _uiFileMenu ( dirs->CurDir , filter ) ;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = m;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = dir;
kgui1.c:      dirs->file = file;
kgui1.c:      dirs->dir = dir;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      dirs = ( ( DIALOG * ) Tmp )->pt;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:          k = strlen ( dirs->CurDir ) ;
kgui1.c:          while ( ( dirs->CurDir [ k ] != '/' ) && ( k > 1 ) )  \
kgui1.c:              {dirs->CurDir [ k ] = '\0';k--;}
kgui1.c:          dirs->CurDir [ k ] = '\0';
kgui1.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp )->d [ 1 ] .i->twin , dirs->CurDir ) ;
kgui1.c:          m = _uiFolderMenu ( dirs->CurDir ) ;
kgui1.c:      m = _uiFileMenu ( dirs->CurDir , filter ) ;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = m;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = dir;
kgui1.c:      dirs->file = m;
kgui1.c:      dirs->dir = dir;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      dirs = ( ( DIALOG * ) Tmp )->pt;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:          strcpy ( dirs->CurDir , dirs->HomeDir ) ;
kgui1.c:          uiinfo_wprintf ( ( DIALOG * ) Tmp , ( ( DIALOG * ) Tmp )->d [ 1 ] .i->twin , dirs->CurDir ) ;
kgui1.c:          m = _uiFolderMenu ( dirs->CurDir ) ;
kgui1.c:      m = _uiFileMenu ( dirs->CurDir , filter ) ;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = m;
kgui1.c:      kgFreeDouble ( ( void ** ) ( E->menu ) ) ;
kgui1.c:      E->menu = dir;
kgui1.c:      dirs->file = m;
kgui1.c:      dirs->dir = dir;
kgui1.c:      dirs = D->pt;
kgui1.c:      I = ( DII * ) ( D->d [ 1 ] .t ) ;
kgui1.c:      uiinfo_wprintf ( ( DIALOG * ) Tmp , D->d [ 1 ] .i->twin , dirs->CurDir ) ;
kgui1.c:      i--;
kgui1.c:          i--;
kgui1.c:      -1 , -1 , -1 };
kgui1.c:      -1 , -1 };
kgui1.c:      -1 , -1 };
kgui1.c:      if ( getcwd ( Dir.HomeDir , 499 ) == NULL ) return -1;
kgui1.c:          if ( pt->d_name [ 0 ] == '.' ) continue;
kgui1.c:     type = stat(pt->d_name,&st);
kgui1.c:          strcat ( buf , pt->d_name ) ;
kgui1.c://     if(pt->d_type != DT_DIR) {
kgui1.c:              sprintf ( buf , "%-s" , pt->d_name ) ;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      m = ( char ** ) ( ( DIALOG * ) Tmp )->pt;
kgui1.c:      e = T->elmt;
kgui1.c:      kgFreeDouble ( ( void ** ) E->menu ) ;
kgui1.c:      E->menu = m;
kgui1.c:       ( ( DIALOG * ) Tmp )->pt = m;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      -1 , -1 , -1 };
kgui1.c:      D.df = -1;
kgui1.c:      -1 , -1 };
kgui1.c:      D.df = -1;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      e = T->elmt;
kgui1.c:      pt = ( void ** ) D->pt;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      e = T->elmt;
kgui1.c:      pt = ( void ** ) D->pt;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      e = T->elmt;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      e = T->elmt;
kgui1.c:      pt = ( void ** ) D->pt;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      pt = ( void ** ) D->pt;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      e = T->elmt;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:      -1 , -1 };
kgui1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      -1 , -1 };
kgui1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      -1 , -1 };
kgui1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      -1 , -1 };
kgui1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      -1 , -1 };
kgui1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      -1 , -1 };
kgui1.c:          2 , 0.200000 /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      dc = G->dc;
kgui1.c:      v0 = dc->ln_color;
kgui1.c:      v2 = dc->fil_color;
kgui1.c:      v4 = dc->t_color;
kgui1.c:      v12 = dc->m_style+1;
kgui1.c:      v13 = dc->trot/10+1;
kgui1.c:      v8 = dc->t_font;
kgui1.c:      v10 = dc->ln_style+1;
kgui1.c:      v11 = dc->ln_width;
kgui1.c:      v5 = dc->bod_color;
kgui1.c:      LnStyle = v10-1;
kgui1.c:      MarkType = v12-1;
kgui1.c:      TextAngle = ( v13-1 ) *10;
kgui1.c:      dc->trot = TextAngle;
kgui1.c:      dc->fil_color = v2;
kgui1.c:      dc->t_color = v4;
kgui1.c:      dc->t_font = v8;
kgui1.c:      dc->ln_color = v0;
kgui1.c:      dc->ln_style = LnStyle;
kgui1.c:      dc->m_style = MarkType;
kgui1.c:      dc->ln_width = LnWidth;
kgui1.c:      dc->bod_color = v5;
kgui1.c:      kgLineColor ( G , dc->ln_color ) ;
kgui1.c:      kgTextAngle ( G , dc->trot ) ;
kgui1.c:      kgTextFont ( G , dc->t_font ) ;
kgui1.c:      kgMarkerType ( G , dc->m_style ) ;
kgui1.c:      kgLineWidth ( G , dc->ln_width ) ;
kgui1.c:      kgTextColor ( G , dc->t_color ) ;
kgui1.c:      D.df = -1;
kgui1.c:      -1 , -1 };
kgui1.c:      D.df = -1;
kgui1.c:      dc = G->dc;
kgui1.c:      dc->A_size = size;
kgui1.c:      dc = G->dc;
kgui1.c:      dc->cmds = ( unsigned int * ) Malloc ( sizeof ( int ) *1000L ) ;
kgui1.c:      if ( dc->cmds == NULL ) {
kgui1.c:      parent = G->D;
kgui1.c:      if ( dc->A_size > 10 ) A_fac = ( float )  \
kgui1.c:          ( dc->A_size/10 ) / ( dc->A_size%10 ) ;
kgui1.c:      tww = ( dc->w_x2-dc->w_x1 ) /30.0;
kgui1.c:      thh = ( dc->w_y2-dc->w_y1 ) /25.0;
kgui1.c:      x = dc->w_x1+ ( dc->w_x2-dc->w_x1 ) *0.5;
kgui1.c:      y = dc->w_y1+ ( dc->w_y2-dc->w_y1 ) *0.5;
kgui1.c:      uiwrite_file ( G , & ( G->rbuf ) , dc->reviewfile ) ;
kgui1.c:      loc = dc->cmds;
kgui1.c:      if ( G->D_ON == 0 ) {
kgui1.c:          MAG = G->MAG;
kgui1.c:      ytwtg = ( tw+tg ) / ( dc->w_x2-dc->w_x1 ) * ( dc->w_y2-dc->w_y1 ) /0.75;
kgui1.c://      while((item=uiMenu(G->D,G->x1,G->y1,1,1,cmenu,17))!=17)
kgui1.c:      while ( ( item = kgMenu ( G->D , parent->xo+G->x2-100 , parent->yo+G->y1 , 1 , 1 , cmenu , 17 ) ) != 17 )  \
kgui1.c:          if ( G->Byte > ( B_min-100 ) ) {
kgui1.c:              uiwrite_file ( G , & ( G->rbuf ) , dc->reviewfile ) ;
kgui1.c:              loc = dc->cmds;
kgui1.c:              ytwtg = ( tw+tg ) / ( dc->w_x2-dc->w_x1 ) * ( dc->w_y2-dc->w_y1 ) /0.75;
kgui1.c:                      if ( count > 1 ) { loc--;count--;
kgui1.c:                          uiupdate_intr ( G , count , dc->cmds ) ;
kgui1.c:              xo = xx-x;yo = yy-y;
kgui1.c:                      if ( count > 1 ) { loc--;count--;
kgui1.c:                          uiupdate_intr ( G , count , dc->cmds ) ;
kgui1.c:              xo = xx-x;yo = yy-y;
kgui1.c:              kgBoxFill ( G , xx , yy , x , y , dc->fil_color , 0 ) ;
kgui1.c:              xo = xx-x;yo = yy-y;
kgui1.c:                      if ( count > 1 ) { loc--;count--;
kgui1.c:                          uiupdate_intr ( G , count , dc->cmds ) ;
kgui1.c:              xo = xx-x;yo = yy-y;
kgui1.c:                  loc--;count--;
kgui1.c:                  uiupdate_intr ( G , count , dc->cmds ) ;
kgui1.c:              npoly = uipolygon_fill ( G , xpoly , ypoly , dc->fil_color ) ;
kgui1.c:              if ( dc->A_size > 10 ) A_fac = ( float )  \
kgui1.c:                  ( dc->A_size/10 ) / ( dc->A_size%10 ) ;
kgui1.c:              xo = xx-x;yo = yy-y;
kgui1.c:                  kgBoxFill ( G , xx , yy , x , y , dc->fil_color , 0 ) ;
kgui1.c://                           np = (npoly-26)/8;
kgui1.c:                          np = ( npoly-14 ) /8;
kgui1.c:                          dx = x-xpoly [ 0 ] ;
kgui1.c:                          dy = y-ypoly [ 0 ] ;
kgui1.c:                          kgPolyFill ( G , np , xpoly , ypoly , 1L , dc->fil_color ) ;
kgui1.c://                           *(loc++) = npoly-12; count++;
kgui1.c:                  uiborder ( G , xx , yy , x , y , dc->bod_width , dc->bod_color ) ;
kgui1.c:                      if ( count != 0 ) { loc--;count--;
kgui1.c:                          uiupdate_intr ( G , count , dc->cmds ) ;
kgui1.c:                      uiborder ( G , xx , yy , x , y , dc->bod_width , dc->bod_color ) ;
kgui1.c:              uiborder ( G , xx , yy , x , y , dc->bod_width , dc->bod_color ) ;
kgui1.c:              xo = xx-x;yo = yy-y;
kgui1.c:              * ( loc ) = uiProcess_arc_fill ( G , & xx , & yy , dc->fil_color ) ;
kgui1.c:                  kgAntialiasingOn ( G , MAG-1 ) ;
kgui1.c:              free ( dc->cmds ) ;
kgui1.c:          kgAntialiasingOn ( G , MAG-1 ) ;
kgui1.c:      free ( dc->cmds ) ;
kgui1.c:      G->Byte = lngth;
kgui1.c:      D.df = -1;
kgui1.c:      -1 , -1 , -1 };
kgui1.c:      D.df = -1;
kgui1.c:      D.yl = t0.y2 -t0.y1+20+50; /* Width of Dialog */
kgui1.c:      H4.x1 = ( D.xl ) /2 -40;
kgui1.c:      H4.y1 = ( D.yl ) -40;
kgui1.c:      if ( fp == ( ( void * ) 0 ) ) return -1;
kgui1.c:      n = Dcount ( fp->L ) ;
kgui1.c:      Resetlink ( fp->L ) ;
kgui1.c:      while ( ( bf = ( char * ) Getrecord ( fp->L ) ) != NULL ) {M [ i++ ] = bf;}
kgui1.c:      M [ n-1 ] = NULL;
kgui1.c:      return n-1;
kgui1.c:      -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 };
kgui1.c:      width = ( H1.y2-H1.y1 ) ;
kgui1.c:      H1.y1 = D.yl - ( width ) -4;
kgui1.c:      H1.x1 = ( D.xl-width ) *.5;
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      G = D->d [ i ] .g;
kgui1.c://  G->D = (void *)getParentDisplay(Tmp);
kgui1.c:      G->D = D;
kgui1.c:      Spos = G->data;
kgui1.c:      xp = D->xl/2;
kgui1.c:      yp = D->yl/2;
kgui1.c://  printf("Gbox Pos: %d %d\n",(int)xp,(int)(D->yl-yp));
kgui1.c:      Spos->xp = xp;
kgui1.c:      Spos->yp = ( int ) ( D->yl-yp ) ;
kgui1.c:      G = D->d [ 0 ] .g;
kgui1.c:      xp = D->xl/2;
kgui1.c:      yp = D->yl/2;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:          -1 , /* bkgr colour */
kgui1.c:      D.StackPos = 0; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      G = D->d [ i ] .g;
kgui1.c://  G->D = (void *)getParentDisplay(Tmp);
kgui1.c:      G->D = D;
kgui1.c:      Srect = G->data;
kgui1.c:      x1 = D->xl/2;
kgui1.c:      y1 = D->yl/2;
kgui1.c://  printf("Gbox Pos: %d %d\n",(int)xp,(int)(D->yl-yp));
kgui1.c:      Srect->x1 = x1;
kgui1.c:      Srect->y1 = ( int ) ( D->yl-y1 ) ;
kgui1.c:      Srect->x2 = x2;
kgui1.c:      Srect->y2 = ( int ) ( D->yl-y2 ) ;
kgui1.c:      G = D->d [ 0 ] .g;
kgui1.c:      xp = D->xl/2;
kgui1.c:      yp = D->yl/2;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:          -1 , /* bkgr colour */
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      count1 = count-1;
kgui1.c:      Dang = 315.0/ ( np-1 ) ;
kgui1.c:      ri = size*0.5-2*size1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:          x [ count1-i ] = ro*cs;
kgui1.c:          y [ count1-i ] = ro*ss;
kgui1.c:      x [ np ] = ( ri-dl ) *cs;
kgui1.c:      y [ np ] = ( ri-dl ) *ss;
kgui1.c:      ang -= ( sign*dang ) ;
kgui1.c:      int r , g , b , np = 120 , i , sign = -1;
kgui1.c:      count1 = count-1;
kgui1.c:      Dang = 315.0/ ( np-1 ) ;
kgui1.c:      ri = size*0.5-2*size1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      ang = ( -0.25 ) *3.14159265;
kgui1.c:          x [ count1-i ] = ro*cs;
kgui1.c:          y [ count1-i ] = ro*ss;
kgui1.c:      x [ np ] = ( ri-dl ) *cs;
kgui1.c:      y [ np ] = ( ri-dl ) *ss;
kgui1.c:      ang -= ( sign*dang ) ;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 0 ] = -size;
kgui1.c:      x [ 1 ] = size-size1;
kgui1.c:      x [ 2 ] = size-size1;
kgui1.c:      x [ 4 ] = size-size1;
kgui1.c:      y [ 4 ] = -size1;
kgui1.c:      x [ 5 ] = size-size1;
kgui1.c:      y [ 5 ] = -size1*0.5;
kgui1.c:      x [ 6 ] = -size;
kgui1.c:      y [ 6 ] = -size1*0.5;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 1 ] = - ( size-size1 ) ;
kgui1.c:      x [ 2 ] = - ( size-size1 ) ;
kgui1.c:      x [ 3 ] = - ( size ) ;
kgui1.c:      x [ 4 ] = - ( size-size1 ) ;
kgui1.c:      y [ 4 ] = -size1;
kgui1.c:      x [ 5 ] = - ( size-size1 ) ;
kgui1.c:      y [ 5 ] = -size1*0.5;
kgui1.c:      y [ 6 ] = -size1*0.5;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 0 ] = -size;
kgui1.c:      x [ 1 ] = size-size1;
kgui1.c:      x [ 2 ] = size-size1;
kgui1.c:      x [ 4 ] = size-size1;
kgui1.c:      y [ 4 ] = -size1;
kgui1.c:      x [ 5 ] = size-size1;
kgui1.c:      y [ 5 ] = -size1*0.5;
kgui1.c:      x [ 6 ] = -size;
kgui1.c:      y [ 6 ] = -size1*0.5;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 1 ] = - ( size-size1 ) ;
kgui1.c:      x [ 2 ] = - ( size-size1 ) ;
kgui1.c:      x [ 3 ] = - ( size ) ;
kgui1.c:      x [ 4 ] = - ( size-size1 ) ;
kgui1.c:      y [ 4 ] = -size1;
kgui1.c:      x [ 5 ] = - ( size-size1 ) ;
kgui1.c:      y [ 5 ] = -size1*0.5;
kgui1.c:      y [ 6 ] = -size1*0.5;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 0 ] = -size;
kgui1.c:      x [ 2 ] = -size;
kgui1.c:      y [ 2 ] = -size;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 1 ] = -size;
kgui1.c:      y [ 2 ] = -size;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 0 ] = -size;
kgui1.c:      x [ 2 ] = -size;
kgui1.c:      y [ 2 ] = -size;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 1 ] = -size;
kgui1.c:      y [ 2 ] = -size;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R*0.75 , +R , +R*1.25 ) ;
kgui1.c:      x [ 1 ] = - ( size-size1 ) ;
kgui1.c:      x [ 2 ] = - ( size-size1 ) ;
kgui1.c:      x [ 3 ] = - ( size ) ;
kgui1.c:      x [ 4 ] = - ( size-size1 ) ;
kgui1.c:      y [ 4 ] = -size1;
kgui1.c:      x [ 5 ] = - ( size-size1 ) ;
kgui1.c:      y [ 5 ] = -size1*0.5;
kgui1.c:      y [ 6 ] = -size1*0.5;
kgui1.c:      x [ 1 ] = ( size-size1 ) ;
kgui1.c:      x [ 2 ] = ( size-size1 ) ;
kgui1.c:      y [ 2 ] = -size1*0.5;
kgui1.c:      y [ 3 ] = -size1*0.5;
kgui1.c:      int r , g , b , np = 8 , i , sign = -1;
kgui1.c:      count1 = count-1;
kgui1.c:      Dang = 90.0/ ( np-1 ) ;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      x [ 0 ] = -size1;
kgui1.c:      x [ 1 ] = -dl;
kgui1.c:      y [ 4 ] = -dl;
kgui1.c:      y [ 5 ] = -size1;
kgui1.c:      x [ 6 ] = -dl;
kgui1.c:      y [ 6 ] = -size1;
kgui1.c:      x [ 7 ] = -size1;
kgui1.c:      y [ 7 ] = -dl;
kgui1.c:      count1 = count-1;
kgui1.c:      Dang = 300.0/ ( np-1 ) ;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      ri = size*0.5-2*size1;
kgui1.c:          x [ count1-i ] = ro*cs;
kgui1.c:          y [ count1-i ] = ro*ss;
kgui1.c:      x [ 0 ] = -size1*0.5;
kgui1.c:      x [ 3 ] = -size1*0.5;
kgui1.c:      count1 = count-1;
kgui1.c:      kgUserFrame ( fid , -R , -R , +R , +R ) ;
kgui1.c:      y [ 0 ] = -size;
kgui1.c:      y [ 1 ] = size-size1;
kgui1.c:      y [ 2 ] = size-size1;
kgui1.c:      x [ 4 ] = -size;
kgui1.c:      y [ 4 ] = size-size1;
kgui1.c:      x [ 5 ] = -size1*0.85;
kgui1.c:      y [ 5 ] = size-size1;
kgui1.c:      x [ 6 ] = -size1*0.85;
kgui1.c:      y [ 6 ] = -size;
kgui1.c:      x [ 7 ] = -size1*0.3;
kgui1.c:      y [ 7 ] = -size;
kgui1.c:      x [ 8 ] = -size1*0.3;
kgui1.c:      y [ 8 ] = size-size1;
kgui1.c:      y [ 9 ] = size-size1;
kgui1.c:      y [ 10 ] = -size;
kgui1.c:      x [ 0 ] = -size*0.8;
kgui1.c:      y [ 0 ] = -size;
kgui1.c:      x [ 1 ] = -size*0.8;
kgui1.c:      y [ 1 ] = size-2.05*size1;
kgui1.c:      y [ 2 ] = size-2.05*size1;
kgui1.c:      y [ 3 ] = -size;
kgui1.c:      img = pt->thImg;
kgui1.c:          pt->thImg = ( GMIMG * ) uiThumbnailgmImage ( img , pt->size , pt->size ) ;
kgui1.c:          pt->thImg->image_width = img->image_width;
kgui1.c:          pt->thImg->image_height = img->image_height;
kgui1.c:          strcpy ( pt->thImg->flname , pt->flname ) ;
kgui1.c:      else pt->thImg = NULL;
kgui1.c:                      sprintf ( name , "(%5d,%5d): %s" , img->image_width , img->image_height , flnames [ i ] ) ;
kgui1.c:                      strcpy ( thImgs [ k ]->flname , name ) ;
kgui1.c:                      if ( ( thImgs [ k ]->image_width > size )  \
kgui1.c:                          || ( thImgs [ k ]->image_height > size ) ) {
kgui1.c:                          printf ( "%s: %d:%d %d:%d\n" , flnames [ i ] , thImgs [ k ]->image_width , thImgs [ k ]->image_height , img->image_width , img->image_height ) ;
kgui1.c:                      thImgs [ k ]->image_width = img->image_width;
kgui1.c:                      thImgs [ k ]->image_height = img->image_height;
kgui1.c://         thImgs[k]->bkgrclr=15;
kgui1.c:                      strcpy ( thImgs [ k ]->flname , flnames [ i ] ) ;
kgui1.c:          menu [ no-1 ] = NULL;
kgui1.c:          for ( i = 0;i < ( no-1 ) ;i++ ) {
kgui1.c:              menu [ i ] = img->flname;
kgui1.c:          for ( i = 0;i < ( no-1 ) ;i++ ) {
kgui1.c:      if ( tb->menu != NULL ) free ( tb->menu ) ;
kgui1.c:      if ( tb->sw != NULL ) free ( tb->sw ) ;
kgui1.c:      if ( tb->xpms != NULL ) {
kgui1.c:          xpms = tb->xpms;
kgui1.c:      tb->xpms = NULL;
kgui1.c:      tb->menu = NULL;
kgui1.c:      tb->sw = NULL;
kgui1.c:          tb [ n-1 ] = NULL;
kgui1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
kgui1.c:              tb [ i ]->img = img;
kgui1.c:              tb [ i ]->name = ( char * ) Malloc ( strlen ( img->flname ) +1 ) ;
kgui1.c:              strcpy ( tb [ i ]->name , img->flname ) ;
kgui1.c:              tb [ i ]->sw = 0;
kgui1.c:              tb [ i ]->id = i;
kgui1.c:              tb [ i ]->state = 1;
kgui1.c:          tb [ n-1 ] = NULL;
kgui1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
kgui1.c:              tb [ i ]->img = NULL;
kgui1.c:              tb [ i ]->name = m [ i ] ;
kgui1.c:              tb [ i ]->sw = 0;
kgui1.c:              tb [ i ]->id = i;
kgui1.c:              tb [ i ]->state = 1;
kgui1.c:          tb [ n-1 ] = NULL;
kgui1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
kgui1.c:              tb [ i ]->img = NULL;
kgui1.c:              tb [ i ]->name = m [ i ] ;
kgui1.c:              tb [ i ]->sw = 0;
kgui1.c:              tb [ i ]->id = i;
kgui1.c:              tb [ i ]->state = 1;
kgui1.c:              if ( tb [ i ]->img != NULL ) uiFreeImage ( tb [ i ]->img ) ;
kgui1.c:              if ( tb [ i ]->name != NULL ) free ( tb [ i ]->name ) ;
kgui1.c:      fillclr = ( D->gc ) .fill_clr;
kgui1.c:      pipe = * ( ( int * ) ( D->pt ) +0 ) ;
kgui1.c:      G = kgInitImage ( D->xl , D->yl , RESIZE ) ;
kgui1.c:      kgUserFrame ( G , -25. , -25. , 25. , 25. ) ;
kgui1.c:      kgRoundedRectangleRing3 ( G , 1. , -1. , 36. , 36 , 0. , 0. , 0. , 0.5 , 4. ) ;
kgui1.c:      kgImage ( D , img , D->xo , D->yo , D->xl , D->yl , 0. , 1.0 ) ;
kgui1.c:      imgbk = kgGetBackground ( Tmp , D->xo , D->yo , D->xo+D->xl , D->yo+D->yl ) ;
kgui1.c:          G = kgInitImage ( D->xl , D->yl , RESIZE ) ;
kgui1.c:          kgUserFrame ( G , -25. , -25. , 25. , 25. ) ;
kgui1.c:          kgImage ( D , imgbk , D->xo , D->yo , D->xl , D->yl , 0. , 1.0 ) ;
kgui1.c:          kgImage ( D , img , D->xo , D->yo , D->xl , D->yl , 0. , 1.0 ) ;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:      parent = dptr->parent;
kgui1.c:      D.xo = dptr->xo; /* Position of Dialog */
kgui1.c:      D.yo = dptr->yo;
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      D.pt = dptr->pipe;
kgui1.c:      pipe ( dptr->pipe ) ;
kgui1.c:      dptr->parent = arg;
kgui1.c:      dptr->xo = xo;
kgui1.c:      dptr->yo = yo;
kgui1.c:      pthread_create ( & ( dptr->Pth ) , NULL , kgBusy , dptr ) ;
kgui1.c:      write ( dptr->pipe [ 1 ] , & bf , 1 ) ;
kgui1.c://   pthread_cancel(dptr->Pth);
kgui1.c:      pthread_join ( dptr->Pth , NULL ) ;
kgui1.c:      close ( dptr->pipe [ 0 ] ) ;
kgui1.c:      close ( dptr->pipe [ 1 ] ) ;
kgui1.c:          th [ n-1 ] = NULL;
kgui1.c:          for ( i = 0;i < ( n-1 ) ;i++ ) {
kgui1.c:                  th [ i ]->name = ( char * ) Malloc ( strlen ( menu [ i ] ) +1 ) ;
kgui1.c:                  strcpy ( th [ i ]->name , menu [ i ] ) ;
kgui1.c:              else th [ i ]->name = NULL;
kgui1.c:              th [ i ]->img = NULL;
kgui1.c:              th [ i ]->sw = 0;
kgui1.c:              th [ i ]->id = i;
kgui1.c:              th [ i ]->state = 1;
kgui1.c:          yoff = ( yl - k*ht*1.4 ) *0.5;
kgui1.c:          yy = yl - 0.8*dyl-yoff;
kgui1.c:                  kgMove2f ( fid , xo+ ( xl-length ) *0.5 , yo+yy ) ;
kgui1.c:                  case -1:
kgui1.c:                  kgMove2f ( fid , xo+ ( xl-length-xoff ) , yo+yy ) ;
kgui1.c:                  kgMove2f ( fid , xo+ ( xl-length ) *0.5 , yo+yy ) ;
kgui1.c:              yy -= dyl;
kgui1.c:      pt = D->pt;
kgui1.c:      if ( D->pt != NULL ) {
kgui1.c:          Fun = D->pt;
kgui1.c:          ret = Fun ( item , E->arg ) ;
kgui1.c:      pt = D->pt;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:              br = E->bwsr;
kgui1.c:              * ( E->df ) = 0;
kgui1.c:              br->df = 0;
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      pt = ( void ** ) ( ( ( DIALOG * ) Tmp )->pt ) ;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      int x = -100 , y = -100 , ymin , ymax;
kgui1.c:      Dia = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      ymin = B->y1+D->yo+B->offset;
kgui1.c:      ymax = B->y2+D->yo-B->offset;
kgui1.c:      th = ( ThumbNail ** ) B->list;
kgui1.c:      if ( kgDragThumbNail ( B , item-1 , & x , & y ) ) {
kgui1.c:          if ( ( pos >= 0 ) && ( pos != ( item-1 ) ) ) {
kgui1.c:              tpt = th [ item-1 ] ;
kgui1.c:              if ( pos < ( item-1 ) ) {
kgui1.c:                  for ( k = ( item-1 ) ;k > pos;k-- ) { th [ k ] = th [ k-1 ] ; }
kgui1.c:                  for ( k = item;k < pos;k++ ) {th [ k-1 ] = th [ k ] ;}
kgui1.c:                  th [ pos-1 ] = tpt;
kgui1.c:              * ( B->df ) = pos+1;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      size = B->width;
kgui1.c:      pt = ( void ** ) ( ( ( DIALOG * ) Tmp )->pt ) ;
kgui1.c://  E->menu=m;
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      n = B->nx*B->ny;
kgui1.c:      pt = ( void ** ) ( ( ( DIALOG * ) Tmp )->pt ) ;
kgui1.c:          while ( ( CurDir [ k ] != '/' ) && ( k > 1 ) ) {CurDir [ k ] = '\0';k--;}
kgui1.c:      D = ( ( DIALOG * ) Tmp )->d;
kgui1.c:      th = ( ThumbNail ** ) Y->list;
kgui1.c:      pt = ( void ** ) ( ( ( DIALOG * ) Tmp )->pt ) ;
kgui1.c:      n = Y->nitems;
kgui1.c:                  if ( th [ k ]->sw == 1 ) {
kgui1.c:                      strcpy ( flname , th [ k ]->name ) ;
kgui1.c:                  if ( th [ k ]->sw == 1 ) {
kgui1.c:                      strcat ( dest , th [ k ]->name ) ;
kgui1.c:      pt = ( char ** ) ( ( ( DIALOG * ) Tmp )->pt ) ;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:      43 , 43 , -1 };
kgui1.c:              ( 0-0.5 ) , bordr , hide */
kgui1.c:      -1 , -1 , -1 , -1 };
kgui1.c:          3 , 0.500000 , /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:      43 , 43 , -1 };
kgui1.c:              ( 0-0.5 ) , bordr , hide */
kgui1.c:      -1 , -1 , -1 , -1 };
kgui1.c:          3 , 0.500000 , /* button type and roundinfg factor ( 0-0.5 ) */
kgui1.c:      D.StackPos = 1; /* -1 , 0 , 1 for for Stack Position -1:below 0:normal 1:above*/
kgui1.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
kgui1.c:           ie 0 to (nx*ny-1)
kgui1.c:      e = T->elmt;
kgui1.c:      if ( T->ny == 1 ) kgSetExit ( Tmp ) ;
kgui1.c:      if ( kbe->event == 1 ) {
kgui1.c:          if ( kbe->button == 1 ) {
kgui1.c:      pt = D->pt;
kgui1.c:      T->item = -1;
kgui1.c:      T->x1 = 5;
kgui1.c:      T->y1 = 5;
kgui1.c:                  size = size*10+ ( *cpt -'0' ) ;
kgui1.c:      T->elmt = e;
kgui1.c:      T->pt = NULL;
kgui1.c:      T->nx = 1;
kgui1.c:      T->ny = it;
kgui1.c:      T->hide = 0;
kgui1.c:      T->col = 1;
kgui1.c:      T->row = 1;
kgui1.c:      width = ( ny ) *T->width+ ( ny-1 ) *10;
kgui1.c:      lngth = ( nx-1 ) *10+lngth;
kgui1.c:      T->x2 = T->x1+lngth;
kgui1.c:      T->y2 = T->y1+width;
kgui1.c:      T->Update = gcanftextbox1callback;
kgui1.c://  H = kgCreateHButtons(T->x1+lngth/2-36,T->y2+4,1,72,25,titles,NULL);
kgui1.c:      H = kgCreateSplButtons ( T->x1+lngth/2-36 , T->y2+4 , 1 , 1 , 72 , 25 , titles , NULL ) ;
kgui1.c:      H->fac = 0.5;
kgui1.c:      H->bordr = 0;
kgui1.c:      H->type = 4;
kgui1.c:          D.xo = ( Par->xl -D.xl ) /2;
kgui1.c:          D.yo = ( Par->yl -D.yl ) /2;
kgui1.c:          switch ( d [ k ] .t->code ) {
kgui1.c:              kgFreeDouble ( ( void ** ) ( d [ k ] .r->list ) ) ;
kgui1.c:              d [ k ] .r->list = NULL;
kgui1.c:              kgFreeDouble ( ( void ** ) ( d [ k ] .c->list ) ) ;
kgui1.c:              d [ k ] .c->list = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( T->Wid , name ) ;
kgui1.c:      T->elmt = E;
kgui1.c:      width = ( ny ) *T->width;
kgui1.c:              l = strlen ( E [ i ] .fmt ) - 1;
kgui1.c:              while ( E [ i ] .fmt [ l ] <= ' ' ) l--;
kgui1.c://   lngth = (nx-1)*10+lngth;
kgui1.c:      T->x1 = xo;
kgui1.c:      T->y1 = yo;
kgui1.c:      T->x2 = x2;
kgui1.c:      T->y2 = y2;
kgui1.c:      T->col = 1;
kgui1.c:      T->row = 1;
kgui1.c:      T->pt = pt;
kgui1.c:      T->Update = NULL;
kgui1.c:      T->hide = 0;
kgui1.c:      T->item = -1;
kgui1.c:      D->VerId = 1401010100;
kgui1.c:      D->d = NULL;
kgui1.c:      D->xo = 100;
kgui1.c:      D->yo = 100;
kgui1.c:      D->xl = length;
kgui1.c:      D->yl = width;
kgui1.c:      D->bkup = 1; /* set to 1 for backup */
kgui1.c:      D->bor_type = 4;
kgui1.c:      D->df = 1;
kgui1.c:      D->tw = 4;
kgui1.c:      D->bw = 4;
kgui1.c:      D->lw = 4;
kgui1.c:      D->rw = 4;
kgui1.c:      D->Initfun = Initfun;
kgui1.c:      D->Cleanupfun = Cleanupfun;
kgui1.c:      D->kbattn = 1;
kgui1.c:      D->butattn = 0;
kgui1.c:      D->fullscreen = 0;
kgui1.c:      D->Deco = 1;
kgui1.c:      D->transparency = 0.0;
kgui1.c:      D->Newwin = 1;
kgui1.c:      D->DrawBkgr = 1;
kgui1.c:      D->Bkpixmap = NULL;
kgui1.c:      D->Sticky = 0;
kgui1.c:      D->Resize = 1;
kgui1.c:      D->MinWidth = 100;
kgui1.c:      D->MinHeight = 100;
kgui1.c:      D->Callback = CallBack;
kgui1.c:      D->ResizeCallback = NULL;
kgui1.c:      D->WaitCallback = NULL;
kgui1.c:      D->Fixpos = 0;
kgui1.c:      D->NoTaskBar = 0;
kgui1.c:      D->StackPos = 0;
kgui1.c:      D->Shapexpm = NULL;
kgui1.c:      D->parent = NULL;
kgui1.c:      D->pt = NULL;
kgui1.c:      d = D->d;
kgui1.c:          switch ( d [ k ] .t->code ) {
kgui1.c:              kgFreeDouble ( ( void ** ) ( d [ k ] .r->list ) ) ;
kgui1.c:              d [ k ] .r->list = NULL;
kgui1.c:              kgFreeDouble ( ( void ** ) ( d [ k ] .c->list ) ) ;
kgui1.c:              d [ k ] .c->list = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->prompt = NULL;
kgui1.c:          W->prompt = ( char * ) Malloc ( n+1 ) ;
kgui1.c:          strcpy ( W->prompt , prompt ) ;
kgui1.c:      W->size = 5;
kgui1.c:      if ( W->size > max ) W->size = max;
kgui1.c:      W->df = ( int * ) ( & ( W->val ) ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = 1;
kgui1.c:      W->menu = ( char ** ) Malloc ( sizeof ( char * ) * ( max+1 ) ) ;
kgui1.c:      W->menu [ max ] = NULL;
kgui1.c:          W->menu [ i ] = ( char * ) Malloc ( ln+1 ) ;
kgui1.c:          strcpy ( W->menu [ i ] , menu [ i ] ) ;
kgui1.c:      W->x1 = x1;
kgui1.c:      W->y1 = y1;
kgui1.c:      W->x2 = x2;
kgui1.c:      W->y2 = y2;
kgui1.c:      W->item = -1;
kgui1.c:      W->Update = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->prompt = ( char * ) " ";
kgui1.c:      W->size = min;
kgui1.c:      W->df = ( int * ) ( & ( W->val ) ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = 1;
kgui1.c:      W->menu = ( char ** ) Malloc ( sizeof ( char * ) * ( max+1 ) ) ;
kgui1.c:      W->menu [ max ] = NULL;
kgui1.c:          W->menu [ i ] = ( char * ) Malloc ( min+1 ) ;
kgui1.c:          strcpy ( W->menu [ i ] , menu [ i ] ) ;
kgui1.c:      W->x1 = x1;
kgui1.c:      W->y1 = y1;
kgui1.c:      W->x2 = x1+w;
kgui1.c:      W->y2 = y1+h;
kgui1.c:      W->Update = NULL;
kgui1.c:      W->item = -1;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->prompt = ( char * ) " ";
kgui1.c:      W->size = min;
kgui1.c:      W->menu = NULL;
kgui1.c:      W->x1 = x1;
kgui1.c:      W->y1 = y1;
kgui1.c:      W->x2 = x1+w;
kgui1.c:      W->y2 = y1+h;
kgui1.c:      W->item = -1;
kgui1.c:      W->Update = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->lngth = length;
kgui1.c:      W->min = min;
kgui1.c:      W->max = max;
kgui1.c:      W->prompt = NULL;
kgui1.c:      W->df = ( int * ) & ( W->val ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = val;
kgui1.c:      ln = W->lngth+10;
kgui1.c:      W->x1 = x1+0.5;
kgui1.c:      W->y1 = y1+0.5;
kgui1.c:      W->x2 = x2+0.5;
kgui1.c:      W->y2 = y2+0.5;
kgui1.c:      W->Update = NULL;
kgui1.c:      W->item = -1;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->lngth = length;
kgui1.c:      W->min = min;
kgui1.c:      W->max = max;
kgui1.c:      W->prompt = NULL;
kgui1.c:      W->df = ( int * ) & ( W->val ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = val;
kgui1.c:      ln = W->lngth+50;
kgui1.c:      W->x1 = x1+0.5;
kgui1.c:      W->y1 = y1+0.5;
kgui1.c:      W->x2 = x2+0.5;
kgui1.c:      W->y2 = y2+0.5;
kgui1.c:      W->Update = NULL;
kgui1.c:      W->item = -1;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->lngth = length;
kgui1.c:      W->min = min;
kgui1.c:      W->max = max;
kgui1.c:      W->prompt = NULL;
kgui1.c:      W->df = ( double * ) & ( W->val ) ;
kgui1.c:      * ( ( double * ) ( W->df ) ) = val;
kgui1.c:      ln = W->lngth+50;
kgui1.c:      W->x1 = x1+0.5;
kgui1.c:      W->y1 = y1+0.5;
kgui1.c:      W->x2 = x2+0.5;
kgui1.c:      W->y2 = y2+0.5;
kgui1.c:      W->Update = NULL;
kgui1.c:      W->item = -1;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->df = ( int * ) & ( W->val ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = 1;
kgui1.c:      W->list = NULL;
kgui1.c:      W->type = type;
kgui1.c:      W->lngth = itemlength;
kgui1.c:      W->x1 = xo;
kgui1.c:      W->y1 = yo;
kgui1.c:      W->x2 = W->x1+length;
kgui1.c:      W->y2 = W->y1+width;
kgui1.c:      W->item = -1;
kgui1.c:      W->Update = NULL;
kgui1.c:      W->pt = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->prompt = NULL;
kgui1.c:      W->df = ( int * ) & ( W->val ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = 1;
kgui1.c:      W->list = ( void ** ) th;
kgui1.c:      W->nx = 1;
kgui1.c:      W->ny = 1;
kgui1.c:      W->lngth = itemlength;
kgui1.c:      W->x1 = x1+0.5;
kgui1.c:      W->y1 = y1+0.5;
kgui1.c:      W->x2 = x2+0.5;
kgui1.c:      W->y2 = y2+0.5;
kgui1.c:      W->item = -1;
kgui1.c:      W->Update = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->prompt = NULL;
kgui1.c:      W->df = ( int * ) & ( W->val ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = 1;
kgui1.c:      W->list = ( void ** ) th;
kgui1.c:      W->nx = 1;
kgui1.c:      W->ny = 1;
kgui1.c:      W->lngth = itemlength;
kgui1.c:      W->x1 = x1+0.5;
kgui1.c:      W->y1 = y1+0.5;
kgui1.c:      W->x2 = x2+0.5;
kgui1.c:      W->y2 = y2+0.5;
kgui1.c:      W->item = -1;
kgui1.c:      W->Update = NULL;
kgui1.c:      if ( name != NULL ) strcpy ( W->Wid , name ) ;
kgui1.c:      W->df = ( int * ) & ( W->val ) ;
kgui1.c:      * ( ( int * ) ( W->df ) ) = 1;
kgui1.c:      W->list = NULL;
kgui1.c:      W->type = type;
kgui1.c:      W->lngth = nailsize;
kgui1.c:      W->width = nailsize;
kgui1.c:      W->x1 = xo;
kgui1.c:      W->y1 = yo;
kgui1.c:      W->x2 = W->x1+length;
kgui1.c:      W->y2 = W->y1+width;
kgui1.c:      W->item = -1;
kgui1.c:      W->Update = NULL;
kgui1.c:      W->pt = NULL;
kgui2.c:      if ( fgets ( buff , 199 , fp ) == NULL ) return -1;
kgui2.c:              if ( fgets ( buff , 199 , fp ) == NULL ) return -1;
kgui2.c:      i = l-1;
kgui2.c:          if ( ( buff [ i ] == '/' ) && ( buff [ i-1 ] == '/' ) ) {OK = 1;break;}
kgui2.c:          else i--;
kgui2.c:      if ( OK ) buff [ i-1 ] = '\0';
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->char_clr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->fill_clr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->bodr_clr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->cur_clr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->high_clr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->char_hclr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->msg_char ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->msg_fill ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->msg_bodr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->txt_fill ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->txt_char ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->txt_pchar ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->tabl_fill ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->tabl_line ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->tabl_char ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->tabl_hchar ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->v_dim ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->dim ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->bright ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->vbright ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->twin_fill ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->twin_char ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->twin_bodr ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->info_fill ) ) ;
kgui2.c:              sscanf ( buff+i+1 , "%d" , & ( gc->info_char ) ) ;
kgui2.c:      fprintf ( fp , "\"%-s\"\n" , Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , m->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , m->x1 , m->y1 ) ;
kgui2.c:      fprintf ( fp , "\"%-s\"/Message\n" , m->msg ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , m->x2 , m->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d //justification,hide\n" , m->justification , m->hide ) ;
kgui2.c:      _uiPrintWid ( fp , m->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      StringCopy ( t->msg , buff ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->justification ) , & ( t->hide ) ) ;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , o->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , o->x1 , o->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , o->x2 , o->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , o->hide ) ;
kgui2.c:      _uiPrintWid ( fp , o->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      t->percent = 50;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      t->clr = -1;
kgui2.c:      t->type = 0;
kgui2.c:      t->bordr = 0;
kgui2.c:      t->direction = 0;
kgui2.c:      fprintf ( fp , "%c     //code\n" , o->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , o->x1 , o->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , o->x2 , o->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , o->hide ) ;
kgui2.c:      _uiPrintWid ( fp , o->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      t->ds = 100.;
kgui2.c:      t->df = 0.;
kgui2.c:      t->mvmt = 5.;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , o->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , o->x1 , o->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , o->x2 , o->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , o->hide ) ;
kgui2.c:      _uiPrintWid ( fp , o->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      t->ds = 100.;
kgui2.c:      t->df = 0.;
kgui2.c:      t->mvmt = 5.;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%lf %lf  //min,max\n" , f->min , f->max ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , f->lngth ) ;
kgui2.c:      if ( f->prompt != NULL ) fprintf ( fp , "\"%-s\" //Prompt\n" , f->prompt ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%lf%lf" , & ( t->min ) , & ( t->max ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:          t->prompt = ( char * ) Malloc ( 200 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      else t->prompt = NULL;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      t->df = ( double * ) Malloc ( sizeof ( double ) ) ;
kgui2.c:      * ( ( double * ) ( t->df ) ) = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //min,max\n" , f->min , f->max ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , f->lngth ) ;
kgui2.c:      if ( f->prompt != NULL ) fprintf ( fp , "\"%-s\" //Prompt\n" , f->prompt ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->min ) , & ( t->max ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:          t->prompt = ( char * ) Malloc ( 200 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      else t->prompt = NULL;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      t->df = ( int * ) Malloc ( sizeof ( int ) ) ;
kgui2.c:      * ( ( int * ) ( t->df ) ) = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //min,max\n" , f->min , f->max ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , f->lngth ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d %d %d //border,hide,type,color\n" , f->bordr , f->hide , f->type , f->sldclr ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->min ) , & ( t->max ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:          t->prompt = ( char * ) Malloc ( 200 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      else t->prompt = NULL;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d%d%d" , & ( t->bordr ) , & ( t->hide ) , &  \
kgui2.c:          ( t->type ) , & ( t->sldclr ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      t->df = ( int * ) Malloc ( sizeof ( int ) ) ;
kgui2.c:      * ( ( int * ) ( t->df ) ) = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //Size \n" , f->size ) ;
kgui2.c:      if ( f->prompt != NULL ) fprintf ( fp , "\"%-s\" //Prompt\n" , f->prompt ) ;
kgui2.c:      pt = f->menu;
kgui2.c:      while ( *pt != NULL ) fprintf ( fp , "\"%-s\" //item\n" , * ( pt++ ) ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      sscanf ( buff , "%d" , & ( t->size ) ) ;
kgui2.c:          t->prompt = ( char * ) Malloc ( 200 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      else t->prompt = NULL;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      t->menu = pt;
kgui2.c:      t->df = ( int * ) Malloc ( sizeof ( int ) ) ;
kgui2.c:      * ( ( int * ) ( t->df ) ) = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //Size \n" , f->size ) ;
kgui2.c:      pt = f->menu;
kgui2.c:      while ( *pt != NULL ) fprintf ( fp , "\"%-s\" //item\n" , * ( pt++ ) ) ;
kgui2.c:      fprintf ( fp , " %d %d %d %d %d %d %-d \n" , f->width , f->offset , f->w , f->itemhi , f->bordr , f->bkgr , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->size ) ) ;
kgui2.c:          t->prompt = ( char * ) Malloc ( 200 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      else t->prompt = NULL;
kgui2.c:      t->menu = pt;
kgui2.c:      t->df = ( int * ) Malloc ( sizeof ( int ) ) ;
kgui2.c:      * ( ( int * ) ( t->df ) ) = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      sscanf ( buff , "%d%d%d%d%d%d%d" , & ( t->width ) , & ( t->offset ) , &  \
kgui2.c:          ( t->w ) , & ( t->itemhi ) , & ( t->bordr ) , &  \
kgui2.c:          ( t->bkgr ) , & ( t->hide ) ) ;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d   //ygap\n" , f->xgap , f->ygap ) ;
kgui2.c:      fprintf ( fp , "%d %d //Width \n" , f->lngth , f->width ) ;
kgui2.c:      fprintf ( fp , "%d  //Ny,\n" , f->ny ) ;
kgui2.c:      fprintf ( fp , "%d %d  // offset, scroll width \n" , f->offset , f->w ) ;
kgui2.c:      fprintf ( fp , "%d %d %d %d %d // type,item hight,bordr,bkgr,hide \n" , f->type , f->itemhi , f->bordr , f->bkgr , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      t->xgap = 10;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->lngth ) , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->ny ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->offset ) , & ( t->w ) ) ;
kgui2.c:      sscanf ( buff , "%d%d%d%d%d" , & ( t->type ) , & ( t->itemhi ) , &  \
kgui2.c:          ( t->bordr ) , & ( t->bkgr ) , & ( t->hide ) ) ;
kgui2.c:      t->nx = 1;
kgui2.c:      t->ny = 1;
kgui2.c:      t->list = NULL;
kgui2.c:      t->df = ( int * ) tmpv;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap, ygap\n" , f->xgap , f->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , f->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  // offset, scroll width \n" , f->offset , f->w ) ;
kgui2.c:      fprintf ( fp , "%d %d %d %d %d // type,item hight,bordr,bkgr,hide \n" , f->type , f->itemhi , f->bordr , f->bkgr , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      t->lngth = t->width;
kgui2.c:      t->nx = t->ny = t->size = t->nxsize = 0;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->offset ) , & ( t->w ) ) ;
kgui2.c:      sscanf ( buff , "%d%d%d%d%d" , & ( t->type ) , & ( t->itemhi ) , &  \
kgui2.c:          ( t->bordr ) , & ( t->bkgr ) , & ( t->hide ) ) ;
kgui2.c:      t->df = ( int * ) tmpv;
kgui2.c:      t->prompt = NULL;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->list = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      pt = ( ThumbNail ** ) f->list;
kgui2.c:      f->ny = n;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap, ygap\n" , f->xgap , f->ygap ) ;
kgui2.c:      fprintf ( fp , "%d %d  //item length,Width \n" , f->lngth , f->width ) ;
kgui2.c:      fprintf ( fp , "%d     //ny \n" , f->ny ) ;
kgui2.c:      fprintf ( fp , "%d %d  // offset, scroll width \n" , f->offset , f->w ) ;
kgui2.c:      fprintf ( fp , "%d %d %d %d %d // type,item hight,bordr,bkgr,hide \n" , f->type , f->itemhi , f->bordr , f->bkgr , f->hide ) ;
kgui2.c:      n = f->ny;
kgui2.c:      pt = ( ThumbNail ** ) f->list;
kgui2.c:          fprintf ( fp , "\"%-s\" //item\n" , ( *pt )->name ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->lngth ) , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->ny ) ) ;
kgui2.c:      t->nx = 1;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->offset ) , & ( t->w ) ) ;
kgui2.c:      sscanf ( buff , "%d%d%d%d%d" , & ( t->type ) , & ( t->itemhi ) , &  \
kgui2.c:          ( t->bordr ) , & ( t->bkgr ) , & ( t->hide ) ) ;
kgui2.c:      n = t->ny;
kgui2.c:          if ( i == t->ny ) break;
kgui2.c:      t->ny = i;
kgui2.c:      t->list = ( void ** ) kgStringToThumbNails ( pt ) ;
kgui2.c:      t->df = ( int * ) tmpv;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      pt = ( ThumbNail ** ) f->list;
kgui2.c:      f->ny = n;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap, ygap\n" , f->xgap , f->ygap ) ;
kgui2.c:      fprintf ( fp , "%d %d  //item length,Width \n" , f->lngth , f->width ) ;
kgui2.c:      fprintf ( fp , "%d     //ny \n" , f->ny ) ;
kgui2.c:      fprintf ( fp , "%d %d  // offset, scroll width \n" , f->offset , f->w ) ;
kgui2.c:      fprintf ( fp , "%d %d %d %d %d // type,item hight,bordr,bkgr,hide \n" , f->type , f->itemhi , f->bordr , f->bkgr , f->hide ) ;
kgui2.c:      n = f->ny;
kgui2.c:      pt = ( ThumbNail ** ) f->list;
kgui2.c:          fprintf ( fp , "\"%-s\" //item\n" , ( *pt )->name ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->lngth ) , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->ny ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->offset ) , & ( t->w ) ) ;
kgui2.c:      sscanf ( buff , "%d%d%d%d%d" , & ( t->type ) , & ( t->itemhi ) , &  \
kgui2.c:          ( t->bordr ) , & ( t->bkgr ) , & ( t->hide ) ) ;
kgui2.c:      n = t->ny;
kgui2.c:      t->nx = 1;
kgui2.c:          if ( i == t->ny ) break;
kgui2.c:      t->ny = i;
kgui2.c:      t->list = ( void ** ) kgStringToThumbNails ( pt ) ;
kgui2.c:      t->df = ( int * ) tmpv;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //Size \n" , f->size ) ;
kgui2.c:      pt = f->menu;
kgui2.c:      while ( *pt != NULL ) fprintf ( fp , "\"%-s\" //item\n" , * ( pt++ ) ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d" , & ( t->size ) ) ;
kgui2.c:          t->prompt = ( char * ) Malloc ( 200 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      else t->prompt = NULL;
kgui2.c:      t->menu = pt;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      t->width = 20 , t->offset = 6 , t->w = 22 , t->itemhi = 1 , t->bordr = 1 , t->bkgr = 1;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:              ( fp , "%-s // XPM \n" , ( char * ) ( xpm+2 ) ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      PrintXpm ( fp , f->xpm ) ;
kgui2.c:      fprintf ( fp , "%d   // background color \n" , f->bkgr_clr ) ;
kgui2.c:      fprintf ( fp , "%d %d // border hide\n" , f->bordr , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y2 = t->y2;
kgui2.c:          t->xpm = ( void * ) Malloc ( 100 ) ;
kgui2.c:          strcpy ( ( char * ) ( t->xpm ) , "##" ) ;
kgui2.c:          sscanf ( buff , "%s" , ( char * ) ( t->xpm ) +2 ) ;
kgui2.c:      else t->xpm = NULL;
kgui2.c:      sscanf ( buff , "%d" , & ( t->bkgr_clr ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->bordr ) , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d //nchrs,nlines\n" , f->nchrs , f->nlines ) ;
kgui2.c:      fprintf ( fp , "%d //hide\n" , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nchrs ) , & ( t->nlines ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c://  printf("%s\n",t->Wid);
kgui2.c:      t->linewidth = 22;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      PrintXpm ( fp , f->xpm ) ;
kgui2.c:      fprintf ( fp , "%d %d //border hide\n" , f->bordr , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      t->y2 = t->y2;
kgui2.c:          t->xpm = ( void * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( ( char * ) t->xpm , buff ) ;
kgui2.c:      else t->xpm = NULL;
kgui2.c:      sscanf ( buff , "%d" , & ( t->bkgr_clr ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->bordr ) , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->initgraph = NULL;
kgui2.c:      t->data = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , t->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , t->x1 , t->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , t->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , t->nx , t->ny ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      e = t->elmt;
kgui2.c:          fprintf ( fp , "\"%-s\" sw: %d\n" , e [ i ] .fmt , sw ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , t->x2 , t->y2 ) ;
kgui2.c:      bordr = t->bordr+t->type*10;
kgui2.c:      fprintf ( fp , "%d %d %d //Cursor Position,bordr+10*type(%d:%d)\n" , t->row , t->col , bordr , t->type , t->bordr ) ;
kgui2.c:      fprintf ( fp , "%d %d %d //hide\n" , t->Font , t->FontSize , t->hide ) ;
kgui2.c:      _uiPrintWid ( fp , t->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = ( t->nx ) * ( t->ny ) ;
kgui2.c:      t->elmt = ( T_ELMT * ) Malloc ( selmt*n ) ;
kgui2.c:      e = t->elmt;
kgui2.c:          l = strlen ( e [ i ] .fmt ) - 1;
kgui2.c:          while ( e [ i ] .fmt [ l ] <= ' ' ) l--;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d%d" , & ( t->row ) , & ( t->col ) , & ( bordr ) ) ;
kgui2.c:      t->bordr = bordr%10;
kgui2.c:      t->type = bordr/10;
kgui2.c:      sscanf ( buff , "%d%d%d" , & ( t->Font ) , &  \
kgui2.c:          ( t->FontSize ) , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , t->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , t->x1 , t->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , t->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , t->nx , t->ny ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      e = t->elmt;
kgui2.c:      for ( i = 0;i < t->nx;i++ ) {
kgui2.c:          fprintf ( fp , "%-d\n" , sw ) ;
kgui2.c:          fprintf ( fp , "\"%-s\"\n" , e [ i ] .fmt ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , t->x2 , t->y2 ) ;
kgui2.c://  fprintf(fp,"%d %d %d //Cursor Position\n",t->row,t->col,t->bordr);
kgui2.c://  bordr = t->bordr+t->type*10;
kgui2.c:      bordr = t->bordr+t->type*10;
kgui2.c:      fprintf ( fp , "%d %d %d //Cursor Position,bordr+10*type(%d:%d)\n" , t->row , t->col , bordr , t->type , t->bordr ) ;
kgui2.c:      fprintf ( fp , "%d %d %d //hide\n" , t->Font , t->FontSize , t->hide ) ;
kgui2.c:      _uiPrintWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , t->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , t->x1 , t->y1 ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , t->width ) ;
kgui2.c:      e = t->elmt;
kgui2.c:      fprintf ( fp , "\"%-s\"\n" , e->fmt ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , t->x2 , t->y2 ) ;
kgui2.c:      fprintf ( fp , "\"%-s\"   //File Filter\n" , t->fltr ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = ( t->nx ) * ( t->ny ) ;
kgui2.c:      nx = t->nx;
kgui2.c:      ny = t->ny;
kgui2.c:      t->elmt = ( T_ELMT * ) Malloc ( selmt*n ) ;
kgui2.c:      e = t->elmt;
kgui2.c:              l = strlen ( e [ i ] .fmt ) - 1;
kgui2.c:              while ( e [ i ] .fmt [ l ] <= ' ' ) l--;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c://  sscanf(buff,"%d%d%d",&(t->row),&(t->col),&(t->bordr));
kgui2.c:      sscanf ( buff , "%d%d%d" , & ( t->row ) , & ( t->col ) , & ( bordr ) ) ;
kgui2.c:      t->bordr = bordr%10;
kgui2.c:      t->type = ( bordr/10 ) %10;
kgui2.c:      sscanf ( buff , "%d%d%d" , & ( t->Font ) , &  \
kgui2.c:          ( t->FontSize ) , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , f->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , f->x1 , f->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d //x2,y2\n" , f->x2 , f->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , f->xgap , f->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //Image Width \n" , f->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  // offset, scroll width \n" , f->offset , f->w ) ;
kgui2.c:      fprintf ( fp , "%d %d %d %d %d //type,itemhi(0/1),bordr(0/1),back_grond(0/1),hide(0/1)\n" , f->type , f->itemhi , f->bordr , f->bkgr , f->hide ) ;
kgui2.c:      _uiPrintWid ( fp , f->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , b->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , b->x1 , b->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , b->xgap , b->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , b->lngth ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , b->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , b->nx , b->ny ) ;
kgui2.c:      n = b->nx*b->ny;
kgui2.c:      if ( b->sw != NULL ) {
kgui2.c:              fprintf ( fp , "%d //status\n" , b->sw [ i ] ) ;
kgui2.c:          fprintf ( fp , "\"%-s\" //title\n" , b->titles [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , b->x2 , b->y2 ) ;
kgui2.c:      if ( b->butncode != NULL ) fprintf ( fp , "\"%-s\"/Button codes\n" , b->butncode ) ;
kgui2.c:      _uiPrintWid ( fp , b->Wid ) ;
kgui2.c:          fprintf ( fp , "\"%-s\" //title \n" , buff ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , b->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , b->x1 , b->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , b->xgap , b->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , b->lngth ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , b->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , b->nx , b->ny ) ;
kgui2.c:      n = b->nx*b->ny;
kgui2.c:      if ( b->sw != NULL ) {
kgui2.c:              fprintf ( fp , "%d //status\n" , b->sw [ i ] ) ;
kgui2.c:      if ( b->titles != NULL ) {
kgui2.c:              if ( b->titles [ i ] == NULL ) fprintf ( fp , "\" \" //title\n" ) ;
kgui2.c:              else fprintf ( fp , "\"%-s\" //title\n" , b->titles [ i ] ) ;
kgui2.c:              PrintTitle ( fp , b->titles [ i ] ) ;
kgui2.c:              fprintf ( fp , "\"%-s\" //title\n" , b->titles [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , b->x2 , b->y2 ) ;
kgui2.c:      if ( b->butncode != NULL ) fprintf ( fp , "\"%-s\"/Button codes\n" , b->butncode ) ;
kgui2.c:      if ( b->xpm == NULL ) {
kgui2.c:              PrintXpm ( fp , b->xpm [ i ] ) ;
kgui2.c:      if ( b->bkgr == NULL ) {
kgui2.c:              fprintf ( fp , "-1 //back ground color\n" ) ;
kgui2.c:              fprintf ( fp , "%d //back ground color\n" , b->bkgr [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %f %d  //type,fac\n" , b->type , b->fac , b->bordr ) ;
kgui2.c:      fprintf ( fp , "%d  //hide\n" , b->hide ) ;
kgui2.c:      _uiPrintWid ( fp , b->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      t->xpm = ( void ** ) Malloc ( sizeof ( char * ) *3*n ) ;
kgui2.c:      t->bkgr = ( int * ) Malloc ( sizeof ( int ) *n ) ;
kgui2.c:      for ( i = 0;i < n;i++ ) { t->bkgr [ i ] = -1;}
kgui2.c:      t->sw = ( int * ) Malloc ( sizeof ( int ) *n ) ;
kgui2.c:              t->sw [ i ] = 1;
kgui2.c:          sscanf ( buff , "%d" , & ( t->sw [ 0 ] ) ) ;
kgui2.c:              sscanf ( buff , "%d" , & ( t->sw [ i ] ) ) ;
kgui2.c:      t->titles = ( char ** ) Malloc ( sizeof ( char * ) * ( n+1 ) ) ;
kgui2.c:          t->titles [ i ] = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->titles [ i ] , buff ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:          t->butncode = NULL;
kgui2.c:          t->butncode = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->butncode , buff ) ;
kgui2.c:              t->xpm [ i ] = ( void * ) Malloc ( 100 ) ;
kgui2.c:              pt = ( char * ) t->xpm [ i ] ;
kgui2.c:          else t->xpm [ i ] = NULL;
kgui2.c:              sscanf ( buff , "%d" , ( t->bkgr ) +i ) ;
kgui2.c:      sscanf ( buff , "%d%f%d" , & ( t->type ) , & ( t->fac ) , & ( t->bordr ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->df = ( int * ) & ( t->bval ) ;
kgui2.c:      t->bval = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , b->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , b->x1 , b->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , b->x2 , b->y2 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , b->xgap , b->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , b->lngth ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , b->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , b->nx , b->ny ) ;
kgui2.c:      n = b->nx*b->ny;
kgui2.c:      butn = ( BUT_STR * ) b->buts;
kgui2.c:      fprintf ( fp , "%d %f %d  //type,fac\n" , b->type , b->fac , b->bordr ) ;
kgui2.c:      fprintf ( fp , "%d %d //hide\n" , b->hide , b->nodrawbkgr ) ;
kgui2.c:      _uiPrintWid ( fp , b->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      t->buts = ( void * ) Malloc ( sizeof ( BUT_STR ) *n ) ;
kgui2.c:      butn = ( BUT_STR * ) t->buts;
kgui2.c:      sscanf ( buff , "%d%f%d" , & ( t->type ) , & ( t->fac ) , & ( t->bordr ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->hide ) , & ( t->nodrawbkgr ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->df = ( int * ) & ( t->bval ) ;
kgui2.c:      t->bval = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      t->buts = ( void * ) Malloc ( sizeof ( BUT_STR ) *n ) ;
kgui2.c:      butn = ( BUT_STR * ) t->buts;
kgui2.c:      sscanf ( buff , "%d%f%d" , & ( t->type ) , & ( t->fac ) , & ( t->bordr ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->hide ) , & ( t->nodrawbkgr ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->df = ( int * ) & ( t->bval ) ;
kgui2.c:      t->bval = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , b->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , b->x1 , b->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , b->xgap , b->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , b->lngth ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , b->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , b->nx , b->ny ) ;
kgui2.c:      if ( b->prompt != NULL ) fprintf ( fp , "\"%-s\"/Prompt\n" , b->prompt ) ;
kgui2.c:      n = b->nx*b->ny;
kgui2.c:          fprintf ( fp , "\"%-s\" //title\n" , b->titles [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , b->x2 , b->y2 ) ;
kgui2.c:      if ( b->butncode != NULL ) fprintf ( fp , "\"%-s\"/Button codes\n" , b->butncode ) ;
kgui2.c:      if ( b->xpm == NULL ) {
kgui2.c:              PrintXpm ( fp , b->xpm [ i ] ) ;
kgui2.c:      if ( b->bkgr == NULL ) {
kgui2.c:              fprintf ( fp , "-1 //back ground color\n" ) ;
kgui2.c:              fprintf ( fp , "%d //back ground color\n" , b->bkgr [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %f %d  //type,fac\n" , b->type , b->fac , b->bordr ) ;
kgui2.c:      fprintf ( fp , "%d  //hide\n" , b->hide ) ;
kgui2.c:      _uiPrintWid ( fp , b->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      t->xpm = ( void ** ) Malloc ( sizeof ( char * ) *3*n ) ;
kgui2.c:      t->bkgr = ( int * ) Malloc ( sizeof ( int ) *n ) ;
kgui2.c:      for ( i = 0;i < n;i++ ) { t->bkgr [ i ] = -1;}
kgui2.c:      if ( NULLDATA ( buff ) ) t->prompt = NULL;
kgui2.c:          t->prompt = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->prompt , buff ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      t->titles = ( char ** ) Malloc ( sizeof ( char * ) * ( n+1 ) ) ;
kgui2.c:          t->titles [ i ] = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->titles [ i ] , buff ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:          t->butncode = NULL;
kgui2.c:          t->butncode = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->butncode , buff ) ;
kgui2.c:              t->xpm [ i ] = ( void * ) Malloc ( 100 ) ;
kgui2.c:              pt = ( char * ) t->xpm [ i ] ;
kgui2.c:          else t->xpm [ i ] = NULL;
kgui2.c:          t->xpm [ i ] = NULL;
kgui2.c:              sscanf ( buff , "%d" , ( t->bkgr ) +i ) ;
kgui2.c:      sscanf ( buff , "%d%f%d" , & ( t->type ) , & ( t->fac ) , & ( t->bordr ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c:      t->df = ( int * ) tmp;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      t->bordr = 0;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , b->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , b->x1 , b->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , b->xgap , b->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , b->lngth ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , b->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , b->nx , b->ny ) ;
kgui2.c:      n = b->nx*b->ny;
kgui2.c:      if ( b->sw != NULL ) {
kgui2.c:              fprintf ( fp , "%d //status\n" , b->sw [ i ] ) ;
kgui2.c:          fprintf ( fp , "\"%-s\" //title\n" , b->titles [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , b->x2 , b->y2 ) ;
kgui2.c:      if ( b->butncode != NULL ) fprintf ( fp , "\"%-s\"/Button codes\n" , b->butncode ) ;
kgui2.c:      _uiPrintWid ( fp , b->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:          t->sw = NULL;
kgui2.c:          t->sw = ( int * ) malloc ( sizeof ( int ) *n ) ;
kgui2.c:          sscanf ( buff , "%d" , & ( t->sw [ 0 ] ) ) ;
kgui2.c:              sscanf ( buff , "%d" , & ( t->sw [ i ] ) ) ;
kgui2.c:      t->titles = ( char ** ) malloc ( sizeof ( char * ) * ( n+1 ) ) ;
kgui2.c:          t->titles [ i ] = ( char * ) malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->titles [ i ] , buff ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:          t->butncode = NULL;
kgui2.c:          t->butncode = ( char * ) malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->butncode , buff ) ;
kgui2.c:      t->df = ( int * ) tmp;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      t->y1 = t->y1;
kgui2.c:      t->y2 = t->y2;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      fprintf ( fp , "%c     //code\n" , b->code ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x1,y1\n" , b->x1 , b->y1 ) ;
kgui2.c:      fprintf ( fp , "%d %d  //xgap,ygap\n" , b->xgap , b->ygap ) ;
kgui2.c:      fprintf ( fp , "%d //length \n" , b->lngth ) ;
kgui2.c:      fprintf ( fp , "%d //Width \n" , b->width ) ;
kgui2.c:      fprintf ( fp , "%d %d  //Nx,Ny,\n" , b->nx , b->ny ) ;
kgui2.c:      n = b->nx*b->ny;
kgui2.c:      if ( b->sw != NULL ) {
kgui2.c:              fprintf ( fp , "%d //status\n" , b->sw [ i ] ) ;
kgui2.c:          if ( b->titles [ i ] == NULL ) fprintf ( fp , "\" \" //title\n" ) ;
kgui2.c:          else fprintf ( fp , "\"%-s\" //title\n" , b->titles [ i ] ) ;
kgui2.c:          PrintTitle ( fp , b->titles [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %d  //x2,y2\n" , b->x2 , b->y2 ) ;
kgui2.c:      if ( b->butncode != NULL ) fprintf ( fp , "\"%-s\"/Button codes\n" , b->butncode ) ;
kgui2.c:      if ( b->xpm == NULL ) {
kgui2.c:              PrintXpm ( fp , b->xpm [ i ] ) ;
kgui2.c:      if ( b->bkgr == NULL ) {
kgui2.c:              fprintf ( fp , "-1 //back ground color\n" ) ;
kgui2.c:              fprintf ( fp , "%d //back ground color\n" , b->bkgr [ i ] ) ;
kgui2.c:      fprintf ( fp , "%d %f %d  //type,fac\n" , b->type , b->fac , b->bordr ) ;
kgui2.c:      fprintf ( fp , "%d  //hide\n" , b->hide ) ;
kgui2.c:      _uiPrintWid ( fp , b->Wid ) ;
kgui2.c:      sscanf ( buff , "%c" , & ( t->code ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x1 ) , & ( t->y1 ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->xgap ) , & ( t->ygap ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->lngth ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->width ) ) ;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->nx ) , & ( t->ny ) ) ;
kgui2.c:      n = t->nx*t->ny;
kgui2.c:      t->xpm = ( void ** ) Malloc ( sizeof ( char * ) *3*n ) ;
kgui2.c:      t->bkgr = ( int * ) Malloc ( sizeof ( int ) *n ) ;
kgui2.c:      for ( i = 0;i < n;i++ ) { t->bkgr [ i ] = -1;}
kgui2.c:          t->sw = NULL;
kgui2.c:          t->sw = ( int * ) Malloc ( sizeof ( int ) *n ) ;
kgui2.c:          sscanf ( buff , "%d" , & ( t->sw [ 0 ] ) ) ;
kgui2.c:              sscanf ( buff , "%d" , & ( t->sw [ i ] ) ) ;
kgui2.c:      t->titles = ( char ** ) Malloc ( sizeof ( char * ) * ( n+1 ) ) ;
kgui2.c:          t->titles [ i ] = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->titles [ i ] , buff ) ;
kgui2.c:      t->titles [ n ] = NULL;
kgui2.c:      sscanf ( buff , "%d%d" , & ( t->x2 ) , & ( t->y2 ) ) ;
kgui2.c:          t->butncode = NULL;
kgui2.c:          t->butncode = ( char * ) Malloc ( 100 ) ;
kgui2.c:          StringCopy ( t->butncode , buff ) ;
kgui2.c:              t->xpm [ i ] = ( void * ) Malloc ( 100 ) ;
kgui2.c:              pt = ( char * ) t->xpm [ i ] ;
kgui2.c:          else t->xpm [ i ] = NULL;
kgui2.c:              sscanf ( buff , "%d" , ( t->bkgr ) +i ) ;
kgui2.c:      sscanf ( buff , "%d%f%d" , & ( t->type ) , & ( t->fac ) , & ( t->bordr ) ) ;
kgui2.c:      sscanf ( buff , "%d" , & ( t->hide ) ) ;
kgui2.c:      if ( ( t->hide != 0 ) && ( t->hide != 1 ) ) t->hide = 0;
kgui2.c://  t->df = (int *)tmp;
kgui2.c:      t->df = ( int * ) & ( t->bval ) ;
kgui2.c:      t->bval = 1;
kgui2.c:      t->arg = NULL;
kgui2.c:      t->Update = NULL;
kgui2.c:      _uiReadWid ( fp , t->Wid ) ;
kgui2.c:      switch ( t->code ) {
kgui2.c:      d = D->d;
kgui2.c:      if ( D->Resize != 1 ) {D->Resize = 0; D->MinWidth = D->MinHeight = 100;}
kgui2.c:      fprintf ( fp1 , "%d %d %d %d\n%d %d %d %d\n%d %d %d %d %d %d %d %d %d %d %d %d %f %d %d %d %d\n" , D->xo , D->yo , D->xl , D->yl , D->lw , D->rw , D->tw , D->bw , D->df , D->bor_type , D->bkup ,  \
kgui2.c:          ( D->Sticky ) , ( D->Fixpos ) , ( D->Deco ) , ( D->fullscreen ) , ( D->kbattn ) ,  \
kgui2.c:          ( D->butattn ) , ( D->Newwin ) , ( D->DrawBkgr ) , ( D->NoTaskBar ) ,  \
kgui2.c:          ( D->transparency ) , D->Resize , D->MinWidth , D->MinHeight , D->StackPos ) ;
kgui2.c:      int clr = -1;
kgui2.c:      if ( name != NULL ) strcpy ( h->Wid , name ) ;
kgui2.c:      xpm = ( char ** ) Malloc ( sizeof ( char * ) * ( h->nx*h->ny ) *3 ) ;
kgui2.c:      bkgr = ( int * ) Malloc ( sizeof ( int ) * ( h->nx*h->ny ) ) ;
kgui2.c:      h->titles = ( char ** ) Malloc ( sizeof ( char * ) * ( nx+1 ) ) ;
kgui2.c:      h->sw = ( int * ) Malloc ( sizeof ( int ) * ( nx+1 ) ) ;
kgui2.c:      h->bkgr = bkgr;
kgui2.c:      h->xpm = ( void ** ) xpm;
kgui2.c:      for ( i = 0;i < 3* ( h->nx*h->ny ) ;i++ ) {
kgui2.c:      for ( i = 0;i < ( h->nx*h->ny ) ;i++ ) {
kgui2.c:          bkgr [ i ] = -1;
kgui2.c:          h->titles [ i ] = NULL;
kgui2.c:          h->sw [ i ] = 1;
kgui2.c:          for ( i = 0;i < ( h->nx*h->ny ) ;i++ ) {
kgui2.c:              h->titles [ i ] = ( char * ) Malloc ( strlen ( titles [ i ] ) +1 ) ;
kgui2.c:              strcpy ( h->titles [ i ] , titles [ i ] ) ;
kgui2.c:      h->df = & ( h->bval ) ;
kgui2.c:      * ( h->df ) = 1;
kgui2.c:      h->butncode = NULL;
kgui2.c:      h->x1 = xo;h->y1 = yo;
kgui2.c:      h->x2 = h->x1+h->nx*h->lngth+ ( h->nx ) *h->xgap+2*offset;
kgui2.c:      h->y2 = h->y1+h->ny* ( h->width+h->ygap ) +2*offset;
kgui2.c:      h->Update = NULL;
kgui2.c:      h->item = -1;
kgui2.c:      int clr = -1;
kgui2.c:      DIB htmp = {'b' , 10L , 10L , 60 , 20 , 5 , 5 , 52 , 52 , 1 , 1 , NULL , NULL , NULL , NULL , NULL , NULL , NULL , NULL , 2 , 0.2 , 0 , 0 , -1};
kgui2.c:      if ( name != NULL ) strcpy ( h->Wid , name ) ;
kgui2.c:      xpm = ( char ** ) Malloc ( sizeof ( char * ) * ( h->nx*h->ny ) *3 ) ;
kgui2.c:      bkgr = ( int * ) Malloc ( sizeof ( int ) * ( h->nx*h->ny ) ) ;
kgui2.c:      h->titles = ( char ** ) Malloc ( sizeof ( char * ) * ( h->ny*h->nx+1 ) ) ;
kgui2.c:      h->sw = ( int * ) Malloc ( sizeof ( int ) * ( h->nx*h->ny+1 ) ) ;
kgui2.c:      h->bkgr = bkgr;
kgui2.c:      h->xpm = ( void ** ) xpm;
kgui2.c:      for ( i = 0;i < 3* ( h->nx*h->ny ) ;i++ ) {
kgui2.c:      for ( i = 0;i < ( h->nx*h->ny ) ;i++ ) {
kgui2.c:          bkgr [ i ] = -1;
kgui2.c:          h->titles [ i ] = NULL;
kgui2.c:          h->sw [ i ] = 1;
kgui2.c:          for ( i = 0;i < ( h->nx*h->ny ) ;i++ ) {
kgui2.c:              h->titles [ i ] = ( char * ) Malloc ( strlen ( titles [ i ] ) +1 ) ;
kgui2.c:              strcpy ( h->titles [ i ] , titles [ i ] ) ;
kgui2.c:      h->df = & ( h->bval ) ;
kgui2.c:      * ( h->df ) = 1;
kgui2.c:      h->butncode = NULL;
kgui2.c:      h->x1 = xo;h->y1 = yo;
kgui2.c:      h->x2 = h->x1+h->nx*h->lngth+ ( h->nx ) *h->xgap+2*offset;
kgui2.c:      h->y2 = h->y1+h->ny* ( h->width+h->ygap ) +2*offset;
kgui2.c:      h->Update = NULL;
kgui2.c:      h->item = -1;
kgui2.c:      int clr = -1;
kgui2.c:      if ( name != NULL ) strcpy ( h->Wid , name ) ;
kgui2.c:      h->df = & ( h->bval ) ;
kgui2.c:      * ( h->df ) = 1;
kgui2.c:      h->x1 = xo;h->y1 = yo;
kgui2.c:      h->x2 = h->x1+h->nx*h->lngth+ ( h->nx ) *h->xgap+2*offset;
kgui2.c:      h->y2 = h->y1+h->ny* ( h->width+h->ygap ) +2*offset;
kgui2.c:      h->Update = NULL;
kgui2.c:      h->item = -1;
kgui2.c:      h->buts = ( void * ) Malloc ( sizeof ( BUT_STR ) *nx*ny ) ;
kgui2.c:      butn = ( BUT_STR * ) h->buts;
kgui2.c:          butn [ i ] .bkgr = -1;
kgui2.c:      int clr = -1;
kgui2.c:      if ( name != NULL ) strcpy ( h->Wid , name ) ;
kgui2.c:      h->df = & ( h->bval ) ;
kgui2.c:      * ( h->df ) = 1;
kgui2.c:      h->x1 = xo;h->y1 = yo;
kgui2.c:      h->x2 = h->x1+h->nx*h->lngth+ ( h->nx ) *h->xgap+2*offset;
kgui2.c:      h->y2 = h->y1+h->ny* ( h->width+h->ygap ) +2*offset;
kgui2.c:      h->Update = NULL;
kgui2.c:      h->item = -1;
kgui2.c:      h->buts = ( void * ) Malloc ( sizeof ( BUT_STR ) *nx*ny ) ;
kgui2.c:      butn = ( BUT_STR * ) h->buts;
kgui2.c:          butn [ i ] .bkgr = -1;
kgui2.c:      if ( name != NULL ) strcpy ( g->Wid , name ) ;
kgui2.c:      g->x1 = x1;
kgui2.c:      g->y1 = y1;
kgui2.c:      g->x2 = x1 + l;
kgui2.c:      g->y2 = y1 + w;
kgui2.c:      g->nchrs = nchars;
kgui2.c:      g->nlines = nlines;
kgui2.c:      g->item = -1;
kgui2.c:      g->xpm = NULL;
kgui2.c:      if ( name != NULL ) strcpy ( g->Wid , name ) ;
kgui2.c:      g->x1 = xo;
kgui2.c:      g->y1 = yo;
kgui2.c:      g->x2 = g->x1 + xsize;
kgui2.c:      g->y2 = g->y1 + ysize;
kgui2.c:      g->bkgr_clr = 0;
kgui2.c:      g->xpm = NULL;
kgui2.c:      g->initgraph = NULL;
kgui2.c:      g->item = -1;
kgui2.c:      int i , n , col = -1;
kgui2.c:      DIP ptmp = {'p' , 10 , 10 , 20 , 20 , NULL , -1};
kgui2.c:      if ( name != NULL ) strcpy ( p->Wid , name ) ;
kgui2.c:          p->xpm = xpm;
kgui2.c:      p->x1 = xo;
kgui2.c:      p->y1 = yo;
kgui2.c:      p->x2 = p->x1 + length;
kgui2.c:      p->y2 = p->y1 + width;
kgui2.c:      p->bkgr_clr = -1;
kgui2.c:      p->bordr = bordrtype;
kgui2.c:      p->hide = 0;
kgui2.c:      p->item = -1;
kgui2.c:      if ( name != NULL ) strcpy ( m->Wid , name ) ;
kgui2.c:      m->hide = 0;
kgui2.c:      m->x1 = xo;
kgui2.c:      m->y1 = yo;
kgui2.c:      m->x2 = m->x1+length;
kgui2.c:      m->y2 = m->y1+width;
kgui2.c:      m->hide = 0;
kgui2.c:      m->justification = 1;
kgui2.c:      strcpy ( m->msg , "" ) ;
kgui2.c:      m->item = -1;
kgui2.c:      if ( name != NULL ) strcpy ( m->Wid , name ) ;
kgui2.c:      m->x1 = xo;
kgui2.c:      m->y1 = yo;
kgui2.c:      m->x2 = xo+length;
kgui2.c:      m->y2 = yo+width;
kgui2.c:      m->hide = 0;
kgui2.c:      m->bordr = 0;
kgui2.c:      m->percent = 0;
kgui2.c:      m->type = 0;
kgui2.c:      m->item = -1;
kgui2.c:      if ( name != NULL ) strcpy ( m->Wid , name ) ;
kgui2.c:      m->x1 = xo;
kgui2.c:      m->y1 = yo;
kgui2.c:      m->x2 = xo+width;
kgui2.c:      m->y2 = yo+height;
kgui2.c:      m->hide = 0;
kgui2.c:      m->bordr = 0;
kgui2.c:      m->ds = 100;
kgui2.c:      m->df = 0;
kgui2.c:      m->mvmt = 1;
kgui2.c:      m->type = 0;
kgui2.c:      m->Update = NULL;
kgui2.c:      m->item = -1;
kgui2.c:      if ( name != NULL ) strcpy ( m->Wid , name ) ;
kgui2.c:      m->x1 = xo;
kgui2.c:      m->y1 = yo;
kgui2.c:      m->x2 = xo+length;
kgui2.c:      m->y2 = yo+width;
kgui2.c:      m->hide = 0;
kgui2.c:      m->bordr = 0;
kgui2.c:      m->ds = 100;
kgui2.c:      m->df = 0;
kgui2.c:      m->mvmt = 1;
kgui2.c:      m->type = 0;
kgui2.c:      m->Update = NULL;
kgui2.c:      m->item = -1;
kgui2.c:      if ( name != NULL ) strcpy ( m->Wid , name ) ;
kgui2.c:      m->x1 = xo;
kgui2.c:      m->y1 = yo;
kgui2.c:      m->x2 = m->x1+length;
kgui2.c:      m->y2 = m->y1+width;
kgui2.c:      m->msg [ 0 ] = '\0';
kgui2.c:      if ( msg != NULL ) strncpy ( m->msg , msg , 499 ) ;
kgui2.c:      m->hide = 0;
kgui2.c:          m->code = 'm';
kgui2.c:          m->justification = 1;
kgui2.c:          m->code = 'B';
kgui2.c:          m->justification = 0;
kgui2.c:          m->code = 'M';
kgui2.c:          m->justification = 1;
kgui2.c:          m->code = 'm';
kgui2.c:      m->item = -1;
kgui2.c:          i++; if ( isdigit ( * ( c+i ) ) ) no = no*10+ ( * ( c+i ) -'0' ) ;
kgui2.c:          i++; if ( isdigit ( * ( c+i ) ) ) { no = no*10+ ( * ( c+i ) -'0' ) ;i++;}
kgui2.c:                  size = size*10+ ( *cpt -'0' ) ;
kgui2.c:                  size = size*10+ ( *cpt -'0' ) ;
kgui2.c:      width = ( it ) *T->width+ ( it-1 ) *10;
kgui2.c:      T->elmt = e;
kgui2.c:      T->pt = v;
kgui2.c:      T->x2 = T->x1+lngth;
kgui2.c:      T->y2 = T->y1+width;
kgui2.c:      T->pt = v;
kgui2.c:      T->x1 = xo;
kgui2.c:      T->y1 = yo;
kgui2.c:      T->width = width;
kgui2.c:      if ( name != NULL ) strcpy ( T->Wid , name ) ;
kgui2.c:      width = ( ny ) *T->width+ ( ny-1 ) *10;
kgui2.c:      T->nx = nx;
kgui2.c:      T->ny = ny;
kgui2.c:      T->hide = 0;
kgui2.c:      T->col = 1;
kgui2.c:      T->row = 1;
kgui2.c:      T->Update = NULL;
kgui2.c:      T->item = -1;
lowlib.c:       D = ( DIALOG * ) ( ( w )->D ) ; \
lowlib.c:       if ( w->x1 < 0 ) return 0; \
lowlib.c:       if ( w->y1 < 0 ) return 0; \
lowlib.c:       if ( w->x2 > D->xl ) return 0; \
lowlib.c:       if ( w->y2 > D->yl ) return 0; \
lowlib.c:       D = ( DIALOG * ) ( ( w )->D ) ; \
lowlib.c:       x1 = D->xo+ ( w )->x1; \
lowlib.c:       y1 = D->yo+ ( w )->y1; \
lowlib.c:       x2 = D->xo+ ( w )->x2; \
lowlib.c:       y2 = D->yo+ ( w )->y2; \
lowlib.c:       if ( ( w )->Bimg == NULL ) ( w )->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ; \
lowlib.c:       D = ( DIALOG * ) ( ( w )->D ) ; \
lowlib.c:       x1 = D->xo+ ( w )->x1; \
lowlib.c:       y1 = D->yo+ ( w )->y1; \
lowlib.c:       xl = ( w )->x2- ( w )->x1+1; \
lowlib.c:       yl = ( w )->y2- ( w )->y1+1; \
lowlib.c:       if ( ( w )->Bimg != NULL ) kgRestoreImage ( D , ( w )->Bimg , x1 , y1 , xl , yl ) ; \
lowlib.c:       D = ( DIALOG * ) ( ( w )->D ) ; \
lowlib.c:       x1 = D->xo+ ( w )->x1; \
lowlib.c:       y1 = D->yo+ ( w )->y1; \
lowlib.c:       xoff = ( xp1 ) -x1; \
lowlib.c:       yoff = ( yp1 ) -y1; \
lowlib.c:       xl = ( xp2 ) - ( xp1 ) +1; \
lowlib.c:       yl = ( yp2 ) - ( yp1 ) +1; \
lowlib.c:       if ( ( w )->Bimg != NULL ) kgRestoreImagePart ( D , ( w )->Bimg , xp1 , yp1 , xoff , yoff , xl , yl ) ; \
lowlib.c:   if ( dc->greek > 0 ) {\
lowlib.c:           dc->icpos = dc->icpostmp; \
lowlib.c:           dc->icxv = dc->icxvtmp; \
lowlib.c:           dc->icyv = dc->icyvtmp; \
lowlib.c:   if ( dc->greek > 0 ) {\
lowlib.c:           dc->icpostmp = dc->icpos; \
lowlib.c:           dc->icxvtmp = dc->icxv; \
lowlib.c:           dc->icyvtmp = dc->icyv; \
lowlib.c:           dc->icpos = dc->icposf0; \
lowlib.c:           dc->icxv = dc->icxvf0; \
lowlib.c:           dc->icyv = dc->icyvf0; \
lowlib.c:#define uiTX(x,y) (dc->cx +(x)*dc->cost+(y)*dc->sint)
lowlib.c:#define uiTY(x,y) (dc->cy -(x)*dc->sint+(y)*dc->cost)
lowlib.c:#define uiset_clip_limits(wc,x1,y1,x2,y2) wc->c_v_x1=x1,wc->c_v_y1=y1,wc->c_v_x2=x2,wc->c_v_y2=y2
lowlib.c:#define uibkup_clip_limits wc->c_v_x1_o=wc->c_v_x1,wc->c_v_y1_o=wc->c_v_y1,wc->c_v_x2_o=wc->c_v_x2,wc->c_v_y2_o=wc->c_v_y2
lowlib.c:#define uiset_sup_clip_limits(wc,x1,y1,x2,y2) wc->s_v_x1=x1,wc->s_v_y1=y1,wc->s_v_x2=x2,wc->s_v_y2=y2
lowlib.c:#define uirest_clip_limits wc->c_v_x1=wc->c_v_x1_o,wc->c_v_y1=wc->c_v_y1_o,wc->c_v_x2=wc->c_v_x2_o,wc->c_v_y2=wc->c_v_y2_o
lowlib.c:#define uiset_full_scrn  wc->c_v_x1=0,wc->c_v_y1=0,wc->c_v_x2=(wc->EVGAX),wc->c_v_y2=(wc->EVGAY)
lowlib.c:#define uipclr(p)  (float)(((p-dc->pmin)*dc->dfac+1.))
lowlib.c:#define uiscr_x(x) (int)((x-dc->w_x1)*dc->u_x+dc->D_x+dc->v_x1+0.5)
lowlib.c:#define uiscr_y(y) (int)(((y-dc->w_y1)*dc->u_y+dc->D_y+dc->v_y1)+0.5)
lowlib.c:#define uiusr_x(x) (float)((x-dc->D_x-dc->v_x1)/dc->u_x+dc->w_x1)
lowlib.c:#define uiusr_y(y) (float)((y-dc->D_y-dc->v_y1)/dc->u_y+dc->w_y1)
lowlib.c:  static char Posfmt [ 200 ] = {"%14.5g , %-14.5g"} , Xfmt [ 7 ] = \
lowlib.c:  {" 14.5g"} , Yfmt [ 7 ] = {"-14.5g"};
lowlib.c:      if ( Dtmp->Newwin != 1 ) {
lowlib.c:          Dtmp = Dtmp->parent;
lowlib.c:      dc = G->dc;
lowlib.c:      sprintf ( dc->Posfmt , "%%%s , %%%s" , xfmt , yfmt ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      yy1 = EVGAY-y1;
lowlib.c:      yy2 = EVGAY-y2;
lowlib.c:              yy = EVGAY-dy;
lowlib.c:                      if ( ( ( r [ i ] .x1-dx ) * ( r [ i ] .x2-dx ) <= 0 ) && \
lowlib.c:                       ( ( r [ i ] .y1-yy ) * ( r [ i ] .y2-yy ) <= 0 ) ) {
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->wc = wc;
lowlib.c:      EVGAX = G->x2 -G->x1;
lowlib.c:      EVGAY = G->y2 - G->y1;
lowlib.c:      dc->A_size = 11;
lowlib.c:      dc->msg_x = 0;
lowlib.c:      dc->msg_y = 0;
lowlib.c:      dc->msg_x = ( EVGAX-316 ) /2;
lowlib.c:      dc->msg_y = EVGAY-24;
lowlib.c:      dc->gcur_x = 1 , dc->gcur_y = 1 , dc->gcur_r = 20;
lowlib.c:      dc->cur_x = 320; dc->cur_y = 240;
lowlib.c:      dc->ln_style = LN_STYL;
lowlib.c:      dc->m_style = M_STYL;
lowlib.c:      dc->ln_color = 0x0F;
lowlib.c:      wcset_clr ( wc , dc->ln_color ) ;
lowlib.c:      dc->c_bound = 4;
lowlib.c:      dc->t_color = 14;
lowlib.c:      dc->t_pattern = 15;
lowlib.c:      dc->t_fill = 1;
lowlib.c:      dc->t_font = 0;
lowlib.c:      dc->t_bkgr = 0;
lowlib.c:      dc->t_bodr = 0;
lowlib.c:      dc->fil_color = 0;
lowlib.c:      dc->bod_width = 11;
lowlib.c:      dc->bod_color = 1;
lowlib.c:      dc->DOUBLE = 0;
lowlib.c://  dc->Fontlist=uiGetFontlist(); // need further modification
lowlib.c:      dc->Fontlist = ( Dlink * ) Loadfontstruct ( ) ;
lowlib.c:      count = Dcount ( dc->Fontlist ) ;
lowlib.c:      Dposition ( dc->Fontlist , font+1 ) ;
lowlib.c:      pt = ( FONT * ) Getrecord ( dc->Fontlist ) ;
lowlib.c:      dc->icpos = pt->icpos;
lowlib.c:      dc->icxv = pt->icxv;
lowlib.c:      dc->icyv = pt->icyv;
lowlib.c:      dc->m_f = pt->m_f;
lowlib.c:      dc->icposf0 = dc->icpos; dc->icxvf0 = dc->icxv;
lowlib.c:      dc->icyvf0 = dc->icyv; dc->m_f0 = dc->m_f;
lowlib.c:      dc->ln_width = 1;
lowlib.c:      dc->pr_txt = 1;
lowlib.c:      dc->cost = 1.0;
lowlib.c:      dc->sint = 0.0;
lowlib.c:      dc->txt_ht = 20;
lowlib.c:      dc->txt_wt = 20;
lowlib.c:      dc->txt_htx = 20;
lowlib.c:      dc->txt_wty = 20;
lowlib.c:      dc->txt_hty = 20;
lowlib.c:      dc->txt_wtx = 20;
lowlib.c:      dc->txt_w42 = dc->txt_wt/CFact;
lowlib.c:      dc->txt_h42 = dc->txt_ht/CFact;
lowlib.c:      dc->txt_sp = 2;
lowlib.c:      dc->txt_spy = 2;
lowlib.c:      dc->txt_spx = 2;
lowlib.c:      dc->v_x1 = 0;
lowlib.c:      dc->v_y1 = 0;
lowlib.c:      dc->v_x2 = EVGAX;
lowlib.c:      dc->v_y2 = EVGAY;
lowlib.c:      dc->w_x1 = 0;
lowlib.c:      dc->w_y1 = 0;
lowlib.c:      dc->w_x2 = 1.0;
lowlib.c:      dc->w_y2 = 1.0;
lowlib.c:      dc->u_x = EVGAX;
lowlib.c:      dc->u_y = EVGAY;
lowlib.c:      dc->V_x = EVGAX;
lowlib.c:      dc->V_y = EVGAY;
lowlib.c:      dc->D_x = 0;
lowlib.c:      dc->D_y = 0;
lowlib.c:      dc->jmp = 8;
lowlib.c:      dc->lcur_x = 0;
lowlib.c:      dc->lcur_y = EVGAY;
lowlib.c:      dc->rcur_x = EVGAX;
lowlib.c:      dc->rcur_y = 0;
lowlib.c:      dc->ZBUFF = dc->SET3D = dc->TIFF = dc->PROJ = 0;
lowlib.c:      dc->DBL_BUF = 0;
lowlib.c:      dc->zbuf = dc->redbuf = dc->greenbuf = dc->bluebuf = dc->clrbuf = NULL;
lowlib.c:      dc->D_ON = 1;
lowlib.c:      dc->Cutoff = 1;
lowlib.c:      dc->v_xt1 = ( int ) ( dc->v_x1-dc->txt_wt-dc->txt_sp ) ;
lowlib.c:      dc->v_yt1 = ( int ) ( dc->v_y1-dc->txt_ht ) ;
lowlib.c:      wc->Clip = Dcopy ( WC ( D )->Clip ) ;
lowlib.c:      wc->SBlist = Dcopy ( WC ( D )->SBlist ) ;
lowlib.c:      wc->Clip = Dopen ( ) ;
lowlib.c:      wc->SBlist = Dopen ( ) ;
lowlib.c:      uiset_sup_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , D->evgay- ( dc->v_y2+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , D->evgay- ( dc->v_y1+dc->D_y ) ) ;
lowlib.c:      uiset_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , D->evgay- ( dc->v_y2+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , D->evgay- ( dc->v_y1+dc->D_y ) ) ;
lowlib.c:      uiset_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , D->evgay- ( dc->v_y2+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , D->evgay- ( dc->v_y1+dc->D_y ) ) ;
lowlib.c:      uiset_sup_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , ( dc->v_y1+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , ( dc->v_y2+dc->D_y ) ) ;
lowlib.c:      uiset_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , ( dc->v_y1+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , ( dc->v_y2+dc->D_y ) ) ;
lowlib.c:      dc->msg_x += G->x1+D->xo;
lowlib.c:      dc->msg_y += G->y1+D->yo;
lowlib.c:      strcpy ( dc->Posfmt , Posfmt ) ;
lowlib.c:      strcpy ( dc->Xfmt , Xfmt ) ;
lowlib.c:      strcpy ( dc->Yfmt , Yfmt ) ;
lowlib.c:          dc->ln_ptn [ i ] = ln_ptn [ i ] ;
lowlib.c:          dc->st_ptr [ i ] = st_ptr [ i ] ;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->cur_x = xp ;
lowlib.c:      dc->cur_y = yp ;
lowlib.c:          _draw_line ( x-3*fac , y-3*fac , x+3*fac , y+3*fac ) ;
lowlib.c:          _draw_line ( x-3*fac , y+3*fac , x+3*fac , y-3*fac ) ;
lowlib.c:          _box_fill ( x-3*fac , y-3*fac , x+3*fac , y+3*fac , \
lowlib.c:          case 3 : _draw_line ( x , y-4*fac , x , y+4*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y , x+4*fac , y ) ;
lowlib.c:          _draw_line ( x-2*fac , y-4*fac , x+2*fac , y-4*fac ) ;
lowlib.c:          _draw_line ( x-2*fac , y+4*fac , x+2*fac , y+4*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y-2*fac , x-4*fac , y+2*fac ) ;
lowlib.c:          _draw_line ( x+4*fac , y-2*fac , x+4*fac , y+2*fac ) ;
lowlib.c:          case 4 : _draw_line ( x-4*fac , y-4*fac , x+4*fac , y+4*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y+4*fac , x+4*fac , y-4*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y , x+4*fac , y ) ;
lowlib.c:          _draw_line ( x , y-4*fac , x , y+4*fac ) ;
lowlib.c:          case 5 : _draw_line ( x+3*fac , y , x , y-8*fac ) ;
lowlib.c:          _draw_line ( x-3*fac , y , x , y-8*fac ) ;
lowlib.c:          _draw_line ( x-3*fac , y , x , y+8*fac ) ;
lowlib.c:          case 6 : _draw_line ( x-4*fac , y , x+4*fac , y ) ;
lowlib.c:          _draw_line ( x , y-4*fac , x , y+4*fac ) ;
lowlib.c:          _draw_line ( x+2*fac , y-2*fac , x+2*fac , y+2*fac ) ;
lowlib.c:          _draw_line ( x+2*fac , y+2*fac , x-2*fac , y+2*fac ) ;
lowlib.c:          _draw_line ( x-2*fac , y+2*fac , x-2*fac , y-2*fac ) ;
lowlib.c:          _draw_line ( x-2*fac , y-2*fac , x+2*fac , y-2*fac ) ;
lowlib.c:          _draw_line ( x+7*fac , y , x+3*fac , y-3*fac ) ;
lowlib.c:          _draw_line ( x+3*fac , y-3*fac , x , y-7*fac ) ;
lowlib.c:          _draw_line ( x , y-7*fac , x-3*fac , y-3*fac ) ;
lowlib.c:          _draw_line ( x-3*fac , y-3*fac , x-7*fac , y ) ;
lowlib.c:          _draw_line ( x-7*fac , y , x-3*fac , y+3*fac ) ;
lowlib.c:          _draw_line ( x-3*fac , y+3*fac , x , y+7*fac ) ;
lowlib.c:          case 8 : _draw_line ( x-4*fac , y-4*fac , x+4*fac , y+4*fac ) ;
lowlib.c:          _draw_line ( x+4*fac , y-4*fac , x-4*fac , y+4*fac ) ;
lowlib.c:          _draw_line ( x+4*fac , y-4*fac , x+4*fac , y-2*fac ) ;
lowlib.c:          _draw_line ( x+4*fac , y-4*fac , x+2*fac , y-4*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y-4*fac , x-2*fac , y-4*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y-4*fac , x-4*fac , y-2*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y+4*fac , x-4*fac , y+2*fac ) ;
lowlib.c:          _draw_line ( x-4*fac , y+4*fac , x-2*fac , y+4*fac ) ;
lowlib.c:          px [ 0 ] = x+4*fac; py [ 0 ] = y; px [ 1 ] = x-4*fac; py [ 1 ] = y+4*fac;
lowlib.c:          px [ 2 ] = x-4*fac; py [ 2 ] = y-4*fac;
lowlib.c:          px [ 0 ] = x-4*fac; py [ 0 ] = y; px [ 1 ] = x+4*fac; py [ 1 ] = y+4*fac;
lowlib.c:          px [ 2 ] = x+4*fac; py [ 2 ] = y-4*fac;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y+4*fac; px [ 1 ] = x-4*fac; py [ 1 ] = y-4*fac;
lowlib.c:          px [ 2 ] = x+4*fac; py [ 2 ] = y-4*fac;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y-4*fac; px [ 1 ] = x-4*fac; py [ 1 ] = y+4*fac;
lowlib.c:          _draw_line ( x-2*fac , y-2*fac , x+2*fac , y+2*fac ) ;
lowlib.c:          _draw_line ( x-2*fac , y+2*fac , x+2*fac , y-2*fac ) ;
lowlib.c:          px [ 0 ] = x+2*fac; py [ 0 ] = y; px [ 1 ] = x-2*fac; py [ 1 ] = y+2*fac;
lowlib.c:          px [ 2 ] = x-2*fac; py [ 2 ] = y-2*fac;
lowlib.c:          px [ 0 ] = x-2*fac; py [ 0 ] = y; px [ 1 ] = x+2*fac; py [ 1 ] = y+2*fac;
lowlib.c:          px [ 2 ] = x+2*fac; py [ 2 ] = y-2*fac;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y+2*fac; px [ 1 ] = x-2*fac; py [ 1 ] = y-2*fac;
lowlib.c:          px [ 2 ] = x+2*fac; py [ 2 ] = y-2*fac;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y-2*fac; px [ 1 ] = x-2*fac; py [ 1 ] = y+2*fac;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      dc->cur_x = x ;
lowlib.c:      dc->cur_y = y ;
lowlib.c:      style = dc->m_style%20;
lowlib.c:      mf = dc->m_style/20;
lowlib.c:          _uicircle_fill ( G , x , y , ( int ) ( 3*fac ) , dc->ln_color ) ;
lowlib.c:          _uidraw_line ( wc , x-3*fac , y-3*fac , x+3*fac , y+3*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-3*fac , y+3*fac , x+3*fac , y-3*fac ) ;
lowlib.c:          _uibox_fill ( wc , x-3*fac , y-3*fac , x+3*fac , y+3*fac , dc->ln_color ) ;
lowlib.c:          case 3 : _uidraw_line ( wc , x , y-4*fac , x , y+4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y , x+4*fac , y ) ;
lowlib.c:          _uidraw_line ( wc , x-2*fac , y-4*fac , x+2*fac , y-4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-2*fac , y+4*fac , x+2*fac , y+4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y-2*fac , x-4*fac , y+2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+4*fac , y-2*fac , x+4*fac , y+2*fac ) ;
lowlib.c:          case 4 : _uidraw_line ( wc , x-4*fac , y-4*fac , x+4*fac , y+4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y+4*fac , x+4*fac , y-4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y , x+4*fac , y ) ;
lowlib.c:          _uidraw_line ( wc , x , y-4*fac , x , y+4*fac ) ;
lowlib.c:          case 5 : _uidraw_line ( wc , x+3*fac , y , x , y-8*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-3*fac , y , x , y-8*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-3*fac , y , x , y+8*fac ) ;
lowlib.c:          case 6 : _uidraw_line ( wc , x-4*fac , y , x+4*fac , y ) ;
lowlib.c:          _uidraw_line ( wc , x , y-4*fac , x , y+4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+2*fac , y-2*fac , x+2*fac , y+2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+2*fac , y+2*fac , x-2*fac , y+2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-2*fac , y+2*fac , x-2*fac , y-2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-2*fac , y-2*fac , x+2*fac , y-2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+7*fac , y , x+3*fac , y-3*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+3*fac , y-3*fac , x , y-7*fac ) ;
lowlib.c:          _uidraw_line ( wc , x , y-7*fac , x-3*fac , y-3*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-3*fac , y-3*fac , x-7*fac , y ) ;
lowlib.c:          _uidraw_line ( wc , x-7*fac , y , x-3*fac , y+3*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-3*fac , y+3*fac , x , y+7*fac ) ;
lowlib.c:          case 8 : _uidraw_line ( wc , x-4*fac , y-4*fac , x+4*fac , y+4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+4*fac , y-4*fac , x-4*fac , y+4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+4*fac , y-4*fac , x+4*fac , y-2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x+4*fac , y-4*fac , x+2*fac , y-4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y-4*fac , x-2*fac , y-4*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y-4*fac , x-4*fac , y-2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y+4*fac , x-4*fac , y+2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-4*fac , y+4*fac , x-2*fac , y+4*fac ) ;
lowlib.c:          px [ 0 ] = x+4*fac; py [ 0 ] = y; px [ 1 ] = x-4*fac; py [ 1 ] = y+4*fac;
lowlib.c:          px [ 2 ] = x-4*fac; py [ 2 ] = y-4*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          px [ 0 ] = x-4*fac; py [ 0 ] = y; px [ 1 ] = x+4*fac; py [ 1 ] = y+4*fac;
lowlib.c:          px [ 2 ] = x+4*fac; py [ 2 ] = y-4*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y+4*fac; px [ 1 ] = x-4*fac; py [ 1 ] = y-4*fac;
lowlib.c:          px [ 2 ] = x+4*fac; py [ 2 ] = y-4*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y-4*fac; px [ 1 ] = x-4*fac; py [ 1 ] = y+4*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          _uicircle_fill ( G , x , y , ( int ) ( 3*fac ) , dc->ln_color ) ;
lowlib.c:          _uicircle_fill ( G , x , y , ( int ) ( 1*fac ) , dc->ln_color ) ;
lowlib.c:          _uidraw_line ( wc , x-2*fac , y-2*fac , x+2*fac , y+2*fac ) ;
lowlib.c:          _uidraw_line ( wc , x-2*fac , y+2*fac , x+2*fac , y-2*fac ) ;
lowlib.c:          px [ 0 ] = x+2*fac; py [ 0 ] = y; px [ 1 ] = x-2*fac; py [ 1 ] = y+2*fac;
lowlib.c:          px [ 2 ] = x-2*fac; py [ 2 ] = y-2*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          px [ 0 ] = x-2*fac; py [ 0 ] = y; px [ 1 ] = x+2*fac; py [ 1 ] = y+2*fac;
lowlib.c:          px [ 2 ] = x+2*fac; py [ 2 ] = y-2*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y+2*fac; px [ 1 ] = x-2*fac; py [ 1 ] = y-2*fac;
lowlib.c:          px [ 2 ] = x+2*fac; py [ 2 ] = y-2*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:          px [ 0 ] = x; py [ 0 ] = y-2*fac; px [ 1 ] = x-2*fac; py [ 1 ] = y+2*fac;
lowlib.c:          _uipoly_fill ( G , ( short ) 3 , px , py , ( short ) 0 , dc->ln_color ) ;
lowlib.c:      if ( y > wc->c_v_y2 ) t |= 0x08;
lowlib.c:      if ( y < wc->c_v_y1 ) t |= 0x04;
lowlib.c:      if ( x > wc->c_v_x2 ) t |= 0x02;
lowlib.c:      if ( x < wc->c_v_x1 ) t++;
lowlib.c:      xs = wc->c_v_x1;
lowlib.c:      ys = wc->c_v_y1;
lowlib.c:          tx = ( ( *xb ) - ( *xa ) ) ;
lowlib.c:          ty = ( ( *yb ) - ( *ya ) ) ;
lowlib.c:              y = ( int ) ( *ya+ ( wc->c_v_x1- ( *xa ) ) *ty/tx ) ;
lowlib.c:              if ( ( y == ys ) && ( ( ys > wc->c_v_y2 ) \
lowlib.c:               || ( ys < wc->c_v_y1 ) ) ) return ( 0 ) ;
lowlib.c:              x = wc->c_v_x1;
lowlib.c:              y = ( int ) ( *ya+ ( wc->c_v_x2- ( *xa ) ) *ty/tx ) ;
lowlib.c:              if ( ( y == ys ) && ( ( ys > wc->c_v_y2 ) \
lowlib.c:               || ( ys < wc->c_v_y1 ) ) ) return ( 0 ) ;
lowlib.c:              x = wc->c_v_x2;
lowlib.c:              x = ( int ) ( *xa+ ( wc->c_v_y2- ( *ya ) ) *tx/ty ) ;
lowlib.c:              if ( x == xs && ( ( xs < wc->c_v_x1 ) || \
lowlib.c:               ( xs > wc->c_v_x2 ) ) ) return ( 0 ) ;
lowlib.c:              y = wc->c_v_y2;
lowlib.c:              x = ( int ) ( *xa+ ( wc->c_v_y1- ( *ya ) ) *tx/ty ) ;
lowlib.c:              if ( x == xs && ( ( xs < wc->c_v_x1 ) || \
lowlib.c:               ( xs > wc->c_v_x2 ) ) ) return ( 0 ) ;
lowlib.c:              y = wc->c_v_y1;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      lnwidth = dc->ln_width-2;
lowlib.c:      dx = ( float ) ( xb-xa ) ;
lowlib.c:      dy = ( float ) ( yb-ya ) ;
lowlib.c:      if ( ct < 0. ) dy1 = ( int ) ( ct*i2-0.5 ) ;
lowlib.c:      xa += dx1 , xb += dx1 , ya -= dy1 , yb -= dy1;
lowlib.c:          if ( ct < 0. ) dy1 = ( int ) ( ct*i-0.5 ) ;
lowlib.c:          _uidraw_line ( wc , xa-dx1 , ya+dy1 , xb-dx1 , yb+dy1 ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      EVGAY = ( ( DIALOG * ) ( G->D ) )->evgay;
lowlib.c:      xa = dc->cur_x;
lowlib.c:      ya = dc->cur_y;
lowlib.c:              dc->cur_x = x;
lowlib.c:              dc->cur_y = y;
lowlib.c:          ptn = dc->ln_ptn [ dc->ln_style%10 ] ;
lowlib.c:          dx = xb-xa;
lowlib.c:          dy = yb-ya;
lowlib.c:              g = inc1-dx1;
lowlib.c:              inc2 = g-dx1;
lowlib.c:              else ch = -1;
lowlib.c:              else rh = -1;
lowlib.c:              g = inc1-dy1;
lowlib.c:              inc2 = g-dy1;
lowlib.c:              else ch = -1;
lowlib.c:              else rh = -1;
lowlib.c:          i = dc->st_ptr [ dc->ln_style%10 ] ;
lowlib.c:          while ( abs ( c-f ) > 0 ) {
lowlib.c:                  if ( dx1 > dy1 ) uiput_pixl ( wc , c , ( EVGAY-r ) ) ;
lowlib.c:                  else uiput_pixl ( wc , r , ( EVGAY-c ) ) ;
lowlib.c:      dc->st_ptr [ dc->ln_style%10 ] = i;
lowlib.c:      dc = G->dc;
lowlib.c:      D = G->D;
lowlib.c:      xa = dc->cur_x;
lowlib.c:      ya = dc->cur_y;
lowlib.c:      if ( dc->ln_style == 0 ) {uidraw_line ( G , xa , ya , xb , yb ) ; }
lowlib.c:          if ( dc->ln_width == 1 ) _uidraw_ ( G , x , y ) ;
lowlib.c:              stloc = dc->st_ptr [ dc->ln_style%10 ] ;
lowlib.c:              i2 = dc->ln_width/2;
lowlib.c:              dx = ( float ) ( xb-xa ) ;
lowlib.c:              dy = ( float ) ( yb-ya ) ;
lowlib.c:              if ( ct < 0. ) dy1 = ( int ) ( ct*i2-0.5 ) ;
lowlib.c:              xa += dx1 , xb += dx1 , ya -= dy1 , yb -= dy1;
lowlib.c:              dc->cur_x = xa , dc->cur_y = ya;
lowlib.c:              for ( i = 1; i < dc->ln_width; i++ ) {
lowlib.c:                  dc->st_ptr [ dc->ln_style%10 ] = stloc;
lowlib.c:                  if ( ct < 0. ) dy1 = ( int ) ( ct*i-0.5 ) ;
lowlib.c:                  dc->cur_x = xa-dx1 , dc->cur_y = ya+dy1;
lowlib.c:                  _uidraw_ ( G , xb-dx1 , yb+dy1 ) ;
lowlib.c:      dc->cur_x = x;
lowlib.c:      dc->cur_y = y;
lowlib.c:          tm = 1.-t;
lowlib.c:          dist = ( x-x1 ) * ( x-x1 ) + ( y-y1 ) * ( y-y1 ) ;
lowlib.c:          tm = 1.-t;
lowlib.c:/* this for special use expecting roots between (0-1) */
lowlib.c:          disc = b*b - 4*a*c;
lowlib.c:                  *r1 = *r2 = -b/ ( 2.*a ) ;
lowlib.c:                  if ( *r1* ( 1-*r1 ) <= 0 ) *r1 = *r2 = 0;
lowlib.c:                  *r1 = ( -b+disc ) / ( 2.*a ) ;
lowlib.c:                  if ( *r1* ( 1-*r1 ) <= 0 ) *r1 = 0;
lowlib.c:                  *r2 = ( -b-disc ) / ( 2.*a ) ;
lowlib.c:                  if ( *r2* ( 1-*r2 ) <= 0 ) *r2 = 0;
lowlib.c:      if ( fabs ( y1-y2 ) *Mag > n ) n = fabs ( y1 - y2 ) *Mag;
lowlib.c:      if ( fabs ( y1-y3 ) *Mag > n ) n = fabs ( y1 - y3 ) *Mag;
lowlib.c:      if ( fabs ( y1-y4 ) *Mag > n ) n = fabs ( y1 - y4 ) *Mag;
lowlib.c:      if ( fabs ( y2-y3 ) *Mag > n ) n = fabs ( y2 - y3 ) *Mag;
lowlib.c:      if ( fabs ( y2-y4 ) *Mag > n ) n = fabs ( y2 - y4 ) *Mag;
lowlib.c:      if ( fabs ( y3-y4 ) *Mag > n ) n = fabs ( y3 - y4 ) *Mag;
lowlib.c:      cx = 3* ( x2-x1 ) ;
lowlib.c:      cy = 3* ( y2-y1 ) ;
lowlib.c:      bx = 3* ( x3-x2 ) -cx;
lowlib.c:      by = 3* ( y3-y2 ) -cy;
lowlib.c:      ax = x4-x1-cx-bx;
lowlib.c:      ay = y4-y1-cy-by;
lowlib.c:       dist = (x-x1)*(x-x1)+(y-y1)*(y-y1);
lowlib.c:          j1 = j-1;
lowlib.c:      while ( i < j ) { if ( ( x1 [ i ] == x1 [ i-1 ] ) && ( y1 [ i ] == y1 [ i-1 ] ) ) \
lowlib.c:          { j--; for ( k = i; k < j; k++ ) {x1 [ k ] = x1 [ k+1 ] ;
lowlib.c:      for ( i = 1; i < j; i++ ) {x2 [ i-1 ] = x1 [ i ] ; y2 [ i-1 ] = y1 [ i ] ; }
lowlib.c:      x2 [ j-1 ] = x1 [ 0 ] ; y2 [ j-1 ] = y1 [ 0 ] ;
lowlib.c:      xup = -1000000;
lowlib.c:      ygrt = -1239000;
lowlib.c:          j = i-1;
lowlib.c:              j--;
lowlib.c:      if ( ( scan/Mag > wc->c_v_y2 ) || ( ygrt/Mag < wc->c_v_y1 ) || \
lowlib.c:       ( xlow/Mag > wc->c_v_x2 ) || ( xup/Mag < wc->c_v_x1 ) ) return;
lowlib.c:      tempc = wc->c_color;
lowlib.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * \
lowlib.c:                       ( scan-ymin [ i ] ) +xmin [ i ] +0.5 ) ) ;
lowlib.c:              j = i-1;
lowlib.c:              while ( j >= 0 && txx < xcord [ j ] ) { xcord [ j+1 ] = xcord [ j ] ; j--; }
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      color = dc->t_color;
lowlib.c:      pnt = asc-32+dc->greek;
lowlib.c:      fact = dc->m_f [ pnt ] ;
lowlib.c:      xo = ( int ) ( dc->cx+ ( dc->xp ) ) ;
lowlib.c:      yo = ( int ) ( dc->cy+dc->yp ) ;
lowlib.c:      ptr = dc->icpos [ pnt ] ;
lowlib.c:          code = dc->icxv [ ptr ] ; n = dc->icyv [ ptr ] ;
lowlib.c:                  xdum = dc->icxv [ ptr ] ; ydum = dc->icyv [ ptr ] ; ptr++;
lowlib.c:                  x [ i ] = xdum*dc->txt_w42+xo; y [ i ] = yo+ydum*dc->txt_h42;
lowlib.c:              code = dc->icxv [ ptr ] ; n = dc->icyv [ ptr ] ;
lowlib.c:                  temp = wc->c_color; wcset_clr ( wc , dc->t_color ) ;
lowlib.c:      dc->xp+= ( dc->txt_wt*fact+dc->txt_sp ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      color = dc->t_color;
lowlib.c:      pnt = asc-32+dc->greek;
lowlib.c:      fact = dc->m_f [ pnt ] ;
lowlib.c:      xo = ( int ) ( ( dc->xp ) ) ;
lowlib.c:      yo = ( int ) ( dc->yp ) ;
lowlib.c:      ptr = dc->icpos [ pnt ] ;
lowlib.c:      xa = ( dc->cx+ ( xo ) *dc->cost+yo*dc->sint ) ;
lowlib.c:      ya = ( dc->cy- ( xo ) *dc->sint+yo*dc->cost ) ;
lowlib.c:          code = dc->icxv [ ptr ] ; n = dc->icyv [ ptr ] ;
lowlib.c:                  xdum = dc->icxv [ ptr ] ; ydum = dc->icyv [ ptr ] ; ptr++;
lowlib.c:                  xdum = ( xo+xdum*dc->txt_w42 ) ;
lowlib.c:                  ydum = ( yo+ydum*dc->txt_h42 ) ;
lowlib.c:                  x [ i ] = ( dc->cx+ ( xdum ) *dc->cost+ ( ydum ) *dc->sint ) ;
lowlib.c:                  y [ i ] = ( dc->cy+ ( ydum ) *dc->cost- ( xdum ) *dc->sint ) ;
lowlib.c:              code = dc->icxv [ ptr ] ; n = dc->icyv [ ptr ] ;
lowlib.c:                  temp = wc->c_color; wcset_clr ( wc , dc->t_color ) ;
lowlib.c:      dc->xp+= ( dc->txt_wt*fact+dc->txt_sp ) ;
lowlib.c:      pnt = asc-32+greek;
lowlib.c:      else xo -= ( 1.-fact ) *0.5*txt_wt;
lowlib.c:      pnt = asc-32+greek;
lowlib.c:      else xo -= ( 1.-fact ) *0.5*txt_wt;
lowlib.c:      ya = ( cy- ( xo ) *sint+yo*cost ) ;
lowlib.c:                  y [ i ] = ( cy+ ( ydum ) *cost- ( xdum ) *sint ) ;
lowlib.c:      pnt = asc-33+greek;
lowlib.c:      if ( pr_txt == 0 ) { xo += ( 1.-fact ) *0.5*txt_wt;
lowlib.c:                  if ( ( icxv [ j ] == icxv [ j-1 ] ) && ( icyv [ j ] == icyv [ j-1 ] ) ) {
lowlib.c:      pnt = asc-33+greek;
lowlib.c:      ya = ( int ) ( cy- ( xp ) *sint+yp*cost ) ;
lowlib.c:              ya = ( int ) ( cy+ ( tempy ) *cost- ( tempx ) *sint ) ;
lowlib.c:                  if ( ( icxv [ j ] == icxv [ j-1 ] ) && ( icyv [ j ] == icyv [ j-1 ] ) ) {
lowlib.c:                      ya = ( int ) ( cy+ ( tempy ) *cost- ( tempx ) *sint ) ;
lowlib.c:                  y = ( int ) ( cy+ ( tempy ) *cost- ( tempx ) *sint ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->txt_w42 = SSF*dc->txt_w42;
lowlib.c:      dc->txt_h42 = SSF*dc->txt_h42;
lowlib.c:      dc->txt_wt = SSF*dc->txt_wt;
lowlib.c:      dc->txt_ht = SSF*dc->txt_ht;
lowlib.c:          dc->yp = dc->yp+1.4*dc->txt_ht;
lowlib.c:      else dc->yp = dc->yp-0.7*dc->txt_ht;
lowlib.c:      pt = dc->O_L;
lowlib.c:          if ( ( pt->x2 ) < 0. ) {
lowlib.c:              if ( ( pt->ymax ) < ( dc->yp+1.4*dc->txt_ht ) ) pt->ymax = dc->yp+1.4*dc->txt_ht;
lowlib.c:              if ( ( pt->ymin ) > ( dc->yp-0.4*dc->txt_ht ) ) pt->ymin = dc->yp-0.4*dc->txt_ht;
lowlib.c:          pt = pt->Pr;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      is = *ishft- ( ( *ishft ) /10 ) *10;
lowlib.c:          *ishft = ( *ishft ) -1;
lowlib.c:          dc->yp = dc->yp-1.4*dc->txt_ht;
lowlib.c:      else dc->yp = dc->yp+0.7*dc->txt_ht;
lowlib.c:      dc->txt_w42 = dc->txt_w42/SSF;
lowlib.c:      dc->txt_h42 = dc->txt_h42/SSF;
lowlib.c:      dc->txt_wt = dc->txt_wt/SSF;
lowlib.c:      dc->txt_ht = dc->txt_ht/SSF;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      xup = -100000;
lowlib.c:      ygrt = -1239000;
lowlib.c:          j = i-1;
lowlib.c:              j--;
lowlib.c:      if ( ( scan > wc->c_v_y2 ) || ( ygrt < wc->c_v_y1 ) || \
lowlib.c:       ( xlow > wc->c_v_x2 ) || ( xup < wc->c_v_x1 ) ) return;
lowlib.c:      tempc = wc->c_color;
lowlib.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * \
lowlib.c:                       ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
lowlib.c:              j = i-1;
lowlib.c:              while ( j >= 0 && txx < xcord [ j ] ) { xcord [ j+1 ] = xcord [ j ] ; j--; }
lowlib.c:      wcset_clr ( wc , dc->ln_color ) ;
lowlib.c:      ym = y- ( short ) ( r/sqrt ( ( double ) 2. ) ) ;
lowlib.c:      for ( j = y; j >= ym; --j ) {
lowlib.c:          i = x+ ( short ) sqrt ( ( double ) sqrd- ( ( y-j ) * ( y-j ) ) ) ;
lowlib.c:          uiput_pixel ( wc , i , 2*y-j ) ;
lowlib.c:          uiput_pixel ( wc , x+y-j , y+i-x ) ;
lowlib.c:          uiput_pixel ( wc , x-y+j , y+i-x ) ;
lowlib.c:          uiput_pixel ( wc , 2*x-i , 2*y-j ) ;
lowlib.c:          uiput_pixel ( wc , 2*x-i , j ) ;
lowlib.c:          uiput_pixel ( wc , x-y+j , y-i+x ) ;
lowlib.c:          uiput_pixel ( wc , x+y-j , y-i+x ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      ym = y- ( short ) ( r/sqrt ( ( double ) 2. ) ) ;
lowlib.c:      temp = wc->c_color;
lowlib.c:      uiput_pixel ( wc , x , y+r ) , uiput_pixel ( wc , x , y-r ) ;
lowlib.c:      uiput_pixel ( wc , x+r , y ) , uiput_pixel ( wc , x-r , y ) ;
lowlib.c:      _uihori_line ( wc , x-r+1 , x+r-1 , y ) ;
lowlib.c:          t = sqrd- ( float ) ( j*j ) ;
lowlib.c:          uiput_pixel ( wc , x-i , y-j ) ;
lowlib.c:          uiput_pixel ( wc , x+i , y-j ) ;
lowlib.c:          uiput_pixel ( wc , x-i , y+j ) ;
lowlib.c:          _uihori_line ( wc , x-i+1 , x+i-1 , y-j ) ;
lowlib.c:          _uihori_line ( wc , x-i+1 , x+i-1 , y+j ) ;
lowlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
lowlib.c:      scr_back ( gcur_x-8 , gcur_y-8 , gcur_x+8 , gcur_y+8 ) ;
lowlib.c:              if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
lowlib.c:                  *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
lowlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
lowlib.c:      dc->gcur_x-= dc->jmp;
lowlib.c:      dc->gcur_x+= dc->jmp;
lowlib.c:      dc->gcur_y-= dc->jmp;
lowlib.c:      dc->gcur_y+= dc->jmp;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      temp = wc->c_color;
lowlib.c:      uiset_clr ( wc->D , c_color ) ;
lowlib.c:      _uihori_line ( wc , dc->lcur_x , dc->lcur_x+16 , EVGAY-dc->lcur_y ) ;
lowlib.c:      _uivert_line ( wc , EVGAY-dc->lcur_y , EVGAY-dc->lcur_y+16 , dc->lcur_x ) ;
lowlib.c:      uiset_clr ( wc->D , c_color ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      temp = wc->c_color;
lowlib.c:      uiset_clr ( wc->D , c_color ) ;
lowlib.c:      _uihori_line ( wc , dc->rcur_x , dc->rcur_x-16 , EVGAY-dc->rcur_y ) ;
lowlib.c:      _uivert_line ( wc , EVGAY-dc->rcur_y , EVGAY-dc->rcur_y-16 , dc->rcur_x ) ;
lowlib.c:      uiset_clr ( wc->D , c_color ) ;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      jmpy = ( float ) jmp/ ( v_x2-v_x1 ) * ( v_y2-v_y1 ) ;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) {jmp = ch-'0'; jmpy = \
lowlib.c:                   ( float ) jmp/ ( v_x2-v_x1 ) * ( v_y2-v_y1 ) ; };
lowlib.c:                  kg_scr_recover ( G->wc ) ;
lowlib.c:                  kg_scr_recover ( G->wc ) ;
lowlib.c:                  kg_scr_recover ( G->wc ) ;
lowlib.c:                  kg_scr_recover ( G->wc ) ;
lowlib.c:              kg_scr_back ( G->wc , xmin , ymin , xmax , ymin+1 ) ;
lowlib.c:              kg_scr_back ( G->wc , xmin , ymax-1 , xmax , ymax ) ;
lowlib.c:              kg_scr_back ( G->wc , xmin , ymin , xmin+1 , ymax ) ;
lowlib.c:              kg_scr_back ( G->wc , xmax-1 , ymin , xmax , ymax ) ;
lowlib.c:              _uiDraw_Bound ( G->wc , xmin , ymin , xmax , ymax ) ;
lowlib.c:          kg_scr_recover ( G->wc ) ;
lowlib.c:          kg_scr_recover ( G->wc ) ;
lowlib.c:          kg_scr_recover ( G->wc ) ;
lowlib.c:          kg_scr_recover ( G->wc ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      D = G->D;
lowlib.c:      lcur_x-= jmp;
lowlib.c:/*  lcur_y+=jmp-2;*/
lowlib.c:      yrcur -= jmpy;
lowlib.c:/*  rcur_y-=jmp-2;*/
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      D = G->D;
lowlib.c:/*  lcur_y-=jmp-2;*/
lowlib.c:      ylcur -= jmpy;
lowlib.c:      rcur_x-= jmp;
lowlib.c:/*  rcur_y+=jmp-2;*/
lowlib.c:          lcur_x-= jmp;
lowlib.c:          yrcur -= jmpy;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:              if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
lowlib.c:      lcur_y-= jmp;
lowlib.c:      rcur_y-= jmp;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      lcur_x-= jmp;
lowlib.c:      rcur_x-= jmp;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:              if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
lowlib.c:      rcur_y-= jmp;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      lcur_y-= jmp;
lowlib.c:          rcur_y-= jmp;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      lcur_x-= jmp;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      rcur_x-= jmp;
lowlib.c:          lcur_x-= jmp;
lowlib.c:      kg_scr_back ( D , lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
lowlib.c:      kg_scr_back ( D , rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      xup = -100000;
lowlib.c:      ygrt = -1239000;
lowlib.c:          j = i-1;
lowlib.c:              j--;
lowlib.c:      if ( ( scan > wc->c_v_y2 ) || ( ygrt < wc->c_v_y1 ) || \
lowlib.c:       ( xlow > wc->c_v_x2 ) || ( xup < wc->c_v_x1 ) ) return;
lowlib.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * \
lowlib.c:                       ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
lowlib.c:                      pcord [ cnt ] = ( ( ( float ) ( pmax [ i ] -pmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * \
lowlib.c:                       ( scan-ymin [ i ] ) +pmin [ i ] ) ) ;
lowlib.c:              j = i-1;
lowlib.c:                  j--;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      c_color = wc->c_color;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      if ( ( y > wc->c_v_y2 ) || ( y < wc->c_v_y1 ) ) return;
lowlib.c:      yy = EVGAY-y;
lowlib.c:      if ( p1 < 1 ) p1 = dc->Cutoff;
lowlib.c:      if ( p2 < 1 ) p2 = dc->Cutoff;
lowlib.c:      if ( p1 > dc->max_clr ) p1 = dc->max_clr;
lowlib.c:      if ( p2 > dc->max_clr ) p2 = dc->max_clr;
lowlib.c:          if ( p1 > 0 ) p1 += dc->min_clr;
lowlib.c:          tempc = wc->c_color;
lowlib.c:          if ( xa > wc->c_v_x2 ) return;
lowlib.c:          if ( xb < wc->c_v_x1 ) return;
lowlib.c:          if ( xb > wc->c_v_x2 ) return;
lowlib.c:          if ( xa < wc->c_v_x1 ) return;
lowlib.c:      if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
lowlib.c:      if ( xa < wc->c_v_x1 ) {
lowlib.c:          pval = pa+ ( wc->c_v_x1-xa ) *pfac;
lowlib.c:          xa = wc->c_v_x1;
lowlib.c:      if ( xb > wc->c_v_x2 ) {
lowlib.c:          pval = pa+ ( wc->c_v_x2-xa ) *pfac;
lowlib.c:          xb = wc->c_v_x2;
lowlib.c:          tempc = ( int ) ( pa+ ( i-xa ) *pfac+0.5 ) ;
lowlib.c:          if ( tempc < 1 ) tempc = dc->Cutoff;
lowlib.c:          if ( tempc > dc->max_clr ) tempc = dc->max_clr;
lowlib.c:          if ( tempc > 0 ) tempc += dc->min_clr;
lowlib.c:      D = ( G->D ) ;
lowlib.c:      Parent = ( G->D ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->vu_x1 = x1 , dc->vu_y1 = y1 , dc->vu_x2 = x2 , dc->vu_y2 = y2;
lowlib.c:      EVGAX = G->x2-G->x1+1;
lowlib.c:      EVGAY = abs ( G->y2-G->y1 ) +1;
lowlib.c:      dc->v_x1 = x1* ( float ) EVGAX;
lowlib.c:      dc->v_y1 = y1* ( float ) EVGAY;
lowlib.c:      dc->v_x2 = x2* ( float ) EVGAX;
lowlib.c:      dc->v_y2 = y2* ( float ) EVGAY;
lowlib.c:      if ( dc->v_y2 <= 0 ) {printf ( "dc->v_y2<=0:%d\n" , dc->v_y2 ) ;
lowlib.c:      dc->D_x = dc->v_x1+G->x1+D->xo;
lowlib.c:      dc->D_y = dc->v_y1-G->y2+D->evgay- ( D->yo ) ;
lowlib.c:      dc->V_x = dc->v_x2-dc->v_x1;
lowlib.c:      dc->V_y = dc->v_y2-dc->v_y1;
lowlib.c:      t = ( dc->V_x*dc->V_x+dc->V_y*dc->V_y ) ;
lowlib.c:      dc->u_x = ( dc->V_x/ ( dc->w_x2-dc->w_x1 ) ) ;
lowlib.c:      dc->u_y = ( dc->V_y/ ( dc->w_y2-dc->w_y1 ) ) ;
lowlib.c:      dc->v_r = sqrt ( ( double ) t ) ;
lowlib.c:      dc->lcur_x = dc->D_x;
lowlib.c:      dc->lcur_y = dc->D_y;
lowlib.c:      dc->rcur_x = dc->D_x+dc->V_x;
lowlib.c:      dc->rcur_y = dc->D_y+dc->V_y;
lowlib.c://   Dempty(wc->Clip);
lowlib.c://   wc->Clip=Dopen();
lowlib.c://   uiset_sup_clip_limits(wc,(dc->v_x1+dc->D_x),(dc->v_y1+dc->D_y),(dc->v_x2+dc->D_x),(dc->v_y2+dc->D_y));
lowlib.c://   uiset_clip_limits(wc,(dc->v_x1+dc->D_x),(dc->v_y1+dc->D_y),(dc->v_x2+dc->D_x),(dc->v_y2+dc->D_y));
lowlib.c:// uiset_sup_clip_limits(wc,(dc->v_x1+dc->D_x),D->evgay-(dc->v_y2+dc->D_y),(dc->v_x2+dc->D_x),D->evgay-(dc->v_y1+dc->D_y));
lowlib.c:// uiset_clip_limits(wc,(dc->v_x1+dc->D_x),D->evgay-(dc->v_y2+dc->D_y),(dc->v_x2+dc->D_x),D->evgay-(dc->v_y1+dc->D_y));
lowlib.c:      uiset_sup_clip_limits ( wc , ( dc->D_x ) , D->evgay- ( dc->V_y+dc->D_y ) , \
lowlib.c:       ( dc->V_x+dc->D_x ) , D->evgay- ( dc->D_y ) ) ;
lowlib.c:      uiset_clip_limits ( wc , ( dc->D_x ) , D->evgay- ( dc->V_y+dc->D_y ) , \
lowlib.c:       ( dc->V_x+dc->D_x ) , D->evgay- ( dc->D_y ) ) ;
lowlib.c://  uiset_sup_clip_limits(wc,(dc->D_x),(dc->D_y),(dc->V_x+dc->D_x),(dc->V_y+dc->D_y));
lowlib.c://  uiset_clip_limits(wc,(dc->D_x),(dc->D_y),(dc->V_x+dc->D_x),(dc->V_y+dc->D_y));
lowlib.c:      D = ( G->D ) ;
lowlib.c:      Parent = ( G->D ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->vu_x1 = x1 , dc->vu_y1 = y1 , dc->vu_x2 = x2 , dc->vu_y2 = y2;
lowlib.c:      EVGAX = G->x2-G->x1+1;
lowlib.c:      EVGAY = abs ( G->y2-G->y1 ) +1;
lowlib.c:      dc->v_x1 = x1* ( float ) EVGAX;
lowlib.c:      dc->v_y1 = y1* ( float ) EVGAY;
lowlib.c:      dc->v_x2 = x2* ( float ) EVGAX;
lowlib.c:      dc->v_y2 = y2* ( float ) EVGAY;
lowlib.c:      if ( dc->v_y2 <= 0 ) {printf ( "dc->v_y2<=0:%d\n" , dc->v_y2 ) ;
lowlib.c:      dc->D_x = G->x1+D->xo;
lowlib.c://   dc->D_y=D->yl-G->y2+D->evgay-(D->yo+D->yl);
lowlib.c:      dc->D_y = G->y2+D->yo;
lowlib.c:      dc->D_y = D->evgay - dc->D_y;
lowlib.c:      dc->V_x = dc->v_x2-dc->v_x1;
lowlib.c:      dc->V_y = dc->v_y2-dc->v_y1;
lowlib.c:      t = ( dc->V_x*dc->V_x+dc->V_y*dc->V_y ) ;
lowlib.c:      dc->u_x = ( dc->V_x/ ( dc->w_x2-dc->w_x1 ) ) ;
lowlib.c:      dc->u_y = ( dc->V_y/ ( dc->w_y2-dc->w_y1 ) ) ;
lowlib.c:      dc->v_r = sqrt ( ( double ) t ) ;
lowlib.c:      dc->lcur_x = dc->D_x;
lowlib.c:      dc->lcur_y = dc->D_y;
lowlib.c:      dc->rcur_x = dc->D_x+dc->V_x;
lowlib.c:      dc->rcur_y = dc->D_y+dc->V_y;
lowlib.c:      uiset_sup_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , ( dc->v_y1+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , ( dc->v_y2+dc->D_y ) ) ;
lowlib.c:      uiset_clip_limits ( wc , ( dc->v_x1+dc->D_x ) , ( dc->v_y1+dc->D_y ) , \
lowlib.c:       ( dc->v_x2+dc->D_x ) , ( dc->v_y2+dc->D_y ) ) ;
lowlib.c:      dc = ( kgDC * ) G->dc;
lowlib.c:      dc->w_x1 = x1;
lowlib.c:      dc->w_y1 = y1;
lowlib.c:      dc->w_x2 = x2;
lowlib.c:      dc->w_y2 = y2;
lowlib.c:      dc->u_x = ( dc->V_x/ ( x2-x1 ) ) ;
lowlib.c:      dc->u_y = ( dc->V_y/ ( y2-y1 ) ) ;
lowlib.c:      r_d = ( ( ( x2-x1 ) * ( x2-x1 ) + ( y2-y1 ) * ( y2-y1 ) ) ) ;
lowlib.c:      dc->r_d = sqrt ( ( double ) r_d ) ;
lowlib.c:      dc->txt_ht = ( dc->w_y2-dc->w_y1 ) *0.03;
lowlib.c:      dc->txt_wt = ( dc->w_x2-dc->w_x1 ) *0.03;
lowlib.c:      dc->txt_sp = ( dc->w_x2-dc->w_x1 ) *0.003;
lowlib.c:      dc->txt_htx = dc->txt_ht;
lowlib.c:      dc->txt_hty = dc->txt_ht;
lowlib.c:      dc->txt_wtx = dc->txt_wt;
lowlib.c:      dc->txt_wty = dc->txt_wt;
lowlib.c:      dc->txt_spx = dc->txt_sp;
lowlib.c:      dc->txt_spy = dc->txt_sp;
lowlib.c:      if ( ( G->D != NULL ) ) ui_vu_port ( G , dc->vu_x1 , dc->vu_y1 , dc->vu_x2 , dc->vu_y2 ) ;
lowlib.c:      if ( G->D_ON == 0 ) img_viewport ( G , dc->vu_x1 , dc->vu_y1 , dc->vu_x2 , dc->vu_y2 ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->ln_width = width;
lowlib.c:      dc = G->dc;
lowlib.c:      dc = G->dc;
lowlib.c:      uiset_clr ( G->D , dc->ln_color ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      D = G->D;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( X1 > wc->c_v_x2 ) return;
lowlib.c:      if ( X2 < wc->c_v_x1 ) return;
lowlib.c:      if ( Y1 > wc->c_v_y2 ) return;
lowlib.c:      if ( Y2 < wc->c_v_y1 ) return;
lowlib.c:      w = X2-X1+1;
lowlib.c:      h = Y2 -Y1+1;
lowlib.c:      iw = img->image_width;
lowlib.c:      ih = img->image_height;
lowlib.c:      Y0 = EVGAY-Y2+h*0.5;
lowlib.c:      if ( X2 > wc->c_v_x2 ) X2 = wc->c_v_x2;
lowlib.c:      if ( X1 < wc->c_v_x1 ) X1 = wc->c_v_x1;
lowlib.c:      if ( Y2 > wc->c_v_y2 ) Y2 = wc->c_v_y2;
lowlib.c:      if ( Y1 < wc->c_v_y1 ) Y1 = wc->c_v_y1;
lowlib.c:      temp = EVGAY-Y1;
lowlib.c:      Y1 = EVGAY -Y2;
lowlib.c:      w = X2-X1+1;
lowlib.c:      h = Y2 -Y1+1;
lowlib.c:      rzimg->xoffset = + ( X1+w/2 -X0 ) *2;
lowlib.c:      rzimg->yoffset = + ( Y1+h/2 -Y0 ) *2;
lowlib.c://  printf("Getting rzimg %d %d %d %d\n",rzimg->image_width,rzimg->image_height,rzimg->xoffset,rzimg->yoffset);
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      D = G->D;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( X1 > wc->c_v_x2 ) return;
lowlib.c:      if ( X2 < wc->c_v_x1 ) return;
lowlib.c:      if ( Y1 > wc->c_v_y2 ) return;
lowlib.c:      if ( Y2 < wc->c_v_y1 ) return;
lowlib.c:      if ( xl < wc->c_v_x1 ) xl = wc->c_v_x1;
lowlib.c:      if ( xu < wc->c_v_x1 ) xu = wc->c_v_x1;
lowlib.c:      if ( xl > wc->c_v_x2 ) xl = wc->c_v_x2;
lowlib.c:      if ( xu > wc->c_v_x2 ) xu = wc->c_v_x2;
lowlib.c:      if ( yl < wc->c_v_y1 ) yl = wc->c_v_y1;
lowlib.c:      if ( yu < wc->c_v_y1 ) yu = wc->c_v_y1;
lowlib.c:      if ( yl > wc->c_v_y2 ) yl = wc->c_v_y2;
lowlib.c:      if ( yu > wc->c_v_y2 ) yu = wc->c_v_y2;
lowlib.c:      w = xu -xl+1;
lowlib.c:      h = yu -yl+1;
lowlib.c:      lper = ( xl-X1 ) / ( float ) ( X2-X1 ) ;
lowlib.c:      rper = ( X2-xu ) / ( float ) ( X2-X1 ) ;
lowlib.c:      tper = ( yl-Y1 ) / ( float ) ( Y2-Y1 ) ;
lowlib.c:      bper = ( Y2-yu ) / ( float ) ( Y2-Y1 ) ;
lowlib.c:      iw = img->image_width;
lowlib.c:      ih = img->image_height;
lowlib.c:      rzimg = ( GMIMG * ) kgChangeSizeImage ( img , ( X2-X1 ) , ( Y2-Y1 ) ) ;
lowlib.c:      iw = img->image_width;
lowlib.c:      ih = img->image_height;
lowlib.c:          l = iw*lper+1; r = iw* ( 1-rper ) ;
lowlib.c:          b = ih*bper+1; t = ih* ( 1-tper ) ;
lowlib.c:      temp = EVGAY-yl;
lowlib.c:      Y1 = EVGAY -yu;
lowlib.c:      w = X2-X1+1;
lowlib.c:      h = Y2 -Y1+1;
lowlib.c:      kgImage ( D , img , X1 , Y1 , img->image_width , img->image_height , 0.0 , 1.0 ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->ln_style = istl;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->ln_color = color;
lowlib.c:      dc->c_color = color;
lowlib.c:      uiset_clr ( G->D , color ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->t_color = color;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      dc->txt_hty = ht;
lowlib.c:      dc->txt_wtx = wt;
lowlib.c:      dc->txt_spx = sp;
lowlib.c:      dc->txt_htx = htx;
lowlib.c:      dc->txt_wty = wty;
lowlib.c:      dc->txt_spy = spy;
lowlib.c:      dc->txt_wt = dc->sint*dc->sint*dc->txt_wty* ( dc->w_x2-dc->w_x1 ) / \
lowlib.c:       ( dc->w_y2-dc->w_y1 ) +dc->cost*dc->cost*dc->txt_wtx;
lowlib.c:      dc->txt_sp = dc->sint*dc->sint*dc->txt_spy* ( dc->w_x2-dc->w_x1 ) / \
lowlib.c:       ( dc->w_y2-dc->w_y1 ) +dc->cost*dc->cost*dc->txt_spx;
lowlib.c:      dc->txt_ht = dc->sint*dc->sint*dc->txt_htx/ ( dc->w_x2-dc->w_x1 ) * \
lowlib.c:       ( dc->w_y2-dc->w_y1 ) +dc->cost*dc->cost*dc->txt_hty;
lowlib.c:      dc->txt_ht = dc->txt_ht*dc->V_y/ ( dc->w_y2-dc->w_y1 ) ;
lowlib.c:      dc->txt_wt = dc->txt_wt*dc->V_x/ ( dc->w_x2-dc->w_x1 ) ;
lowlib.c:      dc->txt_sp = dc->txt_sp*dc->V_x/ ( dc->w_x2-dc->w_x1 ) ;
lowlib.c:      dc->v_xt1 = ( int ) ( dc->v_x1-dc->txt_wt-dc->txt_sp ) ;
lowlib.c:      dc->v_yt1 = ( int ) ( dc->v_y1-dc->txt_ht ) ;
lowlib.c:      dc->txt_w42 = dc->txt_wt/CFact;
lowlib.c:      dc->txt_h42 = dc->txt_ht/CFact;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->trot = t;
lowlib.c:      dc->theta = -t*rad;
lowlib.c:      dc->cost = cos ( dc->theta ) ;
lowlib.c:      dc->sint = sin ( dc->theta ) ;
lowlib.c:      dc->txt_wt = dc->sint*dc->sint*dc->txt_wty* ( dc->w_x2-dc->w_x1 ) / \
lowlib.c:       ( dc->w_y2-dc->w_y1 ) +dc->cost*dc->cost*dc->txt_wtx;
lowlib.c:      dc->txt_sp = dc->sint*dc->sint*dc->txt_spy* ( dc->w_x2-dc->w_x1 ) / \
lowlib.c:       ( dc->w_y2-dc->w_y1 ) +dc->cost*dc->cost*dc->txt_spx;
lowlib.c:      dc->txt_ht = dc->sint*dc->sint*dc->txt_htx/ ( dc->w_x2-dc->w_x1 ) * \
lowlib.c:       ( dc->w_y2-dc->w_y1 ) +dc->cost*dc->cost*dc->txt_hty;
lowlib.c:      dc->txt_ht = dc->txt_ht*dc->V_y/ ( dc->w_y2-dc->w_y1 ) ;
lowlib.c:      dc->txt_wt = dc->txt_wt*dc->V_x/ ( dc->w_x2-dc->w_x1 ) ;
lowlib.c:      dc->txt_sp = dc->txt_sp*dc->V_x/ ( dc->w_x2-dc->w_x1 ) ;
lowlib.c:      dc->v_xt1 = ( int ) ( dc->v_x1-dc->txt_wt-dc->txt_sp ) ;
lowlib.c:      dc->v_yt1 = ( int ) ( dc->v_y1-dc->txt_ht ) ;
lowlib.c:      dc->txt_w42 = dc->txt_wt/CFact;
lowlib.c:      dc->txt_h42 = dc->txt_ht/CFact;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      dc->O_L = NULL;
lowlib.c:      bold = dc->txt_bold;
lowlib.c:      font_o = dc->t_font;
lowlib.c:      dc->trot = ( dc->cost < 0.99 ) ;
lowlib.c:      tempc = wc->c_color;
lowlib.c:      wcset_clr ( wc , dc->t_color ) ;
lowlib.c:      dc->cx = ( int ) ( dc->cur_x+0.5 ) ;
lowlib.c:      dc->cy = ( int ) ( dc->cur_y+0.5 ) ;
lowlib.c:      dc->xp = 0.0;
lowlib.c:      dc->yp = 0.0;
lowlib.c:      dc->greek = 0;
lowlib.c:      lnwidth_o = dc->ln_width;
lowlib.c:      dc->ln_width = 1;
lowlib.c:              if ( txt [ i ] != '!' ) { if ( dc->trot ) uidrawgch ( G , txt [ i ] ) ;
lowlib.c:                  dc->greek = 0;
lowlib.c:                          dc->greek = 0;
lowlib.c:                          if ( dc->trot ) uidrawgch ( G , txt [ i ] ) ;
lowlib.c:                          dc->xp = dc->xp -dc->txt_wt -dc->txt_sp;
lowlib.c:                          dc->txt_bold = 2;
lowlib.c:                          dc->Slant = Slnt [ 1 ] ;
lowlib.c:                          dc->Slant = Slant_o; dc->txt_bold = txt_bold_o;
lowlib.c:                              while ( ( pt->x2 ) >= 0. ) pt = pt->Pr;
lowlib.c:                               ( pt->x2 ) = dc->xp-dc->txt_sp;
lowlib.c:                              pt = pt->Pr;
lowlib.c:                          dc->greek = 128;
lowlib.c:                          if ( dc->O_P != NULL ) {
lowlib.c:                              dc->xp = dc->O_P->x;
lowlib.c:                              dc->yp = dc->O_P->y;
lowlib.c:                              dc->D_P = dc->O_P;
lowlib.c:                              dc->O_P = dc->O_P->Pr;
lowlib.c:                              free ( dc->D_P ) ;
lowlib.c:                              if ( dc->O_P == NULL ) FB_P = NULL;
lowlib.c:                              dc->O_P = FB_P;
lowlib.c:                              dc->O_P->Nx = NULL; dc->O_P->Pr = NULL;
lowlib.c:                              dc->O_P->Nx = ( B_K * ) Malloc ( ( int ) sizeof ( B_K ) ) ;
lowlib.c:                              dc->O_P->Nx->Pr = dc->O_P;
lowlib.c:                              dc->O_P = dc->O_P->Nx;
lowlib.c:                              dc->O_P->Nx = NULL;
lowlib.c:                           ( dc->O_P->x ) = dc->xp;
lowlib.c:                           ( dc->O_P->y ) = dc->yp;
lowlib.c:                          dc->yp += 0.2*dc->txt_ht;
lowlib.c:                          dc->yp -= 0.2*dc->txt_ht;
lowlib.c:                          dc->yp += 0.9*dc->txt_ht;
lowlib.c:                          dc->yp -= 0.9*dc->txt_ht;
lowlib.c:                              dc->O_L = FO_L;
lowlib.c:                              dc->O_L->Nx = NULL; dc->O_L->Pr = NULL;
lowlib.c:                              dc->O_L->Nx = ( L_N * ) Malloc ( ( int ) sizeof ( L_N ) ) ;
lowlib.c:                              dc->O_L->Nx->Pr = dc->O_L;
lowlib.c:                              dc->O_L = dc->O_L->Nx;
lowlib.c:                              dc->O_L->Nx = NULL;
lowlib.c:                           ( dc->O_L->x1 ) = dc->xp;
lowlib.c:                           ( dc->O_L->x2 ) = -1.0;
lowlib.c:                          dc->O_L->ymax = dc->yp+1.4*dc->txt_ht;
lowlib.c:                          dc->O_L->ymin = dc->yp-0.4*dc->txt_ht;
lowlib.c:                          dc->O_L->p = cntl;
lowlib.c:                          pt = dc->O_L;
lowlib.c:                          dc->xp = ( gap+1 ) * ( dc->txt_wt+dc->txt_sp ) ;
lowlib.c:                          Nu = ( txt [ i+1 ] -'0' ) ;
lowlib.c:                          De = ( txt [ i+2 ] -'0' ) ;
lowlib.c:                          dc->txt_w42 = dc->txt_w42*val;
lowlib.c:                          dc->txt_h42 = dc->txt_h42*val;
lowlib.c:                          dc->txt_wt = dc->txt_wt*val;
lowlib.c:                          dc->txt_ht = dc->txt_ht*val;
lowlib.c:                          Nu = ( txt [ i+1 ] -'0' ) *10+ ( txt [ i+2 ] -'0' ) ;
lowlib.c:                          Nu = ( txt [ i+1 ] -'0' ) *10+ ( txt [ i+2 ] -'0' ) ;
lowlib.c:                          Nu = ( txt [ i+1 ] -'0' ) ;
lowlib.c:                          De = ( txt [ i+2 ] -'0' ) ;
lowlib.c:                          dc->txt_h42 = dc->txt_h42*val;
lowlib.c:                          dc->txt_ht = dc->txt_ht*val;
lowlib.c:                          Nu = ( txt [ i+1 ] -'0' ) ;
lowlib.c:                          De = ( txt [ i+2 ] -'0' ) ;
lowlib.c:                          dc->txt_w42 = dc->txt_w42*val;
lowlib.c:                          dc->txt_wt = dc->txt_wt*val;
lowlib.c:      dc->txt_w42 = dc->txt_w42/fact;
lowlib.c:      dc->txt_h42 = dc->txt_h42/hfact;
lowlib.c:      dc->txt_wt = dc->txt_wt/fact;
lowlib.c:      dc->txt_ht = dc->txt_ht/hfact;
lowlib.c:      dc->ln_width = 2;
lowlib.c:          if ( pt->x2 < 0. ) pt->x2 = dc->xp;
lowlib.c:          if ( pt->p == 'U' ) {
lowlib.c:              _uimove ( G , uiTX ( ( pt->x1 ) , pt->ymin ) , uiTY \
lowlib.c:               ( ( pt->x1 ) , pt->ymin ) ) ;
lowlib.c:              _uidraw ( G , uiTX ( ( pt->x2 ) , pt->ymin ) , uiTY \
lowlib.c:               ( ( pt->x2 ) , pt->ymin ) ) ;
lowlib.c:              _uimove ( G , uiTX ( ( pt->x1 ) , pt->ymax ) , uiTY \
lowlib.c:               ( ( pt->x1 ) , pt->ymax ) ) ;
lowlib.c:              _uidraw ( G , uiTX ( ( pt->x2 ) , pt->ymax ) , uiTY \
lowlib.c:               ( ( pt->x2 ) , pt->ymax ) ) ;
lowlib.c:          dc->O_L = pt;
lowlib.c:          pt = pt->Nx;
lowlib.c:          free ( dc->O_L ) ;
lowlib.c:      dc->O_P = FB_P;
lowlib.c:      while ( dc->O_P != NULL ) {
lowlib.c:          dc->D_P = dc->O_P;
lowlib.c:          dc->O_P = dc->O_P->Pr;
lowlib.c:          free ( dc->D_P ) ;
lowlib.c:      dc->ln_width = lnwidth_o;
lowlib.c:      if ( dc->t_font != font_o ) ui_txt_font ( G , font_o ) ;
lowlib.c:      D = G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          uiCleangmImage ( G->img ) ;
lowlib.c:          ui_vu_port ( G , dc->vu_x1 , dc->vu_y1 , dc->vu_x2 , dc->vu_y2 ) ;
lowlib.c:          _uibox_fill ( G->wc , dc->D_x+dc->v_x1 , dc->D_y+dc->v_y1 , dc->v_x2+dc->D_x , dc->v_y2+dc->D_y , 0 ) ;
lowlib.c:          img_viewport ( G , dc->vu_x1 , dc->vu_y1 , dc->vu_x2 , dc->vu_y2 ) ;
lowlib.c:      else _uibox_fill ( G->wc , dc->D_x+dc->v_x1 , dc->D_y+dc->v_y1 , dc->v_x2+dc->D_x , dc->v_y2+dc->D_y , 0 ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->pmax = p2;
lowlib.c:      dc->pmin = p1;
lowlib.c:      dc->min_clr = sclr;
lowlib.c:      dc->max_clr = n;
lowlib.c:      dc->ibdr = ib;
lowlib.c:      dc->dfac = ( n -1 ) / ( dc->pmax-dc->pmin ) ;
lowlib.c://  printf("%f %f %f\n",dc->pmax,dc->pmin,dc->dfac);
lowlib.c:      int xmin = 10000000 , xmax = -10000000 , ymin = 10000000 , ymax = -10000000;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      if ( ( xmax < dc->v_x1 ) || ( xmin > dc->v_x2 ) || ( ymax < dc->v_y1 ) \
lowlib.c:       || ( ymin > dc->v_y2 ) ) return;
lowlib.c:      _uigodard_fill ( G , n , x1 , y1 , dc->ibdr , p1 ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      wcset_clr ( wc , dc->ln_color ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->m_style = istl;
lowlib.c:      i = ln-1;
lowlib.c:      * ( ptr+i ) = '\0'; i--;
lowlib.c:      while ( ( i >= 0 ) && ( * ( ptr+i ) <= ' ' ) ) {* ( ptr+i ) = '\0'; i--; }
lowlib.c:  pnt=asc-32;
lowlib.c:          xdum=(icxvF[ptr]-1500.)*fact+1500;
lowlib.c:          pt->icpos = icposf0;
lowlib.c:          pt->m_f = m_f0;
lowlib.c:          pt->icxv = icxvf0;
lowlib.c:          pt->icyv = icyvf0;
lowlib.c:          pt->fontname = fontname0;
lowlib.c:          pt->icpos = icposf1; pt->m_f = m_f1; pt->icxv = icxvf1;
lowlib.c:          pt->icyv = icyvf1; pt->fontname = fontname1;
lowlib.c:          pt->icpos = icposf2; pt->m_f = m_f2; pt->icxv = icxvf2;
lowlib.c:          pt->icyv = icyvf2; pt->fontname = fontname2;
lowlib.c:          pt->icpos = icposf3; pt->m_f = m_f3; pt->icxv = icxvf3;
lowlib.c:          pt->icyv = icyvf3; pt->fontname = fontname3;
lowlib.c:          pt->icpos = icposf4; pt->m_f = m_f4; pt->icxv = icxvf4;
lowlib.c:          pt->icyv = icyvf4; pt->fontname = fontname4;
lowlib.c:          pt->icpos = icposf5; pt->m_f = m_f5; pt->icxv = icxvf5;
lowlib.c:          pt->icyv = icyvf5; pt->fontname = fontname5;
lowlib.c:          pt->icpos = icposf6; pt->m_f = m_f6; pt->icxv = icxvf6;
lowlib.c:          pt->icyv = icyvf6; pt->fontname = fontname6;
lowlib.c:          pt->icpos = icposf7; pt->m_f = m_f7; pt->icxv = icxvf7;
lowlib.c:          pt->icyv = icyvf7; pt->fontname = fontname7;
lowlib.c:          pt->icpos = icposf8; pt->m_f = m_f8; pt->icxv = icxvf8;
lowlib.c:          pt->icyv = icyvf8; pt->fontname = fontname8;
lowlib.c:          pt->icpos = icposf9; pt->m_f = m_f9; pt->icxv = icxvf9;
lowlib.c:          pt->icyv = icyvf9; pt->fontname = fontname9;
lowlib.c:          pt->icpos = icposf10; pt->m_f = m_f10; pt->icxv = icxvf10;
lowlib.c:          pt->icyv = icyvf10; pt->fontname = fontname10;
lowlib.c:          pt->icpos = icposf11; pt->m_f = m_f11; pt->icxv = icxvf11;
lowlib.c:          pt->icyv = icyvf11; pt->fontname = fontname11;
lowlib.c:          pt->icpos = icposf12; pt->m_f = m_f12; pt->icxv = icxvf12;
lowlib.c:          pt->icyv = icyvf12; pt->fontname = fontname12;
lowlib.c:          pt->icpos = icposf13; pt->m_f = m_f13; pt->icxv = icxvf13;
lowlib.c:          pt->icyv = icyvf13; pt->fontname = fontname13;
lowlib.c:          pt->icpos = icposf14; pt->m_f = m_f14; pt->icxv = icxvf14;
lowlib.c:          pt->icyv = icyvf14; pt->fontname = fontname14;
lowlib.c:          pt->icpos = icposf15; pt->m_f = m_f15; pt->icxv = icxvf15;
lowlib.c:          pt->icyv = icyvf15; pt->fontname = fontname15;
lowlib.c:          pt->icpos = icposf16; pt->m_f = m_f16; pt->icxv = icxvf16;
lowlib.c:          pt->icyv = icyvf16; pt->fontname = fontname16;
lowlib.c:          pt->icpos = icposf17; pt->m_f = m_f17; pt->icxv = icxvf17;
lowlib.c:          pt->icyv = icyvf17; pt->fontname = fontname17;
lowlib.c:          pt->icpos = icposf18; pt->m_f = m_f18; pt->icxv = icxvf18;
lowlib.c:          pt->icyv = icyvf18; pt->fontname = fontname18;
lowlib.c:          pt->icpos = icposf19; pt->m_f = m_f19; pt->icxv = icxvf19;
lowlib.c:          pt->icyv = icyvf19; pt->fontname = fontname19;
lowlib.c:          pt->icpos = icposf20; pt->m_f = m_f20; pt->icxv = icxvf20;
lowlib.c:          pt->icyv = icyvf20; pt->fontname = fontname20;
lowlib.c:          pt->icpos = icposf21; pt->m_f = m_f21; pt->icxv = icxvf21;
lowlib.c:          pt->icyv = icyvf21; pt->fontname = fontname21;
lowlib.c:          pt->icpos = icposf22; pt->m_f = m_f22; pt->icxv = icxvf22;
lowlib.c:          pt->icyv = icyvf22; pt->fontname = fontname22;
lowlib.c:          pt->icpos = icposf23; pt->m_f = m_f23; pt->icxv = icxvf23;
lowlib.c:          pt->icyv = icyvf23; pt->fontname = fontname23;
lowlib.c:          pt->icpos = icposf24; pt->m_f = m_f24; pt->icxv = icxvf24;
lowlib.c:          pt->icyv = icyvf24; pt->fontname = fontname24;
lowlib.c:          pt->icpos = icposf25; pt->m_f = m_f25; pt->icxv = icxvf25;
lowlib.c:          pt->icyv = icyvf25; pt->fontname = fontname25;
lowlib.c:          pt->icpos = icposf26; pt->m_f = m_f26; pt->icxv = icxvf26;
lowlib.c:          pt->icyv = icyvf26; pt->fontname = fontname26;
lowlib.c:          pt->icpos = icposf27; pt->m_f = m_f27; pt->icxv = icxvf27;
lowlib.c:          pt->icyv = icyvf27; pt->fontname = fontname27;
lowlib.c:          pt->icpos = icposf28; pt->m_f = m_f28; pt->icxv = icxvf28;
lowlib.c:          pt->icyv = icyvf28; pt->fontname = fontname28;
lowlib.c:          pt->icpos = icposf29; pt->m_f = m_f29; pt->icxv = icxvf29;
lowlib.c:          pt->icyv = icyvf29; pt->fontname = fontname29;
lowlib.c:          pt->icpos = icposf30; pt->m_f = m_f30; pt->icxv = icxvf30;
lowlib.c:          pt->icyv = icyvf30; pt->fontname = fontname30;
lowlib.c:          pt->icpos = icposf31; pt->m_f = m_f31; pt->icxv = icxvf31;
lowlib.c:          pt->icyv = icyvf31; pt->fontname = fontname31;
lowlib.c:          pt->icpos = icposf32; pt->m_f = m_f32; pt->icxv = icxvf32;
lowlib.c:          pt->icyv = icyvf32; pt->fontname = fontname32;
lowlib.c:          pt->icpos = icposf33; pt->m_f = m_f33; pt->icxv = icxvf33;
lowlib.c:          pt->icyv = icyvf33; pt->fontname = fontname33;
lowlib.c:          pt->icpos = icposf34; pt->m_f = m_f34; pt->icxv = icxvf34;
lowlib.c:          pt->icyv = icyvf34; pt->fontname = fontname34;
lowlib.c:          pt->icpos = icposf35; pt->m_f = m_f35; pt->icxv = icxvf35;
lowlib.c:          pt->icyv = icyvf35; pt->fontname = fontname35;
lowlib.c:          pt->icpos = icposf36; pt->m_f = m_f36; pt->icxv = icxvf36;
lowlib.c:          pt->icyv = icyvf36; pt->fontname = fontname36;
lowlib.c:  pt->icpos = icposf37; pt->m_f = m_f37; pt->icxv = icxvf37;
lowlib.c:  pt->icyv = icyvf37; pt->fontname = fontname37;
lowlib.c:  pt->icpos = icposf38; pt->m_f = m_f38; pt->icxv = icxvf38;
lowlib.c:  pt->icyv = icyvf38; pt->fontname = fontname38;
lowlib.c:  pt->icpos = icposf39; pt->m_f = m_f39; pt->icxv = icxvf39;
lowlib.c:  pt->icyv = icyvf39; pt->fontname = fontname39;
lowlib.c:  pt->icpos = icposf40; pt->m_f = m_f40; pt->icxv = icxvf40;
lowlib.c:  pt->icyv = icyvf40; pt->fontname = fontname40;
lowlib.c:  pt->icpos = icposf41; pt->m_f = m_f41; pt->icxv = icxvf41;
lowlib.c:  pt->icyv = icyvf41; pt->fontname = fontname41;
lowlib.c:  pt->icpos = icposf42; pt->m_f = m_f42; pt->icxv = icxvf42;
lowlib.c:  pt->icyv = icyvf42; pt->fontname = fontname42;
lowlib.c:  pt->icpos = icposf43; pt->m_f = m_f43; pt->icxv = icxvf43;
lowlib.c:  pt->icyv = icyvf43; pt->fontname = fontname43;
lowlib.c:  pt->icpos = icposf44; pt->m_f = m_f44; pt->icxv = icxvf44;
lowlib.c:  pt->icyv = icyvf44; pt->fontname = fontname44;
lowlib.c:  pt->icpos = icposf45; pt->m_f = m_f45; pt->icxv = icxvf45;
lowlib.c:  pt->icyv = icyvf45; pt->fontname = fontname45;
lowlib.c:  pt->icpos = icposf46; pt->m_f = m_f46; pt->icxv = icxvf46;
lowlib.c:  pt->icyv = icyvf46; pt->fontname = fontname46;
lowlib.c:  pt->icpos = icposf47; pt->m_f = m_f47; pt->icxv = icxvf47;
lowlib.c:  pt->icyv = icyvf47; pt->fontname = fontname47;
lowlib.c:  pt->icpos = icposf48; pt->m_f = m_f48; pt->icxv = icxvf48;
lowlib.c:  pt->icyv = icyvf48; pt->fontname = fontname48;
lowlib.c:  pt->icpos = icposf49; pt->m_f = m_f49; pt->icxv = icxvf49;
lowlib.c:  pt->icyv = icyvf49; pt->fontname = fontname49;
lowlib.c:  pt->icpos = icposf50; pt->m_f = m_f50; pt->icxv = icxvf50;
lowlib.c:  pt->icyv = icyvf50; pt->fontname = fontname50;
lowlib.c:  pt->icpos = icposf51; pt->m_f = m_f51; pt->icxv = icxvf51;
lowlib.c:  pt->icyv = icyvf51; pt->fontname = fontname51;
lowlib.c:  pt->icpos = icposf52; pt->m_f = m_f52; pt->icxv = icxvf52;
lowlib.c:  pt->icyv = icyvf52; pt->fontname = fontname52;
lowlib.c:          fnames [ i ] = ( char * ) Malloc ( strlen ( pt->fontname ) +20 ) ;
lowlib.c:          sprintf ( fnames [ i ] , "!f18%2.2d !f%-2.2d %-s" , i , i , pt->fontname ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      if ( dc->Fontlist == NULL ) dc->Fontlist = Loadfontstruct ( ) ;
lowlib.c:      count = Dcount ( dc->Fontlist ) ;
lowlib.c:      Dposition ( dc->Fontlist , font+1 ) ;
lowlib.c:      pt = ( FONT * ) Getrecord ( dc->Fontlist ) ;
lowlib.c:      dc->icpos = pt->icpos;
lowlib.c:      dc->icxv = pt->icxv;
lowlib.c:      dc->icyv = pt->icyv;
lowlib.c:      dc->m_f = pt->m_f;
lowlib.c:      dc->t_font = font;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      rd -= xa;
lowlib.c:      dc = G->dc;
lowlib.c:      dc->O_L = NULL;
lowlib.c:      dc->greek = 0;
lowlib.c:      font_o = dc->t_font;
lowlib.c:      wd = dc->txt_wtx;
lowlib.c:      gp = dc->txt_spx;
lowlib.c:      fj = 0.0; gj = -1; fact = 1.0;
lowlib.c:              if ( dc->pr_txt > 0 ) fact1 = dc->m_f [ title [ i ] -32+dc->greek ] *fact;
lowlib.c:              fj += fact1; dc->greek = 0;
lowlib.c:                  fj = fj-fact1; fjl-= 1.; gj = gj-1;
lowlib.c:                  dc->greek = 128;
lowlib.c:                  if ( dc->O_P != NULL ) {
lowlib.c:                      fj = dc->O_P->x;
lowlib.c:                      fjl = dc->O_P->xl;
lowlib.c:                      gj = dc->O_P->y;
lowlib.c:                      dc->D_P = dc->O_P;
lowlib.c:                      dc->O_P = dc->O_P->Pr;
lowlib.c:                      free ( dc->D_P ) ;
lowlib.c:                      if ( dc->O_P == NULL ) FB_P = NULL;
lowlib.c:                      dc->O_P = FB_P;
lowlib.c:                      dc->O_P->Nx = NULL; dc->O_P->Pr = NULL;
lowlib.c:                      dc->O_P->Nx = ( B_K * ) Malloc ( ( int ) sizeof ( B_K ) ) ;
lowlib.c:                      dc->O_P->Nx->Pr = dc->O_P;
lowlib.c:                      dc->O_P = dc->O_P->Nx;
lowlib.c:                      dc->O_P->Nx = NULL;
lowlib.c:                   ( dc->O_P->x ) = fj;
lowlib.c:                   ( dc->O_P->xl ) = fjl;
lowlib.c:                   ( dc->O_P->y ) = gj;
lowlib.c:                  Nu = ( title [ i+1 ] -'0' ) ;
lowlib.c:                  Nu = Nu*10+ ( title [ i+2 ] -'0' ) ;
lowlib.c:                  Nu = ( title [ i+1 ] -'0' ) ;
lowlib.c:                  De = ( title [ i+2 ] -'0' ) ;
lowlib.c:                  Nu = ( title [ i+1 ] -'0' ) ;
lowlib.c:                  De = ( title [ i+2 ] -'0' ) ;
lowlib.c:                  Nu = ( title [ i+1 ] -'0' ) ;
lowlib.c:                  De = ( title [ i+2 ] -'0' ) ;
lowlib.c:      dc->O_P = FB_P;
lowlib.c:      while ( dc->O_P != NULL ) {
lowlib.c:          dc->D_P = dc->O_P;
lowlib.c:          dc->O_P = dc->O_P->Pr;
lowlib.c:          free ( dc->D_P ) ;
lowlib.c:      if ( dc->t_font != font_o ) ui_txt_font ( G , ( int ) font_o ) ;
lowlib.c:      font_o = dc->t_font;
lowlib.c:      wd = dc->txt_wtx;
lowlib.c:      gp = dc->txt_spx;
lowlib.c:      fj = 0.0; gj = -1; fact = 1.0;
lowlib.c:              if ( dc->pr_txt > 0 ) fact1 = dc->m_f [ title [ i ] -32+greek ] *fact;
lowlib.c:                  fj = fj-fact1; fjl-= 1.; gj = gj-1;
lowlib.c:                  if ( dc->O_P != NULL ) {
lowlib.c:                      fj = dc->O_P->x;
lowlib.c:                      fjl = dc->O_P->xl;
lowlib.c:                      gj = dc->O_P->y;
lowlib.c:                      dc->D_P = dc->O_P;
lowlib.c:                      dc->O_P = dc->O_P->Pr;
lowlib.c:                      free ( dc->D_P ) ;
lowlib.c:                      if ( dc->O_P == NULL ) FB_P = NULL;
lowlib.c:                      dc->O_P = FB_P;
lowlib.c:                      dc->O_P->Nx = NULL; dc->O_P->Pr = NULL;
lowlib.c:                      dc->O_P->Nx = ( B_K * ) Malloc ( ( int ) sizeof ( B_K ) ) ;
lowlib.c:                      dc->O_P->Nx->Pr = dc->O_P;
lowlib.c:                      dc->O_P = dc->O_P->Nx;
lowlib.c:                      dc->O_P->Nx = NULL;
lowlib.c:                   ( dc->O_P->x ) = fj;
lowlib.c:                   ( dc->O_P->xl ) = fjl;
lowlib.c:                   ( dc->O_P->y ) = gj;
lowlib.c:                  val = title [ i+1 ] -'0';
lowlib.c:                  val = val*10+ ( title [ i+2 ] -'0' ) ;
lowlib.c:                         /*gj = gj-2;*/
lowlib.c:                  val = title [ i+2 ] -'0';
lowlib.c:                  val = ( float ) ( title [ i+1 ] -'0' ) /val;
lowlib.c:                         /*gj = gj-2;*/
lowlib.c:                  val = title [ i+2 ] -'0';
lowlib.c:                  val = ( float ) ( title [ i+1 ] -'0' ) /val;
lowlib.c:                         /*gj = gj-2;*/
lowlib.c:                  val = title [ i+2 ] -'0';
lowlib.c:                  val = ( float ) ( title [ i+1 ] -'0' ) /val;
lowlib.c:                         /*gj = gj-2;*/
lowlib.c:      dc->O_P = FB_P;
lowlib.c:      while ( dc->O_P != NULL ) {
lowlib.c:          dc->D_P = dc->O_P;
lowlib.c:          dc->O_P = dc->O_P->Pr;
lowlib.c:          free ( dc->D_P ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( ix2 < wc->c_v_x1 ) {wc->c_v_x1 = 1 , wc->c_v_x2 = 0 , wc->c_v_y1 = 1 , wc->c_v_y2 = 0;
lowlib.c:      if ( ix1 > wc->c_v_x2 ) {wc->c_v_x1 = 1 , wc->c_v_x2 = 0 , wc->c_v_y1 = 1 , wc->c_v_y2 = 0;
lowlib.c:      if ( iy2 < wc->c_v_y1 ) {wc->c_v_x1 = 1 , wc->c_v_x2 = 0 , wc->c_v_y1 = 1 , wc->c_v_y2 = 0;
lowlib.c:      if ( iy1 > wc->c_v_y2 ) {wc->c_v_x1 = 1 , wc->c_v_x2 = 0 , wc->c_v_y1 = 1 , wc->c_v_y2 = 0;
lowlib.c:      if ( ix1 >= wc->c_v_x1 ) wc->c_v_x1 = ix1;
lowlib.c:      if ( ix2 <= wc->c_v_x2 ) wc->c_v_x2 = ix2;
lowlib.c:      if ( iy1 >= wc->c_v_y1 ) wc->c_v_y1 = iy1;
lowlib.c:      if ( iy2 <= wc->c_v_y2 ) wc->c_v_y2 = iy2;
lowlib.c:      wc = G->wc;
lowlib.c:      Dempty ( wc->Clip ) ;
lowlib.c:      wc->Clip = Dopen ( ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      if ( wc->entry == 0 ) {x2 = -100; y2 = -100; }
lowlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
lowlib.c:          if ( wc->entry ) {
lowlib.c:          wc->entry = 1;
lowlib.c:          kg_scr_back ( wc , xmin , ymax-1 , xmax , ymax ) ;
lowlib.c:          kg_scr_back ( wc , xmax-1 , ymin , xmax , ymax ) ;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      x2 = dc->x2 , y2 = dc->y2;
lowlib.c:      if ( dc->entry == 0 ) {x2 = -100; y2 = -100; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:      dc->entry = 1;
lowlib.c:      kg_scr_back ( wc , xmin , ymax-1 , xmax , ymax ) ;
lowlib.c:      kg_scr_back ( wc , xmax-1 , ymin , xmax , ymax ) ;
lowlib.c:      dc->x2 = x2 , dc->y2 = y2;
lowlib.c:      uiUpdateOn ( wc->D ) ;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      x2 = dc->x2;
lowlib.c:      y2 = dc->y2;
lowlib.c:      if ( dc->entry == 0 ) {x2 = -100; y2 = -100; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:      dc->entry = 1;
lowlib.c:      ymin = y1; ymax = y1-y0;
lowlib.c:      kg_scr_back ( wc , xmin , ymax-1 , xmax , ymax ) ;
lowlib.c:      kg_scr_back ( wc , xmax-1 , ymin , xmax , ymax ) ;
lowlib.c:      uiUpdateOn ( wc->D ) ;
lowlib.c:      dc->x2 = x2 , dc->y2 = y2;
lowlib.c:      if ( D->entry == 0 ) {x2 = -100; y2 = -100; }
lowlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
lowlib.c:          if ( D->entry ) {
lowlib.c:          D->entry = 1;
lowlib.c:          ymin = y1; ymax = y1-y0;
lowlib.c:          kg_scr_back ( D , xmin , ymax-1 , xmax , ymax ) ;
lowlib.c:          kg_scr_back ( D , xmax-1 , ymin , xmax , ymax ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      sprintf ( nbuf , "Angle = %6.2f" , dc->gcur_t ) ;
lowlib.c:      uimsg_menu ( G , dc->msg_x , dc->msg_y , 34L , nbuf ) ;
lowlib.c:      uiUpdateOn ( G->D ) ;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      t = atan2 ( ( double ) ( *y1-yorg ) , ( double ) ( *x1-xorg ) ) ;
lowlib.c:      *x1 = xorg+dc->gcur_r*cos ( t ) ;
lowlib.c:      *y1 = yorg+dc->gcur_r*sin ( t ) ;
lowlib.c:/*  if((*x1<0)||(*x1>EVGAX)||(*y1<0)||(*y1>EVGAY)) return -1;*/
lowlib.c:      dc->gcur_t = 180*t/3.14159265;
lowlib.c:      if ( dc->gcur_t < 0. ) dc->gcur_t = 360+dc->gcur_t;
lowlib.c:      dc->gcur_t = 360-dc->gcur_t;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      x = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      y = uiusr_y ( EVGAY-dc->gcur_y ) ;
lowlib.c:      dist = sqrt ( ( double ) ( xo-x ) * ( xo-x ) + ( yo-y ) * ( yo-y ) ) ;
lowlib.c:      t = atan2 ( ( double ) ( y-yo ) , ( double ) ( x-xo ) ) ;
lowlib.c:      uimsg_menu ( G , dc->msg_x , dc->msg_y , 34L , nbuf ) ;
lowlib.c:      if ( wc->Clip == NULL ) wc->Clip = Dopen ( ) ;
lowlib.c:      tmp->cx1 = wc->c_v_x1;
lowlib.c:      tmp->cy1 = wc->c_v_y1;
lowlib.c:      tmp->cy2 = wc->c_v_y2;
lowlib.c:      tmp->cx2 = wc->c_v_x2;
lowlib.c:      Dappend ( wc->Clip , tmp ) ;
lowlib.c:      EVGAY = wc->EVGAY ;
lowlib.c:      if ( wc->Clip == NULL ) {
lowlib.c:      if ( wc->Clip->st == NULL ) {
lowlib.c:      Dend ( wc->Clip ) ;
lowlib.c:      tmp = ( CLIP * ) Getrecordrev ( wc->Clip ) ;
lowlib.c:      wc->c_v_x1 = tmp->cx1 ;
lowlib.c:      wc->c_v_y1 = tmp->cy1 ;
lowlib.c:      wc->c_v_y2 = tmp->cy2 ;
lowlib.c:      wc->c_v_x2 = tmp->cx2 ;
lowlib.c:      Dend ( wc->Clip ) ;
lowlib.c:      Ddelete ( wc->Clip ) ;
lowlib.c://  printf("Restore:%d\n",Dcount(wc->Clip));
lowlib.c:              _Box_Fill ( x_min , EVGAY-y_max , x_max1 , EVGAY-y_min ) ;
lowlib.c:      D = wc->D;
lowlib.c:      temp = wc->c_color;
lowlib.c:      if ( ( x_min <= wc->c_v_x2 ) && ( x_max1 >= wc->c_v_x1 ) ) {
lowlib.c:          if ( ( y_min <= wc->c_v_y2 ) && ( y_max >= wc->c_v_y1 ) ) {
lowlib.c:              if ( x_max1 > wc->c_v_x2 ) x_max1 = wc->c_v_x2;
lowlib.c:              if ( x_min < wc->c_v_x1 ) x_min = wc->c_v_x1;
lowlib.c:              if ( y_max > wc->c_v_y2 ) y_max = wc->c_v_y2;
lowlib.c:              if ( y_min < wc->c_v_y1 ) y_min = wc->c_v_y1;
lowlib.c:              _uiBox_Fill ( wc , x_min , D->evgay-y_max , x_max1 , D->evgay-y_min ) ;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( dc->DOUBLE == 1 ) {
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      dc->lcur_x = dc->v_x1;
lowlib.c:      dc->lcur_y = EVGAY-dc->v_y1;
lowlib.c:      dc->rcur_x = dc->v_x2;
lowlib.c:      dc->rcur_y = EVGAY-dc->v_y2;
lowlib.c:      dc->gw_x1 = uiusr_x ( dc->lcur_x ) ;
lowlib.c:      dc->gw_x2 = uiusr_x ( dc->rcur_x ) ;
lowlib.c:      dc->gw_y1 = uiusr_y ( ( EVGAY-dc->lcur_y ) ) ;
lowlib.c:      dc->gw_y2 = uiusr_y ( ( EVGAY-dc->rcur_y ) ) ;
lowlib.c:      X0 = dc->gw_x1;
lowlib.c:      Y0 = dc->gw_y1;
lowlib.c:      if ( X0 < X1 ) {dc->gw_x1 = X0; dc->gw_x2 = X1; }
lowlib.c:      else {dc->gw_x1 = X1; dc->gw_x2 = X0; }
lowlib.c:      if ( Y0 < Y1 ) {dc->gw_y1 = Y0; dc->gw_y2 = Y1; }
lowlib.c:      else {dc->gw_y1 = Y1; dc->gw_y2 = Y0; }
lowlib.c:      if ( dc->SET3D == 1 ) {
lowlib.c:          if ( dc->DBL_BUF == 1 ) {
lowlib.c://         ui_window(G,dc->gw_x1,dc->gw_y1,dc->gw_x2,dc->gw_y2);
lowlib.c:          kgUserFrame ( G , dc->gw_x1 , dc->gw_y1 , dc->gw_x2 , dc->gw_y2 ) ;
lowlib.c:          if ( dc->SET3D == 1 ) {
lowlib.c:              G->MAG = 1;
lowlib.c:          kgUserFrame ( G , dc->gw_x1 , dc->gw_y1 , dc->gw_x2 , dc->gw_y2 ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      dc->lcur_x = dc->v_x1;
lowlib.c:      dc->lcur_y = EVGAY-dc->v_y1;
lowlib.c:      dc->rcur_x = dc->v_x2;
lowlib.c:      dc->rcur_y = EVGAY-dc->v_y2;
lowlib.c:      *xmin = dc->gw_x1 , *xmax = dc->gw_x2;
lowlib.c:      *ymin = dc->gw_y1 , *ymax = dc->gw_y2;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( dc->DOUBLE == 1 ) {
lowlib.c:      dc->lcur_x = dc->v_x1;
lowlib.c:      dc->lcur_y = EVGAY-dc->v_y1;
lowlib.c:      dc->rcur_x = dc->v_x2;
lowlib.c:      dc->rcur_y = EVGAY-dc->v_y2;
lowlib.c:      dc->gw_x1 = uiusr_x ( dc->lcur_x ) ;
lowlib.c:      dc->gw_x2 = uiusr_x ( dc->rcur_x ) ;
lowlib.c:      dc->gw_y1 = uiusr_y ( ( EVGAY-dc->lcur_y ) ) ;
lowlib.c:      dc->gw_y2 = uiusr_y ( ( EVGAY-dc->rcur_y ) ) ;
lowlib.c:      X0 = dc->gw_x1;
lowlib.c:      Y0 = dc->gw_y1;
lowlib.c:      if ( X0 < X1 ) {dc->gw_x1 = X0; dc->gw_x2 = X1; }
lowlib.c:      else {dc->gw_x1 = X1; dc->gw_x2 = X0; }
lowlib.c:      if ( Y0 < Y1 ) {dc->gw_y1 = Y0; dc->gw_y2 = Y1; }
lowlib.c:      else {dc->gw_y1 = Y1; dc->gw_y2 = Y0; }
lowlib.c:      ui_window ( G , dc->gw_x1 , dc->gw_y1 , dc->gw_x2 , dc->gw_y2 ) ;
lowlib.c:      if ( dc->SET3D == 1 ) {
lowlib.c:          if ( dc->DBL_BUF == 1 ) {
lowlib.c:      dc->lcur_x = dc->v_x1;
lowlib.c:      dc->lcur_y = EVGAY-dc->v_y1;
lowlib.c:      dc->rcur_x = dc->v_x2;
lowlib.c:      dc->rcur_y = EVGAY-dc->v_y2;
lowlib.c:      *xmin = dc->gw_x1 , *xmax = dc->gw_x2;
lowlib.c:      *ymin = dc->gw_y1 , *ymax = dc->gw_y2;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      dx = ( *xmax - *xmin ) *0.5;
lowlib.c:      dy = ( *ymax - *ymin ) *0.5;
lowlib.c:          if ( ( xpo < dc->v_x1 ) || ( xpo > dc->v_x2 ) || ( ( EVGAY -ypo ) < dc->v_y1 ) \
lowlib.c:           || ( ( EVGAY -ypo ) > dc->v_y2 ) ) break;
lowlib.c:              *xmin = xm -dx;
lowlib.c:              *ymin = ym -dy;
lowlib.c:                      if ( ( xpo < dc->v_x1 ) || ( xpo > dc->v_x2 ) || ( ( EVGAY -ypo ) < dc->v_y1 ) \
lowlib.c:                       || ( ( EVGAY -ypo ) > dc->v_y2 ) ) break;
lowlib.c:                      sx = uiusr_x ( xpo1 ) - uiusr_x ( xpo ) ;
lowlib.c:                      sy = uiusr_y ( EVGAY -ypo1 ) - uiusr_y ( EVGAY -ypo ) ;
lowlib.c:                      xm -= sx;
lowlib.c:                      ym -= sy;
lowlib.c:                      *xmin = xm -dx;
lowlib.c:                      *ymin = ym -dy;
lowlib.c:              *xmin = xm -dx;
lowlib.c:              *ymin = ym -dy;
lowlib.c:      wc = G->wc;
lowlib.c:      D = G->D;
lowlib.c:      gw_y1 = usr_y ( ( EVGAY-lcur_y ) ) ;
lowlib.c:      gw_y2 = usr_y ( ( EVGAY-rcur_y ) ) ;
lowlib.c:              gw_y1 = usr_y ( ( EVGAY-lcur_y ) ) ;
lowlib.c:              gw_y2 = usr_y ( ( EVGAY-rcur_y ) ) ;
lowlib.c:      D = G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      vx1 = dc->v_x1+dc->D_x; vy1 = EVGAY- ( dc->v_y2+dc->D_y ) ;
lowlib.c:      vx2 = ( dc->v_x2+dc->D_x ) ; vy2 = EVGAY- ( dc->v_y1+dc->D_y ) ;
lowlib.c:      if ( dc->gcur_x > vx2-1 ) {dc->gcur_x = vx2-1; }
lowlib.c:      if ( dc->gcur_y > vy2-1 ) {dc->gcur_y = vy2-1; }
lowlib.c:      if ( dc->gcur_x < vx1 ) {dc->gcur_x = vx1; }
lowlib.c:      if ( dc->gcur_y < vy1 ) {dc->gcur_y = vy1; }
lowlib.c:      x = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      y = uiusr_y ( EVGAY-dc->gcur_y ) ;
lowlib.c:      sprintf ( nbuf , dc->Posfmt , x , y ) ;
lowlib.c:      uimsg_menu ( G , dc->msg_x , dc->msg_y , 34 , nbuf ) ;
lowlib.c://  Position_Pointer(dc->gcur_x,dc->gcur_y);
lowlib.c:      if ( gcur_y > EVGAY-v_y1-2 ) {gcur_y = EVGAY-v_y1-2; gbell ( ) ; };
lowlib.c:      if ( gcur_y < EVGAY-v_y2 ) {gcur_y = EVGAY-v_y2; gbell ( ) ; };
lowlib.c:      y = usr_y ( EVGAY-gcur_y ) ;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      vx1 = dc->v_x1+dc->D_x; vy1 = EVGAY- ( dc->v_y2+dc->D_y ) ;
lowlib.c:      vx2 = ( dc->v_x2+dc->D_x ) ; vy2 = EVGAY- ( dc->v_y1+dc->D_y ) ;
lowlib.c:      if ( dc->gcur_x >= vx2 ) {dc->gcur_x = vx2-1; }
lowlib.c:      if ( dc->gcur_y > vy2-1 ) {dc->gcur_y = vy2-1; }
lowlib.c:      if ( dc->gcur_x < vx1 ) {dc->gcur_x = vx1; }
lowlib.c:      if ( dc->gcur_y < vy1 ) {dc->gcur_y = vy1; }
lowlib.c:      x = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      y = uiusr_y ( EVGAY-dc->gcur_y ) ;
lowlib.c:      sprintf ( nbuf , dc->Posfmt , x , y ) ;
lowlib.c://  printf("%s %d %d\n",nbuf,dc->msg_x,dc->msg_y);
lowlib.c:      uimsg_menu ( G , dc->msg_x , dc->msg_y , 34 , nbuf ) ;
lowlib.c:      if ( wc->event.type != ButtonPress ) return;
lowlib.c:      G = ( DIG * ) ( ( DIALOG * ) Tmp )->d [ gbox ] .g;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      dc->entry = 0;
lowlib.c:      dc->gcur_x = uiscr_x ( *xx ) ;
lowlib.c:      dc->gcur_y = D->evgay-uiscr_y ( *yy ) ;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( D->evgay-dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      if ( ( col > wc->c_v_x2 ) || ( col < wc->c_v_x1 ) || ( row > wc->c_v_y2 ) \
lowlib.c:       || ( row < wc->c_v_y1 ) ) return;
lowlib.c:      uiput_pixl ( wc , col , wc->EVGAY-row ) ;
lowlib.c:      D = ( DIALOG * ) ( wc->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      ya = EVGAY-ya , yb = EVGAY-yb;
lowlib.c:      D = ( DIALOG * ) ( wc->D ) ;
lowlib.c:      xa = x1 , xb = x2 , ya = D->evgay-y1 , yb = D->evgay-y2;
lowlib.c:      if ( ( x2-x1 ) > 1 ) {x1++; }
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      dc->entry = 0;
lowlib.c:      temp = dc->c_bound;
lowlib.c:      dc->c_bound = 14;
lowlib.c:      c_color = wc->c_color;
lowlib.c:      yorg1 = D->evgay-uiscr_y ( *yy ) ;
lowlib.c:      yorg = D->evgay-uiscr_y ( *ybgn ) ;
lowlib.c:      dc->gcur_x = xorg1;
lowlib.c:      dc->gcur_y = yorg1;
lowlib.c:      xorg -= xorg1;
lowlib.c:      yorg = yorg1-yorg;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:      xpo = dc->gcur_x , ypo = dc->gcur_y;
lowlib.c:      draw_box_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_box_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_box_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:      dc->c_bound = temp;
lowlib.c:      if ( dc->entry ) {
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( D->evgay-dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      dc->entry = 0;
lowlib.c:      dc->gcur_x = uiscr_x ( *xx ) ;
lowlib.c:      dc->gcur_y = D->evgay-uiscr_y ( *yy ) ;
lowlib.c:      yorg = D->evgay-uiscr_y ( *ybgn ) ;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:      draw_rect_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_rect_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_rect_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( D->evgay-dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      wc = G->wc;
lowlib.c:      D = G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      x2 = dc->x2; y2 = dc->y2;
lowlib.c:      if ( dc->entry == 0 ) {x2 = -1; y2 = -1; };
lowlib.c:      if ( dc->entry ) {
lowlib.c:      dc->entry = 1;
lowlib.c:      if ( xmin >= ( D->evgax+1 ) ) {xmax = D->evgax+1; xmin = xmax-1; };
lowlib.c:      ymax = y1; ymin = ymax-1;
lowlib.c:      if ( ymax >= ( D->evgay ) ) {ymax = D->evgay; ymin = ymax-1; };
lowlib.c:      kg_scr_back ( wc , xmin , 0 , xmax , ( D->evgay ) ) ;
lowlib.c:      kg_scr_back ( wc , 0 , ymin , ( D->evgax ) +1 , ymax ) ;
lowlib.c:      _uiLINE ( wc , 0 , y1 , ( D->evgax+1 ) , y1 ) ;
lowlib.c:      _uiLINE ( wc , x1 , 0 , x1 , ( D->evgay ) ) ;
lowlib.c:      dc->x2 = x1 , dc->y2 = y1;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      temp = wc->c_color;
lowlib.c:      dc->entry = 0;
lowlib.c:      dc->gcur_x = uiscr_x ( *xx ) ;
lowlib.c:      dc->gcur_y = D->evgay-uiscr_y ( *yy ) ;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:      draw_cross_cursor ( G , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_cross_cursor ( G , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_cross_cursor ( G , dc->gcur_x , dc->gcur_y ) ;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( D->evgay-dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:              else pointer = -1;
lowlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      dc->entry = 0;
lowlib.c:      dc->gcur_x = uiscr_x ( *xx ) ;
lowlib.c:      dc->gcur_y = D->evgay-uiscr_y ( *yy ) ;
lowlib.c:      yorg = D->evgay-uiscr_y ( *ybgn ) ;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:      kg_scr_back ( wc , 0 , yorg , D->evgax+1 , yorg ) ;
lowlib.c:      kg_scr_back ( wc , xorg , 0 , xorg , D->evgay ) ;
lowlib.c:      _uiLINE ( wc , 0 , yorg , D->evgax+1 , yorg ) ;
lowlib.c:      _uiLINE ( wc , xorg , 0 , xorg , D->evgay ) ;
lowlib.c:      draw_cross_cursor ( G , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_cross_cursor ( G , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_cross_cursor ( G , dc->gcur_x , dc->gcur_y ) ;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( D->evgay-dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      D = G->D;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      x2 = dc->x2;
lowlib.c:      y2 = dc->y2;
lowlib.c:      if ( dc->entry == 0 ) {x2 = -100; y2 = -100; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:          _uirecover_line ( wc , xorg , yorg , dc->xrbr , dc->yrbr ) ;
lowlib.c:      dc->entry = 1;
lowlib.c:      if ( xmin >= ( D->evgax+1 ) ) {xmax = x1; xmin = xmax-1; };
lowlib.c:      if ( ymin >= ( D->evgay ) ) {ymax = y1; ymin = ymax-1; };
lowlib.c:      kg_scr_back ( wc , xmin , 0 , xmax , ( D->evgay ) ) ;
lowlib.c:      kg_scr_back ( wc , 0 , ymin , ( D->evgax+1 ) , ymax ) ;
lowlib.c:      _uiLINE ( wc , 0 , y1 , ( D->evgax+1 ) , y1 ) ;
lowlib.c:      _uiLINE ( wc , x1 , 0 , x1 , ( D->evgay ) ) ;
lowlib.c:      dc->x2 = x1 , dc->y2 = y1;
lowlib.c:      dc->xrbr = x1 , dc->yrbr = y1;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      dc->entry = 0;
lowlib.c:      dc->gcur_x = uiscr_x ( *xx ) ;
lowlib.c:      dc->gcur_y = ( D->evgay ) -uiscr_y ( *yy ) ;
lowlib.c:      yorg = ( D->evgay ) -uiscr_y ( *ybgn ) ;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:      kg_scr_back ( wc , 0 , yorg , ( D->evgax+1 ) , yorg ) ;
lowlib.c:      kg_scr_back ( wc , xorg , 0 , xorg , ( D->evgay ) ) ;
lowlib.c:      _uiLINE ( wc , 0 , yorg , ( D->evgax+1 ) , yorg ) ;
lowlib.c:      _uiLINE ( wc , xorg , 0 , xorg , ( D->evgay ) ) ;
lowlib.c:      draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:               ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ; break; }
lowlib.c:      if ( dc->entry ) {
lowlib.c:          _uirecover_line ( wc , xorg , yorg , dc->xrbr , dc->yrbr ) ;
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( ( D->evgay ) -dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      D = ( DIALOG * ) G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      dc = G->dc;
lowlib.c:      if ( G->D_ON == 0 ) {
lowlib.c:          MAG = G->MAG;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      dc->entry = 0;
lowlib.c:      dc->gcur_x = uiscr_x ( *xx ) ;
lowlib.c:      dc->gcur_y = ( D->evgay ) -uiscr_y ( *yy ) ;
lowlib.c:      yorg = ( D->evgay ) -uiscr_y ( *ybgn ) ;
lowlib.c:      dc->gcur_r = sqrt ( ( double ) ( ( dc->gcur_x-xorg ) * ( dc->gcur_x-xorg ) + \
lowlib.c:       ( dc->gcur_y-yorg ) * ( dc->gcur_y-yorg ) ) ) ;
lowlib.c:      uiScrn_back ( wc , dc->msg_x , dc->msg_y , 34 ) ;
lowlib.c:      kg_scr_back ( wc , 0 , yorg , ( D->evgax+1 ) , yorg ) ;
lowlib.c:      kg_scr_back ( wc , xorg , 0 , xorg , ( D->evgay ) ) ;
lowlib.c:      _uiLINE ( wc , 0 , yorg , ( D->evgax+1 ) , yorg ) ;
lowlib.c:      _uiLINE ( wc , xorg , 0 , xorg , ( D->evgay ) ) ;
lowlib.c:      xpo = dc->gcur_x , ypo = dc->gcur_y;
lowlib.c:      gcurx = dc->gcur_x; gcury = dc->gcur_y;
lowlib.c:      dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:      draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  gcurx = dc->gcur_x; gcury = dc->gcur_y;
lowlib.c:                  dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:              if ( ( xpo != dc->gcur_x ) || ( ypo != dc->gcur_y ) ) {
lowlib.c:                  dc->gcur_x = xpo , dc->gcur_y = ypo;
lowlib.c:                  gcurx = dc->gcur_x; gcury = dc->gcur_y;
lowlib.c:                  dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c://       if(isdigit(kb)) {jmp = kb-'0';continue;}
lowlib.c:              if ( ( kb >= '0' ) && ( kb <= '9' ) ) {dc->jmp = kb-'0'; continue; }
lowlib.c:                  gcurx = dc->gcur_x; gcury = dc->gcur_y-dc->jmp;
lowlib.c:                  dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:                  gcurx = dc->gcur_x; gcury = dc->gcur_y+dc->jmp;
lowlib.c:                  dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:                  gcurx = dc->gcur_x-dc->jmp; gcury = dc->gcur_y;
lowlib.c:                  dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:                  gcurx = dc->gcur_x+dc->jmp; gcury = dc->gcur_y;
lowlib.c:                  dc->gcur_x = gcurx , dc->gcur_y = gcury;
lowlib.c://  uiPositionPointer(wc,dc->gcur_x,dc->gcur_y);
lowlib.c:                  draw_rbr_cursor ( G , xorg , yorg , dc->gcur_x , dc->gcur_y ) ;
lowlib.c:      if ( dc->entry ) {
lowlib.c:          _uirecover_line ( wc , xorg , yorg , dc->xrbr , dc->yrbr ) ;
lowlib.c:      *xx = uiusr_x ( dc->gcur_x ) ;
lowlib.c:      *yy = uiusr_y ( ( ( D->evgay ) -dc->gcur_y ) ) ;
lowlib.c:          kgAntialiasingOn ( G , MAG-1 ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      wc = G->wc;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      tempc = wc->c_color;
lowlib.c:      wcset_clr ( wc , dc->ln_color ) ;
lowlib.c:      _uiLINE ( wc , xa , ( EVGAY-ya ) , xb , ( EVGAY-yb ) ) ;
lowlib.c:      D = wc->D;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      if ( ( x_min <= ( D->evgax+1 ) ) && ( x_max1 >= 0 ) ) {
lowlib.c:          if ( ( y_min <= ( D->evgay ) ) && ( y_max >= 0 ) ) {
lowlib.c:              if ( x_max1 > ( D->evgax+1 ) ) x_max1 = ( D->evgax+1 ) ;
lowlib.c:              if ( y_max > ( D->evgay ) ) y_max = ( D->evgay ) ;
lowlib.c:              _uiBox_Fill ( wc , x_min , ( D->evgay ) -y_max , x_max1 , \
lowlib.c:               ( D->evgay ) -y_min ) ;
lowlib.c:      D = wc->D;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      if ( ( x_min < ( D->evgax ) ) && ( x_max1 >= 0 ) ) {
lowlib.c:          if ( ( y_min < ( D->evgay ) ) && ( y_max >= 0 ) ) {
lowlib.c:              if ( x_max1 > ( D->evgax-1 ) ) x_max1 = ( D->evgax-1 ) ;
lowlib.c:              if ( y_max > ( D->evgay-1 ) ) y_max = ( D->evgay-1 ) ;
lowlib.c:      D = wc->D;
lowlib.c:      if ( ( D->NoWinMngr == 1 ) && ( D->transparency == 1.0 ) ) return;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      if ( ( x_min <= ( D->evgax+1 ) ) && ( x_max1 >= 0 ) ) {
lowlib.c:          if ( ( y_min <= ( D->evgay ) ) && ( y_max >= 0 ) ) {
lowlib.c:              if ( x_max1 > ( D->evgax+1 ) ) x_max1 = ( D->evgax+1 ) ;
lowlib.c:              if ( y_max > ( D->evgay ) ) y_max = ( D->evgay ) ;
lowlib.c:              _dvBox_Fill_Transparent ( wc , x_min , ( D->evgay ) -y_max , x_max1 , \
lowlib.c:               ( D->evgay ) -y_min , transparency ) ;
lowlib.c:      D = wc->D;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c://  if((D->parent != NULL) &&(D->transparency==1.0)) return;
lowlib.c:      if ( ( D->parent != NULL ) && ( transparency == 1.0 ) ) return;
lowlib.c:      if ( ( D->NoWinMngr == 1 ) && ( transparency == 1.0 ) ) return;
lowlib.c:      if ( ( x_min <= ( D->evgax ) ) && ( x_max1 >= 0 ) ) {
lowlib.c:          if ( ( y_min <= ( D->evgay ) ) && ( y_max >= 0 ) ) {
lowlib.c:              if ( x_max1 > ( D->evgax ) ) x_max1 = ( D->evgax ) ;
lowlib.c:              if ( y_max > ( D->evgay ) ) y_max = ( D->evgay ) ;
lowlib.c:      int ln , i , maxchar , temp , justification = -1;
lowlib.c:      wc = D->wc;
lowlib.c:      xp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width-1.5*BxSize;
lowlib.c:              case -1:
lowlib.c:              kgMove2f ( fid , ( width1-length ) *.5 , xp ) ;
lowlib.c:              kgMove2f ( fid , ( width1-length-tw*0.5 ) , xp ) ;
lowlib.c:              kgMove2f ( fid , ( width1-length ) *.5 , xp ) ;
lowlib.c:              width1 = width-1.25*BxSize;
lowlib.c:              kgMove2f ( fid , width1 , xp-0.2*BxSize ) ;
lowlib.c:              kgDraw2f ( fid , width1+BxSize , xp-0.2*BxSize ) ;
lowlib.c:              kgDraw2f ( fid , width1 , xp-0.2*BxSize ) ;
lowlib.c:      wc = D->wc;
lowlib.c:      yp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width-FontSize;
lowlib.c:              case -1:
lowlib.c:              kgMove2f ( fid , xp+ ( width1-length ) *.5 , yp ) ;
lowlib.c:              kgMove2f ( fid , xp+ ( width1-length-tw*0.5 ) , yp ) ;
lowlib.c:              kgMove2f ( fid , xp+ ( width1-length ) *.5 , yp ) ;
lowlib.c:      wc = D->wc;
lowlib.c:      yp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width-FontSize;
lowlib.c:                  case -1:
lowlib.c:                  kgMove2f ( fid , xp+ ( width1-length ) *.5 , yp ) ;
lowlib.c:                  kgMove2f ( fid , xp+ ( width1-length-tw*0.5 ) , yp ) ;
lowlib.c:                  kgMove2f ( fid , xp+ ( width1-length ) *.5 , yp ) ;
lowlib.c:      wc = D->wc;
lowlib.c:      yp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width-FontSize;
lowlib.c:              Str = Strs [ i ]->name;
lowlib.c:                  case -1:
lowlib.c:                  kgMove2f ( fid , xp+ ( width1-length ) *.5 , yp ) ;
lowlib.c:                  kgMove2f ( fid , xp+ ( width1-length-tw*0.5 ) , yp ) ;
lowlib.c:                  kgMove2f ( fid , xp+ ( width1-length ) *.5 , yp ) ;
lowlib.c:      int ln , i , maxchar , temp , justification = -1;
lowlib.c:      D = w->D;
lowlib.c:      wc = D->wc;
lowlib.c:      xp = height*0.5-BxSize*0.5;
lowlib.c:      width1 = width*0.5-0.5*BxSize;
lowlib.c:              kgDraw2f ( fid , width1+1 , xp+BxSize-1 ) ;
lowlib.c:              kgDraw2f ( fid , width1+BxSize-1 , xp+BxSize-1 ) ;
lowlib.c:              kgDraw2f ( fid , width1+BxSize-1 , xp+1 ) ;
lowlib.c:      int ln , i , maxchar , temp , justification = -1;
lowlib.c:      D = w->D;
lowlib.c:      wc = D->wc;
lowlib.c:      height = w->width+w->ygap;
lowlib.c:      yp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width*0.5-0.5*BxSize;
lowlib.c:      int ln , i , maxchar , temp , justification = -1 , r , g , b;
lowlib.c:      D = w->D;
lowlib.c:      wc = D->wc;
lowlib.c:      height = w->width+w->ygap;
lowlib.c:      yp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width*0.5-0.5*BxSize;
lowlib.c:              kgMove2f ( fid , ( float ) BxSize-0.4*FontSize , yp+0.1*BxSize ) ;
lowlib.c:      int ln , i , maxchar , temp , justification = -1;
lowlib.c:      wc = D->wc;
lowlib.c:      xp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width-2*BxSize;
lowlib.c:              case -1:
lowlib.c:              kgMove2f ( fid , ( width1-length ) *.5 , xp ) ;
lowlib.c:              kgMove2f ( fid , ( width1-length-tw*0.5 ) , xp ) ;
lowlib.c:              kgMove2f ( fid , ( width1-length ) *.5 , xp ) ;
lowlib.c:              kgMove2f ( fid , ( float ) BxSize-0.4*FontSize , xp+0.1*BxSize ) ;
lowlib.c:      int ln , i , maxchar , temp , justification = -1;
lowlib.c:      wc = D->wc;
lowlib.c:      xp = height*0.5-FontSize*0.5;
lowlib.c:      width1 = width-2*BxSize;
lowlib.c:              case -1:
lowlib.c:              kgMove2f ( fid , ( width1-length ) *.5 , xp ) ;
lowlib.c:              kgMove2f ( fid , ( width1-length-tw*0.5 ) , xp ) ;
lowlib.c:              kgMove2f ( fid , ( width1-length ) *.5 , xp ) ;
lowlib.c:               ( float ) BxSize , ( float ) BxSize , D->gc.fill_clr , 0.5 , 4 ) ;
lowlib.c:   -1 left justification
lowlib.c:      wc = D->wc;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:      img = kgFilledStringToImage3 ( str , NULL , ln , height , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , depthfac ) ;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:      img = kgFilledStringToImage1 ( str , NULL , ln , height , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , depthfac ) ;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:      img = kgSplashStringToImage ( str , ln , height , font , fillcolor , color , D->gc.fill_clr , justfic , FontSize , rfac ) ;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:          img = kgShadedStringToImage ( str , NULL , ln , height , font , fillcolor , highli , color , justfic , FontSize , rfac , state , type-4 ) ;
lowlib.c:           ( float ) ( type-6 ) ) ;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:      off = ( width-ln ) *0.5;
lowlib.c:          if ( image != NULL ) { kgImage ( D , image , x+1 , y+1 , width-2 , height-2 , 0.0 , 1.0 ) ;
lowlib.c:          if ( image != NULL ) { kgImage ( D , image , x+1 , y+1 , width-2 , height-2 , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( str != NULL ) && ( str [ 0 ] != '\0' ) ) uiString ( D , str , x+off , y , ln , height , font , color , FontSize , justfic , -1 ) ;
lowlib.c:          if ( image != NULL ) { kgImage ( D , image , x+1 , y+1 , width-2 , height-2 , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( str != NULL ) && ( str [ 0 ] != '\0' ) ) uiString ( D , str , x+off , y , ln , height , font , color , FontSize , justfic , -1 ) ;
lowlib.c:          if ( image != NULL ) { kgImage ( D , image , x+1 , y+1 , width-2 , height-2 , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( str != NULL ) && ( str [ 0 ] != '\0' ) ) uiString ( D , str , x+off , y , ln , height , font , color , FontSize , justfic , -1 ) ;
lowlib.c:          img = kgShadedStringToImage ( NULL , NULL , width , height , font , fillcolor , highli , color , justfic , FontSize , rfac , state , type-4 ) ;
lowlib.c:          if ( image != NULL ) { kgImage ( D , image , x+1 , y+1 , width-2 , height-2 , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( str != NULL ) && ( str [ 0 ] != '\0' ) ) uiString ( D , str , x+off , y , ln , height , font , color , FontSize , justfic , -1 ) ;
lowlib.c:           ( float ) ( type-3. ) ) ;
lowlib.c:          if ( image != NULL ) { kgImage ( D , image , x+1 , y+1 , width-2 , height-2 , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( str != NULL ) && ( str [ 0 ] != '\0' ) ) uiString ( D , str , x+off , y , ln , height , font , color , FontSize , justfic , -1 ) ;
lowlib.c:   -1 left justification
lowlib.c:    -1 pressed
lowlib.c:      wc = D->wc;
lowlib.c:      off = ( width-ln ) *0.5;
lowlib.c:      if ( state == -1 ) poff = -1;
lowlib.c:          if ( ( gimg->image_width > width ) || ( gimg->image_height > height ) ) {
lowlib.c:                  cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:          if ( ( gimg->image_width > width ) || ( gimg->image_height > height ) ) {
lowlib.c:                  cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:                  img = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:                  cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:              case -1:
lowlib.c:              img = kgBorderedRectangle ( width , height , D->gc.dim , rfac ) ;
lowlib.c:              cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:              img = kgFilledStringToImage3 ( NULL , NULL , width , height , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , 2.0 ) ;
lowlib.c:              img1 = kgFilledStringToImage3 ( NULL , NULL , width-2 , height-2 , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , 3.0 ) ;
lowlib.c:                  cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:              img = kgFilledStringToImage3 ( NULL , NULL , width , height , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , 2.0 ) ;
lowlib.c:              img1 = kgFilledStringToImage3 ( str , NULL , width-2 , height-2 , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , 3.0 ) ;
lowlib.c:              img = kgShadedStringToImage ( NULL , NULL , width , height , font , fillcolor , highli , color , justfic , FontSize , rfac , state , type-4 ) ;
lowlib.c:                  cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:              img = kgShadedStringToImage ( str , NULL , width , height , font , fillcolor , highli , color , justfic , FontSize , rfac , state , type-4 ) ;
lowlib.c:              img = kgFilledStringToImage1 ( NULL , NULL , width , height , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , 3.0 ) ;
lowlib.c:                  cimg = kgStringToImage ( str , NULL , ln , height , font , color , justfic , FontSize , -1 ) ;
lowlib.c:              img = kgFilledStringToImage1 ( str , NULL , width , height , font , fillcolor , highli , color , D->gc.fill_clr , justfic , FontSize , rfac , state , 3.0 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:          iy = D->evgay-iy1-11;
lowlib.c:          uiDraw_String ( D , ix1+2 , D->evgay-iy1 , str , -1 ) ;
lowlib.c:          kgImage ( D , img , x1 , y1-th , xsize , ysize , 0.0 , 1.0 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      iy = D->evgay-iy1-11;
lowlib.c: /* Draw_String(ix1+2,EVGAY-iy1,c,-1);*/
lowlib.c:      uiDraw_String ( D , ix1+2 , D->evgay-iy1 , c , -1 ) ;
lowlib.c:      uiset_sup_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
lowlib.c:      uiset_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
lowlib.c:      uiset_sup_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
lowlib.c:      uiset_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
lowlib.c:      if ( ( D->parent != NULL ) && ( D->SUBWIN == 1 ) ) wc = kgCreateSubWindow \
lowlib.c:      uiset_sup_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
lowlib.c:      uiset_clip_limits ( wc , 0 , 0 , wc->EVGAX , wc->EVGAY ) ;
lowlib.c:      dc = G->dc;
lowlib.c:      *x0 = dc->v_x1 , *x1 = dc->v_x2;
lowlib.c:      *y0 = dc->v_y1 , *y1 = dc->v_y2;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = abs ( ix0 - ix1 ) ;
lowlib.c:      h = abs ( iy0 - iy1 ) ;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = abs ( ix0 - ix1 ) ;
lowlib.c:      h = abs ( iy0 - iy1 ) ;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = abs ( ix0 - ix1 ) ;
lowlib.c:      h = abs ( iy0 - iy1 ) ;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = abs ( ix0 - ix1 ) ;
lowlib.c:      h = abs ( iy0 - iy1 ) ;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = abs ( ix0 - ix1 ) ;
lowlib.c:      h = abs ( iy0 - iy1 ) ;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = xu - xo;
lowlib.c:      h = yu - yo;
lowlib.c:      iy0 = EVGAY-scr_y ( y0 ) ;
lowlib.c:      iy1 = EVGAY-scr_y ( y1 ) ;
lowlib.c:      w = xu - xo;
lowlib.c:      h = yu - yo;
lowlib.c:      uiwrite_string ( D , m , x , D->evgay-y , D->gc.txt_pchar ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+4 , xmax-4 , ymax+4 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin-4 , ymax+4 , xmax-4 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+4 , xmax-4 , ymin-4 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin-4 , ymax+4 , xmin+4 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+lw , xmax-rw , ymax-bw ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin+tw , ymax-bw , xmax-rw ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+lw , xmax-rw , ymin+tw ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin+tw , ymax-bw , xmin+lw ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymin+1 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax-1 , ymin+1 , xmin+1 ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymin+2 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax-2 , ymin+2 , xmin+2 ) ;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+3 , xmax-3 , ymin+3 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax-3 , ymin+3 , xmin+3 ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+4 , xmax-4 , ymin-4 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax+4 , ymin-4 , xmin+4 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymax+1 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax+1 , ymin-1 , xmax-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymax+2 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax+2 , ymin-2 , xmax-2 ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+3 , xmax-3 , ymax+3 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax+3 , ymin-3 , xmax-3 ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+4 , xmax-4 , ymax+4 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymax+4 , ymin-4 , xmax-4 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymin-1 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin-1 , ymax+2 , xmin+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymin-1 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin-2 , ymax+3 , xmin+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymax+1 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ymin-1 , ymax+1 , xmax-1 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymin+1 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+1 , ymax-1 , xmin+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymax-1 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+1 , ymax-1 , xmax-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymax-2 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+2 , ymax-2 , xmax-2 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+lw , xmax-rw , ymax-bw ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+tw , ymax-bw , xmax-rw ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+lw , xmax-rw , ymin+tw ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+tw , ymax-bw , xmin+lw ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymin+1 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-1 , ymin+1 , xmin+1 ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymin+2 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-2 , ymin+2 , xmin+2 ) ;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+3 , xmax-3 , ymin+3 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-3 , ymin+3 , xmin+3 ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+4 , xmax-4 , ymin+4 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-4 , ymin+4 , xmin+4 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymax-1 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-1 , ymin+1 , xmax-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymax-2 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-2 , ymin+2 , xmax-2 ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+3 , xmax-3 , ymax-3 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-3 , ymin+3 , xmax-3 ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+4 , xmax-4 , ymax-4 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymax-4 , ymin+4 , xmax-4 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymin+1 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+1 , ymax-1 , xmin+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+2 , xmax-2 , ymin+2 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+2 , ymax-2 , xmin+2 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _dv_h_line ( WC ( D ) , xmin+1 , xmax-1 , ymax-1 ) ;
lowlib.c:      _dv_v_line ( WC ( D ) , ymin+1 , ymax-1 , xmax-1 ) ;
lowlib.c:      x1 = D->xo , y1 = D->yo , x2 = D->xo+D->xl-1 , y2 = D->yo+D->yl-1;
lowlib.c:      _dvrect_fill ( wc , x1 , y1 , x2 , y2 , D->gc.fill_clr ) ;
lowlib.c:      switch ( D->bor_type ) {
lowlib.c:          _dvbordertype2 ( D , x1 , y1 , x2 , y2 , D->tw , D->lw , D->rw , D->bw ) ;
lowlib.c:      x1 = D->xo , y1 = D->yo , x2 = D->xo+D->xl-1 , y2 = D->yo+D->yl-1;
lowlib.c:      _dvrect_fill_transparent ( wc , x1 , y1 , x2 , y2 , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      switch ( D->bor_type ) {
lowlib.c:          _dvbordertype2 ( D , x1 , y1 , x2 , y2 , D->tw , D->lw , D->rw , D->bw ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      x2 = nxb* ( b_w+xgap ) +x1-xgap;
lowlib.c:      y2 = nyb* ( b_h+ygap ) +y1-ygap;
lowlib.c:      ptr->x2 = x2;
lowlib.c:      ptr->y1 = EVGAY-y2;
lowlib.c:      ptr->nxb = nxb;
lowlib.c:      ptr->nyb = nyb;
lowlib.c:      ptr->b_w = b_w;
lowlib.c:      ptr->b_h = b_h;
lowlib.c:      ptr->df = df;
lowlib.c:      ptr->x1 = x1;
lowlib.c:      ptr->y2 = EVGAY-y1;
lowlib.c:      ptr->title = title;
lowlib.c:      ptr->xgap = xgap;
lowlib.c:      ptr->ygap = ygap;
lowlib.c:      ptr->xpm = xpm;
lowlib.c:      ptr->bkgr = bkgr;
lowlib.c:          ptr->sw = ( int * ) Malloc ( sizeof ( int ) *nxb*nyb ) ;
lowlib.c:          for ( k = 0; k < ( nxb*nyb ) ; k++ ) ptr->sw [ k ] = 1;
lowlib.c:          ptr->sw = sw;
lowlib.c:      ptr->Hsize = 1;
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      buf = ( char ** ) ( bt->xpm [ k ] ) ;
lowlib.c:      Hsize = bt->Hsize;
lowlib.c:      l = x2 -x1;
lowlib.c:      w = y2 -y1;
lowlib.c:      if ( l < 0 ) l = -l;
lowlib.c:      if ( w < 0 ) w = -w;
lowlib.c:      if ( color >= 0 ) _uibox_fill ( wc , x1+2 , EVGAY-y1+2 , x2-2 , EVGAY-y2-2 , \
lowlib.c:          kgImage ( D , bt->xpm [ k ] , x0+1 , y0+1 , l-2 , w-2 , 0.0 , 1.0 ) ;
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      buf = ( char ** ) ( bt->xpm [ k ] ) ;
lowlib.c:      Hsize = bt->Hsize;
lowlib.c:      l = x2 -x1;
lowlib.c:      w = y2 -y1;
lowlib.c:      if ( l < 0 ) l = -l;
lowlib.c:      if ( w < 0 ) w = -w;
lowlib.c://   if(color >= 0) _uibox_fill(wc,x1+2,EVGAY-y1+2,x2-2,EVGAY-y2-2,(unsigned int) color);
lowlib.c:      if ( buf != NULL ) kgImage ( D , bt->xpm [ k ] , x0+1 , y0+1 , l-2 , w-2 , transparency , highfac ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y2+1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x2-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y1-1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x1+1 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      EVGAY = Dtmp->evgay;
lowlib.c:      dvdraw_depre ( Dtmp , x1 , EVGAY-y1 , x2 , EVGAY-y2 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _dv_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y1+1 ) ;
lowlib.c:      _dv_v_line ( wc , ( int ) y1+1 , ( int ) y2-1 , ( int ) x1+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _dv_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y2-1 ) ;
lowlib.c:      _dv_v_line ( wc , ( int ) y1+1 , ( int ) y2-1 , ( int ) x2-1 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _dv_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y1+1 ) ;
lowlib.c:      _dv_v_line ( wc , ( int ) y1+1 , ( int ) y2-1 , ( int ) x1+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _dv_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y2-1 ) ;
lowlib.c:      _dv_v_line ( wc , ( int ) y1+1 , ( int ) y2-1 , ( int ) x2-1 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y1+1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1+1 , ( int ) y2-1 , ( int ) x1+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y2-1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1+1 , ( int ) y2-1 , ( int ) x2-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y1-1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x1+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1 , ( int ) x2-1 , ( int ) y2+1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x2-1 ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y2+1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x2-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.dim ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-2 , ( int ) y1-1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+2 , ( int ) x1+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y2+1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x2-1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.fill_clr ) ;
lowlib.c:      _ui_h_line ( wc , ( int ) x1+1 , ( int ) x2-1 , ( int ) y1-1 ) ;
lowlib.c:      _ui_v_line ( wc , ( int ) y1-1 , ( int ) y2+1 , ( int ) x1+1 ) ;
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      Hsize = bt->Hsize;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      if ( ( bt->nyb ) > 1 ) ygap = ( ( float ) ( ( bt->y2-bt->y1 ) -height*bt->nyb ) / \
lowlib.c:       ( bt->nyb-1.0 ) +0.5 ) ;
lowlib.c:      if ( ( bt->nxb ) > 1 ) xgap = ( float ) ( ( bt->x2-bt->x1 ) -width*bt->nxb ) / \
lowlib.c:       ( bt->nxb-1.0 ) +0.5;
lowlib.c:      sw = bt->sw;
lowlib.c:      if ( df != bt->df ) {
lowlib.c:          for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:              for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:                  if ( k+1 == bt->df ) {
lowlib.c:                      yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:                      xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:                      if ( sw [ k ] == 1 ) uirmv_inset_protru ( D , xx-Hsize , yy+height+Hsize , xx+width+Hsize , yy-Hsize ) ;
lowlib.c:                      yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:                      xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:                      if ( sw [ k ] == 1 ) uidraw_depre ( D , xx-Hsize , yy+height+Hsize , xx+width+Hsize , yy-Hsize ) ;
lowlib.c:      bt->df = df;
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      if ( ( bt->nyb ) > 1 ) ygap = ( ( float ) ( ( bt->y2-bt->y1 ) -height*bt->nyb ) / \
lowlib.c:       ( bt->nyb-1.0 ) +0.5 ) ;
lowlib.c:      if ( ( bt->nxb ) > 1 ) xgap = ( float ) ( ( bt->x2-bt->x1 ) -width*bt->nxb ) / \
lowlib.c:       ( bt->nxb-1.0 ) +0.5;
lowlib.c:      for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:          yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:          for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:              xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:              _ui_draw_newbutton ( xx , yy+height , xx+width , yy , bt , k , D->transparency ) ;
lowlib.c:              if ( ( bt->sw [ k ] == 1 ) || ( bt->sw [ k ] == 3 ) ) {
lowlib.c:                  if ( bt->D->butattn ) {
lowlib.c:                          uidraw_depre ( D , xx-bt->Hsize , yy+height+bt->Hsize , xx+width+bt->Hsize , yy-bt->Hsize ) ;
lowlib.c:                          uirmv_inset_protru ( D , xx-bt->Hsize , yy+height+bt->Hsize , xx+width+bt->Hsize , yy-bt->Hsize ) ;
lowlib.c:      bt->df = df;
lowlib.c:      if ( bt->sw [ k ] < 1 ) return; //not active
lowlib.c://   if(bt->sw[k]!=  1) return; //not active
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      n = bt->nxb*bt->nyb;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      _uirect_fill ( wc , x1+1 , y1-1 , x2-1 , y2+1 , D->gc.fill_clr ) ;
lowlib.c:      if ( bt->xpm != NULL ) {
lowlib.c:          if ( bt->bkgr == NULL ) bkgr = -1;
lowlib.c:          else bkgr = bt->bkgr [ k ] ;
lowlib.c:          if ( ( bt->xpm != NULL ) ) {
lowlib.c:              if ( bt->xpm [ k ] != NULL ) _ui_jpg_draw ( bt , k , x1 , D->evgay-y2+1 , x2 , D->evgay-y1+1 , bkgr ) ;
lowlib.c:              else _uirect_fill ( wc , x1+4 , y1-4 , x2-4 , y2+4 , bkgr ) ;
lowlib.c:          else if ( bkgr >= 0 ) _uirect_fill ( wc , x1+4 , y1-4 , x2-4 , y2+4 , bkgr ) ;
lowlib.c:      if ( bt->sw [ k ] == 1 ) {
lowlib.c://     uiMenustr(D,x1+15,y2+8,bt->title[k],D->gc.but_char);
lowlib.c:          uiString ( D , bt->title [ k ] , x1+4 , D->evgay- ( y2+24 ) , ( x2-x1-8 ) , 22 , D->gc.ButtonFont , D->gc.but_char , D->gc.FontSize , 0 , -1 ) ;
lowlib.c:          uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:          _uidraw_line ( wc , x1+1 , y1-1 , x2-1 , y1-1 ) ;
lowlib.c:          _uidraw_line ( wc , x1+1 , y1-1 , x1+1 , y2+1 ) ;
lowlib.c:          uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:          _uidraw_line ( wc , x1+1 , y2+1 , x2-1 , y2+1 ) ;
lowlib.c:          _uidraw_line ( wc , x2-1 , y1-1 , x2-1 , y2+1 ) ;
lowlib.c:      if ( bt->sw [ k ] < 1 ) return; //not active
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      x0 = x1; y0 = EVGAY-y1;
lowlib.c:      l = abs ( x2-x1 ) ; w = abs ( y2 -y1 ) ;
lowlib.c:      n = bt->nxb*bt->nyb;
lowlib.c:      if ( ( bt->xpm != NULL ) && ( bt->xpm [ k ] != NULL ) ) xpm = bt->xpm [ k ] ;
lowlib.c:          if ( bt->xpm [ k+n ] != NULL ) xpm = bt->xpm [ k+n ] ;
lowlib.c:      if ( k+1 == bt->df ) highli = 1;
lowlib.c:      if ( D->butattn == 0 ) highli = 0;
lowlib.c:      xgap = bt->xgap/2;
lowlib.c:      ygap = bt->ygap/2;
lowlib.c:      _uirect_fill_transparent ( wc , x1-xgap , y1+ygap , x2+xgap , y2-ygap , D->gc.fill_clr , transparency ) ;
lowlib.c:      if ( bt->bkgr == NULL ) bkgr = D->gc.fill_clr;
lowlib.c:      else bkgr = bt->bkgr [ k ] ;
lowlib.c:          if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:      uiShadedStringImage ( D , bt->title [ k ] , xpm , x0 , ( y0 ) , l , w , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.FontSize , 0 , bt->fac , -1 , bt->type ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      if ( bt->sw [ k ] < 1 ) return; //not active
lowlib.c://   if(bt->sw[k]!=  1) return; //not active
lowlib.c://     printf("Inside _ui_draw_button:title:%s\n",bt->title[k]);
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      _uirect_fill ( wc , x1+1 , y1-1 , x2-1 , y2+1 , D->gc.fill_clr ) ;
lowlib.c:      if ( bt->xpm != NULL ) {
lowlib.c:          if ( bt->bkgr == NULL ) bkgr = -1;
lowlib.c:          else bkgr = bt->bkgr [ k ] ;
lowlib.c:          if ( ( bt->xpm != NULL ) && ( bt->xpm [ k ] != NULL ) ) _ui_jpg_draw \
lowlib.c:           ( bt , k , x1 , D->evgay-y2+1 , x2 , D->evgay-y1+1 , bkgr ) ;
lowlib.c:          else if ( bkgr >= 0 ) _uirect_fill ( wc , x1+4 , y1-4 , x2-4 , y2+4 , bkgr ) ;
lowlib.c:      if ( bt->sw [ k ] == 1 ) {
lowlib.c://     uiMenustr(D,x1+15,y2+8,bt->title[k],D->gc.but_char);
lowlib.c:          uiString ( D , bt->title [ k ] , x1+4 , D->evgay- ( y2+24 ) , ( x2-x1-8 ) , 22 , D->gc.ButtonFont , D->gc.but_char , D->gc.FontSize , 0 , -1 ) ;
lowlib.c:          uiset_clr ( Parent , D->gc.vbright ) ;
lowlib.c:          _uidraw_line ( wc , x1+1 , y1-1 , x2-1 , y1-1 ) ;
lowlib.c:          _uidraw_line ( wc , x1+1 , y1-1 , x1+1 , y2+1 ) ;
lowlib.c:          uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:          _uidraw_line ( wc , x1+1 , y2+1 , x2-1 , y2+1 ) ;
lowlib.c:          _uidraw_line ( wc , x2-1 , y1-1 , x2-1 , y2+1 ) ;
lowlib.c://   if(bt->sw[k]< 1) return; //not active
lowlib.c:      if ( bt->sw [ k ] != 1 ) return; //Need not Draw
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _uidraw_line ( wc , x1+1 , y1-1 , x2-1 , y1-1 ) ;
lowlib.c:      _uidraw_line ( wc , x1+1 , y1-1 , x1+1 , y2+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uidraw_line ( wc , x1+1 , y2+1 , x2-1 , y2+1 ) ;
lowlib.c:      _uidraw_line ( wc , x2-1 , y1-1 , x2-1 , y2+1 ) ;
lowlib.c:      if ( N->code != 'n' ) {
lowlib.c:          D = ( DIALOG * ) ( B->D ) ;
lowlib.c:          df = * ( B->df ) ;
lowlib.c:          D = N->D;
lowlib.c:          df = * ( N->df ) ;
lowlib.c:      transparency = D->transparency;
lowlib.c:      if ( D->butattn == 0 ) highli = 0;
lowlib.c:      switch ( B->code ) {
lowlib.c:          butn = ( BUT_STR * ) ( N->buts ) ;
lowlib.c:          if ( D->DrawBkgr != 0 ) _dvrect_fill_transparent ( wc , x1 , y1 , x2 , y2 , D->gc.fill_clr , transparency ) ;
lowlib.c:              kgImage ( D , img , x1 , y1 , x2-x1 , y2-y1 , 0.0 , 1.0 ) ;
lowlib.c:              case -1:
lowlib.c:              kgImage ( D , img , x1 , y1 , x2-x1 , y2-y1 , 0.0 , 1.0 ) ;
lowlib.c:          if ( B->sw [ k ] < 1 ) return; //not active
lowlib.c:          EVGAY = D->evgay;
lowlib.c:          temp = WC ( D )->c_color;
lowlib.c:          xpm = B->xpm;
lowlib.c:          nb = B->nx*B->ny;
lowlib.c:          ix = k%B->nx;
lowlib.c:          iy = k/B->nx;
lowlib.c:          xgap = B->xgap;
lowlib.c:          ygap = B->ygap;
lowlib.c:          ln = B->lngth;
lowlib.c:          wd = B->width;
lowlib.c:          df = * ( B->df ) ;
lowlib.c:          x1 = D->xo+B->x1+offset+ix* ( xgap+ln ) ;
lowlib.c:          y1 = D->yo+B->y1+offset+iy* ( ygap+wd ) ;
lowlib.c:          if ( D->DrawBkgr != 0 ) _dvrect_fill_transparent ( wc , x1 , y1 , x1+ln+xgap , y1+wd+ygap , D->gc.fill_clr , transparency ) ;
lowlib.c:          if ( B->bkgr == NULL ) bkgr = D->gc.fill_clr;
lowlib.c:          else bkgr = B->bkgr [ k ] ;
lowlib.c:              if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:          uiShadedStringImage ( D , B->titles [ k ] , img , x1+xgap/2 , y1+ygap/2 , ln , wd , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.FontSize , 0 , B->fac , state , B->type ) ;
lowlib.c:      D = N->D;
lowlib.c:      df = * ( N->df ) ;
lowlib.c:      if ( N->type == 10 ) return;
lowlib.c:      xgap = N->xgap;
lowlib.c:      ygap = N->ygap;
lowlib.c:      transparency = D->transparency;
lowlib.c:      if ( D->butattn == 0 ) highli = 0;
lowlib.c:      butn = ( BUT_STR * ) ( N->buts ) ;
lowlib.c:      if ( D->DrawBkgr != 0 ) {
lowlib.c:          if ( N->nodrawbkgr != 1 ) {
lowlib.c://     _dvrect_fill_transparent(wc,x1,y1,x2,y2,D->gc.fill_clr,transparency);
lowlib.c:          _dvrect_fill_transparent ( wc , x1 , y1 , x2 , y2 , D->gc.fill_clr , transparency ) ;
lowlib.c://     else kgImage(D,butn[k].Bimg,x1,y1,(x2-x1+1),(y2-y1+1),0.0,1.0);
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:          kgImage ( D , img , x1 , y1 , x2-x1 , y2-y1 , 0.0 , 1.0 ) ;
lowlib.c:          case -1:
lowlib.c:          kgImage ( D , img , x1 , y1 , x2-x1 , y2-y1 , 0.0 , 1.0 ) ;
lowlib.c:      if ( bt->sw [ k ] < 1 ) return; //not active
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      x0 = x1; y0 = EVGAY-y1;
lowlib.c:      l = abs ( x2-x1 ) ; w = abs ( y2 -y1 ) ;
lowlib.c:      n = bt->nxb*bt->nyb;
lowlib.c:      if ( ( bt->xpm != NULL ) && ( bt->xpm [ k ] != NULL ) ) xpm = bt->xpm [ k ] ;
lowlib.c:      if ( k+1 == bt->df ) highli = 1;
lowlib.c:          if ( bt->xpm [ k+2*n ] != NULL ) xpm = bt->xpm [ k+2*n ] ;
lowlib.c:      if ( D->butattn == 0 ) highli = 0;
lowlib.c:      xgap = bt->xgap/2;
lowlib.c:      ygap = bt->ygap/2;
lowlib.c:      _uirect_fill_transparent ( wc , x1-xgap , y1+ygap , x2+xgap , y2-ygap , D->gc.fill_clr , transparency ) ;
lowlib.c:      if ( bt->bkgr == NULL ) bkgr = D->gc.fill_clr;
lowlib.c:      else bkgr = bt->bkgr [ k ] ;
lowlib.c:          if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:      uiShadedStringImage ( D , bt->title [ k ] , xpm , x0 , y0 , l , w , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.FontSize , 0 , bt->fac , 0 , bt->type ) ;
lowlib.c:      if ( bt->sw [ k ] < 1 ) return; //not active
lowlib.c:      xgap = bt->xgap/2;
lowlib.c:      ygap = bt->ygap/2;
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      if ( D->kbattn != 1 ) return;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c://   _uirect_fill_transparent(wc,x1+1,y1-1,x2-1,y2+1,D->gc.fill_clr,transparency);
lowlib.c:      _uirect_fill_transparent ( wc , x1-xgap , y1+ygap , x2+xgap , y2-ygap , D->gc.fill_clr , transparency ) ;
lowlib.c:      if ( bt->bkgr == NULL ) bkgr = D->gc.fill_clr;
lowlib.c:      else bkgr = bt->bkgr [ k ] ;
lowlib.c:      if ( bkgr < 0 ) bkgr = D->gc.fill_clr;
lowlib.c:      uiShadedString ( D , bt->title [ k ] , x1 , D->evgay- ( y1 ) , ( x2-x1 ) , \
lowlib.c:       ( y1-y2 ) , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.FontSize , 0 , bt->fac , 0 , bt->type ) ;
lowlib.c:      if ( ( bt->xpm != NULL ) && ( bt->xpm [ k ] != NULL ) ) {
lowlib.c:          _ui_jpg_newdraw ( bt , k , x1 , EVGAY-y2 , x2 , EVGAY-y1 , bkgr , 0.0 , 1.0 ) ;
lowlib.c://   if(bt->sw[k]< 1) return; //not active
lowlib.c:      if ( bt->sw [ k ] != 1 ) return; //Need not Draw
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _uidraw_line ( wc , x1+1 , y1-1 , x2-1 , y1-1 ) ;
lowlib.c:      _uidraw_line ( wc , x1+1 , y1-1 , x1+1 , y2+1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uidraw_line ( wc , x1+1 , y2+1 , x2-1 , y2+1 ) ;
lowlib.c:      _uidraw_line ( wc , x2-1 , y1-1 , x2-1 , y2+1 ) ;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      if ( ( bt->nyb ) > 1 ) ygap = ( ( float ) ( ( bt->y2-bt->y1 ) -height*bt->nyb ) / \
lowlib.c:       ( bt->nyb-1.0 ) +0.5 ) ;
lowlib.c:      if ( ( bt->nxb ) > 1 ) xgap = ( float ) ( ( bt->x2-bt->x1 ) -width*bt->nxb ) / \
lowlib.c:       ( bt->nxb-1.0 ) +0.5;
lowlib.c:      for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:          yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:          for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:              xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:              if ( ( bt->sw [ k ] == 1 ) || ( bt->sw [ k ] == 3 ) ) {
lowlib.c:                  if ( bt->D->butattn ) {
lowlib.c:                      if ( k+1 == bt->df ) {
lowlib.c:                          uidraw_depre ( ( bt->D ) , xx-bt->Hsize , yy+height+bt->Hsize , xx+width+bt->Hsize , yy-bt->Hsize ) ;
lowlib.c:                          _ui_rmv_inset_protru ( ( bt->D ) , xx-bt->Hsize , yy+height+bt->Hsize , xx+width+bt->Hsize , yy-bt->Hsize ) ;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      if ( ( bt->nyb ) > 1 ) ygap = ( ( float ) ( ( bt->y2-bt->y1 ) -height*bt->nyb ) / \
lowlib.c:       ( bt->nyb-1.0 ) +0.5 ) ;
lowlib.c:      if ( ( bt->nxb ) > 1 ) xgap = ( float ) ( ( bt->x2-bt->x1 ) -width*bt->nxb ) / \
lowlib.c:       ( bt->nxb-1.0 ) +0.5;
lowlib.c:      for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:          for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:                  yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:                  xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:                  _ui_draw_pressed_newbutton ( xx , yy+height , xx+width , yy , bt , k , bt->D->transparency ) ;
lowlib.c:      uiUpdateOff ( bt->D ) ;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      if ( ( bt->nyb ) > 1 ) ygap = ( ( float ) ( ( bt->y2-bt->y1 ) -height*bt->nyb ) / \
lowlib.c:       ( bt->nyb-1.0 ) +0.5 ) ;
lowlib.c:      if ( ( bt->nxb ) > 1 ) xgap = ( float ) ( ( bt->x2-bt->x1 ) -width*bt->nxb ) / \
lowlib.c:       ( bt->nxb-1.0 ) +0.5;
lowlib.c:      for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:          yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:          for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:              xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:              if ( ( bt->sw [ k ] == 1 ) || ( bt->sw [ k ] == 3 ) ) {
lowlib.c:                  if ( bt->D->butattn ) {
lowlib.c:                      if ( k+1 == bt->df ) {
lowlib.c:                          uidraw_depre ( bt->D , xx-bt->Hsize , yy+height+bt->Hsize , xx+width+bt->Hsize , yy-bt->Hsize ) ;
lowlib.c:                          _ui_rmv_inset_protru ( bt->D , xx-bt->Hsize , yy+height+bt->Hsize , xx+width+bt->Hsize , yy-bt->Hsize ) ;
lowlib.c:      uiUpdateOn ( bt->D ) ;
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      ygap = bt->ygap;
lowlib.c:      xgap = bt->xgap;
lowlib.c:      for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:          yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:          for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:              xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:              _ui_draw_newbutton ( xx , yy+height , xx+width , yy , bt , k , bt->D->transparency ) ;
lowlib.c:      if ( B->code == 'n' ) {
lowlib.c:          if ( N->hide == 1 ) return;
lowlib.c:      else if ( B->hide == 1 ) return;
lowlib.c:      for ( j = 0; j < ( B->ny ) ; j++ ) {
lowlib.c:          for ( i = 0; i < ( B->nx ) ; i++ ) {
lowlib.c:      if ( N->hide == 1 ) return;
lowlib.c:      for ( j = 0; j < ( N->ny ) ; j++ ) {
lowlib.c:          for ( i = 0; i < ( N->nx ) ; i++ ) {
lowlib.c:      D = ( DIALOG * ) ( bt->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      width = bt->b_w; height = bt->b_h;
lowlib.c:      if ( ( bt->nyb ) > 1 ) ygap = ( ( float ) ( ( bt->y2-bt->y1 ) -height*bt->nyb ) / \
lowlib.c:       ( bt->nyb-1.0 ) +0.5 ) ;
lowlib.c:      if ( ( bt->nxb ) > 1 ) xgap = ( float ) ( ( bt->x2-bt->x1 ) -width*bt->nxb ) / \
lowlib.c:       ( bt->nxb-1.0 ) +0.5;
lowlib.c:      for ( j = 0; j < ( bt->nyb ) ; j++ ) {
lowlib.c:          yy = bt->y2- j* ( bt->b_h+ygap ) -bt->b_h;
lowlib.c:          for ( i = 0; i < ( bt->nxb ) ; i++ ) {
lowlib.c:              xx = bt->x1+ i* ( bt->b_w+xgap ) ;
lowlib.c:              _ui_draw_newbutton ( xx , yy+height , xx+width , yy , bt , k , D->transparency ) ;
lowlib.c:      Hsize = D->Hsize;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      while ( ( b->prompt [ i ] ) == ' ' ) i++;
lowlib.c:      while ( ( b->prompt [ i+n ] ) != '\0' ) n++;
lowlib.c:      if ( b->nx <= 1 ) b->xgap = 0;
lowlib.c:      if ( b->ny <= 1 ) b->ygap = 0;
lowlib.c://   uidia_message(D,b->x1+x1,b->y1+12+y1+b->width/2,b->prompt+i);
lowlib.c:      uiString ( D , b->prompt+i , b->x1+x1 , b->y1+y1+b->width/2-10 , n*9-5 , 20 , D->gc.PromptFont , D->gc.txt_pchar , D->gc.FontSize , 1 , D->gc.fill_clr ) ;
lowlib.c:      b->buts = make_but_str ( D , b->x1+x1+lngth , b->y1+y1+Hsize+2 , b->xgap , b->ygap , b->nx , b->ny , b->lngth , b->width , * \
lowlib.c:       ( b->df ) , b->titles , b->xpm , b->bkgr , NULL ) ;
lowlib.c:      buts = ( BUTS * ) ( b->buts ) ;
lowlib.c:      buts->D = D;
lowlib.c:      buts->Hsize = D->Hsize;
lowlib.c://   b->x2 = b->x1+lngth+b->nx*(b->lngth+b->xgap)-b->xgap+(Hsize+2);
lowlib.c://   b->y2 = b->y1+2*Hsize+2+b->ny*(b->width+b->ygap)-b->ygap+(Hsize+2);
lowlib.c:      if ( b->code == 'N' ) {
lowlib.c:          n = b->nx*b->ny;
lowlib.c:          for ( i = 0; i < n; i++ ) buts->sw [ i ] = 2;
lowlib.c:      _uiDrawButns ( ( BUTS * ) ( b->buts ) ) ;
lowlib.c://   DR_BUTNS((BUTS *)(b->buts),0);
lowlib.c:      Hsize = D->Hsize;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      while ( ( b->prompt [ i ] ) == ' ' ) i++;
lowlib.c:      while ( ( b->prompt [ i+n ] ) != '\0' ) n++;
lowlib.c:      if ( b->nx <= 1 ) b->xgap = 0;
lowlib.c:      if ( b->ny <= 1 ) b->ygap = 0;
lowlib.c://   uiString(D,b->prompt+i,b->x1+x1,b->y1+y1+b->width/2-10,n*9-5,20,D->gc.PromptFont,D->gc.txt_pchar,D->gc.FontSize,1,D->gc.fill_clr);
lowlib.c:      uiString ( D , b->prompt+i , b->x1+x1 , b->y1+y1 , n*9-5 , b->width , D->gc.PromptFont , D->gc.txt_pchar , D->gc.FontSize , 1 , D->gc.fill_clr ) ;
lowlib.c:      b->buts = make_but_str ( D , b->x1+x1+lngth , b->y1+y1+Hsize+2 , b->xgap , b->ygap , b->nx , b->ny , b->lngth , b->width , * \
lowlib.c:       ( b->df ) , b->titles , b->xpm , b->bkgr , NULL ) ;
lowlib.c:      buts = ( BUTS * ) ( b->buts ) ;
lowlib.c:      buts->D = D;
lowlib.c:      buts->Hsize = D->Hsize;
lowlib.c:      buts->type = b->type;
lowlib.c:      buts->fac = b->fac;
lowlib.c:      if ( b->code == 'N' ) {
lowlib.c:          n = b->nx*b->ny;
lowlib.c:          for ( i = 0; i < n; i++ ) buts->sw [ i ] = 2;
lowlib.c:      _uiDrawNewButns ( ( BUTS * ) ( b->buts ) ) ;
lowlib.c:      D = b->D;
lowlib.c:      x1 = b->x1+D->xo;
lowlib.c:      x2 = b->x2+D->xo;
lowlib.c:      y1 = b->y1+D->yo;
lowlib.c:      y2 = b->y2+D->yo;
lowlib.c:      if ( b->code != 'n' ) {
lowlib.c:          buts = ( BUTS * ) ( b->buts ) ;
lowlib.c:              buts->xpm = b->xpm;
lowlib.c:              buts->bkgr = b->bkgr;
lowlib.c:      if ( b->hide != 1 ) {
lowlib.c:          if ( b->bordr == 1 ) {
lowlib.c:               ( x2-2 ) , ( y2-2 ) , D->gc.high_clr ) ;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      D = b->D;
lowlib.c:      x1 = b->x1+D->xo;
lowlib.c:      x2 = b->x2+D->xo;
lowlib.c:      y1 = b->y1+D->yo;
lowlib.c:      y2 = b->y2+D->yo;
lowlib.c:      buts = ( BUT_STR * ) b->buts;
lowlib.c:          n = b->nx*b->ny;
lowlib.c:      n = b->nx*b->ny;
lowlib.c:              DoInAnyThread ( D->ThInfo , _uiMakeButnImages , buts+k ) ;
lowlib.c:      WaitThreads ( D->ThInfo ) ;
lowlib.c:          n = b->nx*b->ny;
lowlib.c:      if ( b->type == 10 ) return ret;
lowlib.c:      if ( b->hide != 1 ) {
lowlib.c:          if ( b->bordr == 1 ) {
lowlib.c:               ( x2-2 ) , ( y2-2 ) , D->gc.high_clr ) ;
lowlib.c:               ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      lngth = D->Hsize+2;
lowlib.c:      b->buts = make_but_str ( D , b->x1+x1+lngth , b->y1+y1+lngth , b->xgap , b->ygap , b->nx , b->ny , b->lngth , b->width , * \
lowlib.c:       ( b->df ) , b->titles , b->xpm , b->bkgr , b->sw ) ;
lowlib.c:      buts = ( BUTS * ) ( b->buts ) ;
lowlib.c:      buts->D = D;
lowlib.c:      buts->Hsize = D->Hsize;
lowlib.c:      buts->type = b->type;
lowlib.c:      buts->fac = b->fac;
lowlib.c://   _uiDrawNewButns((BUTS *)(b->buts));
lowlib.c:      if ( b->hide != 1 ) {
lowlib.c:          D = b->D;
lowlib.c:          x1 = b->x1+D->xo;
lowlib.c:          x2 = b->x2+D->xo;
lowlib.c:          y1 = b->y1+D->yo;
lowlib.c:          y2 = b->y2+D->yo;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      else if ( clr >= 0 ) _uibox_fill ( wc , x1 , EVGAY-y1 , x2 , EVGAY-y2 , clr ) ;
lowlib.c:      if ( D->DrawBkgr != 0 ) {
lowlib.c:          _dvbordertype0 ( D , x1- ( offset ) , y1- ( offset ) , x2+ \
lowlib.c:           ( offset ) , y2+ ( offset ) , D->gc.vbright ) ;
lowlib.c:      g = D->d [ i ] .g;
lowlib.c:      dc = g->dc;
lowlib.c:      evgax = D->evgax;
lowlib.c:      evgay = D->evgay;
lowlib.c:      x1 = g->x1+D->xo;
lowlib.c:      x2 = g->x2+D->xo;
lowlib.c:      y1 = ( g->y2+D->yo ) ;
lowlib.c:      y2 = ( g->y1+D->yo ) ;
lowlib.c://   y1 =  evgay-y1;
lowlib.c://   y2 =  evgay-y2;
lowlib.c:      uidraw_g_box ( ( D ) , x1 , y2 , x2 , y1 , g->bkgr_clr , g->xpm ) ;
lowlib.c:      D = g->D;
lowlib.c:      if ( g->hide != 1 ) {
lowlib.c:          dc = g->dc;
lowlib.c:          evgax = D->evgax;
lowlib.c:          evgay = D->evgay;
lowlib.c:          x1 = g->x1+D->xo;
lowlib.c:          x2 = g->x2+D->xo;
lowlib.c:          y1 = ( g->y2+D->yo ) ;
lowlib.c:          y2 = ( g->y1+D->yo ) ;
lowlib.c://   y1 =  evgay-y1;
lowlib.c://   y2 =  evgay-y2;
lowlib.c:          uidraw_g_box ( ( D ) , x1 , y2 , x2 , y1 , g->bkgr_clr , g->xpm ) ;
lowlib.c:          D = g->D;
lowlib.c:          x1 = g->x1+D->xo-offset-1;
lowlib.c:          x2 = g->x2+D->xo+offset+1;
lowlib.c:          y1 = g->y1+D->yo-offset-1;
lowlib.c:          y2 = g->y2+D->yo+offset+1;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      while ( i >= pos ) { s [ i+1 ] = s [ i ] ; i--; }
lowlib.c:      return pt->df*pt->cf+pt->sh;
lowlib.c:      return ( int ) ( pt->df*pt->cf+pt->sh+0.5 ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      l = pt->l+2*w+6;
lowlib.c:      x = pt->x;
lowlib.c:      y = pt->y;
lowlib.c:      _dvrect_fill_transparent ( wc , x , y-w , x+l , y-1 , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      y = EVGAY-y;
lowlib.c://   _uirect_fill(wc,x,y+w,x+l,y+1,pt->fill_clr);
lowlib.c:      if ( pt->code == 'f' ) {
lowlib.c:          val = pt->df*pt->cf+pt->sh;
lowlib.c:          sprintf ( buf , "%-lg" , val ) ;
lowlib.c:          val = pt->df*pt->cf+pt->sh;
lowlib.c://     sprintf(buf,"%-ld",(int)(val+0.5));
lowlib.c:          sprintf ( buf , "%-d" , ( int ) ( val+0.5 ) ) ;
lowlib.c:      uiwrite_string ( D , buf , x , EVGAY-pt->y+4 , pt->char_clr ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:      ww = w/2; xx = x+ ( 2*w ) /5; yy = y-w/4;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x+w ) ;
lowlib.c:      _uihori_line ( wc , x , x+w , y-w ) ;
lowlib.c:      for ( i = -1; i < ww/2; i++ ) {
lowlib.c:          _uivert_line ( wc , yy-i , yy-ww+i , xx+i ) ;
lowlib.c:      ww = w/2; xx = x+w- ( 2*w ) /5; yy = y-w/4;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x+w ) ;
lowlib.c:      _uihori_line ( wc , x , x+w , y-w ) ;
lowlib.c:      for ( i = -1; i < ww/2; i++ ) {
lowlib.c:          _uivert_line ( wc , yy-i , yy-ww+i , xx-i ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      uiShadedString ( D , "!f35t" , x-3 , EVGAY-y-1 , w , w+1 , 35 , D->gc.scroll_fill , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c://   uiShadedString(D,"!f35!w32!xs", x+3, EVGAY-y-1, w,w+1,35,D->gc.fill_clr,0,D->gc.v_dim,D->gc.FontSize-1,0,rfac,1,type);
lowlib.c:      uiShadedString ( D , "!f35s" , x+3 , EVGAY-y-1 , w , w+1 , 35 , D->gc.scroll_fill , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      uiShadedString ( D , "!f35t" , x , y , w-1 , w , 35 , D->gc.scroll_fill , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c://   uiShadedString(D,"!f35!w32!xs", x+3, EVGAY-y-1, w,w+1,35,D->gc.fill_clr,0,D->gc.v_dim,D->gc.FontSize-1,0,rfac,1,type);
lowlib.c:      uiShadedString ( D , "!f35s" , x , y , w-1 , w , 35 , D->gc.scroll_fill , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = D->gc;
lowlib.c:      x = pt->x;
lowlib.c:      y = pt->y;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      sw = pt->Sw;
lowlib.c:      l = pt->l+2*w+6;
lowlib.c:      y = EVGAY-y;
lowlib.c:      _uirect_fill ( wc , x , y+w , x+l , y-w , gc.fill_clr ) ;
lowlib.c:      _uirect_fill ( wc , x+w+1+sw/2 , y-pt->Sdpw , x+l-w-1-sw/2 , y+pt->Sdpw-w , gc.fill_clr ) ;
lowlib.c:      uidraw_depre ( D , x+w+1 , y-Sdpw , x+l-w-1 , y+Sdpw-w ) ;
lowlib.c:      _ui_right_dir ( D , x+2 , y-2 , w-4 , gc.vbright ) ;
lowlib.c:      _ui_left_dir ( D , x+l-w+2 , y-2 , w-4 , gc.vbright ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = D->gc;
lowlib.c:      x = pt->x;
lowlib.c:      y = pt->y;
lowlib.c:      Widget = ( DID * ) pt->Widget;
lowlib.c:      x1 = D->xo+Widget->x1;
lowlib.c:      y1 = D->yo+Widget->y1;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      sw = pt->Sw;
lowlib.c:      l = pt->l+2*w+6;
lowlib.c://   _dvrect_fill_transparent(wc,x,y-w-3,x+l,y+w+3,gc.fill_clr,D->transparency);
lowlib.c:      kgRestoreImagePart ( D , Bimg , x , y-w-3 , \
lowlib.c:       ( x-x1 ) , - ( y1-y+w+3 ) , l+1 , w+w+7 ) ;
lowlib.c:      y = EVGAY-y;
lowlib.c://   _uirect_fill(wc,x,y+w,x+l,y-w,gc.fill_clr);
lowlib.c://   _uirect_fill(wc,x+w+1+sw/2,y-pt->Sdpw,x+l-w-1-sw/2,y+pt->Sdpw-w,gc.fill_clr);
lowlib.c://   uidraw_depre(D,x+w+1,y-Sdpw,x+l-w-1,y+Sdpw-w);
lowlib.c:      _ui_right_dir ( D , x+2 , y-2 , w-4 , gc.vbright ) ;
lowlib.c:      _ui_left_dir ( D , x+l-w+2 , y-2 , w-4 , gc.vbright ) ;
lowlib.c:      D = f->D;
lowlib.c:      pt = f->sptr;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:      x = pt->x;
lowlib.c:      y = pt->y;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      sw = pt->Sw;
lowlib.c:      l = pt->l+2*w+6;
lowlib.c://   _rect_fill(x,y+w,x+l,y-w,pt->fill_clr);
lowlib.c:      switch ( f->type ) {
lowlib.c:          y = EVGAY-y;
lowlib.c:          _uirect_fill_transparent ( wc , x+w+1+sw/2 , y-pt->Sdpw , x+l-w-1-sw/2 , y+pt->Sdpw-w , pt->fill_clr , D->transparency ) ;
lowlib.c://      uidraw_depre(D,x+w+1,y-pt->Sdpw,x+l-w-1,y+pt->Sdpw-w);
lowlib.c://     _dvrect_fill(wc,x+w+1+sw/2,y+w/2-1,x+l-w-1-sw/2,y+w/2+1,gc->v_dim);
lowlib.c:      D = B->D;
lowlib.c:      pt = B->sptr;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:      Bimg = B->Bimg;
lowlib.c:      x = pt->x , y = pt->y , l = pt->l;
lowlib.c:      sx = pt->df;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      sw = pt->Sw;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      x1 = B->x1+offset+D->xo;
lowlib.c:      y1 = B->y1+offset+D->yo;
lowlib.c:      x2 = B->x2-offset+D->xo;
lowlib.c:      y2 = B->y2-offset+D->yo;
lowlib.c:      _dvrect_fill_transparent ( wc , x1 , y1 , x2 , y2 , gc->fill_clr , D->transparency ) ;
lowlib.c:      kgRestoreImage ( D , Bimg , x1 , y1 , ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      Wd = pt->Sldwd;
lowlib.c:      w = pt->Sw;
lowlib.c:      l = pt->l;
lowlib.c:      x1 = pt->x;
lowlib.c:      y1 = pt->y;
lowlib.c:      switch ( B->type ) {
lowlib.c:          switch ( B->direction ) {
lowlib.c:              x1 = pt->x-Wd/2-of/2;
lowlib.c:              y1 = pt->y - w/2-of/2;
lowlib.c:              kgImage ( D , pt->bimg , x1 , y1 , l+Wd+of , w+of , 0.0 , 1.0 ) ;
lowlib.c:              x1 = pt->x+pt->df-Wd/2-of/2;
lowlib.c:              y1 = pt->y -w/2-of/2;
lowlib.c:              kgImage ( D , pt->fimg , x1 , y1 , Wd+of , w+of , 0.0 , 1.0 ) ;
lowlib.c:              y1 = pt->y-Wd/2-of/2;
lowlib.c:              x1 = pt->x - w/2-of/2;
lowlib.c:              kgImage ( D , pt->bimg , x1 , y1 , w+of , l+Wd+of , 0.0 , 1.0 ) ;
lowlib.c:              y1 = pt->y+B->lngth-pt->df-Wd/2-of/2;
lowlib.c:              x1 = pt->x -w/2-of/2;
lowlib.c:              kgImage ( D , pt->fimg , x1 , y1 , w+of , Wd+of , 0.0 , 1.0 ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:      Widget = ( DID * ) pt->Widget;
lowlib.c:      xo = D->xo+Widget->x1;
lowlib.c:      yo = D->yo+Widget->y1;
lowlib.c:      x = pt->x , y = pt->y , l = pt->l;
lowlib.c:      sx = pt->df;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      sw = pt->Sw;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      y = EVGAY-y;
lowlib.c:      x1 = x+w+2; y1 = y-4; x2 = x+l-w-2; y2 = y-w+4;
lowlib.c:      _uirect_fill_transparent ( wc , x1-2 , y1+5 , x2+2 , y2-5 , gc->fill_clr , D->transparency ) ;
lowlib.c:      _uirect_fill ( wc , x1+1 , y1-1 , x2-2 , y2+2 , gc->fill_clr ) ;
lowlib.c:      kgRestoreImagePart ( D , Bimg , x1-2 , EVGAY-y1-5 , ( x1-2-xo ) , \
lowlib.c:       ( EVGAY-y1-4-yo ) , ( x2+5-x1 ) , abs ( y2-9-y1 ) ) ;
lowlib.c:      kgRestoreImagePart ( D , Bimg , x1+1 , EVGAY-y1+1 , ( x1+1-xo ) , \
lowlib.c:       ( EVGAY-y1+2-yo ) , ( x2-2-x1 ) , abs ( y2+4-y1 ) ) ;
lowlib.c:      _uirect_fill ( wc , x+w+1+sw/2 , y-pt->Sdpw , x+l-w-1-sw/2 , y+pt->Sdpw-w , gc->dim ) ;
lowlib.c:      uidraw_depre ( D , x+w+1+sw/2 , y-pt->Sdpw , x+l-w-1-sw/2 , y+pt->Sdpw-w ) ;
lowlib.c:      if ( sx+sw > x2 ) sx = x2-sw-1;
lowlib.c:      _uirect_fill ( wc , sx , y1+2 , sx+sw , y2-2 , gc->fill_clr ) ;
lowlib.c:      uiset_clr ( D , gc->vbright ) ;
lowlib.c:      _uihori_line ( wc , sx+1 , sx+sw-1 , y1+1 ) ;
lowlib.c:      _uivert_line ( wc , y1+2 , y2-2 , sx ) ;
lowlib.c:      _uivert_line ( wc , y1+1 , y2-1 , sx+1 ) ;
lowlib.c:      uiset_clr ( D , gc->v_dim ) ;
lowlib.c:      _uihori_line ( wc , sx , sx+sw , y2-2 ) ;
lowlib.c:      _uivert_line ( wc , y1+2 , y2-2 , sx+sw ) ;
lowlib.c:      uiset_clr ( D , gc->dim ) ;
lowlib.c:      _uihori_line ( wc , sx+1 , sx+sw-1 , y2-1 ) ;
lowlib.c:      _uivert_line ( wc , y1+1 , y2-1 , sx+sw-1 ) ;
lowlib.c:      uiset_clr ( D , gc->vbright ) ;
lowlib.c:      _uivert_line ( wc , y1-1 , y2+1 , ( int ) ( sx+sw/2-0.5 ) ) ;
lowlib.c:      uiset_clr ( D , gc->v_dim ) ;
lowlib.c:      _uivert_line ( wc , y1-1 , y2+1 , ( int ) ( sx+sw/2+0.5 ) ) ;
lowlib.c:      if ( f->code == 'f' ) {
lowlib.c:          ptr = f->sptr;
lowlib.c:          D = f->D;
lowlib.c:          ptr = ( ( DID * ) tmp )->sptr;
lowlib.c:          D = ( ( DID * ) tmp )->D;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:          printf ( "Error: Wrong slide-bar limits: min=%d max=%d\n" , min , max ) ;
lowlib.c:      if ( ( df-min ) * ( max-df ) < 0 ) df = ( max+min ) /2;
lowlib.c:      ptr->x = x;
lowlib.c:      ptr->y = y;
lowlib.c:      ptr->l = l;
lowlib.c:      ptr->df = df;
lowlib.c:      ptr->min = min;
lowlib.c:      ptr->max = max;
lowlib.c:      ptr->fac = fac;
lowlib.c:      ptr->code = ch;
lowlib.c:      ptr->cf = cf;
lowlib.c:      ptr->sh = sh;
lowlib.c:      ptr->Sdpw = Sdpw;
lowlib.c:      ptr->Sw = Sw;
lowlib.c:      ptr->Sldwd = Sldwd;
lowlib.c:      ptr->D = D;
lowlib.c:      ptr->fill_clr = gc->fill_clr;
lowlib.c:      ptr->char_clr = gc->char_clr;
lowlib.c:      ptr->slide_fill_clr = gc->txt_fill;
lowlib.c:      ptr->bright_clr = gc->vbright;
lowlib.c:      D = f->D;
lowlib.c:      x1 = f->x1+D->xo;
lowlib.c:      x2 = f->x2+D->xo;
lowlib.c:      y1 = f->y1+D->yo;
lowlib.c:      y2 = f->y2+D->yo;
lowlib.c:      if ( f->hide != 1 ) {
lowlib.c:          if ( f->Bimg == NULL ) f->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c://  else kgRestoreImage(D,f->Bimg,x1,y1,(x2-x1+1),(y2-y1+1));
lowlib.c:          ptr = f->sptr;
lowlib.c:          if ( f->prompt != NULL ) {
lowlib.c:              while ( ( f->prompt [ i ] ) == ' ' ) i++;
lowlib.c:              while ( ( f->prompt [ n+i ] ) >= ' ' ) n++;
lowlib.c://        uiString(D,f->prompt+i,f->x1+D->xo+2,f->y1+D->yo+21,n*9-5,20,D->gc.PromptFont,D->gc.txt_pchar,D->gc.FontSize,1,D->gc.fill_clr);
lowlib.c:                  uiString ( D , f->prompt+i , f->x1+D->xo+2 , f->y1+D->yo+21 , n*9-5 , 20 , D->gc.PromptFont , D->gc.txt_pchar , D->gc.FontSize , 1 , -1 ) ;
lowlib.c:          D = f->D;
lowlib.c:          x1 = f->x1+D->xo;
lowlib.c:          x2 = f->x2+D->xo;
lowlib.c:          y1 = f->y1+D->yo;
lowlib.c:          y2 = f->y2+D->yo;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( f->Bimg != NULL ) kgRestoreImage ( D , f->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      D = f->D;
lowlib.c:      x1 = f->x1+D->xo;
lowlib.c:      x2 = f->x2+D->xo;
lowlib.c:      y1 = f->y1+D->yo;
lowlib.c:      y2 = f->y2+D->yo;
lowlib.c:      if ( f->hide != 1 ) {
lowlib.c:          if ( f->Bimg == NULL ) f->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c://  else kgRestoreImage(D,f->Bimg,x1,y1,(x2-x1+1),(y2-y1+1));
lowlib.c:          ptr = f->sptr;
lowlib.c:          if ( f->prompt != NULL ) {
lowlib.c:              while ( ( f->prompt [ i ] ) == ' ' ) i++;
lowlib.c:              while ( ( f->prompt [ n+i ] ) >= ' ' ) n++;
lowlib.c://        uiString(D,f->prompt+i,f->x1+D->xo+2,f->y1+D->yo+21,n*9-5,20,D->gc.PromptFont,D->gc.txt_pchar,D->gc.FontSize,1,D->gc.fill_clr);
lowlib.c:                  uiString ( D , f->prompt+i , f->x1+D->xo+2 , f->y1+D->yo+21 , n*9-5 , 20 , D->gc.PromptFont , D->gc.txt_pchar , D->gc.FontSize , 1 , -1 ) ;
lowlib.c:          D = f->D;
lowlib.c:          x1 = f->x1+D->xo;
lowlib.c:          x2 = f->x2+D->xo;
lowlib.c:          y1 = f->y1+D->yo;
lowlib.c:          y2 = f->y2+D->yo;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( f->Bimg != NULL ) kgRestoreImage ( D , f->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      D = f->D;
lowlib.c:      x1 = f->x1+D->xo;
lowlib.c:      x2 = f->x2+D->xo;
lowlib.c:      y1 = f->y1+D->yo;
lowlib.c:      y2 = f->y2+D->yo;
lowlib.c:      if ( f->hide != 1 ) {
lowlib.c:          if ( f->Bimg == NULL ) f->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c://  else kgRestoreImage(D,f->Bimg,x1,y1,(x2-x1+1),(y2-y1+1));
lowlib.c:          ptr = f->sptr;
lowlib.c:          D = f->D;
lowlib.c:          x1 = f->x1+D->xo;
lowlib.c:          x2 = f->x2+D->xo;
lowlib.c:          y1 = f->y1+D->yo;
lowlib.c:          y2 = f->y2+D->yo;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( f->Bimg != NULL ) kgRestoreImage ( D , f->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      D = B->D;
lowlib.c:      gc = & ( D->gc ) ;
lowlib.c:          printf ( "Error: Wrong slide-bar limits: min=%d max=%d\n" , min , max ) ;
lowlib.c:      if ( ( df-min ) * ( max-df ) < 0 ) df = ( max+min ) /2;
lowlib.c:      ptr = ( S_STR * ) B->sptr;
lowlib.c:      ptr->x = x-wd;
lowlib.c:      ptr->y = y;
lowlib.c:      ptr->l = l;
lowlib.c:      ptr->df = df;
lowlib.c:      ptr->min = min;
lowlib.c:      ptr->max = max;
lowlib.c:      ptr->fac = fac;
lowlib.c:      ptr->code = ch;
lowlib.c:      ptr->cf = cf;
lowlib.c:      ptr->sh = sh;
lowlib.c:      ptr->Sdpw = Sdpw;
lowlib.c:      ptr->Sw = Sw;
lowlib.c:      ptr->Sldwd = Sldwd;
lowlib.c:      ptr->D = D;
lowlib.c:      ptr->fill_clr = gc->fill_clr;
lowlib.c:      ptr->char_clr = gc->char_clr;
lowlib.c:      ptr->slide_fill_clr = gc->txt_fill;
lowlib.c:      ptr->bright_clr = gc->vbright;
lowlib.c:      D = v->D;
lowlib.c:      br = v->bwsr;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      v->offset = 0;
lowlib.c:      offset = v->offset;
lowlib.c:      w = v->w;
lowlib.c:      br->tbx1 = br->x2-w-offset ;
lowlib.c:      br->tby1 = br->y1+offset;
lowlib.c:      br->tbx2 = br->tbx1+w;
lowlib.c:      br->tby2 = br->tby1+w;
lowlib.c:      br->bbx1 = br->tbx1;
lowlib.c://   v->bby1=v->y2-v->w+y1+offset/2;
lowlib.c:      br->bby1 = br->y2-w-offset;
lowlib.c:      br->bbx2 = br->bbx1+w;
lowlib.c:      br->bby2 = br->bby1+w;
lowlib.c:      br->rsx1 = br->tbx2+offset;
lowlib.c:      br->rsy1 = br->tby2;
lowlib.c:      br->rsx2 = br->rsx1+w-offset;
lowlib.c:      br->rsy2 = br->bby1;
lowlib.c:      D = v->D;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      v->offset = 0;
lowlib.c:      v->w = ( v->x2-v->x1 ) ;
lowlib.c:      offset = ( v->w ) *0.2;
lowlib.c:      v->tbx1 = v->x1 +x1;
lowlib.c:      v->tby1 = v->y1+y1;
lowlib.c:      v->tbx2 = v->tbx1+v->w;
lowlib.c:      v->tby2 = v->tby1+v->w;
lowlib.c:      v->bbx1 = v->tbx1;
lowlib.c://   v->bby1=v->y2-v->w+y1+offset/2;
lowlib.c:      v->bby1 = v->y2-v->w+y1;
lowlib.c:      v->bbx2 = v->bbx1+v->w;
lowlib.c:      v->bby2 = v->bby1+v->w;
lowlib.c:      v->rsx1 = v->x1+x1+offset;
lowlib.c:      v->rsy1 = v->tby2;
lowlib.c:      v->rsx2 = v->x2+x1-offset;
lowlib.c:      v->rsy2 = v->bby1;
lowlib.c:      v->offset = offset;
lowlib.c:      D = v->D;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      v->offset = 0;
lowlib.c:      v->w = ( v->y2-v->y1 ) ;
lowlib.c:      offset = ( v->w ) *0.2;
lowlib.c:      v->lby1 = v->y1+y1;
lowlib.c:      v->lbx1 = v->x1 +x1;
lowlib.c:      v->lbx2 = v->lbx1+v->w;
lowlib.c:      v->lby2 = v->lby1+v->w;
lowlib.c:      v->rby1 = v->lby1;
lowlib.c://   v->rbx1=x1+v->x2-v->w+offset/2;
lowlib.c:      v->rbx1 = x1+v->x2-v->w+1;
lowlib.c:      v->rbx2 = v->rbx1+v->w;
lowlib.c:      v->rby2 = v->rby1+v->w;
lowlib.c:      v->rsx1 = v->lbx2;
lowlib.c:      v->rsy1 = v->lby1+offset;
lowlib.c:      v->rsx2 = v->x2+x1-v->w;
lowlib.c:      v->rsy2 = v->rby2-offset;
lowlib.c:      v->offset = offset;
lowlib.c:      D = f->D;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      max = f->lngth;
lowlib.c:      sh = f->min;
lowlib.c:      ch = ( f->max -sh ) /max;
lowlib.c:      df = ( * ( f->df ) -sh ) /ch+0.5;
lowlib.c:      sptr = ( S_STR * ) f->sptr;
lowlib.c:      sptr->Widget = f;
lowlib.c:      _ui_setslide ( f , min , max , ( int ) f->x1+lngth+x1+2 , ( int ) f->y1+y1+22 , \
lowlib.c:       ( int ) f->lngth , df , 'f' , ch , sh ) ;
lowlib.c:      D = d->D;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      max = d->lngth;
lowlib.c:      sh = d->min;
lowlib.c:      ch = ( d->max -sh ) /max;
lowlib.c:      df = ( * ( d->df ) -sh ) /ch+0.5;
lowlib.c:      sptr = ( S_STR * ) d->sptr;
lowlib.c:      sptr->Widget = d;
lowlib.c:      _ui_setslide ( d , min , max , ( int ) d->x1+lngth+x1+2 , ( int ) d->y1+y1+22 , \
lowlib.c:       ( int ) d->lngth , df , 'd' , ch , sh ) ;
lowlib.c:      B = ( ( DIALOG * ) tmp )->d [ i ] .B;
lowlib.c:      if ( val < B->min ) val = B->min;
lowlib.c:      if ( val > B->max ) val = B->max;
lowlib.c:      * ( B->df ) = val;
lowlib.c:      pt = ( S_STR * ) B->sptr;
lowlib.c:      pt->df = ( ( val -B->min ) *B->lngth ) / ( B->max - B->min ) ;
lowlib.c:      B = ( ( DIALOG * ) tmp )->d [ i ] .d;
lowlib.c:      if ( val < B->min ) val = B->min;
lowlib.c:      if ( val > B->max ) val = B->max;
lowlib.c:      * ( B->df ) = val;
lowlib.c:      pt = ( S_STR * ) B->sptr;
lowlib.c:      pt->df = ( ( val -B->min ) *B->lngth ) / ( B->max - B->min ) ;
lowlib.c:      B = ( ( DIALOG * ) tmp )->d [ i ] .B;
lowlib.c:      * ( B->df ) = val;
lowlib.c:      pt = ( S_STR * ) B->sptr;
lowlib.c://   pt->df = ((val -B->min)*B->lngth)/(B->max - B->min);
lowlib.c:      val = ( ( pt->df ) * ( B->max - B->min ) ) / ( B->lngth ) +B->min;
lowlib.c:      B = ( ( DIALOG * ) tmp )->d [ i ] .d;
lowlib.c:      * ( B->df ) = val;
lowlib.c:      pt = ( S_STR * ) B->sptr;
lowlib.c://   pt->df = ((val -B->min)*B->lngth)/(B->max - B->min);
lowlib.c:      val = ( ( pt->df ) * ( B->max - B->min ) ) / ( B->lngth ) +B->min;
lowlib.c:      type = B->type-2;
lowlib.c:      color = B->sldclr;
lowlib.c:      pt = B->sptr;
lowlib.c:      D = ( DIALOG * ) B->D;
lowlib.c:          if ( color == -1 ) color = D->gc.fill_clr;
lowlib.c:      w = pt->Sw+of;
lowlib.c:      l = pt->l+pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:       ( float ) ( w+of*0.5 ) , 0 , D->gc.fill_clr , 0.5 ) ;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) 1.0 , -1.0 , ( float ) \
lowlib.c:       ( l-of ) , ( float ) ( w-of ) , 0 , D->gc. vbright , 0.5 ) ;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) -1.0 , 0.0 , ( float ) \
lowlib.c:       ( l-of ) , ( float ) ( w-of ) , 0 , D->gc.v_dim , 0.5 ) ;
lowlib.c:       ( l-of ) , ( float ) ( w-of ) , 0 , D->gc.dim , 0.5 ) ;
lowlib.c:// kgRoundedRectanglePressed(fid,0.,0.,(float)l,(float)w,D->gc.v_dim,0.5,1);
lowlib.c:      pt->bimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      l = pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      xsize = ( l-of ) -0.5*of; ysize = ( w-of ) -0.5*of;
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:// kgRoundedRectangleFill(fid,(float)0.0,0.0,(float)(l-of),(float)(w-of),0,fillcolor,0.5);
lowlib.c:// kgRoundedRectangleRaised(fid,0.,0.,(float)(l-of),(float)(w-of),fillcolor,0.5,1);
lowlib.c:      kgRoundedRectangleFill ( fid , -1.0 , 0.0 , ( float ) xsize , \
lowlib.c:      kgRoundedRectangleFill ( fid , 1.0 , -1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , 1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , 1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , +1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , 0.5 , ( float ) xsize , \
lowlib.c:       ( float ) ysize+1.0 , D->gc.v_dim , rfac , 0.5 ) ;
lowlib.c:      kgMove2f ( fid , -1.0 , ysize*.5-1 ) ;
lowlib.c:      kgDraw2f ( fid , -1.0 , -ysize*.5+1 ) ;
lowlib.c:      kgMove2f ( fid , -.0 , ysize*.5-1 ) ;
lowlib.c:      kgDraw2f ( fid , -.0 , -ysize*.5+1 ) ;
lowlib.c:      pt->fimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      type = B->type-2;
lowlib.c:      color = B->sldclr;
lowlib.c:      pt = B->sptr;
lowlib.c:      D = ( DIALOG * ) B->D;
lowlib.c:          if ( color == -1 ) color = D->gc.fill_clr;
lowlib.c:      w = pt->Sw+of;
lowlib.c:      l = pt->l+pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      fillcolor = D->gc.fill_clr;
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:      kgRoundedRectanglePressed ( fid , 0. , 0. , ( float ) ( l-of ) , \
lowlib.c:       ( float ) ( w-of ) , D->gc.fill_clr , 0.5 , 3 ) ;
lowlib.c:      kgRoundedRectangleFill ( fid , 0. , 0. , ( float ) ( l-of-4.5 ) , \
lowlib.c:       ( float ) ( w-of-4.5 ) , 0 , 15 , 0.5 ) ;
lowlib.c:      pt->bimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      l = pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      xsize = ( l-of ) -0.5*of; ysize = ( w-of ) -0.5*of;
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:      kgRoundedRectangleRaised ( fid , 0. , 0. , ( float ) ( l-of ) , \
lowlib.c:       ( float ) ( w-of ) , fillcolor , 0.5 , 1 ) ;
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , 1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , 1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , +1.0 , ( float ) xsize , \
lowlib.c:          kgRoundedRectangleFill ( fid , -1.0 , 0.5 , ( float ) xsize , \
lowlib.c:      kgMove2f ( fid , -0.0 , ysize*.5-1 ) ;
lowlib.c:      kgDraw2f ( fid , -0.0 , -ysize*.5+1 ) ;
lowlib.c:      kgMove2f ( fid , 1.0 , ysize*.5-1 ) ;
lowlib.c:      kgDraw2f ( fid , 1.0 , -ysize*.5+1 ) ;
lowlib.c:      pt->fimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      if ( B->direction == 1 ) {
lowlib.c:          timg = kgRotateImage ( pt->fimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->fimg ) ;
lowlib.c:          pt->fimg = timg;
lowlib.c:          kgFlipImage ( pt->fimg ) ;
lowlib.c:          timg = kgRotateImage ( pt->bimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->bimg ) ;
lowlib.c:          pt->bimg = timg;
lowlib.c:          kgFlipImage ( pt->bimg ) ;
lowlib.c:      type = B->type;
lowlib.c:      color = B->sldclr;
lowlib.c:      pt = B->sptr;
lowlib.c:      D = ( DIALOG * ) B->D;
lowlib.c:          if ( color == -1 ) color = D->gc.fill_clr;
lowlib.c:      l = pt->l+pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5-0.1 , - ( float ) w*0.5-0.1 , \
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:// kgRoundedRectangleFill(fid,(float).5,-.5,(float)(pt->l+3),(float)(3),0,140,0.5);
lowlib.c:       ( pt->l+3 ) , ( float ) ( 3.0 ) , 0 , fillcolor , 0.5 ) ;
lowlib.c:      pt->bimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      w = pt->Sw+of;
lowlib.c:      l = pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      xsize = ( w-of ) -.75*of; ysize = ( w-of ) -.75*of;
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) -1.0 , 0.0 , ( float ) \
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , 150 , 0.5 ) ;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) 0.5 , -0.5 , ( float ) \
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , 0 , 0.5 ) ;
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , fillcolor , 0.5 ) ;
lowlib.c:// kgRoundedRectangleRaised(fid,0.,0.,(float)(w-of),(float)(w-of),fillcolor,0.5,1);
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) 0.0 , -.0 , ( float ) \
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , 150 , 0.5 ) ;
lowlib.c:       ( w-of-1 ) , ( float ) ( w-of-1 ) , 0 , 153 , 0.5 ) ;
lowlib.c:       ( w-of-3.0 ) , ( float ) ( w-of-3.0 ) , 0 , 152 , 0.5 ) ;
lowlib.c:       ( w-of-6 ) , ( float ) ( w-of-6 ) , 0 , 151 , 0.5 ) ;
lowlib.c:      kgDraw2f ( fid , 0.0 , -ysize*.5 ) ;
lowlib.c:      kgDraw2f ( fid , 1.0 , -ysize*.5 ) ;
lowlib.c:// pt->fimg =  (void *)kgGetResizedImage(fid);
lowlib.c:      pt->fimg = ( void * ) kgGetSmoothImage ( fid ) ;
lowlib.c:      pt->fimg = kgBorderedRectangle ( ( int ) ( w-of ) , \
lowlib.c:       ( int ) ( w-of ) , color , 0.5 ) ;
lowlib.c:      if ( B->direction == 1 ) {
lowlib.c:          timg = kgRotateImage ( pt->fimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->fimg ) ;
lowlib.c:          pt->fimg = timg;
lowlib.c:          kgFlipImage ( pt->fimg ) ;
lowlib.c:          timg = kgRotateImage ( pt->bimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->bimg ) ;
lowlib.c:          pt->bimg = timg;
lowlib.c:          kgFlipImage ( pt->bimg ) ;
lowlib.c:      type = B->type;
lowlib.c:      color = B->sldclr;
lowlib.c:      pt = B->sptr;
lowlib.c:      D = ( DIALOG * ) B->D;
lowlib.c:          if ( color == -1 ) color = D->gc.fill_clr;
lowlib.c:      l = pt->l+pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      kgRoundedRectangleFill ( fid , 0. , 0. , ( float ) ( l-of ) , \
lowlib.c:       ( float ) ( w-of ) , 0 , fillcolor , 0.2 ) ;
lowlib.c:      kgRoundedRectanglePressed ( fid , 0. , 0. , ( float ) ( l-of ) , \
lowlib.c:       ( float ) ( w-of ) , D->gc.fill_clr , 0.2 , 2 ) ;
lowlib.c:      pt->bimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      w = pt->Sw+of;
lowlib.c:      l = pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      xsize = ( l ) -.75*of; ysize = ( w-of ) -.75*of;
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) -1.0 , 0.0 , ( float ) \
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , 15 , 0.5 ) ;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) 0.5 , -0.5 , ( float ) \
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , 0 , 0.5 ) ;
lowlib.c:       ( w-of ) , ( float ) ( w-of ) , 0 , fillcolor , 0.5 ) ;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) -0.5 , 0.5 , \
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) 0.5 , -0.5 , \
lowlib.c:      kgDraw2f ( fid , 0.0 , -ysize*.5 ) ;
lowlib.c:      kgDraw2f ( fid , 1.0 , -ysize*.5 ) ;
lowlib.c:      pt->fimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      if ( B->direction == 1 ) {
lowlib.c:          timg = kgRotateImage ( pt->fimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->fimg ) ;
lowlib.c:          pt->fimg = timg;
lowlib.c:          kgFlipImage ( pt->fimg ) ;
lowlib.c:          timg = kgRotateImage ( pt->bimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->bimg ) ;
lowlib.c:          pt->bimg = timg;
lowlib.c:          kgFlipImage ( pt->bimg ) ;
lowlib.c:      type = B->type;
lowlib.c:      color = B->sldclr;
lowlib.c:      pt = B->sptr;
lowlib.c:      D = ( DIALOG * ) B->D;
lowlib.c:          if ( color == -1 ) color = D->gc.fill_clr;
lowlib.c:      l = pt->l+pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:      kgRoundedRectangleFill ( fid , 0. , 0. , ( float ) ( l-of ) , \
lowlib.c:       ( float ) ( w-of ) , 0 , fillcolor , 0.2 ) ;
lowlib.c:// kgRoundedRectanglePressed(fid,0.,0.,(float)(l-of),(float)(w-of),D->gc.fill_clr,0.2,2);
lowlib.c:      pt->bimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      w = pt->Sw+of;
lowlib.c:      l = pt->Sldwd+of;
lowlib.c:      kgUserFrame ( fid , - ( float ) l*0.5 , - ( float ) w*0.5 , \
lowlib.c:      xsize = ( l ) -.75*of; ysize = ( w-of ) -.75*of;
lowlib.c:          fillcolor = -fillcolor;
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) -0.5 , 0.5 , \
lowlib.c:      kgRoundedRectangleFill ( fid , ( float ) 0.5 , -0.5 , \
lowlib.c:      kgDraw2f ( fid , 0.0 , -ysize*.5 ) ;
lowlib.c:      kgDraw2f ( fid , 1.0 , -ysize*.5 ) ;
lowlib.c:      pt->fimg = ( void * ) kgGetResizedImage ( fid ) ;
lowlib.c:      if ( B->direction == 1 ) {
lowlib.c:          timg = kgRotateImage ( pt->fimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->fimg ) ;
lowlib.c:          pt->fimg = timg;
lowlib.c:          kgFlipImage ( pt->fimg ) ;
lowlib.c:          timg = kgRotateImage ( pt->bimg , 90 ) ;
lowlib.c:          kgFreeImage ( pt->bimg ) ;
lowlib.c:          pt->bimg = timg;
lowlib.c:          kgFlipImage ( pt->bimg ) ;
lowlib.c:      D = d->D;
lowlib.c:      df = * ( d->df ) ;
lowlib.c:      if ( df < d->min ) df = d->min;
lowlib.c:      if ( df > d->max ) df = d->max;
lowlib.c:      * ( d->df ) = df;
lowlib.c:      ptr = ( S_STR * ) d->sptr;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      l = d->x2 -d->x1-4*offset;
lowlib.c:      w = d->y2 -d->y1-4*offset;
lowlib.c:      kgFreeImage ( ptr->bimg ) ;
lowlib.c:      kgFreeImage ( ptr->fimg ) ;
lowlib.c:      ptr->bimg = ptr->fimg = NULL;
lowlib.c:      if ( l >= w ) d->direction = 0;
lowlib.c:      else d->direction = 1;
lowlib.c:      if ( d->direction == 0 ) {
lowlib.c:              d->y2 = w+d->y1+4*offset;
lowlib.c:          lngth = d->x2 -d->x1-4*offset-w*1.61;
lowlib.c:          if ( lngth < 2 ) {lngth = 2; w = ( d->x2 -d->x1-4*offset-lngth ) /1.61; }
lowlib.c:          switch ( d->type ) {
lowlib.c:              ptr->Sldwd = 6;
lowlib.c:              ptr->Sldwd = 6;
lowlib.c:              ptr->Sldwd = w*1.61;
lowlib.c:          lngth = d->x2 -d->x1-4*offset-ptr->Sldwd;
lowlib.c:          w = d->x2 -d->x1-4*offset;
lowlib.c:              d->x2 = w+d->x1+4*offset;
lowlib.c:          lngth = d->y2 -d->y1-4*offset-w*1.61;
lowlib.c:          if ( lngth < 2 ) {lngth = 2; w = ( d->y2 -d->y1-4*offset-lngth ) /1.61; }
lowlib.c:          switch ( d->type ) {
lowlib.c:              ptr->Sldwd = 8;
lowlib.c:              ptr->Sldwd = 6;
lowlib.c:              ptr->Sldwd = w*1.61;
lowlib.c:          lngth = d->y2 -d->y1-4*offset-ptr->Sldwd;
lowlib.c:      d->lngth = lngth;
lowlib.c:      max = d->lngth;
lowlib.c:      sh = d->min;
lowlib.c:      ch = ( d->max -sh ) /max;
lowlib.c:      df = ( * ( d->df ) -sh ) /ch+0.5;
lowlib.c:      switch ( d->direction ) {
lowlib.c:          x = d->x1+x1+2*offset+ptr->Sldwd/2;
lowlib.c:          y = d->y1+y1+2*offset+w/2;
lowlib.c:          x = d->x1+x1+2*offset+w/2;
lowlib.c:          y = d->y1+y1+2*offset+ptr->Sldwd/2;
lowlib.c:          printf ( "Error: Wrong slide-bar limits: min=%d max=%d\n" , min , max ) ;
lowlib.c:      if ( ( df-min ) * ( max-df ) < 0 ) df = ( max+min ) /2;
lowlib.c:      ptr->x = x;
lowlib.c:      ptr->y = y;
lowlib.c:      ptr->l = l;
lowlib.c:      ptr->df = df;
lowlib.c:      ptr->cf = ch;
lowlib.c:      ptr->sh = sh;
lowlib.c:      ptr->min = min;
lowlib.c:      ptr->max = max;
lowlib.c:      ptr->Sdpw = Sdpw;
lowlib.c:      ptr->Sw = w;
lowlib.c:      ptr->D = D;
lowlib.c:      switch ( d->type ) {
lowlib.c:      lngth = XX - ( x->x1+x1 ) +10;
lowlib.c:      ret = put_fbrowser ( x->x1+x1 , x->y1+y1-21 , lngth ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      ww = w/2; xx = x+w/4; yy = y-w+w/2;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      _uirect_fill ( wc , x , y , x+w , y-w , D->gc.fill_clr ) ;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x+w ) ;
lowlib.c:      _uihori_line ( wc , x , x+w , y-w ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      for ( i = -1; i < ww/2; i++ ) {
lowlib.c:          _uihori_line ( wc , xx+i , xx+ww-i , yy+i ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      uiShadedString ( D , "!f35!w32!xs" , x-1 , EVGAY-y-1 , w+2 , w+2 , 35 , D->gc.fill_clr , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      uiShadedString ( D , "!f35!w32!xt" , x-1 , EVGAY-y-1 , w+2 , w+2 , 35 , D->gc.fill_clr , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      uiShadedString ( D , "!f35!w32!xs" , x , y , w , w , 35 , D->gc.scroll_fill , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      uiShadedString ( D , "!f35!w32!xt" , x , y , w , w , 35 , D->gc.scroll_fill , 0 , D->gc.v_dim , D->gc.FontSize-1 , 0 , rfac , 1 , type ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      ww = w/2; xx = x+w/4; yy = y-w/2;
lowlib.c:      _uirect_fill ( wc , x , y , x+w , y-w , D->gc.fill_clr ) ;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      uiset_clr ( D , D->gc.bright ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uivert_line ( wc , y , y-w , x+w ) ;
lowlib.c:      _uihori_line ( wc , x , x+w , y-w ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      for ( i = -1; i < ww/2; i++ ) {
lowlib.c:          _uihori_line ( wc , xx+i , xx+ww-i , yy-i ) ;
lowlib.c:      D = br->D;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      x1 = br->x1;
lowlib.c:      y1 = EVGAY-br->y1;
lowlib.c:      x2 = br->x2-br->width-br->offset;
lowlib.c:      y2 = EVGAY-br->y2;
lowlib.c:      yoff = ( br->y2-br->y1-br->width ) *0.5;
lowlib.c:      y1-= yoff;
lowlib.c:      ln = br->x2-br->x1-32;
lowlib.c:      _uirect_fill ( wc , x1+1 , y1-1 , x2-1 , y2+1 , D->gc.dim ) ;
lowlib.c:      menu = br->menu [ br->df-1 ] ;
lowlib.c://  uiMenustr(D,x1+4,y2+5,br->menu[br->df-1],D->gc.menu_char);
lowlib.c:      uiString ( D , menu , x1 , br->y1+yoff , ln , br->width , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 , -1 ) ;
lowlib.c:      D = w->D;
lowlib.c:      x1 = w->x1+D->xo;
lowlib.c:      y1 = w->y1+D->yo;
lowlib.c:      x2 = w->x2+D->xo;
lowlib.c:      y2 = w->y2+D->yo;
lowlib.c:      if ( w->Bimg == NULL ) w->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c:      if ( w->Bimg != NULL ) kgRestoreImage ( D , w->Bimg , x1 , y1 , \
lowlib.c:       ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:          uiString ( D , w->prompt , x1 , y1 , lngth , w->y2-w->y1 , D->gc.PromptFont , D->gc.txt_pchar , D->gc.FontSize , 1 , D->gc.fill_clr ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      x1 = w->xb+D->xo+2;
lowlib.c:      x2 = w->x2+D->xo-w->width-w->offset;
lowlib.c:      y1 = w->y1+D->yo+2;
lowlib.c:      y2 = w->y2+D->yo-2;
lowlib.c:      y1 = w->y1+D->yo;
lowlib.c:      y2 = w->y2+D->yo;
lowlib.c:      yoff = ( y2-y1-w->width ) *0.5;
lowlib.c:      y2-= yoff;
lowlib.c:      yoff = w->width*0.5;
lowlib.c:      y1 = ( w->y1+w->y2 ) *0.5+D->yo-yoff;
lowlib.c:      y2 = ( w->y1+w->y2 ) *0.5+D->yo+yoff;
lowlib.c:      ln = x2-x1-5;
lowlib.c:      _dvrect_fill ( wc , x1+1 , y1+1 , x2-1 , y2-1 , D->gc.dim ) ;
lowlib.c:      menu = w->menu [ * ( w->df ) -1 ] ;
lowlib.c:      img = w->imgs [ * ( w->df ) -1 ] ;
lowlib.c://  uiMenustr(D,x1+4,y2+5,br->menu[br->df-1],D->gc.menu_char);
lowlib.c:      uiString ( D , menu , x1+5 , y1 , ln , w->width , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 , -1 ) ;
lowlib.c://  kgImage(D,img,x1+5,y1,ln,w->width,0.0,1.0);
lowlib.c:      y1-= yoff;
lowlib.c:      yoff = ( y2-y1-w->w ) *0.5;
lowlib.c:      _dvdown_dir ( D , x2 , y1+yoff , w->w , 0.2 , 5 ) ;
lowlib.c:      _dvdown_dir ( D , x2 , y1 , w->w , 0.2 , 5 ) ;
lowlib.c:      _dvdown_dir ( D , x2 , y1-3 , w->width+4 , 0.2 , 4 ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->item == -1 ) return;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      if ( w->menu != NULL ) {
lowlib.c:          while ( ( w->menu [ i ] ) != NULL ) i++;
lowlib.c:          w->imgs = ( void ** ) Malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) kgStringToImage ( w->menu [ i ] , NULL , lng , w->width , D->gc.MenuFont , D->gc.menu_char , -1 , D->gc.FontSize , -1 ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      if ( w->menu != NULL ) {
lowlib.c:          while ( ( w->menu [ i ] ) != NULL ) i++;
lowlib.c:          w->imgs = ( void ** ) malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) kgStringToImage ( w->menu [ i ] , NULL , lng , w->width , D->gc.MenuFont , D->gc.menu_char , -1 , D->gc.FontSize , -1 ) ;
lowlib.c:      w->imgs = ( void ** ) uiMenuStringImages ( D , w->menu , lng , w->width , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 , 8 ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->item == -1 ) return;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      lng = w->lngth+w->xgap;
lowlib.c:      width = w->ygap-6;
lowlib.c:      menu = ( ThumbNail ** ) w->list;
lowlib.c:          w->imgs = ( void ** ) malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) uiMenuStringImage ( D , menu [ i ]->name , lng , width , D->gc.MsgFont , D->gc.info_char , D->gc.FontSize , 0 ) ;
lowlib.c:      w->imgs = ( void ** ) uiMenuNailImages ( D , menu , lng , width , D->gc.MsgFont , D->gc.twin_char , D->gc.FontSize , 0 , 8 ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->item == -1 ) return;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          kgFreeImage ( w->nimg ) ;
lowlib.c:          kgFreeImage ( w->himg ) ;
lowlib.c:          w->nimg = NULL;
lowlib.c:          w->himg = NULL;
lowlib.c:          w->imgs = NULL;
lowlib.c:      D = w->D;
lowlib.c:      TextQua = ( w->type/10 ) ;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:          kgFreeImage ( w->nimg ) ;
lowlib.c:          kgFreeImage ( w->himg ) ;
lowlib.c:          w->nimg = NULL;
lowlib.c:          w->himg = NULL;
lowlib.c:      w->nimg = uiMakeXSymbol ( w , D->gc.twin_char , D->gc.FontSize , 0 ) ;
lowlib.c:      w->himg = uiMakeXSymbol ( w , D->gc.twin_char , D->gc.FontSize , 1 ) ;
lowlib.c:      menu = ( ThumbNail ** ) w->list;
lowlib.c:          w->imgs = ( void ** ) malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) uiMenuStringImage ( D , menu [ i ]->name , lng , w->width , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 ) ;
lowlib.c:          w->imgs = ( void ** ) uiMenuNailImages ( D , menu , lng , w->width , D->gc.MenuFont , D->gc.twin_char , D->gc.FontSize , -1 , Mag ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->item == -1 ) return;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          kgFreeImage ( w->nimg ) ;
lowlib.c:          kgFreeImage ( w->himg ) ;
lowlib.c:          w->nimg = NULL;
lowlib.c:          w->himg = NULL;
lowlib.c:          w->imgs = NULL;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:          kgFreeImage ( w->nimg ) ;
lowlib.c:          kgFreeImage ( w->himg ) ;
lowlib.c:          w->nimg = NULL;
lowlib.c:          w->himg = NULL;
lowlib.c:      th = w->width+w->ygap;
lowlib.c:      BxSize = 2*D->gc.FontSize;
lowlib.c:      w->nimg = uiMakeRSymbol ( w , D->gc.fill_clr , D->gc.FontSize , 0 ) ;
lowlib.c:      w->himg = uiMakeRSymbol ( w , D->gc.fill_clr , D->gc.FontSize , 1 ) ;
lowlib.c:      menu = ( ThumbNail ** ) w->list;
lowlib.c:          w->imgs = ( void ** ) malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) uiMenuStringImage ( D , menu [ i ]->name , lng-2*BxSize , th , D->gc.Font , D->gc.menu_char , D->gc.FontSize , -1 ) ;
lowlib.c:          w->imgs = ( void ** ) uiMenuNailImages ( D , menu , lng-2*BxSize , th , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 , 8 ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->item == -1 ) return;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          kgFreeImage ( w->nimg ) ;
lowlib.c:          kgFreeImage ( w->himg ) ;
lowlib.c:          w->nimg = NULL;
lowlib.c:          w->himg = NULL;
lowlib.c:          w->imgs = NULL;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:          kgFreeImage ( w->nimg ) ;
lowlib.c:          kgFreeImage ( w->himg ) ;
lowlib.c:          w->nimg = NULL;
lowlib.c:          w->himg = NULL;
lowlib.c:      th = w->width+w->ygap;
lowlib.c:      BxSize = 2*D->gc.FontSize;
lowlib.c:      w->nimg = uiMakeCSymbol ( w , D->gc.menu_char , D->gc.FontSize , 0 ) ;
lowlib.c:      w->himg = uiMakeCSymbol ( w , D->gc.menu_char , D->gc.FontSize , 1 ) ;
lowlib.c:      menu = ( ThumbNail ** ) w->list;
lowlib.c:          w->imgs = ( void ** ) malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) uiMenuStringImage ( D , menu [ i ]->name , lng-2*BxSize , th , D->gc.Font , D->gc.menu_char , D->gc.FontSize , -1 ) ;
lowlib.c:          w->imgs = ( void ** ) uiMenuNailImages ( D , menu , lng-2*BxSize , th , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 , 8 ) ;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->item == -1 ) return;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      D = w->D;
lowlib.c:      if ( w->imgs != NULL ) {
lowlib.c:          while ( w->imgs [ i ] != NULL ) kgFreeImage ( w->imgs [ i++ ] ) ;
lowlib.c:          free ( w->imgs ) ;
lowlib.c:          w->imgs = NULL;
lowlib.c:      lng = w->x2-w->width-w->offset - w->xb-2;
lowlib.c:      if ( w->menu != NULL ) {
lowlib.c:          while ( ( w->menu [ i ] ) != NULL ) i++;
lowlib.c:          w->imgs = ( void ** ) malloc ( sizeof ( void * ) * ( i+1 ) ) ;
lowlib.c:          w->imgs [ i ] = NULL;
lowlib.c:              w->imgs [ i ] = ( void * ) kgStringToImage ( w->menu [ i ] , NULL , lng , w->width , D->gc.MenuFont , D->gc.menu_char , -1 , D->gc.FontSize , -1 ) ;
lowlib.c:      w->imgs = ( void ** ) uiMenuStringImages ( D , w->menu , lng , w->width , D->gc.MenuFont , D->gc.menu_char , D->gc.FontSize , -1 , 8 ) ;
lowlib.c:      D = w->D;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      br = w->bwsr;
lowlib.c:      br->df = * ( w->df ) ;
lowlib.c:      if ( w->hide != 1 ) {
lowlib.c:          x1 = w->x1+D->xo;
lowlib.c:          y1 = w->y1+D->yo;
lowlib.c:          x2 = w->x2+D->xo;
lowlib.c:          y2 = w->y2+D->yo;
lowlib.c:          if ( w->Bimg == NULL ) w->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c:          if ( w->prompt != NULL ) {
lowlib.c:              while ( ( w->prompt [ n ] ) != '\0' ) n++;
lowlib.c:          if ( lngth > ( ( w->x2-w->x1 ) *0.8+32 ) ) lngth = ( w->x2-w->x1 ) *0.8+32;
lowlib.c:          w->xb = w->x1+lngth;
lowlib.c:          while ( ( w->menu [ i ] ) != NULL ) i++;
lowlib.c:          df = * ( w->df ) ;
lowlib.c:          * ( w->df ) = df;
lowlib.c:              uiString ( D , w->prompt , x1 , y1 , lngth , w->y2-w->y1 , D->gc.PromptFont , D->gc.txt_pchar , D->gc.FontSize , 1 , D->gc.fill_clr ) ;
lowlib.c:          D = w->D;
lowlib.c:          x1 = w->x1+D->xo;
lowlib.c:          y1 = w->y1+D->yo;
lowlib.c:          x2 = w->x2+D->xo;
lowlib.c:          y2 = w->y2+D->yo;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( w->Bimg != NULL ) kgRestoreImage ( D , w->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      D = w->D;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      bwsr = ( BRW_STR * ) ( w->bwsr ) ;
lowlib.c:      w->bwsr = bwsr;
lowlib.c:      bwsr->D = D;
lowlib.c:      if ( pos >= n ) pos = n-1;
lowlib.c:      br->D = D;
lowlib.c:      br->x1 = xx1;
lowlib.c:      br->y1 = yy1;
lowlib.c:      br->pos = pos;
lowlib.c:      br->df = df;
lowlib.c:      br->menu = menu;
lowlib.c:      br->size = size;
lowlib.c:      br->D = ( DIALOG * ) D;
lowlib.c:      m = br->menu;
lowlib.c:          length = uiStringLength ( m [ i ] , D->gc.FontSize ) ;
lowlib.c:      x1 = br->x1;
lowlib.c:      y1 = br->D->evgay-br->y1+1;
lowlib.c:      y2 = y1-20;
lowlib.c:      br->xb = x2+2;
lowlib.c:      br->width = 20;
lowlib.c:      br->x2 = br->xb;
lowlib.c:      if ( pos >= n ) pos = n-1;
lowlib.c:      br->D = D;
lowlib.c:      br->x1 = w->x1;
lowlib.c:      br->y1 = w->y1;
lowlib.c:      br->x2 = w->x2;
lowlib.c:      br->y2 = w->y2;
lowlib.c:      br->pos = pos;
lowlib.c:      br->df = df;
lowlib.c:      br->menu = menu;
lowlib.c:      br->size = size;
lowlib.c:      br->xb = br->x2;
lowlib.c:      br->width = 20;
lowlib.c:      if ( x->nx < 1 ) x->nx = 1;
lowlib.c:      x->ny = ( n-x->nx+1 ) / ( x->nx ) ;
lowlib.c:      if ( pos >= n ) pos = n-1;
lowlib.c:      br->D = D;
lowlib.c:      br->x1 = x->x1;
lowlib.c:      br->y1 = x->y1;
lowlib.c:      br->x2 = x->x2;
lowlib.c:      br->y2 = x->y2;
lowlib.c:      br->pos = pos;
lowlib.c:      br->df = df;
lowlib.c:      br->menu = menu;
lowlib.c:      br->size = size;
lowlib.c:      br->xb = br->x2;
lowlib.c:      br->width = x->width+x->ygap;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( y->nx < 1 ) y->nx = 1;
lowlib.c:      y->ny = ( n ) / ( y->nx ) ;
lowlib.c:      if ( ( n%y->nx ) != 0 ) y->ny+= 1;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->D = D;
lowlib.c:      br->x1 = y->x1;
lowlib.c:      br->y1 = y->y1;
lowlib.c:      br->x2 = y->x2;
lowlib.c:      br->y2 = y->y2;
lowlib.c:      br->pos = pos;
lowlib.c:      br->df = df;
lowlib.c:      br->menu = menu;
lowlib.c:      br->size = y->ny;
lowlib.c:      br->xb = br->x2;
lowlib.c:      br->width = y->width+y->ygap;
lowlib.c:      y->size = ( y->y2-y->y1-2*y->offset ) /br->width;
lowlib.c:      br->w = y->w;
lowlib.c:      br->offset = y->offset;
lowlib.c:      D = w->D;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      menu = w->menu;
lowlib.c:      size = w->size;
lowlib.c:      if ( pos >= n ) pos = n-1;
lowlib.c:      br = w->bwsr;
lowlib.c:      br->gc = D->gc;
lowlib.c:      br->x1 = w->x1+D->xo;
lowlib.c:      br->y1 = w->y1+D->yo;
lowlib.c:      br->x2 = w->x2+D->xo;
lowlib.c:      br->y2 = w->y2+D->yo;
lowlib.c:      br->pos = pos;
lowlib.c:      br->df = df;
lowlib.c:      br->hitem = df;
lowlib.c:      br->menu = menu;
lowlib.c:      br->size = size;
lowlib.c:      br->xb = br->x2;
lowlib.c:      br->width = w->w;
lowlib.c:      ch = ( d [ i ] .t->code ) ;
lowlib.c:          X1 = d [ i ] .t->x1+x1;
lowlib.c:          Y1 = d [ i ] .t->y1+y1;
lowlib.c:          X2 = d [ i ] .t->x2+x1;
lowlib.c:          Y2 = d [ i ] .t->y2+y1;
lowlib.c:          X1 = d [ i ] .t->x1+x1;
lowlib.c:          Y1 = d [ i ] .t->y1+y1;
lowlib.c:          X2 = d [ i ] .t->x2+x1;
lowlib.c:          Y2 = d [ i ] .t->y2+y1;
lowlib.c:          X1 = d [ i ] .x->x1+x1;
lowlib.c:          Y1 = d [ i ] .x->y1+y1;
lowlib.c:          X2 = d [ i ] .x->x2+x1;
lowlib.c:          Y2 = d [ i ] .x->y2+y1;
lowlib.c:          X1 = d [ i ] .h->x1+x1;
lowlib.c:          Y1 = d [ i ] .h->y1+y1;
lowlib.c:          X2 = d [ i ] .h->x2+x1;
lowlib.c:          Y2 = d [ i ] .h->y2+y1;
lowlib.c:          X1 = d [ i ] .b->x1+x1;
lowlib.c:          Y1 = d [ i ] .b->y1+y1;
lowlib.c:          X2 = d [ i ] .b->x2+x1;
lowlib.c:          Y2 = d [ i ] .b->y2+y1;
lowlib.c:          X1 = d [ i ] .f->x1+x1;
lowlib.c:          Y1 = d [ i ] .f->y1+y1;
lowlib.c:          X2 = d [ i ] .f->x2+x1;
lowlib.c:          Y2 = d [ i ] .f->y2+y1;
lowlib.c:          X1 = d [ i ] .d->x1+x1;
lowlib.c:          Y1 = d [ i ] .d->y1+y1;
lowlib.c:          X2 = d [ i ] .d->x2+x1;
lowlib.c:          Y2 = d [ i ] .d->y2+y1;
lowlib.c:          X1 = d [ i ] .B->x1+x1;
lowlib.c:          Y1 = d [ i ] .B->y1+y1;
lowlib.c:          X2 = d [ i ] .B->x2+x1;
lowlib.c:          Y2 = d [ i ] .B->y2+y1;
lowlib.c:          X1 = d [ i ] .w->x1+x1;
lowlib.c:          Y1 = d [ i ] .w->y1+y1;
lowlib.c:          X2 = d [ i ] .w->x2+x1;
lowlib.c:          Y2 = d [ i ] .w->y2+y1;
lowlib.c:          return -1;
lowlib.c:      _uirect_fill_transparent ( WC ( D ) , X1 , D->evgay-Y1 , X2 , D->evgay-Y2 , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      return -1;
lowlib.c:      d = D->d;
lowlib.c:      br = ( BRW_STR * ) ( E->bwsr ) ;
lowlib.c:      menu = br->menu;
lowlib.c:          br->menu = m;
lowlib.c:          br->size = E->size;
lowlib.c:      menu = br->menu;
lowlib.c:      E->menu = menu;
lowlib.c:      uiclean_gui_area ( D , item , D->xo , D->yo , D->d ) ;
lowlib.c:      d = D->d;
lowlib.c:      br = ( BRW_STR * ) ( E->bwsr ) ;
lowlib.c:      E->menu = m;
lowlib.c:      br->menu = m;
lowlib.c:      br->size = E->size;
lowlib.c:      uiclean_gui_area ( D , item , D->xo , D->yo , D->d ) ;
lowlib.c:      d = D->d;
lowlib.c:      br = ( BRW_STR * ) ( E->bwsr ) ;
lowlib.c:      br->size = E->size;
lowlib.c:      uiclean_gui_area ( D , item , D->xo , D->yo , D->d ) ;
lowlib.c:      w->bwsr = make_dialog_menu_str ( D , w , * ( w->df ) , * \
lowlib.c:       ( w->df ) , w->menu , w->size ) ;
lowlib.c:      bwsr = ( BRW_STR * ) w->bwsr;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->x1 += x1;
lowlib.c:      bwsr->y1 += y1;
lowlib.c:      bwsr->x2 += x1;
lowlib.c:      bwsr->y2 += y1;
lowlib.c:      _uiDrawDialogMenu ( w->bwsr ) ;
lowlib.c:      switch ( x->code ) {
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      menu = ( ThumbNail ** ) y->list;
lowlib.c:          if ( ( ( y->type ) %10 ) != 0 ) menu [ n ]->sw = 0;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 0;
lowlib.c:      if ( * ( y->df ) > n ) * ( y->df ) = n;
lowlib.c:      df = * ( y->df ) -1;
lowlib.c:      if ( ( ( ( y->type ) %10 ) != 0 ) && ( menu != NULL ) && ( menu [ 0 ] != NULL ) && \
lowlib.c:       ( df >= 0 ) ) menu [ df ]->sw = 1;
lowlib.c:      y->nx = ( y->x2 -y->x1-2*y->offset-y->w ) / ( y->width+y->xgap ) ;
lowlib.c:      if ( y->nx < 1 ) {
lowlib.c:          y->width = ( y->x2 -y->x1-2*y->offset-y->w ) -y->xgap;
lowlib.c:          y->nx = 1;
lowlib.c:      y->nx = ( y->x2 -y->x1-2*y->offset-y->w ) / ( y->lngth+y->xgap ) ;
lowlib.c:      if ( y->nx < 1 ) {
lowlib.c:          y->lngth = ( y->x2 -y->x1-2*y->offset-y->w ) -y->xgap;
lowlib.c:          y->nx = 1;
lowlib.c:      xshift = ( y->x2 -y->x1-2*y->offset-y->w ) - ( y->lngth+y->xgap ) *y->nx;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->offset = y->offset;
lowlib.c:      bwsr->xshift = xshift;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->x1 = y->x1+x1;
lowlib.c:      bwsr->y1 = y->y1+y1;
lowlib.c:      bwsr->x2 = y->x2+x1;
lowlib.c:      bwsr->y2 = y->y2+y1;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c:          if ( y->Bimg == NULL ) {
lowlib.c:              y->Bimg = kgGetBackground ( D , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:          bwsr->df = * ( y->df ) ;
lowlib.c:          bwsr->size = y->ny;
lowlib.c:          bwsr->xb = bwsr->x2;
lowlib.c:          height = y->width+y->ygap;
lowlib.c:          bwsr->width = height;
lowlib.c:          y->size = ( y->y2-y->y1-2*y->offset ) /bwsr->width;
lowlib.c:          bwsr->w = y->w;
lowlib.c:          bwsr->offset = y->offset;
lowlib.c:          if ( y->size <= 0 ) {
lowlib.c:              y->size = 1;
lowlib.c:              y->y2 = height+y->y1+2*y->offset;
lowlib.c:          extra = ( y->y2 -y->y1-2*y->offset-y->size*height ) /2;
lowlib.c:          if ( extra < -y->offset ) extra = -y->offset;
lowlib.c:          bwsr->offset = y->offset+extra;
lowlib.c:          if ( y->list != NULL ) while ( y->list [ n ] != NULL ) n++;
lowlib.c:          y->nitems = n;
lowlib.c:          y->ny = ( n/y->nx ) ;
lowlib.c:          if ( ( n%y->nx ) != 0 ) y->ny+= 1;
lowlib.c:          if ( y->size > y->ny ) y->size = y->ny;
lowlib.c:          bwsr->scroll = 1;
lowlib.c:          if ( y->size == y->ny ) {
lowlib.c:              bwsr->scroll = 0;
lowlib.c:              bwsr->pos = 0;
lowlib.c:          bwsr->size = y->size;
lowlib.c:          if ( bwsr->df > n ) bwsr->df = 1;
lowlib.c:          if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:          * ( y->df ) = bwsr->df;
lowlib.c:          bwsr->menu = ( char ** ) y->list;
lowlib.c://   bwsr->pos=0;
lowlib.c:          size = y->nx*y->size;
lowlib.c:          bwsr->D = D;
lowlib.c:          bwsr->hitem = bwsr->df-1;
lowlib.c:          if ( ( bwsr->hitem - bwsr->pos ) < 0 ) bwsr->pos = 0;
lowlib.c:          if ( ( bwsr->hitem - bwsr->pos ) > size ) bwsr->pos = bwsr->hitem/y->nx;
lowlib.c:          bwsr->w = bwsr->scroll*y->w;
lowlib.c:          bwsr->tbx1 = bwsr->x2 - y->offset -bwsr->w ;
lowlib.c:          bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:          bwsr->tbx2 = bwsr->tbx1+bwsr->w;
lowlib.c:          bwsr->tby2 = bwsr->tby1+bwsr->w;
lowlib.c:          bwsr->bbx1 = bwsr->tbx1;
lowlib.c:          bwsr->bby1 = bwsr->y2-y->offset-bwsr->w;
lowlib.c:          bwsr->bbx2 = bwsr->bbx1+bwsr->w;
lowlib.c:          bwsr->bby2 = bwsr->bby1+bwsr->w;
lowlib.c:          bwsr->rsx1 = bwsr->tbx1;
lowlib.c:          bwsr->rsy1 = bwsr->tby2;
lowlib.c:          bwsr->rsx2 = bwsr->bbx2;
lowlib.c:          bwsr->rsy2 = bwsr->bby1;
lowlib.c:          _dvrect_fill_transparent ( wc , ( bwsr->x1 ) , ( bwsr->y1 ) , ( bwsr->x2 ) , \
lowlib.c:           ( bwsr->y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , bwsr->x1 , bwsr->y1 , \
lowlib.c:           ( bwsr->x2-bwsr->x1+1 ) , ( bwsr->y2-bwsr->y1+1 ) ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      menu = ( ThumbNail ** ) y->list;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 1;
lowlib.c:      if ( * ( y->df ) > n ) * ( y->df ) = n;
lowlib.c:      for ( i = 0; i < n; i++ ) menu [ i ]->sw = 0;
lowlib.c:      menu [ * ( y->df ) -1 ]->sw = 1;
lowlib.c://   y->nx = 1;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->x1 = y->x1+x1;
lowlib.c:      bwsr->y1 = y->y1+y1;
lowlib.c:      bwsr->x2 = y->x2+x1;
lowlib.c:      bwsr->y2 = y->y2+y1;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground ( D , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:          bwsr->hitem = 0;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->df = * ( y->df ) ;
lowlib.c:          bwsr->size = y->ny;
lowlib.c:          bwsr->xb = bwsr->x2;
lowlib.c:          bwsr->width = y->width+y->ygap;
lowlib.c:          bwsr->offset = y->offset;
lowlib.c:          height = y->width+y->ygap;
lowlib.c:          y->size = ( y->y2 -y->y1-2*y->offset ) /height;
lowlib.c:          if ( y->size <= 0 ) {
lowlib.c:              y->size = 1;
lowlib.c:              y->y2 = height+y->y1+2*y->offset;
lowlib.c://     y->width=(y->y2 -y->y1-2*y->offset)/2;
lowlib.c://     y->ygap=0;
lowlib.c:          extra = ( y->y2 -y->y1-2*y->offset-y->size*height ) /2;
lowlib.c:          if ( extra < -y->offset ) extra = -y->offset;
lowlib.c:          bwsr->offset = y->offset+extra;
lowlib.c:          y->nitems = n;
lowlib.c:          y->ny = ( n/y->nx ) ;
lowlib.c:          if ( ( n%y->nx ) != 0 ) y->ny+= 1;
lowlib.c:          if ( y->size > y->ny ) y->size = y->ny;
lowlib.c:          bwsr->scroll = 1;
lowlib.c:          if ( y->size == y->ny ) {
lowlib.c:              bwsr->scroll = 0;
lowlib.c:          bwsr->menu = ( char ** ) y->list;
lowlib.c:          bwsr->size = y->size;
lowlib.c:          if ( bwsr->df > n ) bwsr->df = 1;
lowlib.c:          if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:          * ( y->df ) = bwsr->df;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->D = D;
lowlib.c:          bwsr->hitem = bwsr->df-1;
lowlib.c:          w = bwsr->scroll*y->w;
lowlib.c:          bwsr->w = w;
lowlib.c:          bwsr->tbx1 = bwsr->x2 - y->offset -bwsr->w;
lowlib.c:          bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:          bwsr->tbx2 = bwsr->tbx1+bwsr->w;
lowlib.c:          bwsr->tby2 = bwsr->tby1+bwsr->w;
lowlib.c:          bwsr->bbx1 = bwsr->tbx1;
lowlib.c:          bwsr->bby1 = bwsr->y2-y->offset-bwsr->w;
lowlib.c:          bwsr->bbx2 = bwsr->bbx1+bwsr->w;
lowlib.c:          bwsr->bby2 = bwsr->bby1+bwsr->w;
lowlib.c:          bwsr->rsx1 = bwsr->tbx1;
lowlib.c:          bwsr->rsy1 = bwsr->tby2;
lowlib.c:          bwsr->rsx2 = bwsr->bbx2;
lowlib.c:          bwsr->rsy2 = bwsr->bby1;
lowlib.c:          _dvrect_fill_transparent ( wc , ( bwsr->x1 ) , ( bwsr->y1 ) , ( bwsr->x2 ) , \
lowlib.c:           ( bwsr->y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , bwsr->x1 , bwsr->y1 , \
lowlib.c:           ( bwsr->x2-bwsr->x1+1 ) , ( bwsr->y2-bwsr->y1+1 ) ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      menu = ( ThumbNail ** ) y->list;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 1;
lowlib.c:      if ( * ( y->df ) > n ) * ( y->df ) = n;
lowlib.c://   y->nx = 1;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->x1 = y->x1+x1;
lowlib.c:      bwsr->y1 = y->y1+y1;
lowlib.c:      bwsr->x2 = y->x2+x1;
lowlib.c:      bwsr->y2 = y->y2+y1;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground ( D , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:          bwsr->hitem = 0;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->df = * ( y->df ) ;
lowlib.c:          bwsr->size = y->ny;
lowlib.c:          bwsr->xb = bwsr->x2;
lowlib.c:          bwsr->width = y->width+y->ygap;
lowlib.c:          bwsr->offset = y->offset;
lowlib.c:          height = y->width+y->ygap;
lowlib.c:          y->size = ( y->y2 -y->y1-2*y->offset ) /height;
lowlib.c:          if ( y->size <= 0 ) {
lowlib.c:              y->size = 1;
lowlib.c:              y->y2 = height+y->y1+2*y->offset;
lowlib.c:          extra = ( y->y2 -y->y1-2*y->offset-y->size*height ) /2;
lowlib.c:          if ( extra < -y->offset ) extra = -y->offset;
lowlib.c:          bwsr->offset = y->offset+extra;
lowlib.c:          y->ny = ( n/y->nx ) ;
lowlib.c:          if ( ( n%y->nx ) != 0 ) y->ny+= 1;
lowlib.c:          if ( y->size > y->ny ) y->size = y->ny;
lowlib.c:          bwsr->scroll = 1;
lowlib.c:          if ( y->size == y->ny ) {
lowlib.c:              bwsr->scroll = 0;
lowlib.c:          bwsr->menu = ( char ** ) y->list;
lowlib.c:          bwsr->size = y->size;
lowlib.c:          if ( bwsr->df > n ) bwsr->df = 1;
lowlib.c:          if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:          * ( y->df ) = bwsr->df;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->D = D;
lowlib.c:          bwsr->hitem = bwsr->df-1;
lowlib.c:          w = bwsr->scroll*y->w;
lowlib.c:          bwsr->w = w;
lowlib.c:          bwsr->tbx1 = bwsr->x2 - y->offset -bwsr->w;
lowlib.c:          bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:          bwsr->tbx2 = bwsr->tbx1+bwsr->w;
lowlib.c:          bwsr->tby2 = bwsr->tby1+bwsr->w;
lowlib.c:          bwsr->bbx1 = bwsr->tbx1;
lowlib.c:          bwsr->bby1 = bwsr->y2-y->offset-bwsr->w;
lowlib.c:          bwsr->bbx2 = bwsr->bbx1+bwsr->w;
lowlib.c:          bwsr->bby2 = bwsr->bby1+bwsr->w;
lowlib.c:          bwsr->rsx1 = bwsr->tbx1;
lowlib.c:          bwsr->rsy1 = bwsr->tby2;
lowlib.c:          bwsr->rsx2 = bwsr->bbx2;
lowlib.c:          bwsr->rsy2 = bwsr->bby1;
lowlib.c:          _dvrect_fill_transparent ( wc , ( bwsr->x1 ) , ( bwsr->y1 ) , ( bwsr->x2 ) , \
lowlib.c:           ( bwsr->y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , bwsr->x1 , bwsr->y1 , \
lowlib.c:           ( bwsr->x2-bwsr->x1+1 ) , ( bwsr->y2-bwsr->y1+1 ) ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      menu = ( ThumbNail ** ) y->list;
lowlib.c:          if ( ( ( y->type ) %10 ) != 0 ) menu [ n ]->sw = 0;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 0;
lowlib.c:      if ( * ( y->df ) > n ) * ( y->df ) = n;
lowlib.c://   y->nx = 1;
lowlib.c:      df = * ( y->df ) -1;
lowlib.c:      if ( ( ( ( y->type ) %10 ) != 0 ) && ( menu != NULL ) && ( menu [ 0 ] != NULL ) && \
lowlib.c:       ( df >= 0 ) ) menu [ df ]->sw = 1;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->x1 = y->x1+x1;
lowlib.c:      bwsr->y1 = y->y1+y1;
lowlib.c:      bwsr->x2 = y->x2+x1;
lowlib.c:      bwsr->y2 = y->y2+y1;
lowlib.c:      if ( y->bkgr == 1 ) _dvrect_fill ( WC ( D ) , bwsr->x1+4 , bwsr->y1+4 , bwsr->x2-4 , bwsr->y2-4 , D->gc.twin_fill ) ;
lowlib.c:      else _dvrect_fill ( WC ( D ) , bwsr->x1+4 , bwsr->y1+4 , bwsr->x2-4 , bwsr->y2-4 , D->gc.fill_clr ) ;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground ( D , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:          bwsr->hitem = 0;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->df = * ( y->df ) ;
lowlib.c:          bwsr->size = y->ny;
lowlib.c:          bwsr->xb = bwsr->x2;
lowlib.c:          height = y->width+y->ygap;
lowlib.c:          bwsr->width = height;
lowlib.c:          y->size = ( y->y2-y->y1-2*y->offset ) /bwsr->width;
lowlib.c:          bwsr->w = y->w;
lowlib.c:          bwsr->offset = y->offset;
lowlib.c:          if ( y->size <= 0 ) {
lowlib.c:              y->size = 1;
lowlib.c:              y->y2 = height+y->y1+2*y->offset;
lowlib.c://     y->width=(y->y2 -y->y1-2*y->offset)/2;
lowlib.c://     y->ygap=0;
lowlib.c:          extra = ( y->y2 -y->y1-2*y->offset-y->size*height ) /2;
lowlib.c:          if ( extra < -y->offset ) extra = -y->offset;
lowlib.c:          bwsr->offset = y->offset+extra;
lowlib.c:          y->ny = ( n/y->nx ) ;
lowlib.c:          if ( ( n%y->nx ) != 0 ) y->ny+= 1;
lowlib.c:          if ( y->size > y->ny ) y->size = y->ny;
lowlib.c:          bwsr->scroll = 1;
lowlib.c:          bwsr->menu = ( char ** ) menu;
lowlib.c:          if ( y->size == y->ny ) {
lowlib.c:              bwsr->scroll = 0;
lowlib.c:          bwsr->size = y->size;
lowlib.c:          if ( bwsr->df > n ) bwsr->df = 1;
lowlib.c:          if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:          * ( y->df ) = bwsr->df;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->D = D;
lowlib.c:          bwsr->hitem = bwsr->df-1;
lowlib.c:          w = bwsr->scroll*y->w;
lowlib.c:          bwsr->w = w;
lowlib.c:          bwsr->tbx1 = bwsr->x2 - y->offset -w;
lowlib.c:          bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:          bwsr->tbx2 = bwsr->tbx1+w;
lowlib.c:          bwsr->tby2 = bwsr->tby1+w;
lowlib.c:          bwsr->bbx1 = bwsr->tbx1;
lowlib.c:          bwsr->bby1 = bwsr->y2-y->offset-w;
lowlib.c:          bwsr->bbx2 = bwsr->bbx1+w;
lowlib.c:          bwsr->bby2 = bwsr->bby1+w;
lowlib.c:          bwsr->rsx1 = bwsr->tbx1;
lowlib.c:          bwsr->rsy1 = bwsr->tby2;
lowlib.c:          bwsr->rsx2 = bwsr->bbx2;
lowlib.c:          bwsr->rsy2 = bwsr->bby1;
lowlib.c:          _dvrect_fill_transparent ( wc , ( bwsr->x1 ) , ( bwsr->y1 ) , ( bwsr->x2 ) , \
lowlib.c:           ( bwsr->y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , bwsr->x1 , bwsr->y1 , \
lowlib.c:           ( bwsr->x2-bwsr->x1+1 ) , ( bwsr->y2-bwsr->y1+1 ) ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c:          _dvrect_fill_transparent ( wc , ( y->x1+x1 ) , ( y->y1+y1 ) , ( y->x2+x1 ) , \
lowlib.c:           ( y->y2+y1 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c:          _dvrect_fill_transparent ( wc , ( y->x1+x1 ) , ( y->y1+y1 ) , ( y->x2+x1 ) , \
lowlib.c:           ( y->y2+y1 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      menu = ( char ** ) y->menu;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( y->size > n ) y->size = n;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 1;
lowlib.c:      if ( * ( y->df ) > n ) * ( y->df ) = n;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->size = y->size;
lowlib.c:      bwsr->x1 = y->x1+x1;
lowlib.c:      bwsr->y1 = y->y1+y1;
lowlib.c:      bwsr->x2 = y->x2+x1;
lowlib.c:      bwsr->y2 = y->y2+y1;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   bwsr->y2 =y->y1+y1+y->size*y->width+2*y->offset;
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground ( D , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:          bwsr->hitem = 0;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->df = * ( y->df ) ;
lowlib.c:          bwsr->xb = bwsr->x2;
lowlib.c:          height = y->width;
lowlib.c:          bwsr->width = height;
lowlib.c:          y->size = ( y->y2-y->y1-2*y->offset ) /bwsr->width;
lowlib.c:          if ( y->size > y->nitems ) y->size = y->nitems;
lowlib.c:          bwsr->w = y->w;
lowlib.c:          bwsr->offset = y->offset;
lowlib.c:          if ( y->size <= 0 ) {
lowlib.c:              y->size = 1;
lowlib.c://     y->y2 = height+y->y1+2*y->offset;
lowlib.c:          extra = ( y->y2 -y->y1-2*y->offset-y->size*height ) /2;
lowlib.c:          if ( extra < -y->offset ) extra = -y->offset;
lowlib.c:          bwsr->offset = y->offset+extra;
lowlib.c:          bwsr->scroll = 1;
lowlib.c:          bwsr->menu = ( char ** ) menu;
lowlib.c:          if ( y->size == y->nitems ) {
lowlib.c:              bwsr->scroll = 0;
lowlib.c:          bwsr->size = y->size;
lowlib.c:          if ( bwsr->df > n ) bwsr->df = 1;
lowlib.c:          if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:          * ( y->df ) = bwsr->df;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->D = D;
lowlib.c:          bwsr->hitem = bwsr->df-1;
lowlib.c:          w = bwsr->scroll*y->w;
lowlib.c:          bwsr->w = w;
lowlib.c:          bwsr->tbx1 = bwsr->x2 - y->offset -w;
lowlib.c:          bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:          bwsr->tbx2 = bwsr->tbx1+w;
lowlib.c:          bwsr->tby2 = bwsr->tby1+w;
lowlib.c:          bwsr->bbx1 = bwsr->tbx1;
lowlib.c:          bwsr->bby1 = bwsr->y2-y->offset-w;
lowlib.c:          bwsr->bbx2 = bwsr->bbx1+w;
lowlib.c:          bwsr->bby2 = bwsr->bby1+w;
lowlib.c:          bwsr->rsx1 = bwsr->tbx1;
lowlib.c:          bwsr->rsy1 = bwsr->tby2;
lowlib.c:          bwsr->rsx2 = bwsr->bbx2;
lowlib.c:          bwsr->rsy2 = bwsr->bby1;
lowlib.c:          _dvrect_fill_transparent ( wc , ( bwsr->x1 ) , ( bwsr->y1 ) , ( bwsr->x2 ) , \
lowlib.c:           ( bwsr->y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , bwsr->x1 , bwsr->y1 , \
lowlib.c:           ( bwsr->x2-bwsr->x1+1 ) , ( bwsr->y2-bwsr->y1+1 ) ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      menu = ( char ** ) y->menu;
lowlib.c:      y->nitems = n;
lowlib.c:      if ( y->size > n ) y->size = n;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 1;
lowlib.c:      if ( * ( y->df ) > n ) * ( y->df ) = n;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->D = ( DIALOG* ) D;
lowlib.c:      bwsr->size = y->size;
lowlib.c:      bwsr->x1 = y->xb+x1;
lowlib.c:      bwsr->y1 = y->y1+y1;
lowlib.c:      bwsr->x2 = y->x2+x1;
lowlib.c:      bwsr->offset = y->offset;
lowlib.c:      bwsr->width = y->width;
lowlib.c:      bwsr->w = y->w;
lowlib.c:      bwsr->y2 = bwsr->y1+bwsr->size*y->width+2*y->offset;
lowlib.c:      if ( bwsr->y2 > ( D->yo+D->yl ) ) bwsr->y2 = D->yo+D->yl;
lowlib.c:      bwsr->hitem = 0;
lowlib.c:      bwsr->pos = 0;
lowlib.c:      bwsr->df = * ( y->df ) ;
lowlib.c:      bwsr->xb = bwsr->x2;
lowlib.c:      height = y->width;
lowlib.c:      bwsr->width = height;
lowlib.c:      y->size = ( bwsr->y2-bwsr->y1-2*y->offset ) /bwsr->width;
lowlib.c:      if ( y->size > y->nitems ) y->size = y->nitems;
lowlib.c:      bwsr->w = y->w;
lowlib.c:      bwsr->offset = y->offset;
lowlib.c:      extra = ( bwsr->y2 -bwsr->y1-2*y->offset-y->size*height ) /2;
lowlib.c:      bwsr->offset = y->offset+extra;
lowlib.c:      if ( y->size <= 0 ) {
lowlib.c:          y->size = 1;
lowlib.c://     y->width=(bwsr->y2 -bwsr->y1-2*y->offset)/2;
lowlib.c:      bwsr->scroll = 1;
lowlib.c:      bwsr->menu = ( char ** ) menu;
lowlib.c:      if ( y->size == y->nitems ) {
lowlib.c:          bwsr->scroll = 0;
lowlib.c:      bwsr->size = y->size;
lowlib.c:      if ( bwsr->df > y->nitems ) bwsr->df = y->nitems;
lowlib.c:      if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:      * ( y->df ) = bwsr->df;
lowlib.c:      bwsr->pos = 0;
lowlib.c:      bwsr->D = D;
lowlib.c:      bwsr->hitem = bwsr->df-1;
lowlib.c:      w = bwsr->scroll*y->w;
lowlib.c:      bwsr->w = w;
lowlib.c:      bwsr->tbx1 = bwsr->x2 - y->offset -w;
lowlib.c:      bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:      bwsr->tbx2 = bwsr->tbx1+w;
lowlib.c:      bwsr->tby2 = bwsr->tby1+w;
lowlib.c:      bwsr->bbx1 = bwsr->tbx1;
lowlib.c:      bwsr->bby1 = bwsr->y2-y->offset-w;
lowlib.c:      bwsr->bbx2 = bwsr->bbx1+w;
lowlib.c:      bwsr->bby2 = bwsr->bby1+w;
lowlib.c:      bwsr->rsx1 = bwsr->tbx1;
lowlib.c:      bwsr->rsy1 = bwsr->tby2;
lowlib.c:      bwsr->rsx2 = bwsr->bbx2;
lowlib.c:      bwsr->rsy2 = bwsr->bby1;
lowlib.c:      kg_scr_back ( WC ( D ) , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:      if ( o->hide ) return;
lowlib.c:      D = o->D;
lowlib.c:      wc = D->wc;
lowlib.c:      x1 = D->xo+o->x1+2;
lowlib.c:      y1 = D->yo+o->y1+2;
lowlib.c:      x2 = D->xo+o->x2-2;
lowlib.c:      y2 = D->yo+o->y2-2;
lowlib.c:      width = x2-x1+1;
lowlib.c:      height = y2-y1+1;
lowlib.c:      l = width-2*offset;
lowlib.c:      w = height-2*offset;
lowlib.c:      if ( w > l ) { o->direction = 1; lp = w*o->percent/100.0; }
lowlib.c:      else {o->direction = 0; lp = l*o->percent/100.0; }
lowlib.c:      color = o->clr;
lowlib.c:      if ( color == -1 ) color = D->gc.ProgColor;
lowlib.c:          kgUserFrame ( fid , -1. , -1. , ( float ) width+1. , ( float ) height+1. ) ;
lowlib.c:          bclr = o->bordr;
lowlib.c:          if ( bclr == -1 ) bclr = D->gc.ProgBodrColor;
lowlib.c:              bclr = -bclr;
lowlib.c:              color = -color;
lowlib.c:          kgLineColor ( fid , D->gc.ProgFillColor ) ;
lowlib.c:          kgRoundedRectangleFill ( fid , xp , yp , ( float ) width-2.0 , \
lowlib.c:           ( float ) height-3.0 , 1 , D->gc.ProgFillColor , 0.25 ) ;
lowlib.c:           ( float ) height , D->gc.ProgBodrColor , 0.25 , 0.5 ) ;
lowlib.c:          if ( o->direction == 0 ) {
lowlib.c:              if ( o->percent > 0 ) kgRoundedRectangleFill ( fid , xp , lp*0.5+offset , l , lp , 1 , color , 0.25 ) ;
lowlib.c:      if ( o->Bimg != NULL ) {
lowlib.c:          kgRestoreImage ( D , o->Bimg , x1-2 , y1-2 , x2-x1+5 , y2-y1+5 ) ;
lowlib.c:      kgImage ( D , img , x1-2 , y1-2 , width+4 , height+4 , 0.0 , 1.0 ) ;
lowlib.c:      if ( o->hide ) return;
lowlib.c:      D = o->D;
lowlib.c:      wc = D->wc;
lowlib.c:      x1 = D->xo+o->x1+2;
lowlib.c:      y1 = D->yo+o->y1+2;
lowlib.c:      x2 = D->xo+o->x2-2;
lowlib.c:      y2 = D->yo+o->y2-2;
lowlib.c:      width = x2-x1+1;
lowlib.c:      height = y2-y1+1;
lowlib.c:      l = width-2*offset;
lowlib.c:      w = height-2*offset;
lowlib.c:      if ( w > l ) { o->direction = 1; lp = w*o->percent/100.0; }
lowlib.c:      else {o->direction = 0; lp = l*o->percent/100.0; }
lowlib.c:      color = o->clr;
lowlib.c:      if ( color == -1 ) color = D->gc.ProgColor;
lowlib.c:          kgUserFrame ( fid , -2. , -2. , ( float ) width+2 , ( float ) height+2 ) ;
lowlib.c:          bclr = o->bordr;
lowlib.c:          if ( bclr == -1 ) bclr = D->gc.ProgBodrColor;
lowlib.c:              bclr = -bclr;
lowlib.c:              color = -color;
lowlib.c:          kgRoundedRectangleFill ( fid , xp , yp , ( float ) width-2 , \
lowlib.c:           ( float ) height-2 , 1 , D->gc.fill_clr , 0.2 ) ;
lowlib.c:          if ( o->direction == 0 ) {
lowlib.c:              if ( o->percent > 0 ) kgRoundedRectangleFill ( fid , xp , lp*0.5+offset , l , lp , 1 , color , 0.0 ) ;
lowlib.c:      if ( o->Bimg != NULL ) {
lowlib.c:          kgRestoreImage ( D , o->Bimg , x1-2 , y1-2 , x2-x1+5 , y2-y1+5 ) ;
lowlib.c:      kgImage ( D , img , x1-2 , y1-2 , width+4 , height+4 , 0.0 , 1.0 ) ;
lowlib.c:      if ( o->hide ) return;
lowlib.c:      D = o->D;
lowlib.c:      wc = D->wc;
lowlib.c:      x1 = D->xo+o->x1+2;
lowlib.c:      y1 = D->yo+o->y1+2;
lowlib.c:      x2 = D->xo+o->x2-2;
lowlib.c:      y2 = D->yo+o->y2-2;
lowlib.c:      width = x2-x1+1;
lowlib.c:      height = y2-y1+1;
lowlib.c:          l = width-2*offset;
lowlib.c:          w = height -2*offset;
lowlib.c:      if ( w > l ) { o->direction = 1; lp = w*o->percent/100.0; }
lowlib.c:      else {o->direction = 0; lp = l*o->percent/100.0; }
lowlib.c:      color = o->clr;
lowlib.c:      if ( color == -1 ) color = D->gc.ProgColor;
lowlib.c:          kgUserFrame ( fid , -1.0 , -1.0 , ( float ) width+1.0 , \
lowlib.c:          bclr = o->bordr;
lowlib.c:          if ( bclr == -1 ) bclr = D->gc.ProgBodrColor;
lowlib.c:              bclr = -bclr;
lowlib.c:              color = -color;
lowlib.c:          if ( o->direction == 0 ) {
lowlib.c:               ( float ) w , 0 , D->gc.ProgFillColor , 0.5 ) ;
lowlib.c:               ( float ) w , color , D->gc.ProgFillColor , 0.5 ) ;
lowlib.c:              if ( o->percent > 0 ) kgRoundedRectangleFill ( fid , xp , lp*0.5+offset , l , lp , color , color , 0.5 ) ;
lowlib.c:      if ( o->Bimg != NULL ) {
lowlib.c:          kgRestoreImage ( D , o->Bimg , x1-2 , y1-2 , x2-x1+5 , y2-y1+5 ) ;
lowlib.c:      kgImage ( D , img , x1-2 , y1-2 , width+4 , height+4 , 0.0 , 1.0 ) ;
lowlib.c:      D = ( DIALOG * ) ( o->D ) ;
lowlib.c:      if ( o->percent < 0 ) o->percent = 0;
lowlib.c:      if ( o->percent > 100 ) o->percent = 100;
lowlib.c:      o->oldval = o->percent;
lowlib.c:      o->imgs = NULL;
lowlib.c:      x1 = D->xo+o->x1+1;
lowlib.c:      y1 = D->yo+o->y1+1;
lowlib.c:      x2 = D->xo+o->x2-1;
lowlib.c:      y2 = D->yo+o->y2-1;
lowlib.c:      if ( o->hide != 1 ) {
lowlib.c://    _dvrect_fill_transparent(wc,(x1),(y1),(x2), (y2),D->gc.fill_clr,D->transparency);
lowlib.c:          if ( o->Bimg == NULL ) o->Bimg = kgGetBackground \
lowlib.c:           ( D , x1-1 , y1-1 , x2+1 , y2+1 ) ;
lowlib.c:          if ( o->hide != 1 ) {
lowlib.c:              switch ( o->type ) {
lowlib.c:                  if ( o->Bimg != NULL ) kgRestoreImage ( D , o->Bimg , x1-1 , y1-1 , x2-x1+3 , y2-y1+3 ) ;
lowlib.c:                  l = x2-x1-2*offset;
lowlib.c:                  w = y2 -y1-2*offset;
lowlib.c:                  if ( w > l ) { o->direction = 1; lp = w* ( 100.-o->percent ) /100.0; }
lowlib.c:                  else {o->direction = 0; lp = l*o->percent/100.0; }
lowlib.c:                  color = o->clr;
lowlib.c:                  if ( color == -1 ) color = D->gc.ProgColor;
lowlib.c://       _dvbordertype0(D, x1+offset-2,y1+offset-2,x2+offset+2,y2-offset+2,D->gc.ProgBodrColor);
lowlib.c:                  _dvrect_fill ( wc , x1+offset , y1+offset , x2-offset , y2-offset , D->gc.ProgFillColor ) ;
lowlib.c:                  if ( o->direction == 0 ) {
lowlib.c:                      if ( o->percent > 0 ) _dvrect_fill ( wc , x1+offset , y1+offset+lp , x1+offset+l , y2-offset , color ) ;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( o->Bimg != NULL ) kgRestoreImage ( D , o->Bimg , x1-1 , y1-1 , x2-x1+3 , y2-y1+3 ) ;
lowlib.c:      bwsr = ( BRW_STR * ) w->bwsr;
lowlib.c:      bwsr->D = D;
lowlib.c:      _uiDrawMsg ( w->bwsr ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->x1 = y->x1+D->xo;
lowlib.c:      bwsr->y1 = y->y1+D->yo;
lowlib.c:      bwsr->x2 = y->x2+D->xo;
lowlib.c:      bwsr->y2 = y->y2+D->yo;
lowlib.c://  printf("%d %d %d %d:%d %d\n",y->x1,y->y1,y->x2,y->y2,y->width,y->size);
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   bwsr->y2 =y->y1+y1+y->size*y->width+2*y->offset;
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground ( D , bwsr->x1 , bwsr->y1 , bwsr->x2 , bwsr->y2 ) ;
lowlib.c:          bwsr->df = 1;
lowlib.c:          menu = ( char ** ) y->menu;
lowlib.c:          bwsr->hitem = 0;
lowlib.c:          bwsr->pos = 0;
lowlib.c:          bwsr->xb = bwsr->x2;
lowlib.c:          height = y->width;
lowlib.c:          bwsr->width = height;
lowlib.c:          y->size = ( y->y2-y->y1-2*y->offset ) /bwsr->width;
lowlib.c:          y->nitems = n;
lowlib.c:          if ( n > y->size ) {
lowlib.c:              exitems = n -y->size;
lowlib.c:              y->nitems = y->size;
lowlib.c://   if(y->size>y->nitems) y->size=y->nitems;
lowlib.c:          bwsr->w = y->w;
lowlib.c:          bwsr->offset = y->offset;
lowlib.c:          if ( y->size <= 0 ) {
lowlib.c:              y->size = 1;
lowlib.c://     y->y2 = height+y->y1+2*y->offset;
lowlib.c:          extra = ( y->y2 -y->y1-2*y->offset-y->size*height ) /2;
lowlib.c:          if ( extra < -y->offset ) extra = -y->offset;
lowlib.c://   bwsr->offset =y->offset+extra;
lowlib.c:          bwsr->scroll = 1;
lowlib.c:          bwsr->menu = ( char ** ) menu;
lowlib.c://   if(y->size<=y->nitems) {
lowlib.c:              bwsr->scroll = 0;
lowlib.c:          bwsr->size = y->size;
lowlib.c:          if ( bwsr->df > n ) bwsr->df = 1;
lowlib.c:          if ( bwsr->df < 1 ) bwsr->df = 1;
lowlib.c:          bwsr->df = exitems+1;
lowlib.c:          bwsr->pos = exitems;
lowlib.c:          bwsr->D = D;
lowlib.c:          gc = D->gc;
lowlib.c://   bwsr->MS.color1=gc.fill_clr;bwsr->MS.color2=gc.high_clr;
lowlib.c:          bwsr->MS.color1 = gc.msg_fill; bwsr->MS.color2 = gc.msg_bodr;
lowlib.c:          bwsr->MS.char_clr = gc.msg_char;
lowlib.c:          bwsr->hitem = bwsr->df-1;
lowlib.c:          w = bwsr->scroll*y->w;
lowlib.c:          bwsr->w = w;
lowlib.c:          bwsr->tbx1 = bwsr->x2 - y->offset -w;
lowlib.c:          bwsr->tby1 = bwsr->y1+y->offset;
lowlib.c:          bwsr->tbx2 = bwsr->tbx1+w;
lowlib.c:          bwsr->tby2 = bwsr->tby1+w;
lowlib.c:          bwsr->bbx1 = bwsr->tbx1;
lowlib.c:          bwsr->bby1 = bwsr->y2-y->offset-w;
lowlib.c:          bwsr->bbx2 = bwsr->bbx1+w;
lowlib.c:          bwsr->bby2 = bwsr->bby1+w;
lowlib.c:          bwsr->rsx1 = bwsr->tbx1;
lowlib.c:          bwsr->rsy1 = bwsr->tby2;
lowlib.c:          bwsr->rsx2 = bwsr->bbx2;
lowlib.c:          bwsr->rsy2 = bwsr->bby1;
lowlib.c:          _dvrect_fill_transparent ( wc , ( bwsr->x1 ) , ( bwsr->y1 ) , ( bwsr->x2 ) , \
lowlib.c:           ( bwsr->y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , ( bwsr->x1 ) , \
lowlib.c:           ( bwsr->y1 ) , ( bwsr->x2-bwsr->x1+1 ) , ( bwsr->y2-bwsr->y1+1 ) ) ;
lowlib.c:      elmt = t->elmt;
lowlib.c:      for ( row = 0; row < t->ny; row++ ) {
lowlib.c:          for ( col = 0; col < t->nx; col++ ) {
lowlib.c:                  pos = ( x - elmt [ box ] .x1 -5 ) / ( Gap+Wd ) ;
lowlib.c://        if(pos> (ln-1)) pos=ln-1;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:                  while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                      col = ( col+1 ) %t->nx;
lowlib.c:                      curbox = row*t->nx+col;
lowlib.c:                  t->col = col;
lowlib.c:                  t->row = row;
lowlib.c:                      if ( pos >= elmt [ box ] .ln ) pos = elmt [ box ] .ln-1;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:      return -1;
lowlib.c://  tit = t->tit;
lowlib.c:      elmt = t->elmt;
lowlib.c:      for ( row = 0; row < t->ny; row++ ) {
lowlib.c:          for ( col = 0; col < t->nx; col++ ) {
lowlib.c:                  pos = ( x - elmt [ box ] .x1 -5 ) / ( Gap+Wd ) ;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:                  while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                      col = ( col+1 ) %t->nx;
lowlib.c:                      curbox = row*t->nx+col;
lowlib.c:                  t->col = col;
lowlib.c:                  t->row = row;
lowlib.c://          if(pos >= t->ln[box])pos = t->ln[box]-1;
lowlib.c:                      if ( pos >= elmt [ box ] .ln ) pos = elmt [ box ] .ln-1;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:      return -1;
lowlib.c:      DIT *T = ( DIT * ) t->T;
lowlib.c://  tit = t->tit;
lowlib.c:      elmt = t->elmt;
lowlib.c:      D = t->D;
lowlib.c:      FontSize = D->gc.FontSize;
lowlib.c:      for ( row = 0; row < t->ny; row++ ) {
lowlib.c:          for ( col = 0; col < t->nx; col++ ) {
lowlib.c:              if ( t->elmt [ k ] .sw == 1 ) {Active = 1; break;}
lowlib.c:      if ( Active == 0 ) return -1;
lowlib.c:      for ( row = 0; row < t->ny; row++ ) {
lowlib.c:          for ( col = 0; col < t->nx; col++ ) {
lowlib.c:                  pos = ( x - elmt [ box ] .x1 -FontSize/2 ) / ( FontSize ) ;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:                  while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                      col = ( col+1 ) %t->nx;
lowlib.c:                      curbox = row*t->nx+col;
lowlib.c:                      if ( curbox >= ( t->nx*t->ny ) ) curbox = 0;
lowlib.c:                  t->col = curbox%t->nx;
lowlib.c:                  t->row = curbox/t->nx;
lowlib.c:                  T->col = t->col;
lowlib.c:                  T->row = t->row;
lowlib.c://          if(pos >= t->ln[box])pos = t->ln[box]-1;
lowlib.c:                      if ( pos >= elmt [ box ] .ln ) pos = elmt [ box ] .ln-1;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:      return -1;
lowlib.c://  tit = t->tit;
lowlib.c:      elmt = t->elmt;
lowlib.c:      curbox = t->row*t->nx+t->col;
lowlib.c:              if ( _ui_cuthighlightstring ( t ) ) return -1;
lowlib.c:          row = t->row;
lowlib.c:          row = ( row-1 ) ;
lowlib.c:          if ( row < 0 ) row = t->ny-1;
lowlib.c:          col = t->col;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:              col = ( col+1 ) %t->nx;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:          t->col = col;
lowlib.c:          t->row = row;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          row = t->row;
lowlib.c:          row = ( row+1 ) %t->ny;
lowlib.c:          col = t->col;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:              col = ( col+1 ) %t->nx;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:          t->col = col;
lowlib.c:          t->row = row;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          if ( t->nx == 1 ) {
lowlib.c:              col = t->col;
lowlib.c:              row = t->row;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              if ( t->elmt [ curbox ] .cursor > 0 ) {
lowlib.c:                  t->elmt [ curbox ] .cursor -= 1;
lowlib.c:                  if ( ( t->elmt [ curbox ] .cursor < t->elmt [ curbox ] .startchar ) ) t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:              row = t->row;
lowlib.c:              col = t->col;
lowlib.c:              col--;
lowlib.c:              if ( col < 0 ) col = t->nx-1;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                  col = ( col+1 ) %t->nx;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:              t->col = col;
lowlib.c:              t->row = row;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:          if ( t->nx == 1 ) {
lowlib.c:              col = t->col;
lowlib.c:              row = t->row;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              ln = t->elmt [ curbox ] .ln-1;
lowlib.c:              if ( t->elmt [ curbox ] .cursor < ( MAXTITEMLN-2 ) ) {
lowlib.c:                  if ( t->elmt [ curbox ] .df [ t->elmt [ curbox ] .cursor ] != '\0' ) {
lowlib.c:                      t->elmt [ curbox ] .cursor += 1;
lowlib.c:                      if ( ( t->elmt [ curbox ] .cursor - t->elmt [ curbox ] .startchar ) > ln ) t->elmt [ curbox ] .startchar+= 1;
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:              col = t->col;
lowlib.c:              col = ( col+1 ) %t->nx;
lowlib.c:              row = t->row;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                  col = ( col+1 ) %t->nx;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:              t->col = col;
lowlib.c:              t->row = row;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return t->row*t->ny+t->col;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          if ( t->elmt [ curbox ] .cursor < ( MAXTITEMLN-2 ) ) {
lowlib.c:              if ( t->elmt [ curbox ] .df [ t->elmt [ curbox ] .cursor ] != '\0' ) {
lowlib.c:                  t->elmt [ curbox ] .cursor += 1;
lowlib.c:                  if ( ( t->elmt [ curbox ] .cursor - t->elmt [ curbox ] .startchar ) > ln ) t->elmt [ curbox ] .startchar+= 1;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( t->elmt [ curbox ] .cursor > 0 ) {
lowlib.c:              t->elmt [ curbox ] .cursor -= 1;
lowlib.c:              if ( ( t->elmt [ curbox ] .cursor < t->elmt [ curbox ] .startchar ) ) t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          t->elmt [ curbox ] .cursor = 0;
lowlib.c:          t->elmt [ curbox ] .startchar = 0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          t->elmt [ curbox ] .cursor = strlen ( t->elmt [ curbox ] .df ) ;
lowlib.c:          t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor -ln;
lowlib.c:          if ( t->elmt [ curbox ] .startchar < 0 ) t->elmt [ curbox ] .startchar = 0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          t->elmt [ curbox ] .df [ 0 ] = '\0';
lowlib.c:          t->elmt [ curbox ] .cursor = 0;
lowlib.c:          t->elmt [ curbox ] .startchar = 0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          t->elmt [ curbox ] .df [ t->elmt [ curbox ] .cursor ] = '\0';
lowlib.c://    t->elmt[curbox].cursor = 0;
lowlib.c://    t->elmt[curbox].startchar =0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( _ui_deletechar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor ) ) \
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( t->elmt [ curbox ] .cursor > 0 ) {
lowlib.c:              if ( t->elmt [ curbox ] .startchar > 0 ) {
lowlib.c:                  t->elmt [ curbox ] .startchar -= 1;
lowlib.c:                  t->elmt [ curbox ] .cursor -= 1;
lowlib.c:                  if ( _ui_deletechar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor ) ) \
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:                  t->elmt [ curbox ] .cursor -= 1;
lowlib.c:                  if ( ( t->elmt [ curbox ] .cursor < t->elmt [ curbox ] .startchar ) ) t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor;
lowlib.c:                  if ( _ui_deletechar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor ) ) \
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c://    if(key== ' ') printf("Got Space :%s %d %d %d\n",t->elmt[curbox].df,col,row,curbox);
lowlib.c:          if ( ( ret = _ui_insertchar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor , MAXTITEMLN-2 , key ) ) ) \
lowlib.c:              t->elmt [ curbox ] .cursor += ret;
lowlib.c:              ln = t->elmt [ curbox ] .ln;
lowlib.c:              if ( ( t->elmt [ curbox ] .cursor - t->elmt [ curbox ] .startchar ) >= ln ) t->elmt [ curbox ] .startchar+= 1;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c://    printf("ret = %d: %d\n",ret,t->elmt[curbox].cursor);
lowlib.c:          return -1;
lowlib.c:      return -1;
lowlib.c:      DIT *T = ( DIT * ) t->T;
lowlib.c://  tit = t->tit;
lowlib.c:      elmt = t->elmt;
lowlib.c:      for ( row = 0; row < t->ny; row++ ) {
lowlib.c:          for ( col = 0; col < t->nx; col++ ) {
lowlib.c:              if ( t->elmt [ k ] .sw == 1 ) {Active = 1; box++;break;}
lowlib.c:      if ( Active == 0 ) return -1;
lowlib.c:          row = t->row;
lowlib.c:          row = ( row-1 ) ;
lowlib.c:              col = t->col;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                  col = ( col+1 ) %t->nx;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:                  row = row -1;
lowlib.c:                  if ( row >= 0 ) curbox = row*t->nx+col;
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:              t->col = curbox%t->nx;
lowlib.c:              t->row = curbox/t->nx;
lowlib.c:              T->col = t->col;
lowlib.c:              T->row = t->row;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:          row = t->row;
lowlib.c:          if ( row < t->ny ) {
lowlib.c:              col = t->col;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                  col = ( col+1 ) %t->nx;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:                  if ( row < t->ny ) curbox = row*t->nx+col;
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:              t->col = curbox%t->nx;
lowlib.c:              t->row = curbox/t->nx;
lowlib.c:              T->col = t->col;
lowlib.c:              T->row = t->row;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c://          if ( t->nx == 1 ) {
lowlib.c:              col = t->col;
lowlib.c:              row = t->row;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              if ( t->elmt [ curbox ] .cursor > 0 ) {
lowlib.c:                  t->elmt [ curbox ] .cursor -= 1;
lowlib.c:                  if ( ( t->elmt [ curbox ] .cursor < t->elmt [ curbox ] .startchar ) ) t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:              row = t->row;
lowlib.c:              col = t->col;
lowlib.c:              col--;
lowlib.c:              if ( col < 0 ) col = t->nx-1;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                  col = ( col+1 ) %t->nx;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:              t->col = col;
lowlib.c:              t->row = row;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c://          if ( t->nx == 1 ) {
lowlib.c:              col = t->col;
lowlib.c:              row = t->row;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              ln = t->elmt [ curbox ] .ln-1;
lowlib.c:              if ( t->elmt [ curbox ] .cursor < ( MAXTITEMLN-2 ) ) {
lowlib.c:                  if ( t->elmt [ curbox ] .df [ t->elmt [ curbox ] .cursor ] != '\0' ) {
lowlib.c:                      t->elmt [ curbox ] .cursor += 1;
lowlib.c:                      if ( ( t->elmt [ curbox ] .cursor - t->elmt [ curbox ] .startchar ) > ln ) t->elmt [ curbox ] .startchar+= 1;
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:              col = t->col;
lowlib.c:              col = ( col+1 ) %t->nx;
lowlib.c:              row = t->row;
lowlib.c:              curbox = row*t->nx+col;
lowlib.c:              while ( t->elmt [ curbox ] .sw != 1 ) {
lowlib.c:                  col = ( col+1 ) %t->nx;
lowlib.c:                  curbox = row*t->nx+col;
lowlib.c:              t->col = col;
lowlib.c:              t->row = row;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:              return -1;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return t->row*t->ny+t->col;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          if ( t->elmt [ curbox ] .cursor < ( MAXTITEMLN-2 ) ) {
lowlib.c:              if ( t->elmt [ curbox ] .df [ t->elmt [ curbox ] .cursor ] != '\0' ) {
lowlib.c:                  t->elmt [ curbox ] .cursor += 1;
lowlib.c:                  if ( ( t->elmt [ curbox ] .cursor - t->elmt [ curbox ] .startchar ) > ln ) t->elmt [ curbox ] .startchar+= 1;
lowlib.c:                  uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( t->elmt [ curbox ] .cursor > 0 ) {
lowlib.c:              t->elmt [ curbox ] .cursor -= 1;
lowlib.c:              if ( ( t->elmt [ curbox ] .cursor < t->elmt [ curbox ] .startchar ) ) t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          t->elmt [ curbox ] .cursor = 0;
lowlib.c:          t->elmt [ curbox ] .startchar = 0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          t->elmt [ curbox ] .cursor = strlen ( t->elmt [ curbox ] .df ) ;
lowlib.c:          t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor -ln;
lowlib.c:          if ( t->elmt [ curbox ] .startchar < 0 ) t->elmt [ curbox ] .startchar = 0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          ln = t->elmt [ curbox ] .ln-1;
lowlib.c:          t->elmt [ curbox ] .df [ 0 ] = '\0';
lowlib.c:          t->elmt [ curbox ] .cursor = 0;
lowlib.c:          t->elmt [ curbox ] .startchar = 0;
lowlib.c:          uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( _ui_deletechar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor ) ) \
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( t->elmt [ curbox ] .cursor > 0 ) {
lowlib.c:              if ( t->elmt [ curbox ] .startchar > 0 ) {
lowlib.c:                  t->elmt [ curbox ] .startchar -= 1;
lowlib.c:                  t->elmt [ curbox ] .cursor -= 1;
lowlib.c:                  if ( _ui_deletechar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor ) ) \
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:                  t->elmt [ curbox ] .cursor -= 1;
lowlib.c:                  if ( ( t->elmt [ curbox ] .cursor < t->elmt [ curbox ] .startchar ) ) t->elmt [ curbox ] .startchar = t->elmt [ curbox ] .cursor;
lowlib.c:                  if ( _ui_deletechar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor ) ) \
lowlib.c:                      uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:          col = t->col;
lowlib.c:          row = t->row;
lowlib.c:          curbox = row*t->nx+col;
lowlib.c:          if ( ( ret = _ui_insertchar ( t->elmt [ curbox ] .df , t->elmt [ curbox ] .cursor , MAXTITEMLN-2 , key ) ) ) \
lowlib.c:              t->elmt [ curbox ] .cursor += ret;
lowlib.c:              ln = t->elmt [ curbox ] .ln;
lowlib.c:              if ( ( t->elmt [ curbox ] .cursor - t->elmt [ curbox ] .startchar ) >= ln ) t->elmt [ curbox ] .startchar+= 1;
lowlib.c:              uiUpdateOn ( t->D ) ;
lowlib.c:          return -1;
lowlib.c:      return -1;
lowlib.c:      nxx = t->nx;
lowlib.c:      nyy = t->ny;
lowlib.c:      n = nxx*t->ny;
lowlib.c:      if ( t->tit [ ii ] .sw != 1 ) ii = 0;
lowlib.c:      while ( t->tit [ ii ] .sw != 1 ) {
lowlib.c:      menu_x = t->tit [ ii ] .x1+5;
lowlib.c:      menu_y = EVGAY- ( t->tit [ ii ] .y2-6 ) ;
lowlib.c:      ptr = t->tit [ ii ] .df;
lowlib.c:                  i--; if ( i < 0 ) {
lowlib.c:                      i = nyy-1; k = 0;
lowlib.c:                  k--; if ( k < 0 ) k = nxx-1;
lowlib.c:                  while ( t->tit [ p ] .sw != 1 ) {
lowlib.c:                      k--; if ( k < 0 ) {k = 0; break; }
lowlib.c:                  while ( t->tit [ p ] .sw != 1 ) {
lowlib.c:                      k++; if ( k >= nxx ) {k = nxx-1; break; }
lowlib.c:                      _rect_fill ( menu_x , menu_y-Bt , menu_x+ ( t->ln [ ii ] -1-j ) *nine , menu_y+Ht , fill_clr ) ;
lowlib.c:                      j--;
lowlib.c:                      for ( p = j; p < t->ln [ ii ] -2; p++ ) {
lowlib.c:                          ptr = t->tit [ ii ] .df+p;
lowlib.c:                          menu_x = t->tit [ ii ] .x1+5+p*nine;
lowlib.c:                      ptr = t->tit [ ii ] .df+j;
lowlib.c:                      menu_x = t->tit [ ii ] .x1+5+j*nine;
lowlib.c:                      _rect_fill ( menu_x+Gap , menu_y-Bt , menu_x+Gap+Wd , menu_y+Ht , cur_clr ) ;
lowlib.c:                  _rect_fill ( menu_x+Gap , menu_y-Bt , menu_x+Gap+Wd , menu_y+Ht , fill_clr ) ;
lowlib.c:                  j++; if ( j == ( t->ln [ ii ] -1 ) ) j = t->ln [ ii ] -2;
lowlib.c:                  ptr = t->tit [ ii ] .df+j;
lowlib.c:                  menu_x = t->tit [ ii ] .x1+5+j*nine;
lowlib.c:                  _rect_fill ( menu_x+Gap , menu_y-Bt , menu_x+Gap+Wd , menu_y+Ht , cur_clr ) ;
lowlib.c:      p = D->d [ item ] .p;
lowlib.c:      p->item = item;
lowlib.c:      p->Bimg = NULL;
lowlib.c:      if ( p->transparency > 0.000001 ) {
lowlib.c:          p->Bimg = kgGetBackground ( D , p->x1 , p->y1 , p->x2 , p->y2 ) ;
lowlib.c://    kgWriteImage(p->img,"/root/DIP.jpg");
lowlib.c:      buf = ( char ** ) ( p->xpm ) ;
lowlib.c:      pt = ( char * ) ( p->xpm ) ;
lowlib.c:      x1 = p->x1+D->xo;
lowlib.c:      y1 = p->y1+D->yo;
lowlib.c:      x2 = p->x2+D->xo;
lowlib.c:      y2 = p->y2+D->yo;
lowlib.c:      color = p->bkgr_clr;
lowlib.c:      w = x2 -x1;
lowlib.c:      l = ( y2 - y1 ) ;
lowlib.c:          _uibox_fill ( wc , x1 , D->evgay-y1 , x2-2 , D->evgay-y2+1 , \
lowlib.c:          gc = D->gc;
lowlib.c://       jpg_image(p->xpm,x1,y1,w,l);
lowlib.c:              kgImage ( D , p->xpm , x1 , y1 , w , l , 0.0 , 1.0 ) ;
lowlib.c:      while ( Dtmp->Newwin == 0 ) {
lowlib.c:          Dtmp = ( DIALOG * ) ( Dtmp->parent ) ;
lowlib.c:      p = D->d [ item ] .p;
lowlib.c:      p->item = item;
lowlib.c:      p->D = D;
lowlib.c:      buf = ( char ** ) ( p->xpm ) ;
lowlib.c:      pt = ( char * ) ( p->xpm ) ;
lowlib.c:      x1 = p->x1+D->xo;
lowlib.c:      y1 = p->y1+D->yo;
lowlib.c:      x2 = p->x2+D->xo;
lowlib.c:      y2 = p->y2+D->yo;
lowlib.c:      color = p->bkgr_clr;
lowlib.c:      w = x2 -x1;
lowlib.c:      l = ( y2 - y1 ) ;
lowlib.c:          _uibox_fill ( wc , x1 , D->evgay-y1 , x2-2 , D->evgay-y2+1 , \
lowlib.c:          gc = D->gc;
lowlib.c://       jpg_image_transparent(p->xpm,x1,y1,w,l,D->transparency);
lowlib.c://       jpg_image(p->xpm,x1,y1,w,l);
lowlib.c:              kgImage ( D , p->xpm , x1 , y1 , w , l , D->transparency , 1.0 ) ;
lowlib.c:      D = p->D;
lowlib.c:      x1 = p->x1+D->xo;
lowlib.c:      y1 = p->y1+D->yo;
lowlib.c:      x2 = p->x2+D->xo;
lowlib.c:      y2 = p->y2+D->yo;
lowlib.c:      w = x2 -x1;
lowlib.c:      l = ( y2 - y1 ) ;
lowlib.c:      if ( p->hide != 1 ) {
lowlib.c:          buf = ( char ** ) ( p->xpm ) ;
lowlib.c:          pt = ( char * ) ( p->xpm ) ;
lowlib.c:          color = p->bkgr_clr;
lowlib.c:          if ( p->Bimg == NULL ) {
lowlib.c:              p->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c:          if ( p->transparency > 0.000001 ) {
lowlib.c://    if(p->img!= NULL) kgFreeImage(p->img);
lowlib.c:                      img1 = kgGetImageCopy ( D , p->xpm ) ;
lowlib.c:                      kgAddTransparency ( img1 , p->transparency ) ;
lowlib.c:                      img2 = kgGetImageCopy ( D , p->Bimg ) ;
lowlib.c:                  else kgRestoreImage ( D , p->Bimg , x1 , y1 , w+1 , l+1 ) ;
lowlib.c:              else kgRestoreImage ( D , p->Bimg , x1 , y1 , w+1 , l+1 ) ;
lowlib.c:              kgRestoreImage ( D , p->Bimg , x1 , y1 , w+1 , l+1 ) ;
lowlib.c:              if ( D->DrawBkgr != 0 ) {
lowlib.c:                      gc = D->gc;
lowlib.c:                       ( unsigned int ) color , D->transparency ) ;
lowlib.c:                      kgImage ( D , p->xpm , x1 , y1 , w , l , D->transparency , 1.0 ) ;
lowlib.c:              switch ( p->bordr ) {
lowlib.c:                  _dvbordertype1 ( D , x1-offset , y1-offset , x2+offset , y2+offset ) ;
lowlib.c:                  _dvbordertype0 ( D , x1-offset , y1-offset , x2+offset , y2+offset , gc.bright ) ;
lowlib.c:                  _dvbordertype2 ( D , x1-offset , y1-offset , x2+offset , y2+offset , 0 , 0 , 0 , 0 ) ;
lowlib.c:                  _dvbordertype3 ( D , x1-offset , y1-offset , x2+offset , y2+offset ) ;
lowlib.c:                  _dvbordertype4 ( D , x1-offset , y1-offset , x2+offset , y2+offset ) ;
lowlib.c:                  dvdraw_protru ( D , x1-offset , y1-offset , x2+offset , y2+offset ) ;
lowlib.c:          if ( p->Bimg != NULL ) {
lowlib.c:              kgRestoreImage ( D , p->Bimg , x1 , y1 , w+1 , l+1 ) ;
lowlib.c://      printf("p->img  NULL\n");
lowlib.c:               ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      p = D->d [ item ] .p;
lowlib.c:      p->item = item;
lowlib.c:      p->D = D;
lowlib.c:      p->Bimg = NULL;
lowlib.c:      if ( p->hide != 1 ) _uiMake_P ( p ) ;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      _ui_h_line ( wc , ( int ) x1 , ( int ) x2-1 , ( int ) y1 ) ;
lowlib.c:      chrs = ( x2-ix-10 ) /9;
lowlib.c:      lines = ( y2-iy-2 ) /22;
lowlib.c:      uiPressedBoxFill ( D , ix , iy , ( x2-ix ) , ( y2-iy ) , D->gc.info_fill , D->gc.fill_clr , 3 , 0.0 ) ;
lowlib.c:      Twin->xl = ix+5; Twin->yl = iy+4; Twin->xu = x2-2;
lowlib.c:      y2 = ( 22*lines+Twin->yl ) ;
lowlib.c:      Twin->yu = y2; Twin->w = 0;
lowlib.c:      Twin->nchr = chrs;
lowlib.c:      Twin->xp = Twin->xl;
lowlib.c:      Twin->yp = Twin->yl;
lowlib.c:      I = D->d [ item ] .i;
lowlib.c:      I->D = D;
lowlib.c:      I->item = item; ;
lowlib.c:      I->Bimg = NULL;
lowlib.c:      I->twin = _uiput_txtwin ( D , I->x1+D->xo , ( I->y1+D->yo ) , I->x2+D->xo , \
lowlib.c:       ( I->y2+D->yo ) ) ;
lowlib.c:      D = ( DIALOG * ) ( I->D ) ;
lowlib.c:      x1 = I->x1+D->xo; x2 = I->x2+D->xo;
lowlib.c:      y1 = I->y1+D->yo; y2 = I->y2+D->yo;
lowlib.c:      if ( I->linewidth <= 0 ) I->linewidth = lw;
lowlib.c:      if ( I->hide != 1 ) {
lowlib.c:          lw = I->linewidth;
lowlib.c:          if ( lw > ( y2-y1-2 ) ) lw = y2-y1-2;
lowlib.c:          chrs = ( x2-x1-10 ) /9;
lowlib.c:          lines = ( y2-y1-2 ) /lw;
lowlib.c:              lw = y2-y1-2;
lowlib.c:          I->linewidth = lw;
lowlib.c:          uiPressedBoxFill ( D , x1 , y1 , ( x2-x1 ) , ( y2-y1 ) , D->gc.info_fill , D->gc.fill_clr , 3 , 0.0 ) ;
lowlib.c:          Twin = ( TWIN * ) ( I->twin ) ;
lowlib.c:          Twin->xl = x1+5; Twin->yl = y1+4; Twin->xu = x2-2;
lowlib.c:          y2 = ( lw*lines+Twin->yl ) ;
lowlib.c:          Twin->yu = y2; Twin->w = lw;
lowlib.c:          Twin->nchr = chrs;
lowlib.c:          Twin->xp = Twin->xl;
lowlib.c:          Twin->yp = Twin->yl;
lowlib.c:           ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      I = D->d [ item ] .i;
lowlib.c:      I->D = D;
lowlib.c:      I->item = item;
lowlib.c:      I->twin = ( void * ) Malloc ( sizeof ( TWIN ) ) ;
lowlib.c:      I->linewidth = 22;
lowlib.c:      I->Bimg = NULL;
lowlib.c:      if ( I->hide != 1 ) _uiMake_I ( I ) ;
lowlib.c:      yy = D->evgay-y;
lowlib.c:      elmt = tx->elmt+tx->row*tx->nx+tx->col;
lowlib.c:      ln = elmt->ln;
lowlib.c:      df = elmt->df+elmt->startchar;
lowlib.c:      elmt = tx->elmt+tx->row*tx->nx+tx->col;
lowlib.c:      if ( elmt->hlt == 0 ) return NULL;
lowlib.c:      ln = elmt->ln;
lowlib.c:      df = elmt->df+elmt->startchar;
lowlib.c:      xs = elmt->hxs;
lowlib.c:      xe = elmt->hxe;
lowlib.c:      start = ( xs-4 ) / ( Wd+Gap ) -1;
lowlib.c:      end = ( xe-4 ) / ( Wd+Gap ) -1;
lowlib.c:      strl = ( end-start+1 ) ;
lowlib.c:      elmt = tx->elmt+tx->row*tx->nx+tx->col;
lowlib.c:      if ( elmt->hlt == 0 ) return 0;
lowlib.c:      ln = elmt->ln;
lowlib.c:      df = elmt->df+elmt->startchar;
lowlib.c:      xs = elmt->hxs;
lowlib.c:      xe = elmt->hxe;
lowlib.c:      start = ( xs-4 ) / ( Wd+Gap ) -1;
lowlib.c:      end = ( xe-4 ) / ( Wd+Gap ) -1;
lowlib.c:      strl = ( end-start+1 ) ;
lowlib.c:      elmt->hlt = 0;
lowlib.c:      elmt->cursor = start+elmt->startchar;
lowlib.c:      kgUpdateOn ( tx->D ) ;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c://  tit= tx->tit;
lowlib.c:      type = tx->T->type;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      curbox = tx->row*tx->nx+tx->col;
lowlib.c://  ln = tx->ln[curbox];
lowlib.c:      x1 = ( tx->elmt [ curbox ] .x1 ) ;
lowlib.c:      y1 = ( tx->elmt [ curbox ] .y1 ) ;
lowlib.c:      x2 = ( tx->elmt [ curbox ] .x2 ) ;
lowlib.c:      y2 = ( tx->elmt [ curbox ] .y2 ) ;
lowlib.c:      noecho = tx->elmt [ curbox ] .noecho;
lowlib.c:              Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:              img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c://         _dvrect_fill_transparent(WC(D),x1-2,y1,x2+2,y2,D->gc.fill_clr,D->transparency);
lowlib.c://         kgImage(D,img,x1-1,y1,x2-x1+5,y2-y1,0.0,1.0);
lowlib.c:          kgRestoreImage ( D , img , x1-1 , y1 , x2-x1+5 , y2-y1 ) ;
lowlib.c:          _uirect_fill ( WC ( D ) , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:          if ( ( hxe-hxs ) > 2 ) {
lowlib.c:              if ( hxe > ( elmt [ curbox ] .x2-3 ) ) hxe = elmt [ curbox ] .x2-3;
lowlib.c:              cy = D->evgay-cy;
lowlib.c:              _uirect_fill ( WC ( D ) , hxs , cy-Bt , hxe , cy+Ht , tx->gc.high_clr ) ;
lowlib.c:      cx = elmt [ curbox ] .x1+6+ ( elmt [ curbox ] .cursor-elmt [ curbox ] .startchar ) * \
lowlib.c:      cy = D->evgay-cy;
lowlib.c:      _uirect_fill ( WC ( D ) , cx+Gap+1 , cy-Bt , cx+Gap+1+Wd , cy+Ht , tx->gc.cur_clr ) ;
lowlib.c:      cy = D->evgay-cy;
lowlib.c:          uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:          _ui_putstring ( D , elmt [ curbox ] .x1+6 , cy , df , tx->gc.txt_char ) ;
lowlib.c:          uiSetNoechoFontSize ( D , D->gc.InputFontSize/2 ) ;
lowlib.c:          for ( i = 0; i < ( ln-1 ) ; i++ ) {
lowlib.c:          stars [ ln-1 ] = '\0';
lowlib.c:          _ui_putstring ( D , elmt [ curbox ] .x1+7 , cy , stars , tx->gc.txt_char ) ;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c://  tit= tx->tit;
lowlib.c:      type = tx->T->type;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      n = tx->nx*tx->ny;
lowlib.c:      i = tx->row*tx->nx+tx->col;
lowlib.c:          x1 = ( tx->elmt [ curbox ] .x1 ) ;
lowlib.c:          y1 = ( tx->elmt [ curbox ] .y1 ) ;
lowlib.c:          x2 = ( tx->elmt [ curbox ] .x2 ) ;
lowlib.c:          y2 = ( tx->elmt [ curbox ] .y2 ) ;
lowlib.c:          noecho = tx->elmt [ curbox ] .noecho;
lowlib.c:                  Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:                  img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c://         _dvrect_fill_transparent(WC(D),x1-2,y1,x2+2,y2,D->gc.fill_clr,D->transparency);
lowlib.c://         kgImage(D,img,x1-1,y1,x2-x1+5,y2-y1,0.0,1.0);
lowlib.c:              kgRestoreImage ( D , img , x1-1 , y1 , x2-x1+5 , y2-y1 ) ;
lowlib.c:              _uirect_fill ( WC ( D ) , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:          cx = elmt [ curbox ] .x1+6+ ( elmt [ curbox ] .cursor- elmt [ curbox ] .startchar ) * \
lowlib.c:          cy = D->evgay-cy;
lowlib.c:              _uirect_fill ( WC ( D ) , cx+Gap+1 , cy-Bt , cx+Gap+1+Wd , cy+Ht , tx->gc.cur_clr ) ;
lowlib.c:          cy = D->evgay-cy;
lowlib.c:              uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:              _ui_putstring ( D , elmt [ curbox ] .x1+6 , cy , df , tx->gc.txt_char ) ;
lowlib.c:              uiSetNoechoFontSize ( D , D->gc.InputFontSize/2 ) ;
lowlib.c:              for ( i = 0; i < ( ln-1 ) ; i++ ) {
lowlib.c:              stars [ ln-1 ] = '\0';
lowlib.c:              _ui_putstring ( D , elmt [ curbox ] .x1+7 , cy , stars , tx->gc.txt_char ) ;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      type = tx->T->type;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c:      curbox = tx->row*tx->nx+tx->col;
lowlib.c:      curbox = tx->row*tx->nx+tx->col;
lowlib.c:      Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:      img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c:      type = tx->T->type;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c://  tit= tx->tit;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      curbox = tx->row*tx->nx+tx->col;
lowlib.c://  ln = tx->ln[curbox];
lowlib.c:      x1 = ( tx->elmt [ curbox ] .x1 ) ;
lowlib.c:      y1 = ( tx->elmt [ curbox ] .y1 ) ;
lowlib.c:      x2 = ( tx->elmt [ curbox ] .x2 ) ;
lowlib.c:      y2 = ( tx->elmt [ curbox ] .y2 ) ;
lowlib.c:      noecho = tx->elmt [ curbox ] .noecho;
lowlib.c:              Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:              img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c:          _dvrect_fill_transparent ( WC ( D ) , x1-2 , y1 , x2+2 , y2 , D->gc.fill_clr , D->transparency ) ;
lowlib.c://         kgImage(D,img,x1-1,y1,x2-x1+5,y2-y1,0.0,1.0);
lowlib.c:          kgRestoreImage ( D , img , x1-1 , y1 , x2-x1+5 , y2-y1 ) ;
lowlib.c:          _uirect_fill ( WC ( D ) , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:      _uirect_fill ( WC ( D ) , elmt [ curbox ] .x1 , EVGAY-elmt [ curbox ] .y1 , elmt [ curbox ] .x2-1 , EVGAY-elmt [ curbox ] .y2+1 , tx->gc.txt_fill ) ;
lowlib.c:      uidraw_depre ( D , elmt [ curbox ] .x1 , EVGAY-elmt [ curbox ] .y1 , elmt [ curbox ] .x2 , EVGAY-elmt [ curbox ] .y2 ) ;
lowlib.c:          uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:          _ui_putstring ( D , elmt [ curbox ] .x1+6 , cy , df , tx->gc.txt_char ) ;
lowlib.c:          uiSetNoechoFontSize ( D , D->gc.InputFontSize/2 ) ;
lowlib.c:          for ( i = 0; i < ( ln-1 ) ; i++ ) {
lowlib.c:          stars [ ln-1 ] = '\0';
lowlib.c:          _ui_putstring ( D , elmt [ curbox ] .x1+7 , cy , stars , tx->gc.txt_char ) ;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c:      T = tx->T;
lowlib.c://  tit= tx->tit;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      curbox = tx->row*tx->nx+tx->col;
lowlib.c://  ln = tx->ln[curbox];
lowlib.c:      _uirect_fill ( WC ( D ) , elmt [ curbox ] .x1 , D->evgay-elmt [ curbox ] .y1 , elmt [ curbox ] .x2-1 , D->evgay-elmt [ curbox ] .y2+1 , tx->gc.tabl_fill ) ;
lowlib.c:      cx = elmt [ curbox ] .x1+T->FontSize/2+ ( elmt [ curbox ] .cursor-elmt [ curbox ] .startchar ) * \
lowlib.c:       ( T->FontSize ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , cx , cy , cx+T->FontSize , elmt [ curbox ] .y2-2 , D->gc.cur_clr ) ;
lowlib.c://  uiSetGuiFixFontSize(D,D->gc.FontSize);
lowlib.c://  _ui_putstring(D,elmt[curbox].x1+5,elmt[curbox].y2-4,df,tx->gc.tabl_char);
lowlib.c:      uiPutString ( D , df , elmt [ curbox ] .x1+T->FontSize/2 , elmt [ curbox ] .y2-T->FontSize/2 , tx->gc.tabl_char , T->Font , T->FontSize ) ;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c:      T = tx->T;
lowlib.c:      EVGAY = D->evgay;
lowlib.c://  tit= tx->tit;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      curbox = tx->row*tx->nx+tx->col;
lowlib.c://  ln = tx->ln[curbox];
lowlib.c:      _uirect_fill ( WC ( D ) , elmt [ curbox ] .x1 , EVGAY-elmt [ curbox ] .y1 , elmt [ curbox ] .x2-1 , EVGAY-elmt [ curbox ] .y2+1 , tx->gc.tabl_fill ) ;
lowlib.c://  uiSetGuiFixFontSize(D,D->gc.FontSize);
lowlib.c://  _ui_putstring(D,elmt[curbox].x1+5,elmt[curbox].y2-4,df,tx->gc.tabl_char);
lowlib.c:      uiPutString ( D , df , elmt [ curbox ] .x1+T->FontSize/2 , elmt [ curbox ] .y2-T->FontSize/2 , tx->gc.tabl_char , T->Font , T->FontSize ) ;
lowlib.c:      if ( T->hide == 1 ) return 0;
lowlib.c:      type = T->type;
lowlib.c:      tx = T->tstr;
lowlib.c:      tempc = D->gc.char_clr;
lowlib.c:      X1 = tx->x1;
lowlib.c:      Y1 = tx->y1;
lowlib.c:      nx = tx->nx;
lowlib.c:      ny = tx->ny;
lowlib.c://  tit = tx->tit;
lowlib.c:      width = tx->width;
lowlib.c:      elmt = tx->elmt;
lowlib.c:                  elmt [ k ] .startchar = l-size;
lowlib.c://     tx->ln[k]=l+1;
lowlib.c:              tx->elmt [ k ] .ln = l+1;
lowlib.c:              elmt [ k ] .df [ MAXTITEMLN-1 ] = '\0';
lowlib.c:      X2 = X1+xlng+ ( nx-1 ) *xgap+xgap;
lowlib.c:      Y2 = Y1+ny*width+ ( ny-1 ) *ygap+ygap;
lowlib.c:      tx->x2 = X2;
lowlib.c:      tx->y2 = Y2;
lowlib.c://  uidraw_inset(D,xx1-1,D->evgay-1-yy1+6,xx2+1,D->evgay-1-yy2-6);
lowlib.c:      if ( T->hide != 1 ) {
lowlib.c:              for ( i = 0; i < tx->ny; i++ ) {
lowlib.c://     uiwrite_string(D,elmt[k].pr,x1,D->evgay-1-y2+6,tx->gc.txt_pchar);
lowlib.c:                  uiString ( D , elmt [ k ] .pr , x1 , y1-2 , prsize-D->gc.FontSize , box_width , D->gc.PromptFont , tx->gc.txt_pchar , D->gc.FontSize , 1 , D->gc.fill_clr ) ;
lowlib.c:                  x2 = x1 + ( ( tx->elmt [ k ] .ln ) *9 ) +13;
lowlib.c:                   ( tx->elmt [ k ] .x1 ) = x1;
lowlib.c:                   ( tx->elmt [ k ] .y1 ) = y1;
lowlib.c:                   ( tx->elmt [ k ] .x2 ) = x2;
lowlib.c:                   ( tx->elmt [ k ] .y2 ) = y2;
lowlib.c:                  noecho = tx->elmt [ k ] .noecho;
lowlib.c:                          Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:                          img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c://         _dvrect_fill_transparent(WC(D),x1-2,y1,x2+2,y2,D->gc.fill_clr,D->transparency);
lowlib.c://         kgImage(D,img,x1-1,y1,x2-x1+5,y2-y1,0.0,1.0);
lowlib.c:                      kgRestoreImage ( D , img , x1-1 , y1 , x2-x1+5 , y2-y1 ) ;
lowlib.c:                      _uirect_fill ( wc , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:                  _uirect_fill ( wc , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:                  uidraw_depre ( D , x1 , D->evgay-y1 , x2 , D->evgay-y2 ) ;
lowlib.c:                      uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:                      _ui_putstring ( D , x1+6 , cy , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.txt_char ) ;
lowlib.c:                      uiSetNoechoFontSize ( D , D->gc.InputFontSize/2 ) ;
lowlib.c:                      for ( i = 0; i < ( ln-1 ) ; i++ ) {
lowlib.c:                      stars [ ln-1 ] = '\0';
lowlib.c:                      _ui_putstring ( D , x1+7 , cy , stars , tx->gc.txt_char ) ;
lowlib.c:                  x1 -= prsize;
lowlib.c://  uidraw_inset(D,X1,D->evgay-1-Y1,X2,D->evgay-1-Y2);
lowlib.c:          if ( T->bordr == 1 ) {
lowlib.c:              X1 = D->xo+T->x1+2; Y1 = D->yo+T->y1+2;
lowlib.c:              X2 = D->xo+T->x2-2; Y2 = D->yo+T->y2-2;
lowlib.c:              _dv_draw_bound ( D , ( X1 ) , ( Y1 ) , ( X2 ) , ( Y2 ) , D->gc.high_clr ) ;
lowlib.c:       ( x2 ) , ( y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:      type = T->type;
lowlib.c:      D = T->D;
lowlib.c:      tx = T->tstr;
lowlib.c://  tit= tx->tit;
lowlib.c:      elmt = T->elmt;
lowlib.c:      tempc = D->gc.char_clr;
lowlib.c:      n = T->nx*T->ny;
lowlib.c:      X1 = T->x1+D->xo+2;
lowlib.c:      Y1 = T->y1+D->yo+2;
lowlib.c:      tx->x2 = X1;
lowlib.c:      tx->y1 = Y1;
lowlib.c:      tx->x1 = X1;
lowlib.c:      tx->y2 = Y1;
lowlib.c:      nx = tx->nx;
lowlib.c:      ny = tx->ny;
lowlib.c://  tit = tx->tit;
lowlib.c:      width = tx->width;
lowlib.c:      elmt = tx->elmt;
lowlib.c:                  elmt [ k ] .startchar = l-size;
lowlib.c:              tx->elmt [ k ] .ln = l+1;
lowlib.c:              elmt [ k ] .df [ MAXTITEMLN-1 ] = '\0';
lowlib.c:      X2 = X1+xlng+ ( nx-1 ) *xgap+xgap;
lowlib.c:      Y2 = Y1+ny*width+ ( ny-1 ) *ygap+ygap;
lowlib.c:      tx->x2 = X2;
lowlib.c:      tx->y2 = Y2;
lowlib.c:      if ( T->hide != 1 ) {
lowlib.c:          if ( T->Bimg == NULL ) T->Bimg = kgGetBackground \
lowlib.c:          else kgRestoreImage ( D , T->Bimg , ( X1 ) , \
lowlib.c:           ( Y1 ) , ( X2-X1+1 ) , ( Y2-Y1+1 ) ) ;
lowlib.c:              tx->col = j;
lowlib.c:              for ( i = 0; i < tx->ny; i++ ) {
lowlib.c:                  tx->row = i;
lowlib.c:                  x2 = x1 + ( ( tx->elmt [ k ] .ln ) *9 ) +13;
lowlib.c:                   ( tx->elmt [ k ] .x1 ) = x1;
lowlib.c:                   ( tx->elmt [ k ] .y1 ) = y1;
lowlib.c:                   ( tx->elmt [ k ] .x2 ) = x2;
lowlib.c:                   ( tx->elmt [ k ] .y2 ) = y2;
lowlib.c:                          DoInAnyThread ( D->ThInfo , _uiMakeTextBoxImage , tx ) ;
lowlib.c:                  WaitThreads ( D->ThInfo ) ;
lowlib.c:                  x1 -= prsize;
lowlib.c:           ( X2 ) , ( Y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:          tx->col = 0;
lowlib.c:          tx->row = 0;
lowlib.c:              for ( i = 0; i < tx->ny; i++ ) {
lowlib.c://       uiString(D,elmt[k].pr,x1,y1,prsize-D->gc.FontSize,box_width,D->gc.PromptFont,tx->gc.txt_pchar,D->gc.FontSize,1,D->gc.fill_clr);
lowlib.c:                  uiString ( D , elmt [ k ] .pr , x1 , y1 , prsize-D->gc.FontSize , box_width , D->gc.PromptFont , tx->gc.txt_pchar , D->gc.FontSize , 1 , -1 ) ;
lowlib.c:                  x2 = x1 + ( ( tx->elmt [ k ] .ln ) *9 ) +13;
lowlib.c:                   ( tx->elmt [ k ] .x1 ) = x1;
lowlib.c:                   ( tx->elmt [ k ] .y1 ) = y1;
lowlib.c:                   ( tx->elmt [ k ] .x2 ) = x2;
lowlib.c:                   ( tx->elmt [ k ] .y2 ) = y2;
lowlib.c:                          Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:                          img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c://         kgImage(D,img,x1-1,y1,x2-x1+5,y2-y1,0.0,1.0);
lowlib.c:                      kgRestoreImage ( D , img , x1-1 , y1 , x2-x1+5 , y2-y1 ) ;
lowlib.c:                      _uirect_fill ( wc , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:                      if ( hxe > ( elmt [ k ] .x2-3 ) ) hxe = elmt [ k ] .x2-3;
lowlib.c:                      cy = D->evgay-cy;
lowlib.c:                      _uirect_fill ( wc , hxs , cy-Bt , hxe , cy+Ht , tx->gc.high_clr ) ;
lowlib.c:                      cx = elmt [ k ] .x1+6+ ( elmt [ k ] .cursor-elmt [ k ] .startchar ) * \
lowlib.c:                      cy = D->evgay-cy;
lowlib.c:                      _uirect_fill ( wc , cx+Gap+1 , cy-Bt , cx+Gap+1+Wd , cy+Ht , tx->gc.cur_clr ) ;
lowlib.c:                      uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:                      _ui_putstring ( D , x1+6 , ( y1+y2 ) /2+6 , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.txt_char ) ;
lowlib.c:                      uiSetNoechoFontSize ( D , D->gc.InputFontSize/2 ) ;
lowlib.c:                      for ( i = 0; i < ( ln-1 ) ; i++ ) {
lowlib.c:                      stars [ ln-1 ] = '\0';
lowlib.c:                      _ui_putstring ( D , x1+7 , ( y1+y2 ) /2+6 , stars , tx->gc.txt_char ) ;
lowlib.c:                  x1 -= prsize;
lowlib.c:          tx->col = 0;
lowlib.c:          tx->row = 0;
lowlib.c:          if ( T->bordr == 1 ) {
lowlib.c:              X1 = D->xo+T->x1+2; Y1 = D->yo+T->y1+2;
lowlib.c:              X2 = D->xo+T->x2-2; Y2 = D->yo+T->y2-2;
lowlib.c:              _dv_draw_bound ( D , ( X1 ) , ( Y1 ) , ( X2 ) , ( Y2 ) , D->gc.high_clr ) ;
lowlib.c:// _dvrect_fill_transparent(WC(D),(X1),(Y1),(X2), (Y2),D->gc.fill_clr,D->transparency);
lowlib.c:          if ( T->Bimg != NULL ) kgRestoreImage ( D , T->Bimg , \
lowlib.c:           ( X1 ) , ( Y1 ) , ( X2-X1+1 ) , ( Y2-Y1+1 ) ) ;
lowlib.c:      tx = T->tstr;
lowlib.c:      tempc = D->gc.char_clr;
lowlib.c:      X1 = tx->x1;
lowlib.c:      Y1 = tx->y1;
lowlib.c:      nx = tx->nx;
lowlib.c:      ny = tx->ny;
lowlib.c://  tit = tx->tit;
lowlib.c:      width = tx->width;
lowlib.c:      elmt = tx->elmt;
lowlib.c:                  elmt [ k ] .startchar = l-size;
lowlib.c:              tx->elmt [ k ] .ln = l+1;
lowlib.c:              elmt [ k ] .df [ MAXTITEMLN-1 ] = '\0';
lowlib.c://  Y2= Y1+ny*width+(ny-1)*10;
lowlib.c:      tx->x2 = X2;
lowlib.c:      tx->y2 = Y2;
lowlib.c:          for ( i = 0; i < tx->ny; i++ ) {
lowlib.c:              x2 = x1 + ( ( tx->elmt [ k ] .ln ) *9 ) +13;
lowlib.c:              tx2 = x2-1; ty2 = y2-1;
lowlib.c:               ( tx->elmt [ k ] .x1 ) = tx1;
lowlib.c:               ( tx->elmt [ k ] .y1 ) = ty1;
lowlib.c:               ( tx->elmt [ k ] .x2 ) = tx2;
lowlib.c:               ( tx->elmt [ k ] .y2 ) = ty2;
lowlib.c:              _uirect_fill ( wc , tx1 , D->evgay-ty1 , tx2-1 , D->evgay-ty2 , tx->gc.tabl_fill ) ;
lowlib.c:              uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:              if ( elmt [ k ] .sw == 0 ) _ui_putstring ( D , tx1+5 , ty2-4 , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.tabl_hchar ) ;
lowlib.c:              else _ui_putstring ( D , tx1+5 , ty2-4 , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.tabl_char ) ;
lowlib.c:              _ui_draw_bound ( ( D ) , x1 , D->evgay-y1 , x2 , D->evgay-y2 , tx->gc.tabl_line ) ;
lowlib.c:      uidraw_proj ( D , X1-2 , D->evgay-Y1+2 , X2+2 , D->evgay-Y2-2 ) ;
lowlib.c:      int type = T->type;
lowlib.c:      D = T->D;
lowlib.c:      Fz = T->FontSize;
lowlib.c:      tx = T->tstr;
lowlib.c:      if ( T->hide != 1 ) {
lowlib.c:          tempc = D->gc.char_clr;
lowlib.c:          X1 = T->x1+D->xo+4;
lowlib.c:          Y1 = T->y1+D->yo+4;
lowlib.c:          tx->x2 = X1;
lowlib.c:          tx->y1 = Y1;
lowlib.c:          tx->x1 = X1;
lowlib.c:          tx->y2 = Y1;
lowlib.c:          X1 = tx->x1;
lowlib.c:          Y1 = tx->y1;
lowlib.c:          nx = tx->nx;
lowlib.c:          ny = tx->ny;
lowlib.c:          width = tx->width;
lowlib.c:          elmt = tx->elmt;
lowlib.c:          tx->col = 0;
lowlib.c:          tx->row = 0;
lowlib.c:          n = tx->nx*tx->ny;
lowlib.c:          curpos = -1;
lowlib.c:              if ( T->elmt [ i ] .sw == 1 ) {curpos = i; break;}
lowlib.c:              tx->col = curpos%tx->nx;
lowlib.c:              tx->row = curpos/tx->nx;
lowlib.c:                      elmt [ k ] .startchar = l-size;
lowlib.c:                      elmt [ k ] .cursor = l-size;
lowlib.c:                  tx->elmt [ k ] .ln = l+1;
lowlib.c:                  elmt [ k ] .df [ MAXTITEMLN-1 ] = '\0';
lowlib.c:          tx->x2 = X2;
lowlib.c:          tx->y2 = Y2;
lowlib.c:              for ( i = 0; i < tx->ny; i++ ) {
lowlib.c:                  x2 = x1 + ( ( tx->elmt [ k ] .ln ) *Fz ) +Fz+4;
lowlib.c:                  tx2 = x2-1; ty2 = y2-1;
lowlib.c:                   ( tx->elmt [ k ] .x1 ) = tx1;
lowlib.c:                   ( tx->elmt [ k ] .y1 ) = ty1;
lowlib.c:                   ( tx->elmt [ k ] .x2 ) = tx2;
lowlib.c:                   ( tx->elmt [ k ] .y2 ) = ty2;
lowlib.c:                  if ( type == 0 ) _uirect_fill ( wc , tx1 , D->evgay-ty1 , tx2-1 , D->evgay-ty2 , tx->gc.tabl_fill ) ;
lowlib.c:                  if ( type == 1 ) _uirect_fill ( wc , tx1 , D->evgay-ty1+2 , tx2 , D->evgay-ty2-2 , tx->gc.tabl_fill ) ;
lowlib.c://       uiSetGuiFixFontSize(D,D->gc.FontSize);
lowlib.c:                  if ( elmt [ k ] .sw == 0 ) _ui_putstring ( D , tx1+5 , ty2-4 , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.tabl_hchar ) ;
lowlib.c:                  else _ui_putstring ( D , tx1+5 , ty2-4 , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.tabl_char ) ;
lowlib.c:                  if ( elmt [ k ] .sw == 0 ) uiPutString ( D , str , tx1+T->FontSize/2 , ty2-T->FontSize/2 , tx->gc.tabl_hchar , T->Font , T->FontSize ) ;
lowlib.c:                  else uiPutString ( D , str , tx1+T->FontSize/2 , ty2-T->FontSize/2 , tx->gc.tabl_char , T->Font , T->FontSize ) ;
lowlib.c:                  if ( type == 0 ) _ui_draw_bound ( ( D ) , x1 , D->evgay-y1 , x2 , D->evgay-y2 , tx->gc.tabl_line ) ;
lowlib.c:          if ( type == 0 ) uidraw_proj ( D , X1-2 , D->evgay-Y1+2 , X2+2 , D->evgay-Y2-2 ) ;
lowlib.c:          X1 = T->x1+D->xo; X2 = T->x2+D->xo;
lowlib.c:          Y1 = T->y1+D->yo; Y2 = T->y2+D->yo;
lowlib.c:           ( Y2 ) , D->gc.fill_clr , D->transparency ) ;
lowlib.c:                  size = size*10+ ( *cpt -'0' ) ;
lowlib.c:                  size = size*10+ ( *cpt -'0' ) ;
lowlib.c:                  sprintf ( dfmt , "%%-%-dd" , size ) ;
lowlib.c:                  sprintf ( ffmt , "%%-%-dg" , size ) ;
lowlib.c:                  sprintf ( dfmt , "%%-%-dlg" , size ) ;
lowlib.c:                  sprintf ( sfmt , "%%-%-ds" , size ) ;
lowlib.c:                  wrk [ MAXTITEMLN-1 ] = '\0';
lowlib.c:                  chpt [ size-1 ] = '\0';
lowlib.c:                  strncpy ( wrk , chpt , size-1 ) ;
lowlib.c:                  wrk [ size-1 ] = '\0';
lowlib.c:                  for ( i = l; i < size-1; i++ ) wrk [ i ] = ' ';
lowlib.c://  tit->pr = (char *) malloc((strlen(prompt)+1)*sizeof(char));
lowlib.c://  tit->df = (char *) malloc((strlen(field)+1)*sizeof(char));
lowlib.c:      strcpy ( tit->pr , prompt ) ;
lowlib.c:      strcpy ( tit->df , field ) ;
lowlib.c:      tit->df [ MAXTITEMLN-1 ] = '\0';
lowlib.c:      tit->sw = sw;
lowlib.c:      cp = elmt->fmt;
lowlib.c:      v = elmt->v;
lowlib.c:      sw = elmt->sw;
lowlib.c:                  size = size*10+ ( *cpt -'0' ) ;
lowlib.c:                  sprintf ( dfmt , "%%-%-dd" , size ) ;
lowlib.c:                  sprintf ( ffmt , "%%-%-dg" , size ) ;
lowlib.c:                  sprintf ( dfmt , "%%-%-dlg" , size ) ;
lowlib.c:                  sprintf ( sfmt , "%%-%-ds" , size ) ;
lowlib.c:                  if ( l > MAXTITEMLN-1 ) l = MAXTITEMLN-1;
lowlib.c:                  chpt [ size-1 ] = '\0';
lowlib.c:                  strncpy ( wrk , chpt , size-1 ) ;
lowlib.c:                  wrk [ size-1 ] = '\0';
lowlib.c:                  for ( i = l; i < size-1; i++ ) wrk [ i ] = ' ';
lowlib.c:      strcpy ( elmt->pr , prompt ) ;
lowlib.c:      strcpy ( elmt->df , field ) ;
lowlib.c:      elmt->df [ MAXTITEMLN-1 ] = '\0';
lowlib.c:      T = D->d [ no ] .t;
lowlib.c:      tx = T->tstr;
lowlib.c:      tx = T->tstr;
lowlib.c:      D = ( DIALOG * ) ( tx->D ) ;
lowlib.c:      type = T->type;
lowlib.c:      tempc = D->gc.char_clr;
lowlib.c:      X1 = tx->x1;
lowlib.c:      Y1 = tx->y1;
lowlib.c:      nx = tx->nx;
lowlib.c:      ny = tx->ny;
lowlib.c://  tit = tx->tit;
lowlib.c:      elmt = tx->elmt;
lowlib.c:      width = tx->width;
lowlib.c:      n = tx->nx*tx->ny;
lowlib.c:              elmt [ k ] .startchar = l-size;
lowlib.c:      for ( i = 0; i < tx->ny; i++ ) {
lowlib.c:              x1 = ( tx->elmt [ k ] .x1 ) ;
lowlib.c:              y1 = ( tx->elmt [ k ] .y1 ) ;
lowlib.c:              x2 = ( tx->elmt [ k ] .x2 ) ;
lowlib.c:              y2 = ( tx->elmt [ k ] .y2 ) ;
lowlib.c:              noecho = tx->elmt [ k ] .noecho;
lowlib.c:                      Bimg = kgGetBackground ( D , x1-1 , y1 , x2+4 , y2 ) ;
lowlib.c:                      img = kgPressedRectangle ( x2-x1+2 , abs ( y2-y1 ) , tx->gc.txt_fill , 0.5 ) ;
lowlib.c://         _dvrect_fill_transparent(WC(D),x1-2,y1,x2+2,y2,D->gc.fill_clr,D->transparency);
lowlib.c://         kgImage(D,img,x1-1,y1,x2-x1+5,y2-y1,0.0,1.0);
lowlib.c:                  kgRestoreImage ( D , img , x1-1 , y1 , x2-x1+5 , y2-y1 ) ;
lowlib.c:                  _uirect_fill ( wc , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:              _uirect_fill ( wc , x1 , D->evgay-y1 , x2-1 , D->evgay-y2+1 , tx->gc.txt_fill ) ;
lowlib.c:              uidraw_depre ( D , x1 , D->evgay-y1 , x2 , D->evgay-y2 ) ;
lowlib.c:              uiSetGuiFixFontSize ( D , D->gc.FontSize ) ;
lowlib.c:                  uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:                  _ui_putstring ( D , x1+6 , cy , elmt [ k ] .df+elmt [ k ] .startchar , tx->gc.txt_char ) ;
lowlib.c:                  uiSetNoechoFontSize ( D , D->gc.InputFontSize/2 ) ;
lowlib.c:                  for ( i = 0; i < ( ln-1 ) ; i++ ) {
lowlib.c:                  stars [ ln-1 ] = '\0';
lowlib.c:                  _ui_putstring ( D , x1+7 , cy , stars , tx->gc.txt_char ) ;
lowlib.c:                  size = size*10+ ( *cpt -'0' ) ;
lowlib.c:                  err = sscanf ( tit->df , "%d" , lpt ) ;
lowlib.c:                  else ret = -1;
lowlib.c:                  err = sscanf ( tit->df , "%g" , fpt ) ;
lowlib.c:                  else ret = -1;
lowlib.c:                  err = sscanf ( tit->df , "%lf" , dpt ) ;
lowlib.c:                  else ret = -1;
lowlib.c://      tit->df[size-1]='\0';
lowlib.c:                  while ( tit->df [ i ] >= ' ' ) i++;
lowlib.c:                  tit->df [ i ] = '\0';
lowlib.c:                  stripblnk ( tit->df ) ;
lowlib.c:                  if ( strcmp ( chpt , tit->df ) != 0 ) {
lowlib.c:                      strcpy ( chpt , tit->df ) ;
lowlib.c:      cp = elmt->fmt;
lowlib.c:      v = elmt->v;
lowlib.c:                  size = size*10+ ( *cpt -'0' ) ;
lowlib.c:                  err = sscanf ( elmt->df , "%d" , lpt ) ;
lowlib.c:                  else ret = -1;
lowlib.c:                  err = sscanf ( elmt->df , "%g" , fpt ) ;
lowlib.c:                  else ret = -1;
lowlib.c:                  err = sscanf ( elmt->df , "%lf" , dpt ) ;
lowlib.c:                  else ret = -1;
lowlib.c://      elmt->df[size-1]='\0';
lowlib.c:                  while ( elmt->df [ i ] >= ' ' ) {
lowlib.c:                      if ( i == ( MAXTITEMLN-1 ) ) {elmt->df [ i ] = '\0'; break; }
lowlib.c:                  elmt->df [ i ] = '\0';
lowlib.c://      stripblnk(elmt->df);
lowlib.c:                  if ( strcmp ( chpt , elmt->df ) != 0 ) {
lowlib.c:                      strcpy ( chpt , elmt->df ) ;
lowlib.c:                  strcpy ( wrk , elmt->df ) ;
lowlib.c:                  i = strlen ( wrk ) -1;
lowlib.c:                  if ( ( i > 0 ) && ( wrk [ i ] == ' ' ) ) {wrk [ i ] = '\0'; i--; }
lowlib.c:                  {wrk [ i ] = '\0'; i--; }
lowlib.c:      n = tx->nx*tx->ny;
lowlib.c:      e = tx->elmt;
lowlib.c://     if((err=read_t_item(e[i].fmt,e[i].v,tx->tit+i))<0){
lowlib.c:              ret = -1;
lowlib.c:      t = D->d [ item ] .t;
lowlib.c:      t->item = item;
lowlib.c:      t->D = D;
lowlib.c:      t->Bimg = NULL;
lowlib.c:      X1 = t->x1+D->xo+2;
lowlib.c:      Y1 = t->y1+D->yo+2;
lowlib.c:      nx = t->nx;
lowlib.c:      ny = t->ny;
lowlib.c:      width = t->width;
lowlib.c:      elmt = t->elmt;
lowlib.c:      tx->elmt = elmt;
lowlib.c://   tx->Nx=NULL;
lowlib.c:      tx->nx = nx;
lowlib.c:      tx->ny = ny;
lowlib.c:      tx->width = width;
lowlib.c:      tx->x2 = X1;
lowlib.c:      tx->y1 = Y1;
lowlib.c:      tx->x1 = X1;
lowlib.c:      tx->y2 = Y1;
lowlib.c:      tx->col = 0;
lowlib.c:      if ( elmt [ tx->col ] .sw != 1 ) tx->col = tx->col+1;
lowlib.c:      if ( tx->col >= nx ) {
lowlib.c:      tx->row = 0;
lowlib.c:      tx->gc = Dtmp->gc;
lowlib.c:      tx->D = D;
lowlib.c:      tx->T = t;
lowlib.c:      t->tstr = tx;
lowlib.c:      if ( t->hide != 1 ) _uiMake_Tx ( t ) ;
lowlib.c:      T = D->d [ item ] .t;
lowlib.c:      T->item = item;
lowlib.c:      T->D = D;
lowlib.c:      T->Bimg = NULL;
lowlib.c:      X1 = T->x1+D->xo+4;
lowlib.c:      Y1 = T->y1+D->yo+4;
lowlib.c:      nx = T->nx;
lowlib.c:      ny = T->ny;
lowlib.c:      width = T->width;
lowlib.c:      elmt = T->elmt;
lowlib.c:      tx->elmt = elmt;
lowlib.c://   tx->Nx=NULL;
lowlib.c:      tx->x2 = X1;
lowlib.c:      tx->y1 = Y1;
lowlib.c:      tx->nx = nx;
lowlib.c:      tx->ny = ny;
lowlib.c:      tx->width = width;
lowlib.c:      tx->x1 = X1;
lowlib.c:      tx->y2 = Y1;
lowlib.c:      tx->col = 0;
lowlib.c:      if ( elmt [ tx->col ] .sw != 1 ) tx->col = tx->col+1;
lowlib.c:      if ( tx->col >= nx ) {
lowlib.c:      tx->row = 0;
lowlib.c:      tx->gc = Dtmp->gc;
lowlib.c:      tx->D = D;
lowlib.c:      T->tstr = tx;
lowlib.c:      tx->T = T;
lowlib.c:      if ( T->hide != 1 ) _uiMake_Ta ( T ) ;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      lngth = D->Hsize+2;
lowlib.c:      b = D->d [ item ] .H;
lowlib.c:      b->D = D;
lowlib.c:      b->item = item;
lowlib.c:      b->Bimg = NULL;
lowlib.c:      if ( b->df == NULL ) { b->df = ( int * ) ( & ( b->bval ) ) ; }
lowlib.c:      b->buts = make_but_str ( D , b->x1+x1+lngth , b->y1+y1+lngth , b->xgap , b->ygap , b->nx , b->ny , b->lngth , b->width , * \
lowlib.c:       ( b->df ) , b->titles , b->xpm , b->bkgr , b->sw ) ;
lowlib.c:      buts = ( BUTS * ) ( b->buts ) ;
lowlib.c:      buts->D = D;
lowlib.c:      buts->Hsize = D->Hsize;
lowlib.c:      buts->type = b->type;
lowlib.c:      buts->fac = b->fac;
lowlib.c:      buts->bordr = 0;
lowlib.c:      buts->Widget = b;
lowlib.c:      if ( b->hide != 1 ) _uiMake_H ( b ) ;
lowlib.c:      D = ( DIALOG * ) ( B->D ) ;
lowlib.c:      nx = B->nx;
lowlib.c:      ny = B->ny;
lowlib.c:      transparency = D->transparency;
lowlib.c:      butns = B->buts;
lowlib.c:      xgap = B->xgap;
lowlib.c:      ygap = B->ygap;
lowlib.c:      ln = B->lngth;
lowlib.c:      wd = B->width;
lowlib.c:      type = B->type;
lowlib.c://        xo = D->xo+B->x1+offset+xgap/2;
lowlib.c:          xo = D->xo+B->x1+offset;
lowlib.c:          yo = D->yo+B->y1+offset;
lowlib.c:          xo = D->xo+B->x1+offset;
lowlib.c:          yo = D->yo+B->y1+offset;
lowlib.c:      y1 = yo-dy-2-ygap+mf*ygap/2;
lowlib.c:          x1 = xo -dx-2-xgap+xgap/2;
lowlib.c:              butns [ i ] .D = B->D;
lowlib.c:              if ( * ( B->df ) == ( i+1 ) ) butns [ i ] .highli = 1;
lowlib.c:              if ( D->butattn == 0 ) {butns [ i ] .highli = 0; highli = 0; }
lowlib.c:                  if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:              butns [ i ] .imgn = uiMakeStringImage ( D , butns [ i ] .title , xpm , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , 0 , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , 0 , B->type ) ;
lowlib.c:              butns [ i ] .imgp = uiMakeStringImage ( D , butns [ i ] .title , xpm , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , 0 , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , -1 , B->type ) ;
lowlib.c:              butns [ i ] .imgh = uiMakeStringImage ( D , butns [ i ] .title , xpm , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , 0 , B->type ) ;
lowlib.c:      D = ( DIALOG * ) ( B->D ) ;
lowlib.c:      nx = B->nx;
lowlib.c:      ny = B->ny;
lowlib.c:      transparency = D->transparency;
lowlib.c:      butns = B->buts;
lowlib.c:      xgap = B->xgap;
lowlib.c:      ygap = B->ygap;
lowlib.c:      ln = B->lngth;
lowlib.c:      wd = B->width;
lowlib.c:      type = B->type;
lowlib.c://        xo = D->xo+B->x1+offset+xgap/2;
lowlib.c:          xo = D->xo+B->x1+offset;
lowlib.c:          yo = D->yo+B->y1+offset;
lowlib.c:          xo = D->xo+B->x1+offset;
lowlib.c:          yo = D->yo+B->y1+offset;
lowlib.c:      y1 = yo-dy-2-ygap+mf*ygap/2;
lowlib.c:          x1 = xo -dx-2-xgap+xgap/2;
lowlib.c:              butns [ i ] .D = B->D;
lowlib.c:              if ( * ( B->df ) == ( i+1 ) ) butns [ i ] .highli = 1;
lowlib.c:              if ( D->butattn == 0 ) {butns [ i ] .highli = 0; highli = 0; }
lowlib.c:                  if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:      D = ( DIALOG * ) ( B->D ) ;
lowlib.c:      nx = B->nx;
lowlib.c:      ny = B->ny;
lowlib.c:      transparency = D->transparency;
lowlib.c:      butns = B->buts;
lowlib.c:      xgap = B->xgap;
lowlib.c:      ygap = B->ygap;
lowlib.c:      ln = B->lngth;
lowlib.c:      wd = B->width;
lowlib.c:      type = B->type;
lowlib.c:      xo = D->xo+B->x1+offset;
lowlib.c:      yo = D->yo+B->y1+offset;
lowlib.c:      y1 = yo-dy-ygap+mf*ygap/2;
lowlib.c://    y2 = y1+dy-1+mfp;
lowlib.c:          x1 = xo -dx-xgap+xgap/2;
lowlib.c:              butns [ i ] .D = B->D;
lowlib.c:              if ( * ( B->df ) == ( i+1 ) ) butns [ i ] .highli = 1;
lowlib.c:              if ( D->butattn == 0 ) {butns [ i ] .highli = 0; highli = 0; }
lowlib.c://      x2 = x1+dx-1+mfp;
lowlib.c:                  if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:      B = ( DIN * ) ( butns->Widget ) ;
lowlib.c:      butno = butns->butno;
lowlib.c:      D = ( DIALOG * ) ( B->D ) ;
lowlib.c:      nx = B->nx;
lowlib.c:      ny = B->ny;
lowlib.c:      transparency = D->transparency;
lowlib.c:      butns = B->buts;
lowlib.c:      xgap = B->xgap;
lowlib.c:      ygap = B->ygap;
lowlib.c:      ln = B->lngth;
lowlib.c:      wd = B->width;
lowlib.c:      type = B->type;
lowlib.c:          if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:      butns [ i ] .imgn = uiMakeStringImage ( D , butns [ i ] .title , Bcopy , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , 0 , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , 0 , B->type ) ;
lowlib.c:      butns [ i ] .imgp = uiMakeStringImage ( D , butns [ i ] .title , Bcopy , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , 0 , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , -1 , B->type ) ;
lowlib.c:      butns [ i ] .imgh = uiMakeStringImage ( D , butns [ i ] .title , Bcopy , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , 0 , B->type ) ;
lowlib.c:      B = ( DIN * ) ( butns->Widget ) ;
lowlib.c:      butno = butns->butno;
lowlib.c:      D = ( DIALOG * ) ( B->D ) ;
lowlib.c:      nx = B->nx;
lowlib.c:      ny = B->ny;
lowlib.c:      transparency = D->transparency;
lowlib.c:      butns = B->buts;
lowlib.c:      xgap = B->xgap;
lowlib.c:      ygap = B->ygap;
lowlib.c:      ln = ( ( B->lngth-1 ) /2 ) *2-1;
lowlib.c:      wd = ( ( B->width-1 ) /2 ) *2-1;
lowlib.c:      ln = B->lngth;
lowlib.c:      wd = B->width;
lowlib.c:      type = B->type;
lowlib.c:          if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:      butns [ i ] .imgn = uiMakeStringImage ( D , butns [ i ] .title , xpm , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , 0 , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , 0 , B->type ) ;
lowlib.c:      butns [ i ] .imgp = uiMakeStringImage ( D , butns [ i ] .title , xpm , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , 0 , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , -1 , B->type ) ;
lowlib.c:      butns [ i ] .imgh = uiMakeStringImage ( D , butns [ i ] .title , xpm , x1 , y1 , ln+mfp , wd+mfp , D->gc.ButtonFont , bkgr , highli , D->gc.but_char , D->gc.GuiFontSize , 0 , B->fac , 0 , B->type ) ;
lowlib.c:      if ( B->type != 0 ) return;
lowlib.c:      D = ( DIALOG * ) ( B->D ) ;
lowlib.c:      nx = B->nx;
lowlib.c:      ny = B->ny;
lowlib.c:      transparency = D->transparency;
lowlib.c:      butns = B->buts;
lowlib.c:      xgap = B->xgap;
lowlib.c:      ygap = B->ygap;
lowlib.c:      ln = B->lngth;
lowlib.c:      wd = B->width;
lowlib.c:              x1 = butns [ i ] .x1+2-xgap/2;
lowlib.c:              x2 = butns [ i ] .x2+xgap/2-2;
lowlib.c:                  if ( bkgr == -1 ) bkgr = D->gc.fill_clr;
lowlib.c:               ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:              uiString ( D , butns [ i ] .title , x1 , y1 , width , ygap-1 , D->gc.ButtonFont , D->gc.but_char , D->gc.GuiFontSize , 0 , -1 ) ;
lowlib.c:      b = D->d [ item ] .n;
lowlib.c:      b->D = D;
lowlib.c:      b->item = item;
lowlib.c:      b->Bimg = NULL;
lowlib.c:      Hsize = D->Hsize;
lowlib.c:      x1 = D->xo;
lowlib.c:      y1 = D->yo;
lowlib.c:      switch ( b->code ) {
lowlib.c:          prompt = ( char * ) b->prompt;
lowlib.c:          while ( ( b->prompt [ i ] ) == ' ' ) i++;
lowlib.c:          while ( ( b->prompt [ i+n ] ) != '\0' ) n++;
lowlib.c:          b->buts = make_but_str ( D , b->x1+x1+lngth , b->y1+y1+Hsize+2 , b->xgap , b->ygap , b->nx , b->ny , b->lngth , b->width , * \
lowlib.c:           ( b->df ) , b->titles , b->xpm , b->bkgr , sw ) ;
lowlib.c:          buts = ( BUTS * ) ( b->buts ) ;
lowlib.c:          buts->D = D;
lowlib.c:          buts->Hsize = D->Hsize;
lowlib.c:          buts->type = b->type;
lowlib.c:          buts->fac = b->fac;
lowlib.c:          buts->bordr = b->bordr;
lowlib.c:          buts->Widget = b;
lowlib.c:          sw = ( int * ) ( B->sw ) ;
lowlib.c:          if ( B->df == NULL ) { B->df = ( int * ) ( & ( B->bval ) ) ; }
lowlib.c:          B->buts = NULL;
lowlib.c:          if ( B->df == NULL ) { B->df = ( int * ) ( & ( B->bval ) ) ; }
lowlib.c:      if ( b->hide != 1 ) _uiMake_B ( b ) ;
lowlib.c:      b = D->d [ item ] .N;
lowlib.c:      b->D = D;
lowlib.c:      b->item = item;
lowlib.c:      b->Bimg = NULL;
lowlib.c:      Hsize = D->Hsize;
lowlib.c:      buts = ( BUT_STR * ) b->buts;
lowlib.c:      b->df = ( int * ) ( & ( b->bval ) ) ;
lowlib.c:      n = b->nx*b->ny;
lowlib.c:      if ( b->hide != 1 ) _uiMake_N ( b ) ;
lowlib.c:      d = ( DID * ) uiGetWidget ( pt->D , pt->id ) ;
lowlib.c:      xx = pt->x;
lowlib.c:      yy = pt->y;
lowlib.c:      scr_ln = pt->l;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      l = scr_ln+2*pt->Sldwd+6;
lowlib.c:      fac = pt->fac;
lowlib.c:      sx = ( pt->df- ( pt->min ) ) *fac;
lowlib.c:      if ( _uiGetSItem ( kbe , xx+3 , yy+3 , xx+w-3 , yy+w-3 ) ) { mvnt = -1; }
lowlib.c:      if ( _uiGetSItem ( kbe , xx+l-w+3 , yy+3 , xx+l-3 , yy+w-3 ) ) mvnt = 1;
lowlib.c:      if ( _uiGetSItem ( kbe , xx+w+3 , yy+3 , xx+l-w-3 , yy+w-3 ) ) \
lowlib.c:      { mvnt = kbe.x-xx -w -3+2- pt->df; }
lowlib.c:          df = pt->df;
lowlib.c:          pt->df += mvnt;
lowlib.c:          if ( pt->df < 0 ) pt->df = 0;
lowlib.c:          if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:          if ( df != pt->df ) {
lowlib.c:              _ui_moveslidepointer ( pt->D , pt ) ;
lowlib.c:              _ui_slidevalue ( pt->D , pt ) ;
lowlib.c://      d[i].d->Update(code,i,D);
lowlib.c:              switch ( d->code ) {
lowlib.c:                  if ( d->Update != NULL ) d->Update ( _ui_getdslidevalue \
lowlib.c:                   ( pt ) , pt->id , pt->D ) ;
lowlib.c:              uiUpdateOn ( pt->D ) ;
lowlib.c:      pt = B->sptr;
lowlib.c:      w = pt->Sw;
lowlib.c:      l1 = pt->l+pt->Sldwd;
lowlib.c:      xx1 = pt->x-pt->Sldwd/2;
lowlib.c:      yy1 = pt->y-w/2;
lowlib.c:      w = pt->Sw;
lowlib.c:      l = pt->l;
lowlib.c:      xx = pt->x;
lowlib.c:      yy = pt->y-w/2;
lowlib.c:      switch ( B->direction ) {
lowlib.c:          if ( _uiGetSItem ( kbe , xx1 , yy1 , xx1+l1 , yy1+w ) ) mvnt = kbe.x-xx- pt->df;
lowlib.c:          df = pt->df;
lowlib.c:          pt->df += mvnt;
lowlib.c:          yy1 = pt->y-pt->Sldwd/2;
lowlib.c:          xx1 = pt->x-w/2;
lowlib.c:          yy = pt->y;
lowlib.c:           ( kbe.y-yy-B->lngth+ pt->df ) ;
lowlib.c:          df = pt->df;
lowlib.c:          pt->df = pt->df-mvnt;
lowlib.c:      if ( pt->df < 0 ) pt->df = 0;
lowlib.c:      if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:      if ( df != pt->df ) {
lowlib.c:          uiUpdateOn ( pt->D ) ;
lowlib.c:      d = ( DID * ) uiGetWidget ( pt->D , pt->id ) ;
lowlib.c:      xx = pt->x;
lowlib.c:      yy = pt->y;
lowlib.c:      scr_ln = pt->l;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      l = scr_ln+2*pt->Sldwd+6;
lowlib.c:      fac = pt->fac;
lowlib.c:      sx = ( pt->df- ( pt->min ) ) *fac;
lowlib.c:      if ( _uiGetSItem ( kbe , xx+w+3 , yy+3 , xx+l-w-3 , yy+w-3 ) ) {
lowlib.c:          mvnt = kbe.x-xx -w -3+2- pt->df;
lowlib.c:          df = pt->df;
lowlib.c:          pt->df += mvnt;
lowlib.c:          if ( pt->df < 0 ) pt->df = 0;
lowlib.c:          if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:          if ( df != pt->df ) {
lowlib.c:              _ui_moveslidepointer ( pt->D , pt ) ;
lowlib.c:              _ui_slidevalue ( pt->D , pt ) ;
lowlib.c:              uiUpdateOn ( pt->D ) ;
lowlib.c:              mvnt = kbe.x-xx -w -3+2- pt->df;
lowlib.c:                  df = pt->df;
lowlib.c:                  pt->df += mvnt;
lowlib.c:                  if ( pt->df < 0 ) pt->df = 0;
lowlib.c:                  if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:                  if ( df != pt->df ) {
lowlib.c:                      _ui_moveslidepointer ( pt->D , pt ) ;
lowlib.c:                      _ui_slidevalue ( pt->D , pt ) ;
lowlib.c://           if(d->Update != NULL) d->Update(_ui_getdslidevalue(pt),i,D);
lowlib.c:                      switch ( d->code ) {
lowlib.c:                          if ( d->Update != NULL ) d->Update ( _ui_getdslidevalue \
lowlib.c:                           ( pt ) , pt->id , pt->D ) ;
lowlib.c:                          if ( f->Update != NULL ) f->Update ( _ui_getfslidevalue \
lowlib.c:                           ( pt ) , pt->id , pt->D ) ;
lowlib.c:                      uiUpdateOn ( pt->D ) ;
lowlib.c:              while ( ( kbe = kgGetEvent ( pt->D ) ) .event == 3 ) {
lowlib.c:              while ( ( ( evnt = kgCheckEvent ( pt->D , & kb ) ) != 0 ) && \
lowlib.c:      pt = B->sptr;
lowlib.c:      D = pt->D;
lowlib.c:      kbd = & ( D->kb ) ;
lowlib.c:      w = pt->Sw;
lowlib.c:      l = pt->l;
lowlib.c:      switch ( B->direction ) {
lowlib.c:          xx = pt->x;
lowlib.c:          yy = pt->y-w/2;
lowlib.c:          xx = pt->x-w/2;
lowlib.c:          yy = pt->y;
lowlib.c:          f = -1;
lowlib.c:              switch ( B->direction ) {
lowlib.c:                  mvnt = kbe.x-xx - pt->df;
lowlib.c:                  mvnt = ( kbe.y-yy-B->lngth+ pt->df ) ;
lowlib.c:                  df = pt->df;
lowlib.c:                  pt->df = pt->df+f*mvnt;
lowlib.c:                  if ( pt->df < 0 ) pt->df = 0;
lowlib.c:                  if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:                  if ( df != pt->df ) {
lowlib.c:                      if ( B->Update != NULL ) B->Update ( _ui_getdslidevalue \
lowlib.c:                       ( pt ) , B->item , D ) ;
lowlib.c:                      else { kbd->x = kbe.x; kbd->y = kbe.y; kbd->event = 1; }
lowlib.c:                      uiUpdateOn ( pt->D ) ;
lowlib.c:      xx = pt->x;
lowlib.c:      yy = pt->y;
lowlib.c:      scr_ln = pt->l;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      l = scr_ln+2*pt->Sldwd+6;
lowlib.c:      fac = pt->fac;
lowlib.c:      sx = ( pt->df- ( pt->min ) ) *fac;
lowlib.c:      if ( _uiGetSItem ( kbe , xx+w+3 , yy+3 , xx+l-w-3 , yy+w-3 ) ) mvnt = kbe.x-xx -w -3+2- pt->df;
lowlib.c:          mvnt = -1;
lowlib.c:          mvnt = -1;
lowlib.c:      df = pt->df;
lowlib.c:      pt->df += mvnt;
lowlib.c:      if ( pt->df < 0 ) pt->df = 0;
lowlib.c:      if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:      if ( df != pt->df ) {
lowlib.c:          _ui_moveslidepointer ( pt->D , pt ) ;
lowlib.c:          _ui_slidevalue ( pt->D , pt ) ;
lowlib.c:          uiUpdateOn ( pt->D ) ;
lowlib.c:      pt = B->sptr;
lowlib.c:      xx = pt->x;
lowlib.c:      yy = pt->y;
lowlib.c:      scr_ln = pt->l;
lowlib.c:      w = pt->Sldwd;
lowlib.c:      l = scr_ln+2*pt->Sldwd+6;
lowlib.c:      fac = pt->fac;
lowlib.c:      sx = ( pt->df- ( pt->min ) ) *fac;
lowlib.c:      if ( _uiGetSItem ( kbe , xx+w+3 , yy+3 , xx+l-w-3 , yy+w-3 ) ) mvnt = kbe.x-xx -w -3+2- pt->df;
lowlib.c:          mvnt = -1;
lowlib.c:          mvnt = -1;
lowlib.c:      df = pt->df;
lowlib.c:      pt->df += mvnt;
lowlib.c:      if ( pt->df < 0 ) pt->df = 0;
lowlib.c:      if ( pt->df > ( pt->l ) ) pt->df = pt->l;
lowlib.c:      if ( df != pt->df ) {
lowlib.c:          uiUpdateOn ( pt->D ) ;
lowlib.c:      f = D->d [ item ] .f;
lowlib.c:      f->D = D;
lowlib.c:      f->Bimg = NULL;
lowlib.c://   uiclean_gui_area(D,item,D->xo,D->yo,D->d);
lowlib.c:      f->sptr = sptr;
lowlib.c:      f->item = item;
lowlib.c:      sptr = f->sptr;
lowlib.c:      sptr->id = item;
lowlib.c:      sptr->Widget = f;
lowlib.c:      if ( f->hide != 1 ) _uiMake_SF ( f ) ;
lowlib.c:      v = D->d [ item ] .v;
lowlib.c:      v->D = D;
lowlib.c:      v->item = item;
lowlib.c:      v->Bimg = NULL;
lowlib.c:      if ( v->hide != 1 ) _uiMake_V ( v ) ;
lowlib.c:      v = D->d [ item ] .z;
lowlib.c:      v->D = D;
lowlib.c:      v->item = item;
lowlib.c:      v->Bimg = NULL;
lowlib.c:      if ( v->hide != 1 ) _uiMake_Z ( v ) ;
lowlib.c:      d = D->d [ item ] .d;
lowlib.c:      d->D = D;
lowlib.c:      d->Bimg = NULL;
lowlib.c://   uiclean_gui_area(D,item,D->xo,D->yo,D->d);
lowlib.c:      d->sptr = sptr;
lowlib.c:      d->item = item;
lowlib.c:      sptr = d->sptr;
lowlib.c:      sptr->id = item;
lowlib.c:      sptr->Widget = d;
lowlib.c:      if ( d->hide != 1 ) _uiMake_SD ( d ) ;
lowlib.c:      B = D->d [ item ] .B;
lowlib.c:      B->D = D;
lowlib.c:      B->sptr = sptr;
lowlib.c:      B->item = item;
lowlib.c:      B->Bimg = NULL;
lowlib.c:      sptr = B->sptr;
lowlib.c:      sptr->id = item;
lowlib.c:      sptr->Widget = B;
lowlib.c:      sptr->bimg = NULL;
lowlib.c:      sptr->fimg = NULL;
lowlib.c:      sptr->dir = 0;
lowlib.c:      if ( B->hide != 1 ) _uiMake_SH ( B ) ;
lowlib.c:      w = D->d [ item ] .w;
lowlib.c:      w->D = D;
lowlib.c:      w->Bimg = NULL;
lowlib.c:      w->itemhi = 1;
lowlib.c:      w->bordr = 1;
lowlib.c:      w->offset = 4;
lowlib.c:      w->w = 22;
lowlib.c:      w->width = 18;
lowlib.c:      w->bkgr = 1;
lowlib.c:      w->item = item;
lowlib.c:      w->imgs = NULL;
lowlib.c:      w->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) w->bwsr;
lowlib.c:      bwsr->D = D;
lowlib.c:      bwsr->wid = w;
lowlib.c:      bwsr->Widget = w;
lowlib.c:      if ( w->hide != 1 ) _uiMake_W ( w ) ;
lowlib.c:      w = D->d [ item ] .e;
lowlib.c:      w->D = D;
lowlib.c://   clean_gui_area(item,D->xo,D->yo,D->d);
lowlib.c:      w->item = item;
lowlib.c:      Make_menu ( D , w , D->xo , D->yo ) ;
lowlib.c:      bwsr = ( BRW_STR * ) w->bwsr;
lowlib.c:      bwsr->D = D;
lowlib.c:      bwsr->Widget = w;
lowlib.c:      x = D->d [ item ] .x;
lowlib.c:      x->D = D;
lowlib.c:      x->nx = 1;
lowlib.c:      x->item = item;
lowlib.c:      x->Bimg = NULL;
lowlib.c:      if ( x->offset < 4 ) x->offset = 4;
lowlib.c:      if ( x->w < 2 ) x->w = 2;
lowlib.c://   x->bwsr = make_dialog_y_str(D,(DIY *)x,*(x->df),*(x->df),x->menu,x->size);
lowlib.c:      x->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) x->bwsr;
lowlib.c:      bwsr->Widget = x;
lowlib.c:      x->item = item;
lowlib.c:      x = D->d [ item ] .x;
lowlib.c:      x->D = D;
lowlib.c:      x->nx = 1;
lowlib.c:      x->item = item;
lowlib.c:      x->imgs = NULL;
lowlib.c:      x->Bimg = NULL;
lowlib.c:      if ( x->offset < 4 ) x->offset = 4;
lowlib.c:      if ( x->w < 2 ) x->w = 2;
lowlib.c:      ln = ( x->x2 -x->x1-2*x->offset-x->w ) ;
lowlib.c:      if ( x->lngth > ( ln+x->xgap ) ) x->lngth = ln-x->xgap;
lowlib.c:      x->nx = ln/ ( x->lngth+x->xgap ) ;
lowlib.c:      if ( x->nx < 1 ) { x->nx = 1; }
lowlib.c:      x->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) x->bwsr;
lowlib.c:      bwsr->Widget = x;
lowlib.c:      if ( x->hide != 1 ) _uiMake_X ( x ) ;
lowlib.c:      e = D->d [ item ] .e;
lowlib.c:      e->D = D;
lowlib.c:      e->Bimg = NULL;
lowlib.c:      e->item = item;
lowlib.c:      if ( e->w == 0 ) e->w = 22;
lowlib.c:      if ( e->width == 0 ) e->width = 20;
lowlib.c:      e->itemhi = 1;
lowlib.c:      e->bordr = 1;
lowlib.c:      e->bkgr = 1;
lowlib.c:      e->nitems = 1;
lowlib.c:      e->D = ( void * ) D;
lowlib.c:      e->imgs = NULL;
lowlib.c:      if ( e->offset < 4 ) e->offset = 4;
lowlib.c:      if ( e->w < 2 ) e->w = 2;
lowlib.c://   x->bwsr = make_dialog_y_str(D,(DIY *)x,*(x->df),*(x->df),x->menu,x->size);
lowlib.c:      e->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) e->bwsr;
lowlib.c:      bwsr->Widget = e;
lowlib.c:      if ( e->hide != 1 ) _uiMake_E ( e ) ;
lowlib.c:      o = D->d [ item ] .o;
lowlib.c:      o->D = D;
lowlib.c:      o->item = item;
lowlib.c:      o->Bimg = NULL;
lowlib.c:      if ( o->hide != 1 ) _uiMake_O ( o ) ;
lowlib.c:      y = D->d [ item ] .y;
lowlib.c:      y->D = D;
lowlib.c:      y->item = item;
lowlib.c:      y->Bimg = NULL;
lowlib.c:      if ( y->offset < 4 ) y->offset = 4;
lowlib.c:      if ( y->w < 2 ) y->w = 2;
lowlib.c:      y->nx = ( y->x2 -y->x1-2*y->offset-y->w ) / ( y->width+y->xgap ) ;
lowlib.c:      if ( y->nx < 1 ) {
lowlib.c:          y->width = ( y->x2 -y->x1-2*y->offset-y->w ) -y->xgap;
lowlib.c:          y->nx = 1;
lowlib.c:      y->nx = ( y->x2 -y->x1-2*y->offset-y->w ) / ( y->lngth+y->xgap ) ;
lowlib.c:      if ( y->nx < 1 ) {
lowlib.c:          y->lngth = ( y->x2 -y->x1-2*y->offset-y->w ) -y->xgap;
lowlib.c:          y->nx = 1;
lowlib.c:      y->imgs = NULL;
lowlib.c:      y->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->Widget = y;
lowlib.c:      bwsr->pos = 0;
lowlib.c://   y->bwsr = make_dialog_y_str(D,y,*(y->df),*(y->df),y->menu,y->size);
lowlib.c://   bwsr = (BRW_STR *)y->bwsr;
lowlib.c:      if ( y->hide != 1 ) _uiMake_Y ( y ) ;
lowlib.c:      y = D->d [ item ] .r;
lowlib.c:      y->D = D;
lowlib.c:      y->item = item;
lowlib.c:      y->Bimg = NULL;
lowlib.c:      if ( y->bkgr != 0 ) if ( y->offset < 4 ) y->offset = 4;
lowlib.c:      if ( y->w < 2 ) y->w = 2;
lowlib.c:      ln = ( y->x2 -y->x1-2*y->offset-y->w ) ;
lowlib.c:      if ( y->lngth > ( ln+y->xgap ) ) y->lngth = ln-y->xgap;
lowlib.c:      y->nx = ln/ ( y->lngth+y->xgap ) ;
lowlib.c:      if ( y->nx <= 1 ) { y->nx = 1; }
lowlib.c:      if ( y->xgap < 0 ) y->xgap = 0;
lowlib.c:      y->imgs = NULL;
lowlib.c:      y->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->Widget = y;
lowlib.c:      if ( y->hide != 1 ) _uiMake_RadioButton ( y ) ;
lowlib.c:      y = D->d [ item ] .c;
lowlib.c:      y->D = D;
lowlib.c:      y->item = item;
lowlib.c:      y->imgs = NULL;
lowlib.c:      y->Bimg = NULL;
lowlib.c:      if ( y->bkgr != 0 ) if ( y->offset < 4 ) y->offset = 4;
lowlib.c:      if ( y->w < 2 ) y->w = 2;
lowlib.c:      ln = ( y->x2 -y->x1-2*y->offset-y->w ) ;
lowlib.c:      if ( y->lngth > ( ln+y->xgap ) ) y->lngth = ln-y->xgap;
lowlib.c:      y->nx = ( y->x2 -y->x1-2*y->offset-y->w ) / ( y->lngth+y->xgap ) ;
lowlib.c:      if ( y->nx <= 1 ) y->nx = 1;
lowlib.c:      if ( * ( y->df ) < 1 ) * ( y->df ) = 1;
lowlib.c://   y->bwsr = make_dialog_y_str(D,(DIY *)y,*(y->df),*(y->df),y->menu,y->size);
lowlib.c:      y->bwsr = ( BRW_STR * ) Malloc ( sizeof ( BRW_STR ) ) ;
lowlib.c:      bwsr = ( BRW_STR * ) y->bwsr;
lowlib.c:      bwsr->Widget = y;
lowlib.c:      if ( y->hide != 1 ) _uiMake_CheckBox ( y ) ;
lowlib.c:      w = D->d [ item ] .s;
lowlib.c:      w->D = D;
lowlib.c:      w->Bimg = NULL;
lowlib.c:      w->item = item;
lowlib.c:      w->bwsr = bwsr;
lowlib.c:      bwsr->D = D;
lowlib.c:      bwsr->Widget = w;
lowlib.c:      if ( w->hide != 1 ) _uiMake_MS ( w ) ;
lowlib.c:      w = D->d [ item ] .g;
lowlib.c:      w->D = D;
lowlib.c:      w->Bimg = NULL;
lowlib.c:      w->item = item;
lowlib.c:      w->cMain = NULL;
lowlib.c:      w->glWindow = NULL;
lowlib.c:      if ( w->hide != 1 ) _uiMake_G ( w ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      _uirect_fill ( wc , x1 , EVGAY- ( y1 ) , x2 , EVGAY-y2 , D->gc.msg_fill ) ;
lowlib.c:      uiString ( D , m , x1 , y1 , ( x2-x1 ) , ( y2-y1 ) , D->gc.MsgFont , D->gc.msg_char , D->gc.FontSize , 0 , D->gc.msg_fill ) ;
lowlib.c:      _ui_draw_bound ( ( D ) , x1 , EVGAY- ( y1 ) , x2 , EVGAY-y2 , D->gc.msg_bodr ) ;
lowlib.c:      uiString ( D , m , x1 , y1 , ( x2-x1 ) , abs ( y2-y1 ) , D->gc.MsgFont , D->gc.msg_char , D->gc.FontSize , 0 , D->gc.msg_fill ) ;
lowlib.c:      m = D->d [ item ] .m;
lowlib.c:      m->D = D;
lowlib.c:      m->Bimg = NULL;
lowlib.c:      m->item = item;
lowlib.c:      if ( m->hide != 1 ) _uiMake_M ( m ) ;
lowlib.c:      int w , h , FontSize , ret = 1 , just = -1 , fillclr;
lowlib.c:      if ( m->hide != 1 ) {
lowlib.c:          D = m->D;
lowlib.c:          w = ( m->x2-m->x1 ) ;
lowlib.c:          h = ( m->y2-m->y1 ) ;
lowlib.c:          x1 = m->x1+D->xo; x2 = m->x2+D->xo;
lowlib.c:          y1 = m->y1+D->yo; y2 = m->y2+D->yo;
lowlib.c:          if ( m->Bimg == NULL ) {
lowlib.c:              m->Bimg = kgGetBackground ( D , x1 , y1 , x2 , y2 ) ;
lowlib.c:              kgRestoreImage ( D , m->Bimg , x1 , y1 , ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:          if ( m->justification == 0 ) just = 0;
lowlib.c:          else if ( m->justification == -1 ) just = -1;
lowlib.c:          else if ( m->justification == 1 ) just = 1;
lowlib.c:          switch ( m->code ) {
lowlib.c:              fillclr = D->gc.fill_clr;
lowlib.c:              if ( D->transparency != 0.0 ) fillclr = -1;
lowlib.c:              uiString ( D , m->msg , ( int ) ( x1 ) , ( int ) ( ( y1 ) ) , ( x2-x1 ) , \
lowlib.c:               ( y2-y1 ) , D->gc.MsgFont , D->gc.msg_char , D->gc.FontSize , just , fillclr ) ;
lowlib.c:              uiSplashString ( D , m->msg , ( int ) ( m->x1+D->xo ) , ( int ) ( ( m->y1+D->yo ) ) , w , h , D->gc.SplashFont , D->gc.SplashFillColor , D->gc.SplashCharColor , FontSize , just , 0.25 ) ;
lowlib.c://           _ui_diamessage(D,m->x1+D->xo,m->y1+D->yo,m->x2+D->xo,m->y2+D->yo,m->msg);
lowlib.c:              x1 = m->x1+D->xo; x2 = m->x2+D->xo;
lowlib.c:              y1 = m->y1+D->yo; y2 = m->y2+D->yo;
lowlib.c:              _dvrect_fill ( WC ( D ) , x1 , ( y1 ) , x2 , y2 , D->gc.msg_fill ) ;
lowlib.c:              uiString ( D , m->msg , x1 , y1 , w , h , D->gc.MsgFont , D->gc.msg_char , D->gc.FontSize , just , D->gc.msg_fill ) ;
lowlib.c:              _dv_draw_bound ( ( D ) , x1 , ( y1 ) , x2 , y2 , D->gc.msg_bodr ) ;
lowlib.c:          D = m->D;
lowlib.c:          x1 = m->x1+D->xo;
lowlib.c:          x2 = m->x2+D->xo;
lowlib.c:          y1 = m->y1+D->yo;
lowlib.c:          y2 = m->y2+D->yo;
lowlib.c:          if ( m->Bimg != NULL ) kgRestoreImage ( D , m->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      printf ( "Widget no more supported: %c\n" , D->d [ item ] .t->code ) ;
lowlib.c:      if ( ( x1-kbe.x ) * ( x2-kbe.x ) > 0 ) return 0;
lowlib.c:      if ( ( y1-kbe.y ) * ( y2-kbe.y ) > 0 ) return 0;
lowlib.c:      if ( ( x1-kbe.x ) * ( x2-kbe.x ) > 0 ) return 0;
lowlib.c:      if ( ( y1-kbe.y ) * ( y2-kbe.y ) > 0 ) return 0;
lowlib.c:      D = br->D;
lowlib.c:      df = br->hitem;
lowlib.c:      item = _uiGetSItem ( kbe , br->MS.ixx , br->MS.iyy+br->MS.thirty/2 , br->MS.ixu , br->MS.iyu-br->MS.thirty/2 ) ;
lowlib.c:          item = ( kbe.y - ( br->MS.iyy+br->MS.thirty/2 ) ) /br->MS.thirty+1;
lowlib.c:          if ( item > br->MS.imenu ) item = br->MS.imenu;
lowlib.c:          br->MS.item = item;
lowlib.c:          br->hitem = br->pos+item;
lowlib.c:          if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:          if ( br->hitem > br->MS.nitems ) br->hitem = br->MS.nitems;
lowlib.c:          if ( df != br->hitem ) {
lowlib.c:      int ret = -1 , ans;
lowlib.c:          if ( br->hitem > 1 ) {
lowlib.c:              br->hitem -= 1;
lowlib.c:              br->df = br->hitem;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem < br->MS.nitems ) {
lowlib.c:              br->hitem += 1;
lowlib.c:              br->df = br->hitem;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->hitem;
lowlib.c:      ixmid = br->MS.ixx+br->MS.ixl/2;
lowlib.c:      iy = br->MS.iyy+1;
lowlib.c:      if ( ( br->MS.item != 0 ) && ( br->MS.item <= br->MS.imenu ) ) k = br->MS.item;
lowlib.c:      jj = iy + ( k ) *br->MS.thirty;
lowlib.c:      kk = -1;
lowlib.c:      item = _uiGetSItem ( kbe , br->MS.ixx , br->MS.iyy+br->MS.thirty/2 , br->MS.ixu , br->MS.iyu-br->MS.thirty/2 ) ;
lowlib.c:          item = ( kbe.y - ( br->MS.iyy+br->MS.thirty/2 ) ) /br->MS.thirty+1;
lowlib.c:          if ( item > br->MS.imenu ) item = br->MS.imenu;
lowlib.c:          br->MS.item = item;
lowlib.c:          br->hitem = br->pos+item;
lowlib.c:          br->df = br->hitem;
lowlib.c:          if ( df != br->hitem ) {
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          h = br->MS.iyl+20;
lowlib.c:          xx = br->MS.ixx+br->MS.ixl;
lowlib.c:          yy = br->MS.iyy-10+w+4;
lowlib.c:          item = _uiGetSItem ( kbe , xx+3 , yy , xx+w-3 , yy+h-2*w-8 ) ;
lowlib.c:              if ( br->MS.nitems-br->size > 0 ) {
lowlib.c:                  fac = br->MS.fac;
lowlib.c:                  iy = kbe.y - yy;
lowlib.c:                  br->hitem = iy;
lowlib.c:                  if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:                  if ( br->hitem > br->MS.nitems ) br->hitem = br->MS.nitems;
lowlib.c:                  br->df = br->hitem;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -1;
lowlib.c:              xx = br->MS.ixx+br->MS.ixl;
lowlib.c:              yy = br->MS.iyy-10;
lowlib.c://            if(br->hitem >br->size) {
lowlib.c:                  br->hitem -= 1;
lowlib.c:                  if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:                  br->df = br->hitem;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  xx = br->MS.ixx+br->MS.ixl;
lowlib.c:                  yy = br->MS.iyy-10+h-w;
lowlib.c:                  item = _uiGetSItem ( kbe , xx , yy , xx+w , yy+w-4 ) ;
lowlib.c:                      if ( br->hitem < br->MS.nitems ) {
lowlib.c:                          if ( br->hitem <= br->size ) { br->hitem = br->size+1; }
lowlib.c:                          else br->hitem += 1;
lowlib.c:                          br->df = br->hitem;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -1;
lowlib.c:      wc = br->D->wc;
lowlib.c:      ixmid = br->MS.ixx+br->MS.ixl/2;
lowlib.c:      iy = br->MS.iyy+1;
lowlib.c:      if ( ( br->MS.item != 0 ) && ( br->MS.item <= br->MS.imenu ) ) k = br->MS.item;
lowlib.c:      jj = iy + ( k ) *br->width;
lowlib.c:      kk = -1;
lowlib.c:      df = br->df;
lowlib.c:      //item=_uiGetSItem(kbe,br->MS.ixx,br->MS.iyy+br->MS.thirty/2,br->MS.ixu,br->MS.iyu-br->MS.thirty/2);
lowlib.c:          h = br->MS.iyl+br->width;
lowlib.c:          xx = br->MS.ixx+br->MS.ixl;
lowlib.c:          yy = br->MS.iyy-10+w+4;
lowlib.c:          item = _uiGetSItem ( kbe , xx+3 , yy , xx+w-3 , yy+h-2*w-8 ) ;
lowlib.c:                  if ( br->MS.nitems-br->size > 0 ) {
lowlib.c:                      fac = br->MS.fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      br->hitem = iy;
lowlib.c:                      if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:                      if ( br->hitem > br->MS.nitems ) br->hitem = br->MS.nitems;
lowlib.c:                      br->df = br->hitem;
lowlib.c:                      if ( br->df != df ) {_uiMoveVertPointer ( br ) ;
lowlib.c:                      _uiPutmenu ( br ) ; uiUpdateOn ( br->D ) ; }
lowlib.c:                      ret = -1;
lowlib.c:                  while ( ( kbe = kgGetEvent ( br->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( br->D , & kb ) ) != 0 ) && \
lowlib.c:      type = ( y->type ) %10;
lowlib.c:      if ( y->code == 'r' ) type = 1;
lowlib.c:      val = ( int * ) ( y->df ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      df = br->df-1;
lowlib.c:      *val = br->df;
lowlib.c:      if ( y->list == NULL ) return;
lowlib.c:      list = ( ThumbNail ** ) y->list;
lowlib.c:          if ( list [ df ]->sw == 0 ) list [ df ]->sw = 1;
lowlib.c:          else if ( list [ df ]->sw == 1 ) list [ df ]->sw = 0;
lowlib.c:          for ( i = 0; i < y->nitems; i++ ) list [ i ]->sw = 0;
lowlib.c:          list [ df ]->sw = 1;
lowlib.c:          for ( i = 0; i < y->nitems; i++ ) list [ i ]->sw = 0;
lowlib.c:          list [ df ]->sw = 1;
lowlib.c:      int ret = -1 , ans , df , hitem , i;
lowlib.c:      br = y->bwsr;
lowlib.c:          br->df = br->hitem+1;
lowlib.c:          df = br->df-1;
lowlib.c://          *(y->df)=br->df;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= y->nx ) {
lowlib.c:              br->hitem -= y->nx;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem/y->nx;
lowlib.c:          if ( hitem < ( y->ny-1 ) ) {
lowlib.c:              br->hitem += y->nx;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= 0 ) {
lowlib.c:              br->hitem -= 1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem/y->nx;
lowlib.c:          if ( br->hitem < ( y->nitems-1 ) ) {
lowlib.c:              br->hitem += 1;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      int item = -1 , pos = 0 , iy , ix , ret = -1 , yoffset , xoffset;
lowlib.c:      br = Y->bwsr;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = Y->offset;
lowlib.c:      pos = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+yoffset , br->x2-xoffset-br->w , br->y2-yoffset ) ;
lowlib.c:          iy = ( kbe.y - ( br->y1+yoffset ) ) ;
lowlib.c:          if ( iy > 0 ) iy = iy/br->width;
lowlib.c:          if ( ( iy >= 0 ) && ( iy < Y->size ) ) {
lowlib.c:              ix = ( kbe.x - ( br->x1+xoffset+br->xshift ) ) ;
lowlib.c:              if ( ix > 0 ) ix = ix/ ( Y->lngth+Y->xgap ) ;
lowlib.c:              if ( ( ix >= 0 ) && ( ix < Y->nx ) ) {
lowlib.c:                  item = br->pos+iy*Y->nx+ix;
lowlib.c:                  if ( item < Y->nitems ) {
lowlib.c:              } // eof if ( ( ix > 0 ) && ( ix < y->nx ) ) 
lowlib.c:          }// eof if ( ( iy > 0 ) && ( iy < y->size ) ) 
lowlib.c:      br = Y->bwsr;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = Y->offset;
lowlib.c:      item = item-br->pos;
lowlib.c:      size = Y->size*Y->nx;
lowlib.c:          iy = item/ ( Y->nx ) ;
lowlib.c:          ix = item%Y->nx;
lowlib.c:          *x1 = ( br->x1+xoffset+br->xshift ) + ix* ( Y->lngth+Y->xgap ) ;
lowlib.c:          *x2 = *x1+ ( Y->lngth+Y->xgap ) ;
lowlib.c:          *y1 = br->y1+yoffset + iy*br->width;
lowlib.c:          *y2 = *y1+br->width;
lowlib.c:      int j , item , ret = -1 , xoffset , yoffset , hitem;
lowlib.c:      br = y->bwsr;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -100;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+yoffset , br->x2-xoffset-br->w , br->y2-yoffset ) ;
lowlib.c:          if ( kbe.button != 1 ) { uiRest_clip_limits ( wc ) ; return -1; }
lowlib.c:          iy = ( kbe.y - ( br->y1+yoffset ) ) ;
lowlib.c:          if ( iy > 0 ) iy = iy/br->width;
lowlib.c:          if ( ( iy >= 0 ) && ( iy < y->size ) ) {
lowlib.c:              ix = ( kbe.x - ( br->x1+xoffset+br->xshift ) ) ;
lowlib.c:              if ( ix > 0 ) ix = ix/ ( y->lngth+y->xgap ) ;
lowlib.c:              if ( ( ix >= 0 ) && ( ix < y->nx ) ) {
lowlib.c:                  item = br->pos+iy*y->nx+ix;
lowlib.c:                  if ( item < y->nitems ) {
lowlib.c:                      br->hitem = item;
lowlib.c:                      br->df = item+1;
lowlib.c:                      * ( y->df ) = item+1;
lowlib.c:                      df = br->df-1;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:              } // eof if ( ( ix > 0 ) && ( ix < y->nx ) ) 
lowlib.c:          }// eof if ( ( iy > 0 ) && ( iy < y->size ) ) 
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->ny-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy*y->nx+ ( br->hitem%y->nx ) ;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= y->nx ) {
lowlib.c:                      br->hitem -= y->nx;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -101;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos/y->nx;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->ny ) hitem = y->ny-1;
lowlib.c:                      br->hitem = hitem*y->nx;
lowlib.c:                      if ( hitem < ( y->ny-1 ) ) {
lowlib.c:                          br->hitem += y->nx;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -102;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem/y->nx;
lowlib.c:                  if ( y->ny-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->ny ) iy = y->ny-1;
lowlib.c:                      hitem = br->hitem/y->nx;
lowlib.c:                          br->hitem = iy*y->nx;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -1;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      pos = br->pos/y->nx;
lowlib.c:          br->hitem -= y->nx;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      pos = br->pos/y->nx;
lowlib.c:      if ( pos < ( y->ny-y->size ) ) {
lowlib.c:          br->hitem += y->nx;
lowlib.c:          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:      D = ( ( DIALOG * ) ( Y->D ) ) ;
lowlib.c:      if ( ( Y->code != 'y' ) && ( Y->code != 'x' ) ) return 0;
lowlib.c:      ymin = Y->y1+D->yo+Y->offset;
lowlib.c:      ymax = Y->y2+D->yo-Y->offset;
lowlib.c:      xmin = Y->x1+D->xo+Y->offset;
lowlib.c:      xmax = Y->x2+D->xo-Y->offset;
lowlib.c:      th = ( ThumbNail ** ) Y->list;
lowlib.c:                      xl = ( x2-x1+1 ) ;
lowlib.c:                      yl = ( y2-y1+1 ) ;
lowlib.c:                      xmid = ( xmin+xmax-xl ) /2;
lowlib.c:                  case -1:
lowlib.c:                  *y = ymax-yl;
lowlib.c:      int ret = -1 , ans , df , hitem , i;
lowlib.c:          if ( y->df == 0.0 ) return 1;
lowlib.c:          y->df -= y->mvmt;
lowlib.c:          if ( y->df < 0 ) y->df = 0;
lowlib.c:          uiUpdateOn ( y->D ) ;
lowlib.c:          if ( y->df >= ( 100.-y->ds ) ) return 1;
lowlib.c:          y->df += y->mvmt;
lowlib.c:          if ( y->df > 100 ) y->df = 100;
lowlib.c:          uiUpdateOn ( y->D ) ;
lowlib.c:      D = y->D;
lowlib.c:      wc = D->wc;
lowlib.c:      df = y->df;
lowlib.c:      xoffset = yoffset = y->offset;
lowlib.c:      ln = ( y->rsy2-y->rsy1 ) ;
lowlib.c:      if ( y->ds > 100 ) y->ds = 100;
lowlib.c:      if ( y->df > ( 100-y->ds ) ) y->df = ( 100-y->ds ) ;
lowlib.c:      sy = y->df*ln/100.0+0.5;
lowlib.c:      sy2 = ( y->df+y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:      smax = ( 100-y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:      item = _uiGetSItem ( kbe , y->rsx1 , y->rsy1+sy , y->rsx2 , y->rsy1+sy2 ) ;
lowlib.c:          return -1;
lowlib.c:          item = _uiGetSItem ( kbe , y->rsx1 , y->rsy1 , y->rsx2 , y->rsy2 ) ;
lowlib.c:                  iy = kbe.y - y->rsy1;
lowlib.c:                  if ( iy > ( 100-y->ds ) ) iy = 100-y->ds+0.00001;
lowlib.c:                  y->df = iy;
lowlib.c:                  if ( y->Update != NULL ) y->Update ( y->df , y->item , D ) ;
lowlib.c:                  else if ( D->Callback != NULL ) D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                  uiUpdateOn ( y->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , y->tbx1 , y->tby1 , y->tbx2 , y->tby2 ) ;
lowlib.c:                  if ( y->df == 0.0 ) return -1;
lowlib.c:                  y->df -= y->mvmt;
lowlib.c:                  if ( y->df < 0 ) y->df = 0;
lowlib.c:                  uiUpdateOn ( y->D ) ;
lowlib.c:                  if ( y->Update != NULL ) y->Update ( y->df , y->item , D ) ;
lowlib.c:                  else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , y->bbx1 , y->bby1 , y->bbx2 , y->bby2 ) ;
lowlib.c:                      if ( y->df >= ( 100 -y->ds ) ) return -1;
lowlib.c:                      y->df += y->mvmt;
lowlib.c:                      if ( y->df > ( 100 -y->ds ) ) y->df = ( 100 -y->ds ) ;
lowlib.c:                      uiUpdateOn ( y->D ) ;
lowlib.c:                      if ( y->Update != NULL ) y->Update ( y->df , y->item , D ) ;
lowlib.c:                      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                      ret = -1;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      D = ( DIALOG * ) y->D;
lowlib.c:      wc = WC ( y->D ) ;
lowlib.c:      ln = ( y->rsy2-y->rsy1 ) ;
lowlib.c:      if ( y->ds > 100 ) y->ds = 100;
lowlib.c:      if ( y->df > ( 100-y->ds ) ) y->df = ( 100-y->ds ) ;
lowlib.c:      sy = y->df*ln/100.0+0.5;
lowlib.c:      sy2 = ( y->df+y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:      smax = ( 100-y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:          item = _uiGetSItem ( kbe , y->rsx1 , y->rsy1+sy , y->rsx2 , y->rsy1+sy2 ) ;
lowlib.c:                  iy = kbe.y - y->rsy1;
lowlib.c:                  if ( iy > ( 100-y->ds ) ) iy = 100-y->ds+0.00001;
lowlib.c:                  if ( iy != y->df ) {
lowlib.c:                      y->df = iy;
lowlib.c:                      uiUpdateOn ( y->D ) ;
lowlib.c:                      if ( y->Update != NULL ) y->Update ( y->df , y->item , y->D ) ;
lowlib.c:                      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , i;
lowlib.c:          if ( y->df == 0.0 ) return 1;
lowlib.c:          y->df -= y->mvmt;
lowlib.c:          if ( y->df < 0 ) y->df = 0;
lowlib.c:          uiUpdateOn ( y->D ) ;
lowlib.c:          if ( y->df >= ( 100.-y->ds ) ) return 1;
lowlib.c:          y->df += y->mvmt;
lowlib.c:          if ( y->df > 100 ) y->df = 100;
lowlib.c:          uiUpdateOn ( y->D ) ;
lowlib.c:      D = y->D;
lowlib.c:      wc = D->wc;
lowlib.c:      df = y->df;
lowlib.c:      xoffset = yoffset = y->offset;
lowlib.c:      ln = ( y->rsx2-y->rsx1 ) ;
lowlib.c:      if ( y->ds > 100 ) y->ds = 100;
lowlib.c:      if ( y->df > ( 100-y->ds ) ) y->df = ( 100-y->ds ) ;
lowlib.c:      sy = y->df*ln/100.0+0.5;
lowlib.c:      sy2 = ( y->df+y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:      smax = ( 100-y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:      item = _uiGetSItem ( kbe , y->rsx1+sy , y->rsy1 , y->rsx1+sy2 , y->rsy2 ) ;
lowlib.c:          return -1;
lowlib.c:          item = _uiGetSItem ( kbe , y->rsx1 , y->rsy1 , y->rsx2 , y->rsy2 ) ;
lowlib.c:                  iy = kbe.x - y->rsx1;
lowlib.c:                  if ( iy > ( 100-y->ds ) ) iy = 100-y->ds+0.1;
lowlib.c:                  y->df = iy;
lowlib.c:                  uiUpdateOn ( y->D ) ;
lowlib.c:                  if ( y->Update != NULL ) y->Update ( y->df , y->item , D ) ;
lowlib.c:                  else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , y->lbx1 , y->lby1 , y->lbx2 , y->lby2 ) ;
lowlib.c:                  if ( y->df == 0.0 ) return -1;
lowlib.c:                  y->df -= y->mvmt;
lowlib.c:                  if ( y->df < 0 ) y->df = 0;
lowlib.c:                  uiUpdateOn ( y->D ) ;
lowlib.c:                  if ( y->Update != NULL ) y->Update ( y->df , y->item , D ) ;
lowlib.c:                  else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , y->rbx1 , y->rby1 , y->rbx2 , y->rby2 ) ;
lowlib.c:                      if ( y->df >= ( 100 -y->ds ) ) return -1;
lowlib.c:                      y->df += y->mvmt;
lowlib.c:                      if ( y->df > ( 100 -y->ds ) ) y->df = ( 100 -y->ds ) ;
lowlib.c:                      uiUpdateOn ( y->D ) ;
lowlib.c:                      if ( y->Update != NULL ) y->Update ( y->df , y->item , D ) ;
lowlib.c:                      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                      ret = -1;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      D = ( DIALOG * ) y->D;
lowlib.c:      wc = WC ( y->D ) ;
lowlib.c:      ln = ( y->rsx2-y->rsx1 ) ;
lowlib.c:      if ( y->ds > 100 ) y->ds = 100;
lowlib.c:      if ( y->df > ( 100-y->ds ) ) y->df = ( 100-y->ds ) ;
lowlib.c:      sy = y->df*ln/100.0+0.5;
lowlib.c:      sy2 = ( y->df+y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:      smax = ( 100-y->ds ) * ( ln ) /100.0+0.5;
lowlib.c:          item = _uiGetSItem ( kbe , y->rsx1+sy , y->rsy1 , y->rsx1+sy2 , y->rsy2 ) ;
lowlib.c:                  iy = kbe.x - y->rsx1;
lowlib.c:                  if ( iy > ( 100-y->ds ) ) iy = 100-y->ds;
lowlib.c:                  if ( iy != y->df ) {
lowlib.c:                      y->df = iy;
lowlib.c:                      uiUpdateOn ( y->D ) ;
lowlib.c:                      if ( y->Update != NULL ) y->Update ( y->df , y->item , y->D ) ;
lowlib.c:                      else if ( D->Callback != NULL ) ret = D->Callback ( D , & ( D->kb ) ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , j;
lowlib.c:      br = y->bwsr;
lowlib.c:          br->df = br->hitem+1;
lowlib.c:          df = br->df-1;
lowlib.c://          for(j=0;j<y->nitems;j++) y->sw[j]=0;
lowlib.c://          y->sw[df]=1;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= y->nx ) {
lowlib.c:              br->hitem -= y->nx;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          ret = -101;
lowlib.c:          hitem = br->hitem/y->nx;
lowlib.c:          if ( hitem < ( y->ny-1 ) ) {
lowlib.c:              br->hitem += y->nx;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          ret = -102;
lowlib.c:      int j , item , ret = -1 , offset , hitem , xoffset;
lowlib.c:      br = y->bwsr;
lowlib.c:      offset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -100;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+offset , br->x2-xoffset-br->w , br->y2-offset ) ;
lowlib.c:          if ( kbe.button != 1 ) { uiRest_clip_limits ( wc ) ; return -1; }
lowlib.c:          iy = ( kbe.y - ( br->y1+offset ) ) ;
lowlib.c:          if ( iy > 0 ) iy = iy/br->width;
lowlib.c:          if ( ( iy >= 0 ) && ( iy < y->size ) ) {
lowlib.c:              ix = ( kbe.x - ( br->x1+xoffset+br->BxSize/2 ) ) ;
lowlib.c:              if ( ix > 0 ) ix = ix/ ( y->lngth+y->xgap ) ;
lowlib.c:              if ( ( ix >= 0 ) && ( ix < y->nx ) ) {
lowlib.c:                  item = br->pos+iy*y->nx+ix;
lowlib.c:                  if ( item < y->nitems ) {
lowlib.c:                      br->hitem = item;
lowlib.c:                      br->df = item+1;
lowlib.c:                      * ( y->df ) = item+1;
lowlib.c:                      df = br->df-1;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:              } // eof if ( ( ix > 0 ) && ( ix < y->nx ) ) 
lowlib.c:          }// eof if ( ( iy > 0 ) && ( iy < y->size ) ) 
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->ny-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy*y->nx+ ( br->hitem%y->nx ) ;
lowlib.c://              br->hitem =iy*y->nx;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= y->nx ) {
lowlib.c:                      br->hitem -= y->nx;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -101;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos/y->nx;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->ny ) hitem = y->ny-1;
lowlib.c:                      br->hitem = hitem*y->nx;
lowlib.c:                      if ( hitem < ( y->ny-1 ) ) {
lowlib.c:                          br->hitem += y->nx;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -102;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem/y->nx;
lowlib.c:                  if ( y->ny-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->ny ) iy = y->ny-1;
lowlib.c:                      hitem = br->hitem/y->nx;
lowlib.c:                          br->hitem = iy*y->nx;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -100;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , j;
lowlib.c:      br = y->bwsr;
lowlib.c:          br->df = br->hitem+1;
lowlib.c:          df = br->df-1;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= y->nx ) {
lowlib.c:              br->hitem -= y->nx;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem/y->nx;
lowlib.c:          if ( hitem < ( y->ny-1 ) ) {
lowlib.c:              br->hitem += y->nx;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      int j , item , ret = -1 , offset , hitem , xoffset;
lowlib.c:      br = y->bwsr;
lowlib.c:      offset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -100;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+offset , br->x2-xoffset-br->w , br->y2-offset ) ;
lowlib.c:          if ( kbe.button != 1 ) { uiRest_clip_limits ( wc ) ; return -1; }
lowlib.c:          iy = ( kbe.y - ( br->y1+offset ) ) ;
lowlib.c:          if ( iy > 0 ) iy = iy/br->width;
lowlib.c:          if ( ( iy >= 0 ) && ( iy < y->size ) ) {
lowlib.c:              ix = ( kbe.x - ( br->x1+xoffset ) ) ;
lowlib.c:              if ( ix > 0 ) ix = ix/ ( y->lngth+y->xgap ) ;
lowlib.c:              if ( y->nx == 1 ) ix = 0;
lowlib.c:              if ( ( ix >= 0 ) && ( ix < y->nx ) ) {
lowlib.c:                  item = br->pos+iy*y->nx+ix;
lowlib.c:                  if ( item < y->nitems ) {
lowlib.c:                      br->hitem = item;
lowlib.c:                      br->df = item+1;
lowlib.c:                      * ( y->df ) = item+1;
lowlib.c:                      df = br->df-1;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:              } // eof if ( ( ix > 0 ) && ( ix < y->nx ) ) 
lowlib.c:          }// eof if ( ( iy > 0 ) && ( iy < y->size ) ) 
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->ny-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy*y->nx+ ( br->hitem%y->nx ) ;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= y->nx ) {
lowlib.c:                      br->hitem -= y->nx;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -101;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos/y->nx;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->ny ) hitem = y->ny-1;
lowlib.c:                      br->hitem = hitem*y->nx;
lowlib.c:                      if ( hitem < ( y->ny-1 ) ) {
lowlib.c:                          br->hitem += y->nx;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -102;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem/y->nx;
lowlib.c:                  if ( y->ny-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->ny ) iy = y->ny-1;
lowlib.c:                      hitem = br->hitem/y->nx;
lowlib.c:                          br->hitem = iy*y->nx;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -100;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , j;
lowlib.c:      br = y->bwsr;
lowlib.c:          br->df = br->hitem+1;
lowlib.c:          df = br->df-1;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= 1 ) {
lowlib.c:              br->hitem -= 1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem;
lowlib.c:          if ( hitem < ( y->nitems-1 ) ) {
lowlib.c:              br->hitem += 1;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      int j , item , ret = -1 , offset , hitem , xoffset;
lowlib.c:      br = y->bwsr;
lowlib.c:      offset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -100;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+offset , br->x2-xoffset-br->w , br->y2-offset ) ;
lowlib.c:          if ( kbe.button != 1 ) { uiRest_clip_limits ( wc ) ; return -1; }
lowlib.c:          iy = ( kbe.y - ( br->y1+offset ) ) ;
lowlib.c:          if ( iy > 0 ) iy = iy/br->width;
lowlib.c:          if ( ( iy >= 0 ) && ( iy < y->size ) ) {
lowlib.c:              ix = ( kbe.x - ( br->x1+xoffset ) ) ;
lowlib.c:                  item = br->pos+iy+ix;
lowlib.c:                  if ( item < y->nitems ) {
lowlib.c:                      br->hitem = item;
lowlib.c:                      br->df = item+1;
lowlib.c:                      * ( y->df ) = item+1;
lowlib.c:                      df = br->df-1;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:              } // eof if ( ( ix > 0 ) && ( ix < y->nx ) ) 
lowlib.c:          }// eof if ( ( iy > 0 ) && ( iy < y->size ) ) 
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->nitems-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= 1 ) {
lowlib.c:                      br->hitem -= 1;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -101;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->nitems ) hitem = y->nitems-1;
lowlib.c:                      br->hitem = hitem;
lowlib.c:                      if ( hitem < ( y->nitems-1 ) ) {
lowlib.c:                          br->hitem += 1;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -102;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem;
lowlib.c:                  if ( y->nitems-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->nitems ) iy = y->nitems-1;
lowlib.c:                      hitem = br->hitem;
lowlib.c:                          br->hitem = iy;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -100;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , j;
lowlib.c:      br = y->bwsr;
lowlib.c:          if ( br->hitem >= 1 ) {
lowlib.c:              br->hitem -= 1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem;
lowlib.c:          if ( hitem < ( y->nitems-1 ) ) {
lowlib.c:              br->hitem += 1;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      int j , item , ret = -1 , offset , hitem , xoffset;
lowlib.c:      br = y->bwsr;
lowlib.c:      offset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -100;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+offset , br->x2-xoffset-br->w , br->y2-offset ) ;
lowlib.c:          if ( kbe.button != 1 ) return -1;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->nitems-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= 1 ) {
lowlib.c:                      br->hitem -= 1;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -101;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->nitems ) hitem = y->nitems-1;
lowlib.c:                      br->hitem = hitem;
lowlib.c:                      if ( hitem < ( y->nitems-1 ) ) {
lowlib.c:                          br->hitem += 1;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -102;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem;
lowlib.c:                  if ( y->nitems-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->nitems ) iy = y->nitems-1;
lowlib.c:                      hitem = br->hitem;
lowlib.c:                          br->hitem = iy;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -100;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , j;
lowlib.c:      br = y->bwsr;
lowlib.c:          br->df = br->hitem+1;
lowlib.c:          df = br->df-1;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= 1 ) {
lowlib.c:              br->hitem -= 1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem;
lowlib.c:          if ( hitem < ( y->nitems-1 ) ) {
lowlib.c:              br->hitem += 1;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      offset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -1;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+offset , br->x2-xoffset-br->w , br->y2-offset ) ;
lowlib.c:          if ( kbe.button != 1 ) { uiRest_clip_limits ( wc ) ; return -1; }
lowlib.c:          iy = ( kbe.y - ( br->y1+offset ) ) /br->width;
lowlib.c:          if ( iy >= y->size ) iy = y->size-1;
lowlib.c:          ix = ( kbe.x - ( br->x1 ) ) / ( y->width ) ;
lowlib.c:          item = br->pos+iy+ix;
lowlib.c:          if ( item >= y->nitems ) item = y->nitems-1;
lowlib.c:          br->hitem = item;
lowlib.c:          br->df = item+1;
lowlib.c:          * ( y->df ) = item+1;
lowlib.c://       if(df != br->df) {
lowlib.c:          df = br->df-1;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->nitems-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= 1 ) {
lowlib.c:                      br->hitem -= 1;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->nitems ) hitem = y->nitems-1;
lowlib.c:                      br->hitem = hitem;
lowlib.c:                      if ( hitem < ( y->nitems-1 ) ) {
lowlib.c:                          br->hitem += 1;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -1;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem;
lowlib.c:                  if ( y->nitems-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->nitems ) iy = y->nitems-1;
lowlib.c:                      hitem = br->hitem;
lowlib.c:                          br->hitem = iy;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -1;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      int ret = -1 , ans , df , hitem , j;
lowlib.c:      br = y->bwsr;
lowlib.c:          br->df = br->hitem+1;
lowlib.c:          df = br->df-1;
lowlib.c://          if(y->sw[df]==0) y->sw[df]=1;
lowlib.c://          else if(y->sw[df]==1) y->sw[df]=0;
lowlib.c:          uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem >= y->nx ) {
lowlib.c:              br->hitem -= y->nx;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          hitem = br->hitem/y->nx;
lowlib.c:          if ( hitem < ( y->ny-1 ) ) {
lowlib.c:              br->hitem += y->nx;
lowlib.c:              if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      int j , item , ret = -1 , offset , hitem , xoffset;
lowlib.c:      br = y->bwsr;
lowlib.c:      offset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:      item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:          return -100;
lowlib.c:      item = _uiGetSItem ( kbe , br->x1+xoffset , br->y1+offset , br->x2-xoffset-br->w , br->y2-offset ) ;
lowlib.c:          if ( kbe.button != 1 ) { uiRest_clip_limits ( wc ) ; return -1; }
lowlib.c:          iy = ( kbe.y - ( br->y1+offset ) ) ;
lowlib.c:          if ( iy > 0 ) iy = iy/br->width;
lowlib.c:          if ( ( iy >= 0 ) && ( iy < y->size ) ) {
lowlib.c:              ix = ( kbe.x - ( br->x1+xoffset+br->BxSize/2 ) ) ;
lowlib.c:              if ( ix > 0 ) ix = ix/ ( y->lngth+y->xgap ) ;
lowlib.c:              if ( ( ix >= 0 ) && ( ix < y->nx ) ) {
lowlib.c:                  item = br->pos+iy*y->nx+ix;
lowlib.c:                  if ( item < y->nitems ) {
lowlib.c:                      br->hitem = item;
lowlib.c:                      br->df = item+1;
lowlib.c:                      * ( y->df ) = item+1;
lowlib.c:                      df = br->df-1;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:              } // eof if ( ( ix > 0 ) && ( ix < y->nx ) ) 
lowlib.c:          }// eof if ( ( iy > 0 ) && ( iy < y->size ) ) 
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1 , br->rsx2 , br->rsy2 ) ;
lowlib.c:              if ( y->ny-y->size > 0 ) {
lowlib.c:                  fac = br->fac;
lowlib.c:                  iy = kbe.y - br->rsy1;
lowlib.c:                  br->hitem = iy*y->nx+ ( br->hitem%y->nx ) ;
lowlib.c:                  if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                  if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -100;
lowlib.c:              while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:              item = _uiGetSItem ( kbe , br->tbx1 , br->tby1 , br->tbx2 , br->tby2 ) ;
lowlib.c:                  br->hitem = br->pos;
lowlib.c:                  if ( br->hitem >= y->nx ) {
lowlib.c:                      br->hitem -= y->nx;
lowlib.c:                      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:                      uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -101;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:                  item = _uiGetSItem ( kbe , br->bbx1 , br->bby1 , br->bbx2 , br->bby2 ) ;
lowlib.c:                      hitem = br->pos/y->nx;
lowlib.c:                      hitem += ( y->size-1 ) ;
lowlib.c:                      if ( hitem >= y->ny ) hitem = y->ny-1;
lowlib.c:                      br->hitem = hitem*y->nx;
lowlib.c:                      if ( hitem < ( y->ny-1 ) ) {
lowlib.c:                          br->hitem += y->nx;
lowlib.c:                          if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -102;
lowlib.c:                      while ( ( kbe = kgGetEvent ( y->D ) ) .event != 2 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->df;
lowlib.c:          item = _uiGetSItem ( kbe , br->rsx1 , br->rsy1+br->sy , br->rsx2 , br->rsy1+br->sy+br->shy ) ;
lowlib.c:                  yy = br->rsy1;
lowlib.c:                  hitem = br->hitem/y->nx;
lowlib.c:                  if ( y->ny-y->size > 0 ) {
lowlib.c:                      fac = br->fac;
lowlib.c:                      iy = kbe.y - yy;
lowlib.c:                      if ( iy >= y->ny ) iy = y->ny-1;
lowlib.c:                      hitem = br->hitem/y->nx;
lowlib.c:                          br->hitem = iy*y->nx;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -100;
lowlib.c:                  while ( ( kbe = kgGetEvent ( y->D ) ) .event == 3 ) {
lowlib.c:                  while ( ( ( evnt = kgCheckEvent ( y->D , & kb ) ) != 0 ) && \
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->hitem;
lowlib.c:      item = _uiGetSItem ( kbe , br->MS.ixx , br->MS.iyy+br->MS.thirty/2 , br->MS.ixu , br->MS.iyu-br->MS.thirty/2 ) ;
lowlib.c:          item = ( kbe.y - ( br->MS.iyy+br->MS.thirty/2 ) ) /br->MS.thirty+1;
lowlib.c:          if ( item > br->MS.imenu ) item = br->MS.imenu;
lowlib.c:          br->MS.item = item;
lowlib.c:          br->hitem = br->pos+item;
lowlib.c:          if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:          if ( br->hitem > br->MS.nitems ) br->hitem = br->MS.nitems;
lowlib.c:          if ( df != br->hitem ) {
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      int ret = -1 , ans;
lowlib.c:          if ( br->hitem > 1 ) {
lowlib.c:              br->hitem -= 1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          if ( br->hitem < br->MS.nitems ) {
lowlib.c:              br->hitem += 1;
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:      wc = br->D->wc;
lowlib.c:      df = br->hitem;
lowlib.c:      ixmid = br->MS.ixx+br->MS.ixl/2;
lowlib.c:      iy = br->MS.iyy+1;
lowlib.c:      if ( ( br->MS.item != 0 ) && ( br->MS.item <= br->MS.imenu ) ) k = br->MS.item;
lowlib.c:      jj = iy + ( k ) *br->MS.thirty;
lowlib.c:      kk = -1;
lowlib.c:      item = _uiGetSItem ( kbe , br->MS.ixx , br->MS.iyy+br->MS.thirty/2 , br->MS.ixu , br->MS.iyu-br->MS.thirty/2 ) ;
lowlib.c:          item = ( kbe.y - ( br->MS.iyy+br->MS.thirty/2 ) ) /br->MS.thirty+1;
lowlib.c:          if ( item > br->MS.imenu ) item = br->MS.imenu;
lowlib.c:          br->MS.item = item;
lowlib.c:          br->hitem = br->pos+item;
lowlib.c:          if ( df != br->hitem ) {
lowlib.c:              uiUpdateOn ( br->D ) ;
lowlib.c:          h = br->MS.iyl+20;
lowlib.c:          xx = br->MS.ixx+br->MS.ixl;
lowlib.c:          yy = br->MS.iyy-10+w+4;
lowlib.c:          item = _uiGetSItem ( kbe , xx+3 , yy , xx+w-3 , yy+h-2*w-8 ) ;
lowlib.c:              if ( br->MS.nitems-br->size > 0 ) {
lowlib.c:                  fac = br->MS.fac;
lowlib.c:                  iy = kbe.y - yy;
lowlib.c:                  br->hitem = iy;
lowlib.c:                  if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:                  if ( br->hitem > br->MS.nitems ) br->hitem = br->MS.nitems;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -1;
lowlib.c:              xx = br->MS.ixx+br->MS.ixl;
lowlib.c:              yy = br->MS.iyy-10;
lowlib.c://            if(br->hitem >br->size) {
lowlib.c:                  br->hitem -= 1;
lowlib.c:                  if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:                  uiUpdateOn ( br->D ) ;
lowlib.c:                  ret = -1;
lowlib.c:                  xx = br->MS.ixx+br->MS.ixl;
lowlib.c:                  yy = br->MS.iyy-10+h-w;
lowlib.c:                  item = _uiGetSItem ( kbe , xx , yy , xx+w , yy+w-4 ) ;
lowlib.c:                      if ( br->hitem < br->MS.nitems ) {
lowlib.c:                          if ( br->hitem <= br->size ) { br->hitem = br->size+1; }
lowlib.c:                          else br->hitem += 1;
lowlib.c:                          uiUpdateOn ( br->D ) ;
lowlib.c:                      ret = -1;
lowlib.c:      wc = br->D->wc;
lowlib.c:      ixmid = br->MS.ixx+br->MS.ixl/2;
lowlib.c:      iy = br->MS.iyy+1;
lowlib.c:      if ( ( br->MS.item != 0 ) && ( br->MS.item <= br->MS.imenu ) ) k = br->MS.item;
lowlib.c:      jj = iy + ( k ) *br->MS.thirty;
lowlib.c:      kk = -1;
lowlib.c:      df = br->hitem;
lowlib.c:      //item=_uiGetSItem(kbe,br->MS.ixx,br->MS.iyy+br->MS.thirty/2,br->MS.ixu,br->MS.iyu-br->MS.thirty/2);
lowlib.c:          h = br->MS.iyl+20;
lowlib.c:          xx = br->MS.ixx+br->MS.ixl;
lowlib.c:          yy = br->MS.iyy-10+w+4;
lowlib.c:          item = _uiGetSItem ( kbe , xx+3 , yy , xx+w-3 , yy+h-2*w-8 ) ;
lowlib.c:              if ( br->MS.nitems-br->size > 0 ) {
lowlib.c:                  fac = br->MS.fac;
lowlib.c:                  iy = kbe.y - yy;
lowlib.c:                  br->hitem = iy;
lowlib.c:                  if ( br->hitem < 1 ) br->hitem = 1;
lowlib.c:                  if ( br->hitem > br->MS.nitems ) br->hitem = br->MS.nitems;
lowlib.c:                  if ( br->hitem != df ) {_uiMoveVertPointer ( br ) ;
lowlib.c:                  _uiPutmsg ( br ) ; uiUpdateOn ( br->D ) ; }
lowlib.c:                  ret = -1;
lowlib.c:      temp = WC ( D )->c_color;
lowlib.c:      _ui_h_line ( WC ( D ) , ( int ) x1+1 , ( int ) x2-2 , ( int ) y1-1 ) ;
lowlib.c:      _ui_v_line ( WC ( D ) , ( int ) y1-1 , ( int ) y2+2 , ( int ) x1+1 ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      ln = abs ( br->MS.ixl ) *0.85+0.999;
lowlib.c:      n = br->MS.nitems;
lowlib.c:      if ( br->pos < ( br->hitem-br->size ) ) br->pos = br->hitem-br->size;
lowlib.c:      if ( br->pos >= br->hitem ) br->pos = br->hitem-1;
lowlib.c:      if ( br->pos > ( n - br->size ) ) br->pos = n-br->size;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( pos < 0 ) { pos = 0; br->MS.item = br->hitem; }
lowlib.c:      else br->MS.item = br->hitem - pos;
lowlib.c:      br->MS.menu = br->menu+pos;
lowlib.c:      br->pos = pos;
lowlib.c:      ixmid = br->MS.ixx+br->MS.ixl/2;
lowlib.c:      iy = br->MS.iyy+1;
lowlib.c:      _uirect_fill ( WC ( D ) , ( br->MS.ixx+1 ) , ( EVGAY-br->MS.iyy ) , \
lowlib.c:       ( br->MS.ixu-1 ) , ( EVGAY-br->MS.iyu ) , br->MS.color1 ) ;
lowlib.c:      if ( br->D != NULL ) _ui_draw_bound ( D , br->MS.ixx+1 , ( EVGAY-br->MS.iyy-1 ) , br->MS.ixu-1 , \
lowlib.c:       ( EVGAY-br->MS.iyu+1 ) , br->MS.color2 ) ;
lowlib.c:      else _ui_draw_menu_bound ( D , br->MS.ixx , ( EVGAY-br->MS.iyy ) , br->MS.ixu , \
lowlib.c:       ( EVGAY-br->MS.iyu ) , br->MS.color2 ) ;
lowlib.c:      _ui_draw_menu_bound ( D , br->MS.ixx , ( EVGAY-br->MS.iyy ) , br->MS.ixu , \
lowlib.c:       ( EVGAY-br->MS.iyu ) , br->MS.color2 ) ;
lowlib.c:      if ( ( br->MS.item > 0 ) && ( br->MS.item <= br->MS.imenu ) ) k = br->MS.item;
lowlib.c:      jj = iy + ( k ) *br->MS.thirty;
lowlib.c:      _uirect_fill ( WC ( D ) , ( br->MS.ixx+4 ) , ( EVGAY-jj-12 ) , \
lowlib.c:       ( br->MS.ixu-4 ) , ( EVGAY-jj+8 ) , br->MS.color2 ) ;
lowlib.c:      for ( kk = 0; kk < br->MS.imenu; kk++ ) {
lowlib.c:          jj = iy + kk*br->MS.thirty+br->MS.thirty;
lowlib.c:          ixp = br->MS.ixx+10;
lowlib.c:          iyp = EVGAY-jj-7;
lowlib.c:          uiwrite_string ( D , br->MS.menu [ kk ] , ( int ) ixp , \
lowlib.c:           ( int ) iyp , br->MS.char_clr ) ;
lowlib.c:          ixp = br->MS.ixx+5;
lowlib.c:          iyp = jj+12-br->MS.thirty;
lowlib.c:          uiString ( D , br->MS.menu [ kk ] , ( int ) ixp , ( int ) iyp , ln , br->MS.thirty , D->gc.MsgFont , D->gc.msg_char , D->gc.FontSize , -1 , -1 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      list = ( ThumbNail ** ) y->list;
lowlib.c:      k = 0; while ( list [ k ] != NULL ) {if ( list [ k ]->sw != 0 ) list [ k ]->sw = 1;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->ygap-6;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      nx = y->nx;
lowlib.c:      scrsize = y->size*y->nx;
lowlib.c:      ln = br->y2-br->y1-2*yoffset; ;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= y->nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      pos = ( pos/y->nx ) *y->nx;
lowlib.c:      if ( y->bkgr == 1 ) _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:       ( br->x2-xoffset-w ) , ( br->y2-xoffset ) , D->gc.twin_fill ) ;
lowlib.c:      else _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:       ( br->x2-xoffset-w ) , ( br->y2-xoffset ) , D->gc.fill_clr ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:           ( br->x2-xoffset-w ) , ( br->y2-xoffset ) , D->gc.twin_bodr ) ;
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset+1 ) , ( br->y1+xoffset+1 ) , \
lowlib.c:           ( br->x2-xoffset-w-1 ) , ( br->y2-xoffset-1 ) , D->gc.twin_bodr ) ;
lowlib.c://      _dv_draw_bound(D,(br->x1+xoffset+2),(br->y1+xoffset+2),(br->x2-xoffset-w-2), (br->y2-xoffset-2),D->gc.twin_bodr);
lowlib.c:      if ( y->itemhi ) {
lowlib.c:          xi = ( br->hitem-pos ) %nx;
lowlib.c:          yi = ( br->hitem-pos ) /nx;
lowlib.c:          ixp = br->x1+xoffset+xi* ( y->lngth+y->xgap ) +br->xshift;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width;
lowlib.c:          _dvrect_fill ( WC ( D ) , ixp , iyp , ixp+y->lngth+y->xgap , iyp+y->width+6 , D->gc.ItemHighColor ) ;
lowlib.c:      ny = y->size;
lowlib.c:      if ( y->imgs == NULL ) uiMakeYImages ( y ) ;
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:          if ( list != NULL ) xpm = list [ kk+pos ]->img;
lowlib.c:          if ( list != NULL ) swv = list [ kk+pos ]->sw;
lowlib.c:          else {if ( kk+pos == br->df-1 ) swv = 1; else swv = 0; }
lowlib.c:          ixp = br->x1+xoffset+xi* ( y->lngth+y->xgap ) +br->xshift;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              if ( swv == 1 ) { img->bkgrclr = D->gc.SplashCharColor; }
lowlib.c:              else img->bkgrclr = D->gc.twin_fill;
lowlib.c:              kgImage ( D , xpm , ixp+2 , iyp+2 , y->lngth+y->xgap-4 , y->width+2 , 0.0 , 1.0 ) ;
lowlib.c:          iyp = iyp+br->width-th;
lowlib.c:          iyp = iyp+br->width-th*1.20;
lowlib.c://            uiString(D,menu[kk]->name,ixp,iyp,y->width+y->xgap,th,D->gc.MsgFont,D->gc.info_char,D->gc.FontSize,0,-1);
lowlib.c:          if ( ( list != NULL ) && ( menu [ kk ]->name != NULL ) ) kgImage ( D , y->imgs [ kk+pos ] , ixp , iyp , y->lngth+y->xgap , th , 0.0 , 1.0 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      br->BxSize = 2*D->gc.FontSize;
lowlib.c:      list = ( ThumbNail ** ) y->list;
lowlib.c:      k = 0 ; while ( list [ k ] != NULL ) {if ( list [ k ]->sw != 0 ) list [ k ]->sw = 1;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->width+y->ygap;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      nx = y->nx;
lowlib.c:      xgap = y->xgap;
lowlib.c:      lngth = y->lngth;
lowlib.c:          ln = ( y->x2 -y->x1-2*y->offset-w ) ;
lowlib.c:          xgap = ( ln-lngth ) ;
lowlib.c:      scrsize = y->size*y->nx;
lowlib.c:      ln = br->y2-br->y1-2*br->offset; ;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= y->nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      pos = ( pos/y->nx ) *y->nx;
lowlib.c://      _dvrect_fill(WC(D),(br->x1+xoffset),(br->y1+xoffset),(br->x2-xoffset-w)-1, (br->y2-xoffset),D->gc.fill_clr);
lowlib.c:      if ( y->bkgr == 1 ) {
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:      dx = ( br->x2-xoffset-w ) - ( br->x1+xoffset ) ;
lowlib.c:      dy = ( br->y2-xoffset ) - ( br->y1+xoffset ) +1;
lowlib.c:      kgRestoreImagePart ( D , y->Bimg , ( br->x1+xoffset ) , \
lowlib.c:       ( br->y1+xoffset ) , xoffset , xoffset , dx , dy ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , ( br->x2-xoffset-w ) -1 , \
lowlib.c:           ( br->y2-xoffset ) , D->gc.high_clr ) ;
lowlib.c:      if ( y->imgs == NULL ) uiMakeCImages ( y , bxln ) ;
lowlib.c:      if ( y->nitems > 1 ) {
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              ixp = br->x1+xoffset;
lowlib.c:              yi = br->hitem-pos;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , br->x2-xoffset-w-2 , iyp+br->width-2 , D->gc.high_clr ) ;
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              xi = ( br->hitem%y->nx ) ;
lowlib.c:              yi = ( br->hitem-pos ) /y->nx;
lowlib.c:              ixp = br->x1+xoffset+xi*bxln;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , ixp+bxln-2 , iyp+br->width-2 , D->gc.ItemHighColor ) ;
lowlib.c:      ny = y->size;
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:              xpm = list [ kk+pos ]->img;
lowlib.c:              swv = list [ kk+pos ]->sw;
lowlib.c:          else {if ( kk+pos == br->df-1 ) swv = 1; else swv = 0; }
lowlib.c:          ixp = br->x1+xoffset+xi* ( bxln ) ;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width+y->ygap;
lowlib.c:              if ( y->sw [ kk+pos ] == 1 ) { img->bkgrclr = 1; }
lowlib.c:              else img->bkgrclr = -1;
lowlib.c:              kgImage ( D , xpm , ixp+2 , iyp+4 , y->width+y->xgap-4 , y->width , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( menu != NULL ) ) uiCheckString ( D , menu [ kk ]->name , ( int ) ixp , \
lowlib.c:           ( int ) iyp , bxln , th , D->gc.Font , D->gc.menu_char , D->gc.FontSize , swv ) ;
lowlib.c:              kgImage ( D , y->imgs [ kk+pos ] , ( int ) ( ixp+3.0*D->gc.FontSize ) , \
lowlib.c:               ( int ) iyp , ( bxln -4*D->gc.FontSize ) , th , 0.0 , 1.0 ) ;
lowlib.c:              if ( swv == 0 ) kgImage ( D , y->nimg , ( int ) ixp , \
lowlib.c:               ( int ) iyp , 4*D->gc.FontSize , th , 0.0 , 1.0 ) ;
lowlib.c:              if ( swv == 1 ) kgImage ( D , y->himg , ( int ) ixp , \
lowlib.c:               ( int ) iyp , 4*D->gc.FontSize , th , 0.0 , 1.0 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      Bimg = y->Bimg;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      list = ( ThumbNail ** ) y->list;
lowlib.c:      k = 0 ; while ( list [ k ] != NULL ) {if ( list [ k ]->sw != 0 ) list [ k ]->sw = 1;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->width+y->ygap;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      nx = y->nx;
lowlib.c:      xgap = y->xgap;
lowlib.c:      lngth = y->lngth;
lowlib.c:          ln = ( y->x2 -y->x1-2*y->offset-w ) ;
lowlib.c:          xgap = ( ln-lngth ) ;
lowlib.c:      scrsize = y->size*y->nx;
lowlib.c:      ln = br->y2-br->y1-2*br->offset; ;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= y->nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      pos = ( pos/y->nx ) *y->nx;
lowlib.c:      if ( y->bkgr == 1 ) {
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.twin_fill ) ;
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:      dx = ( br->x2-xoffset-w ) - ( br->x1+xoffset ) ;
lowlib.c:      dy = ( br->y2-xoffset ) - ( br->y1+xoffset ) +1;
lowlib.c:      kgRestoreImagePart ( D , y->Bimg , ( br->x1+xoffset ) , \
lowlib.c:       ( br->y1+xoffset ) , xoffset , xoffset , dx , dy ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , ( br->x2-xoffset-w ) -1 , \
lowlib.c:           ( br->y2-xoffset ) , D->gc.twin_bodr ) ;
lowlib.c:      if ( y->nitems > 1 ) {
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              xi = ( br->hitem%y->nx ) ;
lowlib.c:              yi = ( br->hitem-pos ) /y->nx;
lowlib.c:              ixp = br->x1+xoffset+xi*bxln;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , ixp+bxln-2 , iyp+br->width-2 , D->gc.ItemHighColor ) ;
lowlib.c:      ny = y->size;
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:              xpm = list [ kk+pos ]->img;
lowlib.c:              swv = list [ kk+pos ]->sw;
lowlib.c:          else {if ( kk+pos == br->df-1 ) swv = 1; else swv = 0; }
lowlib.c:          ixp = br->x1+xoffset+xi* ( lngth+xgap ) ;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width+y->ygap;
lowlib.c:          bxln = lngth+xgap/2-4;
lowlib.c:              kgImage ( D , xpm , ixp+2 , iyp , y->width , y->width , 0.0 , 1.0 ) ;
lowlib.c:              ixp = ( ixp+2+y->width ) ;
lowlib.c:              bxln = lngth+xgap-4- ( y->width ) ;
lowlib.c:          if ( y->imgs == NULL ) {
lowlib.c:              if ( ( ( y->type ) %10 ) <= 1 ) uiMakeXImages ( y , bxln-y->width ) ;
lowlib.c:          if ( ( menu != NULL ) && ( menu [ kk ]->name != NULL ) ) {
lowlib.c:              if ( y->type <= 1 ) uiMenuString ( D , menu [ kk ]->name , ( int ) ixp , \
lowlib.c:               ( int ) iyp , bxln , y->width , D->gc.Font , D->gc.menu_char , D->gc.FontSize , swv ) ;
lowlib.c:              else uiString ( D , menu [ kk ]->name , ( int ) ixp , ( int ) iyp , bxln , y->width , D->gc.Font , D->gc.menu_char , D->gc.FontSize , -1 , -1 ) ;
lowlib.c:              if ( ( ( y->type ) %10 ) <= 1 ) {
lowlib.c:                  kgImage ( D , y->imgs [ kk+pos ] , ( int ) ixp , ( int ) iyp , bxln-y->width , y->width , 0.0 , 1.0 ) ;
lowlib.c:                  if ( swv == 0 ) kgImage ( D , y->nimg , ( int ) ixp+bxln-y->width , \
lowlib.c:                   ( int ) iyp , y->width , y->width , 0.0 , 1.0 ) ;
lowlib.c:                  if ( swv == 1 ) kgImage ( D , y->himg , ( int ) ixp+bxln-y->width , \
lowlib.c:                   ( int ) iyp , y->width , y->width , 0.0 , 1.0 ) ;
lowlib.c:                  kgImage ( D , y->imgs [ kk+pos ] , ( int ) ixp , \
lowlib.c:                   ( int ) iyp , bxln , y->width , 0.0 , 1.0 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      list = ( char ** ) y->menu;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->width;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      scrsize = y->size*nx;
lowlib.c:      ln = br->y2-br->y1-2*br->offset; ;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:       ( br->x2-xoffset-w ) -1 , ( br->y2-xoffset ) , D->gc.fill_clr ) ;
lowlib.c:      dx = ( br->x2-xoffset-w ) - ( br->x1+xoffset ) ;
lowlib.c:      dy = ( br->y2-xoffset ) - ( br->y1+xoffset ) +1;
lowlib.c:      kgRestoreImagePart ( D , y->Bimg , ( br->x1+xoffset ) , \
lowlib.c:       ( br->y1+xoffset ) , xoffset , xoffset , dx , dy ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , ( br->x2-xoffset-w ) -1 , \
lowlib.c:           ( br->y2-xoffset ) , D->gc.high_clr ) ;
lowlib.c:      if ( y->nitems > 1 ) {
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              ixp = br->x1+xoffset;
lowlib.c:              yi = br->hitem-pos;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , br->x2-xoffset-w-2 , iyp+br->width-2 , D->gc.ItemHighColor ) ;
lowlib.c:      ny = y->size;
lowlib.c:      bxln = y->x2 - y->x1-2*xoffset-w-xoff*y->width;
lowlib.c:      if ( y->imgs == NULL ) {
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:          if ( kk+pos == br->df-1 ) swv = 1; else swv = 0;
lowlib.c:          ixp = br->x1+xoffset+xi* ( y->width ) ;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width;
lowlib.c://            uiString(D,list[kk+pos], (int)ixp+xoff*y->width,(int)iyp,bxln,y->width,D->gc.Font,
lowlib.c://                    D->gc.menu_char,D->gc.FontSize,-1,-1);
lowlib.c:              kgImage ( D , y->imgs [ kk+pos ] , ( int ) ixp+xoff*y->width , \
lowlib.c:               ( int ) iyp , bxln , y->width , 0.0 , 1.0 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      list = ( char ** ) br->menu;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->width;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      scrsize = y->size*nx;
lowlib.c:      ln = br->y2-br->y1-2*br->offset; ;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      if ( y->nitems > y->size ) menu += ( y->nitems - y->size ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:       ( br->x2-xoffset-w ) -1 , ( br->y2-xoffset ) , D->gc.info_fill ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , ( br->x2-xoffset-w ) -1 , \
lowlib.c:           ( br->y2-xoffset ) , D->gc.high_clr ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:       ( br->x2-xoffset-w ) -1 , ( br->y2-xoffset ) , br->MS.color1 ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c://      _dv_draw_bound(D,(br->x1+xoffset),(br->y1+xoffset),(br->x2-xoffset-w)-1, (br->y2-xoffset),br->MS.color2);
lowlib.c:          _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:           ( br->x2-xoffset-w ) -1 , ( br->y2-xoffset ) , br->MS.color2 ) ;
lowlib.c:          _dvrect_fill ( WC ( D ) , ( br->x1+xoffset+offset ) , ( br->y1+xoffset+offset ) , \
lowlib.c:           ( br->x2-xoffset-w-1-offset ) , ( br->y2-xoffset-offset ) , br->MS.color1 ) ;
lowlib.c:      ny = y->size;
lowlib.c:      bxln = y->x2 - y->x1-2*xoffset-w-xoff*y->width;
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:          if ( kk+pos == br->df-1 ) swv = 1; else swv = 0;
lowlib.c:          ixp = br->x1+xoffset+xi* ( y->width ) +br->width*0.5;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width+br->width*0.5;
lowlib.c:              uiString ( D , list [ kk+pos ] , ( int ) ixp+xoff*y->width , ( int ) iyp , bxln , y->width , D->gc.MsgFont , D->gc.info_char , D->gc.FontSize , -1 , -1 ) ;
lowlib.c:              uiMsgString ( D , list [ kk+pos ] , ( int ) ixp+xoff*y->width , ( int ) iyp , br->MS.char_clr , D->gc.MsgFont , D->gc.FontSize ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      if ( y->imgs == NULL ) uiMakeBrowserImages ( y ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      list = ( char ** ) y->menu;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->width;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      scrsize = y->size*nx;
lowlib.c:      ln = br->y2-br->y1-2*br->offset; ;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      _dvrect_fill ( WC ( D ) , ( br->x1+xoffset ) , ( br->y1+xoffset ) , \
lowlib.c:       ( br->x2-xoffset-w ) -1 , ( br->y2-xoffset ) , D->gc.fill_clr ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , ( br->x2-xoffset-w ) -1 , \
lowlib.c:           ( br->y2-xoffset ) , D->gc.high_clr ) ;
lowlib.c:      if ( y->nitems > 1 ) {
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              ixp = br->x1+xoffset;
lowlib.c:              yi = br->hitem-pos;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , br->x2-xoffset-w-2 , iyp+br->width-2 , D->gc.ItemHighColor ) ;
lowlib.c:      ny = y->size;
lowlib.c://      bxln = y->x2 - y->x1-2*xoffset-w-xoff*y->width;
lowlib.c:      bxln = br->x2 - br->x1-2*xoffset-w-xoff*y->width;
lowlib.c:      bxln -= ( 2*xoffset ) ;
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:          if ( kk+pos == br->df-1 ) swv = 1; else swv = 0;
lowlib.c:          ixp = br->x1+xoffset+xi* ( y->width ) ;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width;
lowlib.c://            uiString(D,list[kk+pos], (int)ixp+xoff*y->width,(int)iyp,bxln,y->width,D->gc.Font,
lowlib.c://                    D->gc.menu_char,D->gc.FontSize,-1,-1);
lowlib.c:              kgImage ( D , y->imgs [ kk+pos ] , ( int ) ixp+xoff*y->width , \
lowlib.c:               ( int ) iyp , bxln , y->width , 0.0 , 1.0 ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->D == NULL ) {
lowlib.c:      br->BxSize = 2*D->gc.FontSize;
lowlib.c:      list = ( ThumbNail ** ) y->list;
lowlib.c:      k = 0; while ( list [ k ] != NULL ) {if ( list [ k ]->sw != 0 ) list [ k ]->sw = 1;
lowlib.c:      scroll = br->scroll;
lowlib.c:      w = y->w*scroll;
lowlib.c:      th = y->width+y->ygap;
lowlib.c:      yoffset = br->offset;
lowlib.c:      xoffset = y->offset;
lowlib.c:      nx = y->nx;
lowlib.c:      xgap = y->xgap;
lowlib.c:      lngth = y->lngth;
lowlib.c:          ln = ( y->x2 -y->x1-2*y->offset-w ) ;
lowlib.c:          xgap = ( ln-lngth ) ;
lowlib.c:      scrsize = y->size*y->nx;
lowlib.c:      ln = br->y2-br->y1-2*br->offset;
lowlib.c:      n = y->nitems;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( br->hitem < 0 ) br->hitem = 0;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      while ( br->hitem > ( pos+scrsize ) ) pos+= y->nx;
lowlib.c:      if ( pos >= y->nitems ) pos = y->nitems-1;
lowlib.c:      br->pos = pos;
lowlib.c:      pos = ( pos/y->nx ) *y->nx;
lowlib.c://      _dvrect_fill(WC(D),(br->x1+xoffset),(br->y1+xoffset),(br->x2-xoffset-w)-1, (br->y2-xoffset),D->gc.fill_clr);
lowlib.c:      if ( y->bkgr == 1 ) {
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:      dx = ( br->x2-xoffset-w ) - ( br->x1+xoffset ) ;
lowlib.c:      dy = ( br->y2-xoffset ) - ( br->y1+xoffset ) +1;
lowlib.c:      kgRestoreImagePart ( D , y->Bimg , ( br->x1+xoffset ) , \
lowlib.c:       ( br->y1+xoffset ) , xoffset , xoffset , dx , dy ) ;
lowlib.c:      if ( y->bordr == 1 ) {
lowlib.c:          _dv_draw_bound ( D , ( br->x1+xoffset ) , ( br->y1+xoffset ) , ( br->x2-xoffset-w ) -1 , \
lowlib.c:           ( br->y2-xoffset ) , D->gc.high_clr ) ;
lowlib.c:      if ( y->imgs == NULL ) uiMakeRImages ( y , bxln ) ;
lowlib.c:      if ( y->nitems > 1 ) {
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              ixp = br->x1+xoffset;
lowlib.c:              yi = br->hitem-pos;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , br->x2-xoffset-w-2 , iyp+br->width-2 , D->gc.high_clr ) ;
lowlib.c:          if ( y->itemhi ) {
lowlib.c:              xi = ( br->hitem%y->nx ) ;
lowlib.c:              yi = ( br->hitem-pos ) /y->nx;
lowlib.c:              ixp = br->x1+xoffset+xi*bxln;
lowlib.c:              iyp = br->y1+yoffset+yi*br->width;
lowlib.c:              _dvrect_fill ( WC ( D ) , ixp+2 , iyp+2 , ixp+bxln-2 , iyp+br->width-2 , D->gc.ItemHighColor ) ;
lowlib.c:      ny = y->size;
lowlib.c:          if ( kk+pos >= y->nitems ) continue;
lowlib.c:              xpm = list [ kk+pos ]->img;
lowlib.c:              swv = list [ kk+pos ]->sw;
lowlib.c:          else {if ( kk+pos == br->df-1 ) swv = 1; else swv = 0; }
lowlib.c:          ixp = br->x1+xoffset+xi* ( bxln ) ;
lowlib.c:          iyp = br->y1+yoffset+yi*br->width+y->ygap;
lowlib.c:              if ( y->sw [ kk+pos ] == 1 ) { img->bkgrclr = 1; }
lowlib.c:              else img->bkgrclr = -1;
lowlib.c:              kgImage ( D , xpm , ixp+2 , iyp+4 , y->width+y->xgap-4 , y->width , 0.0 , 1.0 ) ;
lowlib.c:              kgImage ( D , y->imgs [ kk+pos ] , ( int ) ( ixp+3.0*D->gc.FontSize ) , \
lowlib.c:               ( int ) iyp , ( bxln -4*D->gc.FontSize ) , th , 0.0 , 1.0 ) ;
lowlib.c:              if ( swv == 0 ) kgImage ( D , y->nimg , ( int ) ixp , \
lowlib.c:               ( int ) iyp , 4*D->gc.FontSize , th , 0.0 , 1.0 ) ;
lowlib.c:              if ( swv == 1 ) kgImage ( D , y->himg , ( int ) ixp , \
lowlib.c:               ( int ) iyp , 4*D->gc.FontSize , th , 0.0 , 1.0 ) ;
lowlib.c:          if ( ( list != NULL ) && ( menu [ kk ]->name != NULL ) ) uiRadioString \
lowlib.c:           ( D , menu [ kk ]->name , ( int ) ixp , ( int ) iyp , bxln , th , D->gc.Font , D->gc.menu_char , D->gc.FontSize , swv ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      if ( br->menu != NULL ) while ( br->menu [ n ] != NULL ) n++;
lowlib.c:      if ( br->pos < ( br->hitem-br->size ) ) br->pos = br->hitem-br->size;
lowlib.c:      if ( br->pos >= br->hitem ) br->pos = br->hitem-1;
lowlib.c:      if ( br->pos > ( n - br->size ) ) br->pos = n-br->size;
lowlib.c:      if ( br->pos < 0 ) br->pos = 0;
lowlib.c:      if ( br->pos >= n ) br->pos = n-1;
lowlib.c:      pos = br->pos;
lowlib.c:      ixmid = br->MS.ixx+br->MS.ixl/2;
lowlib.c:      iy = br->MS.iyy+1;
lowlib.c://      _uirect_fill(WC(D),(br->MS.ixx-1),(EVGAY-br->MS.iyy),(br->MS.ixu+1),(EVGAY-br->MS.iyu),br->gc.info_fill);
lowlib.c:      _uirect_fill ( WC ( D ) , ( br->MS.ixx ) , ( EVGAY-br->MS.iyy-1 ) , \
lowlib.c:       ( br->MS.ixu ) , ( EVGAY-br->MS.iyu+1 ) , br->gc.msg_fill ) ;
lowlib.c:      _ui_draw_bound ( D , br->MS.ixx , ( EVGAY-br->MS.iyy-1 ) , br->MS.ixu , \
lowlib.c:       ( EVGAY-br->MS.iyu+1 ) , br->gc.msg_bodr ) ;
lowlib.c:      jj = iy + ( k ) *br->MS.thirty;
lowlib.c:      uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:      for ( kk = 0; kk < br->size; kk++ ) {
lowlib.c:          jj = iy + kk*br->MS.thirty+br->MS.thirty;
lowlib.c:          ixp = br->MS.ixx+10;
lowlib.c:          iyp = EVGAY-jj-7;
lowlib.c://        if(br->MS.menu[kk]== NULL) break;
lowlib.c://        write_string(br->MS.menu[kk],(int)ixp,(int)iyp,br->gc.info_char);
lowlib.c:          if ( ( br->menu != NULL ) && ( ( kk+pos ) < n ) && \
lowlib.c:           ( br->menu [ kk+pos ] != NULL ) ) {
lowlib.c:              uiwrite_string ( D , br->menu [ kk+pos ] , ( int ) ixp , \
lowlib.c:               ( int ) iyp , br->gc.msg_char ) ;
lowlib.c:           ( int ) iyp , br->gc.msg_char ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      xx = br->MS.ixu+3;
lowlib.c:      yy = br->MS.iyy-1;
lowlib.c:      h = br->MS.iyu- br->MS.iyy+4;
lowlib.c:      yy = D->evgay-yy;
lowlib.c:      _uiup_dir ( D , xx+3 , yy-4 , w-5 , 0.1 , 5 ) ;
lowlib.c:      _uidown_dir ( D , xx+3 , yy-h+w-1 , w-5 , 0.1 , 5 ) ;
lowlib.c:      D = ( DIALOG * ) ( v->D ) ;
lowlib.c:      xx = v->tbx1+1;
lowlib.c:      yy = v->tby1+1;
lowlib.c:      w = v->w;
lowlib.c:      yy = v->bby1;
lowlib.c:      D = ( DIALOG * ) ( v->D ) ;
lowlib.c:      xx = v->lbx1;
lowlib.c:      yy = v->lby1;
lowlib.c:      w = v->w;
lowlib.c:      xx = v->rbx1;
lowlib.c:      yy = v->rby1;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      xx = br->tbx1;
lowlib.c:      yy = br->tby1;
lowlib.c:      w = br->w;
lowlib.c:      yy = br->bby1;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      xx = br->tbx1;
lowlib.c:      yy = br->tby1;
lowlib.c:      w = br->w;
lowlib.c:      yy = br->bby1;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      xx = br->tbx1+2;
lowlib.c:      yy = br->tby1;
lowlib.c:      w = br->w;
lowlib.c:      yy = br->bby1;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      xx = br->tbx1;
lowlib.c:      yy = br->tby1;
lowlib.c:      w = br->w;
lowlib.c:      yy = br->bby1;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      y = D->evgay-y;
lowlib.c://   x1=x+4;y1=y-w-2;x2=x+w-4;y2=y-h+w+4;
lowlib.c:      x1 = x+4; y1 = y-w+1; x2 = x+w-4; y2 = y-h+w;
lowlib.c://   _uirect_fill(D,x1,y1,x2,y2,D->gc.fill_clr);
lowlib.c://   _uirect_fill(WC(D),x1,y1,x2,y2+1,D->gc.fill_clr);
lowlib.c://   _uirect_fill(WC(D),x1,y1,x2,y2+1,D->gc.dim);
lowlib.c:      _uirect_fill ( WC ( D ) , x1 , y1 , x2 , y2 , D->gc.dim ) ;
lowlib.c:      sy = y1-1-sy;
lowlib.c:      if ( sy > y1 ) sy = y1-1;
lowlib.c:      if ( sy-sh < y2 ) sy = y2+sh+1;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      x2 -= 1;
lowlib.c:      _uirect_fill ( WC ( D ) , x1 , sy , x2 , sy-sh , D->gc.fill_clr ) ;
lowlib.c:      uiset_clr ( D , D->gc.vbright ) ;
lowlib.c:      _uivert_line ( WC ( D ) , sy , sy-sh , x1 ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      _uihori_line ( WC ( D ) , x1 , x2 , sy-sh ) ;
lowlib.c:      _uivert_line ( WC ( D ) , sy , sy-sh , x2 ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      item = br->df;
lowlib.c:      xx = br->MS.ixx+br->MS.ixl+1;
lowlib.c:      yy = br->MS.iyy-10;
lowlib.c:      h = br->MS.iyl+20;
lowlib.c:      xx = br->MS.ixu+3;
lowlib.c:      yy = br->MS.iyy-1;
lowlib.c:      h = br->MS.iyu - br->MS.iyy+4;
lowlib.c://   scr_ln=h-2*w-8;
lowlib.c:      scr_ln = h-2*w;
lowlib.c:      fac = scr_ln/ ( float ) br->MS.nitems;
lowlib.c:      sh = fac*br->size+0.5;
lowlib.c:      if ( br->MS.nitems-br->size != 0 ) fac = ( scr_ln-sh ) / \
lowlib.c:       ( float ) ( br->MS.nitems-br->size ) ;
lowlib.c:      br->MS.fac = fac;
lowlib.c://   pos=br->df-br->size;
lowlib.c:      if ( br->pos < ( br->hitem-br->size ) ) br->pos = br->hitem-br->size;
lowlib.c:      if ( br->pos >= br->hitem ) br->pos = br->hitem-1;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( pos < 0 ) { pos = 0; br->MS.item = br->df; }
lowlib.c:      if ( ( j+1 ) > item ) j = item-1;
lowlib.c:      if ( item > j+br->size ) j = item-1;
lowlib.c:      if ( j+br->size > br->MS.nitems ) j = br->MS.nitems-br->size;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      item = br->df;
lowlib.c:      xx = br->MS.ixx+br->MS.ixl+1;
lowlib.c:      yy = br->MS.iyy-10;
lowlib.c:      h = br->MS.iyl+20;
lowlib.c:      xx = br->MS.ixu+3;
lowlib.c:      yy = br->MS.iyy-1;
lowlib.c:      h = br->MS.iyu - br->MS.iyy+4;
lowlib.c:      scr_ln = h-2*w;
lowlib.c:      fac = scr_ln/ ( float ) br->MS.nitems;
lowlib.c:      sh = fac*br->size+0.5;
lowlib.c:      if ( br->MS.nitems-br->size != 0 ) fac = ( scr_ln-sh ) / \
lowlib.c:       ( float ) ( br->MS.nitems-br->size ) ;
lowlib.c:      br->MS.fac = fac;
lowlib.c:      if ( br->pos < ( br->hitem-br->size ) ) br->pos = br->hitem-br->size;
lowlib.c:      if ( br->pos >= br->hitem ) br->pos = br->hitem-1;
lowlib.c:      pos = br->pos;
lowlib.c:      if ( pos < 0 ) { pos = 0; br->MS.item = br->df; }
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      _dvrect_fill ( WC ( D ) , x1 , y1 , x2 , y2 , D->gc.scroll_dim ) ;
lowlib.c:      if ( sy > y2 ) sy = y2-sh;
lowlib.c:      if ( sy+sh > y2 ) sy = y2- sh;
lowlib.c:      uiset_clr ( D , D->gc.scroll_vbright ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , x1 , sy , x2 , sy+sh , D->gc.scroll_fill ) ;
lowlib.c:      uiset_clr ( D , D->gc.scroll_vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      tmp = WC ( D )->c_color;
lowlib.c:      _dvrect_fill ( WC ( D ) , x1 , y1 , x2 , y2 , D->gc.scroll_dim ) ;
lowlib.c:      if ( sy > x2 ) sy = x2-sh;
lowlib.c:      if ( sy+sh > x2 ) sy = x2- sh;
lowlib.c:      uiset_clr ( D , D->gc.scroll_vbright ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , sy , y1 , sy+sh , y2 , D->gc.scroll_fill ) ;
lowlib.c:      uiset_clr ( D , D->gc.scroll_vbright ) ;
lowlib.c:      uiset_clr ( D , D->gc.v_dim ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      nx = y->nx;
lowlib.c:      item = br->df;
lowlib.c:      offset = br->w*0.4;
lowlib.c:      xx = br->rsx1+offset/2;
lowlib.c:      yy = br->rsy1;
lowlib.c:      w = br->w-offset;
lowlib.c:      h = br->rsy2 - br->rsy1;
lowlib.c:      fac = scr_ln/ ( float ) y->ny;
lowlib.c:      sh = fac*y->size+0.5;
lowlib.c:      if ( ( y->ny-y->size ) > 0 ) fac = ( scr_ln-sh ) / \
lowlib.c:       ( float ) ( y->ny-y->size ) ;
lowlib.c:      br->MS.fac = fac;
lowlib.c:      br->fac = fac;
lowlib.c:      pos = ( br->pos ) / ( nx ) ;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      hitem = ( br->hitem ) / ( nx ) ;
lowlib.c:      while ( ( hitem-pos ) >= y->size ) pos++;
lowlib.c:      br->pos = pos*y->nx;
lowlib.c:      br->sy = sy;
lowlib.c:      br->shy = sh;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      xx = y->rsx1;
lowlib.c:      yy = y->rsy1;
lowlib.c:      w = y->rsx2 - y->rsx1;
lowlib.c:      h = y->rsy2 - y->rsy1;
lowlib.c:      fac = scr_ln*y->ds/100.0;
lowlib.c:      sy = scr_ln* ( ( y->df ) ) /100;
lowlib.c:      if ( ( sy+sh ) > h ) sy = h-sh;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      xx = y->rsx1;
lowlib.c:      yy = y->rsy1;
lowlib.c:      h = y->rsy2-y->rsy1;
lowlib.c:      w = y->rsx2 - y->rsx1;
lowlib.c:      fac = scr_ln*y->ds/100.0;
lowlib.c:      sy = scr_ln* ( ( y->df ) ) /100;
lowlib.c:      if ( ( sy+sh ) > w ) sy = w-sh;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      item = br->df;
lowlib.c:      offset = br->w*0.4;
lowlib.c:      xx = br->rsx1+offset/2;
lowlib.c:      yy = br->rsy1;
lowlib.c:      w = br->w-offset;
lowlib.c:      h = br->rsy2 - br->rsy1;
lowlib.c:      fac = scr_ln/ ( float ) y->nitems;
lowlib.c:      sh = fac*y->size+0.5;
lowlib.c:      if ( ( y->nitems-y->size ) > 0 ) fac = ( scr_ln-sh ) / \
lowlib.c:       ( float ) ( y->nitems-y->size ) ;
lowlib.c:      br->MS.fac = fac;
lowlib.c:      br->fac = fac;
lowlib.c:      pos = ( br->pos ) / ( nx ) ;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      hitem = ( br->hitem ) / ( nx ) ;
lowlib.c:      while ( ( hitem-pos ) >= y->size ) pos++;
lowlib.c:      br->pos = pos*nx;
lowlib.c:      br->sy = sy;
lowlib.c:      br->shy = sh;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      item = br->df;
lowlib.c:      offset = br->w*0.4;
lowlib.c:      xx = br->rsx1+offset/2;
lowlib.c:      yy = br->rsy1;
lowlib.c:      w = br->w-offset;
lowlib.c:      h = br->rsy2 - br->rsy1;
lowlib.c:      fac = scr_ln/ ( float ) y->nitems;
lowlib.c:      sh = fac*y->size+0.5;
lowlib.c:      if ( ( y->nitems-y->size ) > 0 ) fac = ( scr_ln-sh ) / \
lowlib.c:       ( float ) ( y->nitems-y->size ) ;
lowlib.c:      br->MS.fac = fac;
lowlib.c:      br->fac = fac;
lowlib.c:      pos = ( br->pos ) / ( nx ) ;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      hitem = ( br->hitem ) / ( nx ) ;
lowlib.c:      while ( ( hitem-pos ) >= y->size ) pos++;
lowlib.c:      br->pos = pos*nx;
lowlib.c:      br->sy = sy;
lowlib.c:      br->shy = sh;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      item = br->df;
lowlib.c:      offset = br->w*0.4;
lowlib.c:      xx = br->rsx1+offset/2;
lowlib.c:      yy = br->rsy1;
lowlib.c:      w = br->w-offset;
lowlib.c:      h = br->rsy2 - br->rsy1;
lowlib.c:      fac = scr_ln/ ( float ) y->nitems;
lowlib.c:      sh = fac*y->size+0.5;
lowlib.c:      if ( ( y->nitems-y->size ) > 0 ) fac = ( scr_ln-sh ) / \
lowlib.c:       ( float ) ( y->nitems-y->size ) ;
lowlib.c:      br->MS.fac = fac;
lowlib.c:      br->fac = fac;
lowlib.c:      pos = ( br->pos ) / ( nx ) ;
lowlib.c:      if ( br->hitem >= y->nitems ) br->hitem = y->nitems-1;
lowlib.c:      hitem = ( br->hitem ) / ( nx ) ;
lowlib.c:      while ( ( hitem-pos ) >= y->size ) pos++;
lowlib.c:      br->pos = pos*nx;
lowlib.c:      br->sy = sy;
lowlib.c:      br->shy = sh;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      while ( br->menu [ n ] != NULL ) n++;
lowlib.c:      if ( br->size > n ) br->size = n;
lowlib.c:      if ( br->size == n ) scroll = 0;
lowlib.c:          ptr = br->menu [ i ] ;
lowlib.c:      gc = D->gc;
lowlib.c:      br->D = D;
lowlib.c:      br->hitem = br->df;
lowlib.c:      br->MS.color1 = gc.fill_clr; br->MS.color2 = gc.high_clr;
lowlib.c:      br->MS.char_clr = gc.char_clr;
lowlib.c:      br->MS.ixx = br->x1;
lowlib.c:      br->MS.iyy = br->y1;
lowlib.c:      br->MS.imenu = br->size;
lowlib.c:      br->MS.nitems = n;
lowlib.c:      br->MS.por = br->size;
lowlib.c:      br->MS.ichr = max;
lowlib.c:      br->MS.thirty = thirty;
lowlib.c:      br->MS.iyl = ( br->size+1 ) *thirty;
lowlib.c:      br->MS.ixl = ( max*9+15 ) ;
lowlib.c:      br->MS.iyu = br->MS.iyy +br->MS.iyl;
lowlib.c:      br->MS.ixu = br->MS.ixx+br->MS.ixl-1;
lowlib.c:      kg_scr_back ( WC ( D ) , br->MS.ixx-8 , br->MS.iyy-18 , ( br->MS.ixx+br->MS.ixl+31 ) , \
lowlib.c:       ( br->MS.iyy+br->MS.iyl+18 ) ) ;
lowlib.c:      _uirect_fill ( WC ( D ) , br->MS.ixx-8 , EVGAY-br->MS.iyy+18 , ( br->MS.ixx+br->MS.ixl+31 ) , EVGAY- \
lowlib.c:       ( br->MS.iyy+br->MS.iyl+18 ) , gc.fill_clr ) ;
lowlib.c://   _uiborder3d(D, br->MS.ixx-8,br->MS.iyy-18,(br->MS.ixx+br->MS.ixl+31),(br->MS.iyy+br->MS.iyl+18));
lowlib.c:      _uibordertype4 ( D , br->MS.ixx-8 , br->MS.iyy-18 , ( br->MS.ixx+br->MS.ixl+31 ) , \
lowlib.c:       ( br->MS.iyy+br->MS.iyl+18 ) ) ;
lowlib.c:      xx = br->MS.ixx+br->MS.ixl+1;
lowlib.c:      yy = br->MS.iyy-10;
lowlib.c:      h = br->MS.iyl+20;
lowlib.c:      uiUpdateOn ( br->D ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      while ( br->menu [ n ] != NULL ) n++;
lowlib.c:      if ( br->size > n ) br->size = n;
lowlib.c:      if ( br->size == n ) {
lowlib.c:          ptr = br->menu [ i ] ;
lowlib.c:          j = ( int ) ( uiStringLength ( ptr , D->gc.FontSize ) /D->gc.FontSize ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      if ( br->df > n ) br->df = 1;
lowlib.c:      br->D = D;
lowlib.c:      br->hitem = br->df;
lowlib.c:      br->MS.color1 = gc.fill_clr; br->MS.color2 = gc.high_clr;
lowlib.c:      br->MS.char_clr = gc.menu_char;
lowlib.c:      br->MS.imenu = br->size;
lowlib.c:      br->MS.nitems = n;
lowlib.c:      br->MS.por = br->size;
lowlib.c:      br->MS.ichr = max;
lowlib.c:      br->MS.thirty = thirty;
lowlib.c:      br->MS.iyl = ( br->size+1 ) *thirty;
lowlib.c:      br->MS.ixl = ( max*D->gc.FontSize+15 ) ;
lowlib.c:      br->MS.ixx = br->x1;
lowlib.c:      br->MS.iyy = br->y1;
lowlib.c:          br->MS.ixx += 8;
lowlib.c:          br->MS.iyy -= 2;
lowlib.c:      br->MS.iyu = br->MS.iyy +br->MS.iyl-1;
lowlib.c:      br->MS.ixu = br->MS.ixx+br->MS.ixl-1;
lowlib.c:      X1 = br->MS.ixx-bodrwidth;
lowlib.c:      Y1 = br->MS.iyy-bodrwidth-scroll*10;
lowlib.c:      X2 = ( br->MS.ixu+scroll*24+bodrwidth ) ;
lowlib.c:      Y2 = ( br->MS.iyu+scroll*10+bodrwidth ) ;
lowlib.c:      _uirect_fill ( WC ( D ) , X1 , EVGAY-Y1 , X2 , EVGAY-Y2 , gc.fill_clr ) ;
lowlib.c://  if(scroll) _uiborder3d(D, X1,EVGAY-Y1,X2, EVGAY-Y2);
lowlib.c:      if ( scroll ) _uibordertype4 ( D , X1 , EVGAY-Y1 , X2 , EVGAY-Y2 ) ;
lowlib.c:              xx = br->MS.ixx+br->MS.ixl+1;
lowlib.c:              yy = br->MS.iyy-10;
lowlib.c:              h = br->MS.iyl+20;
lowlib.c:              xx = br->MS.ixu+3;
lowlib.c:              yy = br->MS.iyy-1;
lowlib.c:              h = br->MS.iyu- br->MS.iyy+4;
lowlib.c:      uiUpdateOn ( br->D ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      W = ( DIW * ) br->wid;
lowlib.c:      EVGAY = wc->EVGAY;
lowlib.c:      while ( br->menu [ n ] != NULL ) n++;
lowlib.c:      if ( br->size > n ) br->size = n;
lowlib.c:      if ( br->size == n ) {
lowlib.c:          br->scroll = 0;
lowlib.c:          ptr = br->menu [ i ] ;
lowlib.c:          j = ( int ) ( uiStringLength ( ptr , D->gc.FontSize ) /D->gc.FontSize ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      if ( br->df > n ) br->df = 1;
lowlib.c:      br->hitem = br->df;
lowlib.c:      X1 = br->x1;
lowlib.c:      Y1 = br->y1;
lowlib.c:      X2 = br->x2;
lowlib.c:      Y2 = br->y2;
lowlib.c:          if ( br->scroll ) {
lowlib.c:      uiUpdateOn ( br->D ) ;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      while ( br->menu [ n ] != NULL ) n++;
lowlib.c:      if ( br->size > n ) br->size = n;
lowlib.c:      if ( br->size == n ) {
lowlib.c:          ptr = br->menu [ i ] ;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      gc = D->gc;
lowlib.c:      if ( br->df > n ) br->df = 1;
lowlib.c:      br->D = D;
lowlib.c:      br->hitem = br->df;
lowlib.c:      br->MS.color1 = gc.fill_clr; br->MS.color2 = gc.high_clr;
lowlib.c:      br->MS.char_clr = gc.menu_char;
lowlib.c:      br->MS.imenu = br->size;
lowlib.c:      br->MS.nitems = n;
lowlib.c:      br->MS.por = br->size;
lowlib.c:      br->MS.ichr = max;
lowlib.c:      br->MS.thirty = thirty;
lowlib.c:      br->MS.ixl = ( max*9+15 ) ;
lowlib.c:      br->MS.iyl = ( br->size+1 ) *thirty;
lowlib.c:      br->MS.ixl = br->x2 -br->x1-scroll*24-20;
lowlib.c:      br->MS.ixx = br->x1+10;
lowlib.c:      br->MS.iyy = br->y1+8+scroll*10;
lowlib.c:          br->MS.ixx += 2;
lowlib.c:          br->MS.iyy -= 2;
lowlib.c:          br->MS.ixx = br->x1+2+8;
lowlib.c:          br->MS.iyy = br->y1+3+8;
lowlib.c:      br->MS.iyu = br->MS.iyy +br->MS.iyl;
lowlib.c:      br->MS.ixu = br->MS.ixx+br->MS.ixl;
lowlib.c:      if ( D->DrawBkgr != 0 ) {
lowlib.c:          _uirect_fill ( WC ( D ) , br->x1+ ( offset+2 ) , D->evgay-br->y1- ( offset+2 ) , br->x2- \
lowlib.c:           ( offset+2 ) , D->evgay-br->y2+ ( offset+2 ) , gc.txt_fill ) ;
lowlib.c:          _uibordertype0 ( D , br->x1+ ( offset+2 ) , D->evgay-br->y1- ( offset+2 ) , br->x2- \
lowlib.c:           ( ( offset+2 ) -1 ) , D->evgay-br->y2+ ( ( offset+2 ) -1 ) , gc.vbright ) ;
lowlib.c:          _uibordertype1 ( D , br->x1+ ( offset+2 ) , D->evgay-br->y1- ( offset+2 ) , br->x2- \
lowlib.c:           ( ( offset+2 ) -1 ) , D->evgay-br->y2+ ( ( offset+2 ) -1 ) ) ;
lowlib.c:              xx = br->MS.ixx+br->MS.ixl+4;
lowlib.c:              yy = br->MS.iyy-10;
lowlib.c:              h = br->MS.iyl+20;
lowlib.c:              xx = br->MS.ixu+3;
lowlib.c:              yy = br->MS.iyy-1;
lowlib.c:              h = br->MS.iyu- br->MS.iyy+4;
lowlib.c:      uiUpdateOn ( br->D ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   _dvrect_fill(WC(D), br->x1+offset,br->y1+offset,br->x2-offset,br->y2-offset,gc.fill_clr);
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground \
lowlib.c:           ( D , br->x1 , br->y1 , br->x2 , br->y2 ) ;
lowlib.c:          else kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://   if((D->DrawBkgr!=0)&&(y->bkgr==1)) {
lowlib.c:          if ( ( D->DrawBkgr != 0 ) ) {
lowlib.c:              if ( ( y->bkgr == 1 ) ) {
lowlib.c:                  img = kgBorderedRectangle ( br->x2-br->x1 , br->y2-br->y1 , gc.twin_fill , 0.0 ) ;
lowlib.c:                  kgImage ( D , img , br->x1 , br->y1 , br->x2-br->x1 , br->y2-br->y1 , 0.0 , 1.0 ) ;
lowlib.c:                  img = kgBorderedRectangle ( br->x2-br->x1 , br->y2-br->y1 , gc.fill_clr , 0.0 ) ;
lowlib.c:                  kgImage ( D , img , br->x1 , br->y1 , br->x2-br->x1 , br->y2-br->y1 , 0.0 , 1.0 ) ;
lowlib.c:          if ( y->nitems != 0 ) {
lowlib.c:              if ( br->scroll ) {
lowlib.c://    _dvrect_fill(WC(D), br->x1,br->y1,br->x2,br->y2,gc.fill_clr);
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   _dvrect_fill(WC(D), br->x1+(offset),br->y1+(offset),br->x2-(offset), br->y2-(offset),gc.fill_clr);
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground \
lowlib.c:           ( D , br->x1 , br->y1 , br->x2 , br->y2 ) ;
lowlib.c:          else kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://   if((D->DrawBkgr!=0)&&(y->bkgr==1)) {
lowlib.c:          if ( ( D->DrawBkgr != 0 ) ) {
lowlib.c:              if ( ( y->bkgr == 1 ) ) {
lowlib.c:                  _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:                   ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:                  _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:                   ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:              if ( y->bordr == 1 ) {
lowlib.c:                  _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:                   ( offset ) , br->y2- ( offset ) , gc.vbright ) ;
lowlib.c:          if ( y->nitems != 0 ) {
lowlib.c:              if ( br->scroll ) {
lowlib.c://  else _dvrect_fill(WC(D), br->x1,br->y1,br->x2,br->y2,gc.fill_clr);
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   _dvrect_fill(WC(D), br->x1+(offset),br->y1+(offset),br->x2-(offset), br->y2-(offset),gc.fill_clr);
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground \
lowlib.c:           ( D , br->x1 , br->y1 , br->x2 , br->y2 ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://   if((D->DrawBkgr!=0)&&(y->bkgr==1)) {
lowlib.c:          if ( ( D->DrawBkgr != 0 ) ) {
lowlib.c:              if ( y->bkgr == 1 ) {
lowlib.c:                  _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:                   ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:                  _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:                   ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:              if ( y->bordr == 1 ) {
lowlib.c:                  _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:                   ( offset ) , br->y2- ( offset ) , gc.vbright ) ;
lowlib.c:          if ( y->nitems != 0 ) {
lowlib.c:              if ( br->scroll ) {
lowlib.c://    _dvrect_fill(WC(D), br->x1,br->y1,br->x2,br->y2,gc.fill_clr);
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c://  offset=y->offset;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   _dvrect_fill(WC(D), br->x1+(offset),br->y1+(offset),br->x2-(offset), br->y2-(offset),gc.fill_clr);
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground \
lowlib.c:           ( D , br->x1 , br->y1 , br->x2 , br->y2 ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c:          if ( ( D->DrawBkgr != 0 ) && ( y->bkgr == 1 ) ) {
lowlib.c:              _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:               ( offset ) , br->y2- ( offset ) , gc.twin_fill ) ;
lowlib.c:              _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:               ( offset ) , br->y2- ( offset ) , gc.twin_bodr ) ;
lowlib.c://    _dvbordertype4(D, br->x1+(offset),br->y1+(offset),br->x2-(offset), br->y2-(offset));
lowlib.c:              img = kgBorderedRectangle ( br->x2-br->x1 , br->y2-br->y1 , gc.twin_fill , 0.0 ) ;
lowlib.c:              kgImage ( D , img , br->x1 , br->y1 , br->x2-br->x1 , br->y2-br->y1 , 0.0 , 1.0 ) ;
lowlib.c:          if ( y->nitems != 0 ) {
lowlib.c:              if ( br->scroll ) {
lowlib.c://    _dvrect_fill(WC(D), br->x1,br->y1,br->x2,br->y2,gc.fill_clr);
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      offset = y->offset;
lowlib.c:      x1 = y->x1+D->xo; x2 = y->x2+D->xo;
lowlib.c:      y1 = y->y1+D->yo; y2 = y->y2+D->yo;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://     _dvrect_fill(WC(D), x1+(offset),y1+(offset),x2-(offset), y2-(offset),gc.fill_clr);
lowlib.c:          _dvrect_fill ( WC ( D ) , x1+1 , y1+1 , x2-1 , y2-1 , gc.fill_clr ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImagePart ( D , y->Bimg , x1+1 , y1+1 , 1 , 1 , \
lowlib.c:           ( x2-x1-1 ) , ( y2-y1-1 ) ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      offset = y->offset;
lowlib.c:      x1 = y->x1+D->xo; x2 = y->x2+D->xo;
lowlib.c:      y1 = y->y1+D->yo; y2 = y->y2+D->yo;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://     _dvrect_fill(WC(D), x1+(offset),y1+(offset),x2-(offset), y2-(offset),gc.fill_clr);
lowlib.c:          _dvrect_fill ( WC ( D ) , x1+1 , y1+1 , x2-1 , y2-1 , gc.fill_clr ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImagePart ( D , y->Bimg , x1+1 , y1+1 , 1 , 1 , \
lowlib.c:           ( x2-x1-1 ) , ( y2-y1-1 ) ) ;
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , x1 , y1 , \
lowlib.c:           ( x2-x1+1 ) , ( y2-y1+1 ) ) ;
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c://  if(offset<y->offset) offset=y->offset;
lowlib.c:      if ( y->hide != 1 ) {
lowlib.c://   _dvrect_fill(WC(D), br->x1+(offset),br->y1+(offset),br->x2-(offset), br->y2-(offset),gc.fill_clr);
lowlib.c:          if ( y->Bimg == NULL ) y->Bimg = kgGetBackground \
lowlib.c:           ( D , br->x1 , br->y1 , br->x2 , br->y2 ) ;
lowlib.c:          else kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c:          if ( ( D->DrawBkgr != 0 ) && ( y->bkgr == 1 ) ) {
lowlib.c:              _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:               ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:              _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:               ( offset ) , br->y2- ( offset ) , gc.vbright ) ;
lowlib.c:          if ( y->nitems != 0 ) {
lowlib.c:              if ( br->scroll ) {
lowlib.c://   _dvrect_fill(WC(D), br->x1,br->y1,br->x2,br->y2,gc.fill_clr);
lowlib.c:          if ( y->Bimg != NULL ) kgRestoreImage ( D , y->Bimg , br->x1 , br->y1 , \
lowlib.c:           ( br->x2-br->x1+1 ) , ( br->y2-br->y1+1 ) ) ;
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( y->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:       ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:      if ( ( D->DrawBkgr != 0 ) && ( y->bkgr == 1 ) ) {
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:          _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , gc.vbright ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:       ( offset ) , br->y2- ( offset ) , gc.fill_clr ) ;
lowlib.c:      if ( ( D->DrawBkgr != 0 ) && ( y->bkgr == 1 ) ) {
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , br->MS.color1 ) ;
lowlib.c:          _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , br->MS.color2 ) ;
lowlib.c:          _dvrect_fill ( WC ( D ) , ( br->x1+offset ) , ( br->y1+offset ) , \
lowlib.c:           ( br->x2-offset ) , ( br->y2-offset ) , br->MS.color2 ) ;
lowlib.c:          _dvrect_fill ( WC ( D ) , ( br->x1+offset ) +3 , ( br->y1+offset ) +3 , \
lowlib.c:           ( br->x2-offset ) -3 , ( br->y2-offset ) -3 , br->MS.color1 ) ;
lowlib.c:      if ( y->nitems != 0 ) {
lowlib.c:          if ( br->scroll ) {
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      br = y->bwsr;
lowlib.c:      D = ( DIALOG * ) ( br->D ) ;
lowlib.c:      gc = D->gc;
lowlib.c:      _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:       ( offset ) , br->y2- ( offset ) , gc.txt_fill ) ;
lowlib.c:      _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:       ( offset ) , br->y2- ( offset ) , gc.vbright ) ;
lowlib.c:      if ( y->nitems != 0 ) {
lowlib.c:          if ( br->scroll ) {
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      br = w->bwsr;
lowlib.c:      D = ( DIALOG * ) ( w->D ) ;
lowlib.c:      offset = w->offset;
lowlib.c:      menu = w->menu;
lowlib.c:      if ( br->size > n ) br->size = n;
lowlib.c:      if ( br->size == n ) {
lowlib.c:      gc = D->gc;
lowlib.c:      br->D = D;
lowlib.c:      br->MS.color1 = gc.fill_clr; br->MS.color2 = gc.high_clr;
lowlib.c:      br->MS.color1 = gc.msg_fill; br->MS.color2 = gc.msg_bodr;
lowlib.c:      br->MS.char_clr = gc.msg_char;
lowlib.c:      br->MS.imenu = br->size;
lowlib.c:      br->MS.nitems = n;
lowlib.c:      br->MS.por = br->size;
lowlib.c:      br->MS.ichr = max;
lowlib.c:      br->MS.thirty = thirty;
lowlib.c:      br->MS.iyl = ( br->size+1 ) *thirty;
lowlib.c:      br->MS.ixl = ( max*9+15 ) ;
lowlib.c:      br->MS.ixx = br->x1;
lowlib.c:      br->MS.iyy = br->y1;
lowlib.c:      br->MS.ixl = br->x2 -br->x1-44;
lowlib.c:      br->MS.ixx = br->x1+10;
lowlib.c:      br->MS.iyy = br->y1+10;
lowlib.c:          br->MS.ixx += 8;
lowlib.c:          br->MS.iyy -= 2;
lowlib.c:      br->MS.iyu = br->MS.iyy +br->MS.iyl;
lowlib.c:      br->MS.ixu = br->MS.ixx+br->MS.ixl-1;
lowlib.c:      X1 = br->MS.ixx-bodrwidth;
lowlib.c:      Y1 = br->MS.iyy-bodrwidth-scroll*10;
lowlib.c:      X2 = ( br->MS.ixx+br->MS.ixl+scroll*24+bodrwidth ) ;
lowlib.c:      Y2 = ( br->MS.iyy+scroll*10+bodrwidth+ ( br->MS.iyl ) ) ;
lowlib.c:      _dvrect_fill ( WC ( D ) , br->x1+offset , br->y1+offset , br->x2-offset , br->y2-offset , gc.fill_clr ) ;
lowlib.c:      _dvbordertype1 ( D , br->x1+offset , br->y1+offset , br->x2-offset , br->y2-offset ) ;
lowlib.c:      if ( ( D->DrawBkgr != 0 ) && ( w->bkgr == 1 ) ) {
lowlib.c:          _dvrect_fill ( WC ( D ) , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , br->MS.color1 ) ;
lowlib.c:          _dvbordertype0 ( D , br->x1+ ( offset ) , br->y1+ ( offset ) , br->x2- \
lowlib.c:           ( offset ) , br->y2- ( offset ) , br->MS.color2 ) ;
lowlib.c:              xx = br->MS.ixx+br->MS.ixl+1;
lowlib.c:              yy = br->MS.iyy-10;
lowlib.c:              h = br->MS.iyl+20;
lowlib.c:              xx = br->MS.ixu+3;
lowlib.c:              yy = br->MS.iyy-1;
lowlib.c:              h = br->MS.iyu- br->MS.iyy+4;
lowlib.c://  uiUpdateOn(br->D);
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      c_color = WC ( D )->c_color;
lowlib.c:      y = EVGAY-y;
lowlib.c:      ny = y-18;
lowlib.c:      y1 = y-l;
lowlib.c:      uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:      uiString ( D , ch1 , ix , iy , max1*9 , 22 , D->gc.MsgFont , char_clr , D->gc.FontSize , -1 , fill_clr ) ;
lowlib.c:      EVGAX = D->evgax;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      uig_scroll_up ( D , ( int ) Twin->xl , EVGAY- ( int ) Twin->yl , \
lowlib.c:       ( int ) Twin->xu , EVGAY- ( int ) Twin->yu , Twin->w ) ;
lowlib.c:      yy1 = ( int ) Twin->yl;
lowlib.c:      yy2 = ( int ) Twin->yu;
lowlib.c:      jmp = Twin->w;
lowlib.c:      uiscr_scroll_back ( D , ( int ) Twin->xl , yy1+jmp , \
lowlib.c:       ( int ) Twin->xu , yy2 , jmp ) ;
lowlib.c:      Dend ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      Twin = ( TWIN * ) Getrecordrev ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      EVGAX = D->evgax;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      uig_scroll_up ( D , ( int ) Twin->xl , EVGAY- ( int ) Twin->yl , \
lowlib.c:       ( int ) Twin->xu , EVGAY- ( int ) Twin->yu , 22 ) ;
lowlib.c:      EVGAX = D->evgax;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      Dend ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      Twin = ( TWIN * ) Getrecordrev ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      xp = Twin->xp;
lowlib.c:      yp = Twin->yp;
lowlib.c:      yu = Twin->yu-22-5;
lowlib.c:      n = Twin->nchr;
lowlib.c:          if ( yp > yu ) { yp-= 22; uiscroll_up_twin ( D , Twin ) ; };
lowlib.c:          uiwrt_msg ( D , xp+3 , yp , n , buf , D->gc.twin_fill , D->gc.twin_char ) ;
lowlib.c:      Twin->yp = yp;
lowlib.c:      Dend ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      Twin = ( TWIN * ) Getrecordrev ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      if ( Twin->w == -1 ) return;
lowlib.c:      xp = Twin->xl+ ( col-1 ) *9;
lowlib.c:      if ( xp < Twin->xu ) Twin->xp = xp;
lowlib.c:      yp = Twin->yl+22* ( row-1 ) ;
lowlib.c:      if ( yp < Twin->yu ) Twin->yp = yp;
lowlib.c:      EVGAX = D->evgax;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      kg_scr_back ( WC ( D ) , ( int ) ix-3 , ( int ) ( iy-3 ) , x2+3 , y2+3 ) ;
lowlib.c:      _uirect_fill ( WC ( D ) , ( int ) ix , ( int ) EVGAY-iy , \
lowlib.c:       ( int ) x2 , ( int ) EVGAY-y2 , D->gc.twin_fill ) ;
lowlib.c:      _ui_draw_bound ( D , ( int ) ix-1 , ( int ) EVGAY-iy+1 , \
lowlib.c:       ( int ) x2+1 , ( int ) EVGAY-y2-1 , D->gc.twin_bodr ) ;
lowlib.c:      _ui_draw_bound ( D , ( int ) ix-2 , ( int ) EVGAY-iy+2 , \
lowlib.c:       ( int ) x2+2 , ( int ) EVGAY-y2-2 , D->gc.twin_bodr ) ;
lowlib.c:      _ui_draw_bound ( D , ( int ) ix-3 , ( int ) EVGAY-iy+3 , \
lowlib.c:       ( int ) x2+3 , ( int ) EVGAY-y2-3 , D->gc.twin_bodr ) ;
lowlib.c:      Twin->xl = ix; Twin->yl = iy; Twin->xu = x2;
lowlib.c:      Twin->yu = y2; Twin->w = 1;
lowlib.c:      Twin->nchr = chrs;
lowlib.c:      Twin->xp = ix;
lowlib.c:      Twin->yp = iy;
lowlib.c:      Dappend ( ( Dlink * ) WC ( D )->TLIST , Twin ) ;
lowlib.c:      EVGAX = D->evgax;
lowlib.c:      EVGAY = D->evgay;
lowlib.c:      kg_scr_back ( WC ( D ) , ( int ) ix-dx , ( int ) ( iy-dy ) , x2+dx , y2+dy ) ;
lowlib.c:      ix -= xbdr;
lowlib.c:      iy -= ybdr;
lowlib.c:      _uirect_fill ( WC ( D ) , ( int ) ix , ( int ) EVGAY-iy , \
lowlib.c:       ( int ) x2 , ( int ) EVGAY-y2 , D->gc.twin_fill ) ;
lowlib.c:      _ui_draw_bound ( D , ( int ) ix-1 , ( int ) EVGAY-iy+1 , \
lowlib.c:       ( int ) x2+1 , ( int ) EVGAY-y2-1 , D->gc.twin_bodr ) ;
lowlib.c:      _ui_draw_bound ( D , ( int ) ix-2 , ( int ) EVGAY-iy+2 , \
lowlib.c:       ( int ) x2+2 , ( int ) EVGAY-y2-2 , D->gc.twin_bodr ) ;
lowlib.c:      _ui_draw_bound ( D , ( int ) ix-3 , ( int ) EVGAY-iy+3 , \
lowlib.c:       ( int ) x2+3 , ( int ) EVGAY-y2-3 , D->gc.twin_bodr ) ;
lowlib.c:      Twin->xl = ix; Twin->yl = iy; Twin->xu = x2;
lowlib.c:      Twin->yu = y2; Twin->w = 1;
lowlib.c:      Twin->nchr = chrs;
lowlib.c:      Twin->xp = ix;
lowlib.c:      Twin->yp = iy;
lowlib.c:      Dappend ( ( Dlink * ) WC ( D )->TLIST , Twin ) ;
lowlib.c:      Dend ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      Ddelete ( ( Dlink * ) ( WC ( D )->TLIST ) ) ;
lowlib.c:      xp = Twin->xp;
lowlib.c:      yp = Twin->yp;
lowlib.c:      yu = Twin->yu-22-2;
lowlib.c:      n = Twin->nchr;
lowlib.c:          if ( yp > yu ) { yp-= 22; uiscroll_up_twin ( D , Twin ) ; };
lowlib.c:          uiwrt_msg ( D , xp+3 , yp , n , buf , D->gc.twin_fill , D->gc.twin_char ) ;
lowlib.c:      Twin->yp = yp;
lowlib.c:      lw = Twin->w;
lowlib.c:      xp = Twin->xp;
lowlib.c:      yp = Twin->yp;
lowlib.c:      yu = Twin->yu-lw;
lowlib.c:      n = Twin->nchr;
lowlib.c:      ln = Twin->xu-Twin->xl;
lowlib.c:          if ( yp > yu ) { yp-= lw; uiscroll_up_twin ( D , Twin ) ; };
lowlib.c://    uiwrt_msg(D,xp,yp,n,buf,D->gc.info_fill,D->gc.info_char);
lowlib.c:          uiString ( D , buf , xp , yp , ln , lw , D->gc.MsgFont , D->gc.info_char , D->gc.FontSize , -1 , D->gc.info_fill ) ;
lowlib.c:      Twin->yp = yp;
lowlib.c:      D = G->D;
lowlib.c:      wc = G->wc;
lowlib.c:      EVGAY = wc->EVGAY ;
lowlib.c:      y = EVGAY-y;
lowlib.c:      ny = y-18;
lowlib.c:      y1 = y-l;
lowlib.c:      _uirect_fill ( wc , x1 , y1 , x2 , y2 , D->gc.msg_fill ) ;
lowlib.c:      uiSetGuiFixFontSize ( D , D->gc.InputFontSize ) ;
lowlib.c:      uiMenustr ( D , menu_x , menu_y , ch1 , D->gc.msg_char ) ;
lowlib.c:      br = w->bwsr;
lowlib.c:      D = w->D;
lowlib.c:      item = br->df;
lowlib.c:      x = br->menu;
lowlib.c:      if ( br->menu [ 0 ] == NULL ) return 1;
lowlib.c:          kbevent = kgSkipMouseMove ( br->D ) ;
lowlib.c:          D->PON_X = kbevent.x; D->PON_Y = kbevent.y;
lowlib.c:                  if ( ok == 0 ) br->df = item;
lowlib.c:                  if ( ok == 0 ) br->df = item;
lowlib.c:      item = br->df;
magixresize.c:% Copyright (C) 2003 - 2012 GraphicsMagick Group
magixresize.c:%    Reduce x to |x| since j1(x)= -j1(-x), and for x in (0,8]
magixresize.c:%       j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))
magixresize.c:%    where x1 = x-3*pi/4. Compute sin(x1) and cos(x1) as follow:
magixresize.c:%               =  1/sqrt(2) * (sin(x) - cos(x))
magixresize.c:%       sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
magixresize.c:%               = -1/sqrt(2) * (sin(x) + cos(x))
magixresize.c:      -0.6672106568924916298020941484e+20,
magixresize.c:      -0.3588817569910106050743641413e+17,
magixresize.c:      -0.1322983480332126453125473247e+13,
magixresize.c:      -0.4695753530642995859767162166e+7,
magixresize.c:  for (i=7; i >= 0; i--)
magixresize.c:  for (i=4; i >= 0; i--)
magixresize.c:      0.3532840052740123642735e-1
magixresize.c:  for (i=4; i >= 0; i--)
magixresize.c:    x=(-x);
magixresize.c:  q=sqrt(2.0/(MagickPI*x))*(P1(x)*(1.0/sqrt(2.0)*(sin(x)-cos(x)))-8.0/x*Q1(x)*
magixresize.c:    (-1.0/sqrt(2.0)*(sin(x)+cos(x))));
magixresize.c:    q=(-q);
magixresize.c:  assert(image->signature == MagickSignature);
magixresize.c:  assert(exception->signature == MagickSignature);
magixresize.c:  magnify_image=CloneImage(image,2*image->columns,2*image->rows,True,exception);
magixresize.c:                        image->columns,image->rows,magnify_image->columns,magnify_image->rows);
magixresize.c:  magnify_image->storage_class=DirectClass;
magixresize.c:                               magnify_image->columns,sizeof(PixelPacket));
magixresize.c:  for (y=0; y < (long) image->rows; y++)
magixresize.c:      pixels=AcquireImagePixels(image,0,y,image->columns,1,exception);
magixresize.c:      q=SetImagePixels(magnify_image,0,y,magnify_image->columns,1);
magixresize.c:      (void) memcpy(q,pixels,image->columns*sizeof(PixelPacket));
magixresize.c:  for (y=0; y < (long) image->rows; y++)
magixresize.c:      p=GetImagePixels(magnify_image,0,(long) (image->rows-y-1),
magixresize.c:                       magnify_image->columns,1);
magixresize.c:      (void) memcpy(scanline,p,magnify_image->columns*sizeof(PixelPacket));
magixresize.c:      q=GetImagePixels(magnify_image,0,(long) (2*(image->rows-y-1)),
magixresize.c:                       magnify_image->columns,1);
magixresize.c:      p=scanline+image->columns-1;
magixresize.c:      q+=2*(image->columns-1);
magixresize.c:      for (x=1; x < (long) image->columns; x++)
magixresize.c:          p--;
magixresize.c:          q-=2;
magixresize.c:          (q+1)->red=(Quantum) (((double) p->red+(double) (p+1)->red)/2.0+0.5);
magixresize.c:          (q+1)->green=(Quantum) (((double) p->green+(double) (p+1)->green)/2.0+0.5);
magixresize.c:          (q+1)->blue=(Quantum) (((double) p->blue+(double) (p+1)->blue)/2.0+0.5);
magixresize.c:          (q+1)->opacity=(Quantum)
magixresize.c:            (((double) p->opacity+(double) (p+1)->opacity)/2.0+0.5);
magixresize.c:  for (y=0; y < (long) image->rows; y++)
magixresize.c:      rows=(long) Min(image->rows-y,3);
magixresize.c:      p=GetImagePixels(magnify_image,0,2*y,magnify_image->columns,rows);
magixresize.c:        q=p+magnify_image->columns;
magixresize.c:        r=q+magnify_image->columns;
magixresize.c:      for (x=0; x < (long) (image->columns-1); x++)
magixresize.c:          q->red=(Quantum) (((double) p->red+(double) r->red)/2.0+0.5);
magixresize.c:          q->green=(Quantum) (((double) p->green+(double) r->green)/2.0+0.5);
magixresize.c:          q->blue=(Quantum) (((double) p->blue+(double) r->blue)/2.0+0.5);
magixresize.c:          q->opacity=(Quantum) (((double) p->opacity+(double) r->opacity)/2.0+0.5);
magixresize.c:          (q+1)->red=(Quantum) (((double) p->red+(double) (p+2)->red+
magixresize.c:                                 (double) r->red+(double) (r+2)->red)/4.0+0.5);
magixresize.c:          (q+1)->green=(Quantum) (((double) p->green+(double) (p+2)->green+
magixresize.c:                                   (double) r->green+(double) (r+2)->green)/4.0+0.5);
magixresize.c:          (q+1)->blue=(Quantum) (((double) p->blue+(double) (p+2)->blue+
magixresize.c:                                  (double) r->blue+(double) (r+2)->blue)/4.0+0.5);
magixresize.c:          (q+1)->opacity=(Quantum) (((double) p->opacity+(double) (p+2)->opacity+
magixresize.c:                                     (double) r->opacity+(double) (r+2)->opacity)/4.0+0.5);
magixresize.c:      q->red=(Quantum) (((double) p->red+(double) r->red)/2.0+0.5);
magixresize.c:      q->green=(Quantum) (((double) p->green+(double) r->green)/2.0+0.5);
magixresize.c:      q->blue=(Quantum) (((double) p->blue+(double) r->blue)/2.0+0.5);
magixresize.c:      q->opacity=(Quantum) (((double) p->opacity+(double) r->opacity)/2.0+0.5);
magixresize.c:      q->red=(Quantum) (((double) p->red+(double) r->red)/2.0+0.5);
magixresize.c:      q->green=(Quantum) (((double) p->green+(double) r->green)/2.0+0.5);
magixresize.c:      q->blue=(Quantum) (((double) p->blue+(double) r->blue)/2.0+0.5);
magixresize.c:      q->opacity=(Quantum) (((double) p->opacity+(double) r->opacity)/2.0+0.5);
magixresize.c:      if (QuantumTick(y,image->rows))
magixresize.c:        if (!MagickMonitorFormatted(y,image->rows,exception,
magixresize.c:                                    MagnifyImageText,image->filename))
magixresize.c:  p=GetImagePixels(magnify_image,0,(long) (2*image->rows-2),
magixresize.c:                   magnify_image->columns,1);
magixresize.c:    (void) memcpy(scanline,p,magnify_image->columns*sizeof(PixelPacket));
magixresize.c:  q=GetImagePixels(magnify_image,0,(long) (2*image->rows-1),
magixresize.c:                   magnify_image->columns,1);
magixresize.c:    (void) memcpy(q,scanline,magnify_image->columns*sizeof(PixelPacket));
magixresize.c:  magnify_image->is_grayscale=image->is_grayscale;
magixresize.c:  total.red+=(weight)*(r->red);                 \
magixresize.c:  total.green+=(weight)*(r->green);             \
magixresize.c:  total.blue+=(weight)*(r->blue);               \
magixresize.c:  total.opacity+=(weight)*(r->opacity);         \
magixresize.c:  assert(image->signature == MagickSignature);
magixresize.c:  assert(exception->signature == MagickSignature);
magixresize.c:  minify_image=CloneImage(image,Max(image->columns/2,1),Max(image->rows/2,1),
magixresize.c:                        image->columns,image->rows,
magixresize.c:                        minify_image->columns,minify_image->rows);
magixresize.c:  minify_image->storage_class=DirectClass;
magixresize.c:    for (y=0; y < (long) minify_image->rows; y++)
magixresize.c:        p=AcquireImagePixels(image,-2,2*(y-1),image->columns+4,4,exception);
magixresize.c:        q=SetImagePixelsEx(minify_image,0,y,minify_image->columns,1,exception);
magixresize.c:            for (x=0; x < (long) minify_image->columns; x++)
magixresize.c:                r=p+(image->columns+4);
magixresize.c:                r=p+2*(image->columns+4);
magixresize.c:                r=p+3*(image->columns+4);
magixresize.c:                q->red=(Quantum) (total.red/128.0+0.5);
magixresize.c:                q->green=(Quantum) (total.green/128.0+0.5);
magixresize.c:                q->blue=(Quantum) (total.blue/128.0+0.5);
magixresize.c:                q->opacity=(Quantum) (total.opacity/128.0+0.5);
magixresize.c:          if (QuantumTick(row_count,image->rows))
magixresize.c:            if (!MagickMonitorFormatted(row_count,image->rows,exception,
magixresize.c:                                        MinifyImageText,image->filename))
magixresize.c:  minify_image->is_grayscale=image->is_grayscale;
magixresize.c:  if (x < -0.5)
magixresize.c:  if (x < -2.0)
magixresize.c:  if (x < -1.0)
magixresize.c:    return(0.5*(2.0+x*x*(-5.0-3.0*x)));
magixresize.c:    return(0.5*(2.0+x*x*(-5.0+3.0*x)));
magixresize.c:    return(0.5*(4.0+x*(-8.0+x*(5.0-x))));
magixresize.c:  if (x < -2.0)
magixresize.c:  if (x < -1.0)
magixresize.c:    return((4.0+x*x*(-6.0-3.0*x))/6.0);
magixresize.c:    return((4.0+x*x*(-6.0+3.0*x))/6.0);
magixresize.c:    return((2.0-x)*(2.0-x)*(2.0-x)/6.0);
magixresize.c:  return(exp(-2.0*x*x)*sqrt(2.0/MagickPI));
magixresize.c:  if (x < -1.0)
magixresize.c:    return((2.0*(-x)-3.0)*(-x)*(-x)+1.0);
magixresize.c:    return((2.0*x-3.0)*x*x+1.0);
magixresize.c:  if (x < -3.0)
magixresize.c:    return(Sinc(-x,support)*Sinc(-x/3.0,support));
magixresize.c:#define P0  ((  6.0- 2.0*B       )/6.0)
magixresize.c:#define P2  ((-18.0+12.0*B+ 6.0*C)/6.0)
magixresize.c:#define P3  (( 12.0- 9.0*B- 6.0*C)/6.0)
magixresize.c:#define Q1  ((     -12.0*B-48.0*C)/6.0)
magixresize.c:#define Q3  ((     - 1.0*B- 6.0*C)/6.0)
magixresize.c:  if (x < -2.0)
magixresize.c:  if (x < -1.0)
magixresize.c:    return(Q0-x*(Q1-x*(Q2-x*Q3)));
magixresize.c:    return(P0+x*x*(P2-x*P3));
magixresize.c:  if (x < -1.5)
magixresize.c:  if (x < -0.5)
magixresize.c:    return(0.75-x*x);
magixresize.c:    return(0.5*(x-1.5)*(x-1.5));
magixresize.c:  if (x < -1.0)
magixresize.c:    return(1.0-x);
magixresize.c:  support=scale*filter_info->support;
magixresize.c:  destination->storage_class=source->storage_class;
magixresize.c:    destination->storage_class=DirectClass;
magixresize.c:  for (x=0; x < (long) destination->columns; x++)
magixresize.c:      start=(long) Max(center-support+0.5,0);
magixresize.c:      stop=(long) Min(center+support+0.5,source->columns);
magixresize.c:      for (n=0; n < (stop-start); n++)
magixresize.c:            filter_info->function(scale*(start+n-center+0.5),filter_info->support);
magixresize.c:                           contribution[n-1].pixel-contribution[0].pixel+1,
magixresize.c:                           source->rows,exception);
magixresize.c:	q=SetImagePixelsEx(destination,x,0,1,destination->rows,exception);
magixresize.c:          for (y=0; y < (long) destination->rows; y++)
magixresize.c:              if ((destination->matte) || (destination->colorspace == CMYKColorspace))
magixresize.c:                      j=y*(contribution[n-1].pixel-contribution[0].pixel+1)+
magixresize.c:                        (contribution[i].pixel-contribution[0].pixel);
magixresize.c:                      transparency_coeff = weight * (1 - ((double) p[j].opacity/TransparentOpacity));
magixresize.c:                      j=(long) (y*(contribution[n-1].pixel-contribution[0].pixel+1)+
magixresize.c:                                (contribution[i].pixel-contribution[0].pixel));
magixresize.c:                  i=Min(Max((long) (center+0.5),start),stop-1);
magixresize.c:                  j=y*(contribution[n-1].pixel-contribution[0].pixel+1)+
magixresize.c:                    (contribution[i-start].pixel-contribution[0].pixel);
magixresize.c:                                      ResizeImageText,source->filename))
magixresize.c:  support=scale*filter_info->support;
magixresize.c:  destination->storage_class=source->storage_class;
magixresize.c:    destination->storage_class=DirectClass;
magixresize.c:  for (y=0; y < (long) destination->rows; y++)
magixresize.c:      start=(long) Max(center-support+0.5,0);
magixresize.c:      stop=(long) Min(center+support+0.5,source->rows);
magixresize.c:      for (n=0; n < (stop-start); n++)
magixresize.c:            filter_info->function(scale*(start+n-center+0.5),filter_info->support);
magixresize.c:      p=AcquireImagePixels(source,0,contribution[0].pixel,source->columns,
magixresize.c:                           contribution[n-1].pixel-contribution[0].pixel+1,
magixresize.c:	q=SetImagePixelsEx(destination,0,y,destination->columns,1,exception);
magixresize.c:          for (x=0; x < (long) destination->columns; x++)
magixresize.c:              if ((source->matte) || (source->colorspace == CMYKColorspace))
magixresize.c:                      j=(long) ((contribution[i].pixel-contribution[0].pixel)*
magixresize.c:                                source->columns+x);
magixresize.c:                      transparency_coeff = weight * (1 - ((double) p[j].opacity/TransparentOpacity));
magixresize.c:                      j=(long) ((contribution[i].pixel-contribution[0].pixel)*
magixresize.c:                                source->columns+x);
magixresize.c:                  i=Min(Max((long) (center+0.5),start),stop-1);
magixresize.c:                  j=(long) ((contribution[i-start].pixel-contribution[0].pixel)*
magixresize.c:                            source->columns+x);
magixresize.c:                                      ResizeImageText,source->filename))
magixresize.c:      span=source_image->columns+resize_image->rows;
magixresize.c:      span=resize_image->columns+source_image->rows;
magixresize.c:  resize_image->is_grayscale=image->is_grayscale;
magixresize.c:  assert(image->signature == MagickSignature);
magixresize.c:  assert(exception->signature == MagickSignature);
magixresize.c:  if ((columns == image->columns) && (rows == image->rows))
magixresize.c:                        image->columns,image->rows,sample_image->columns,
magixresize.c:                        sample_image->rows);
magixresize.c:  pixels=MagickAllocateArray(PixelPacket *,image->columns,sizeof(PixelPacket));
magixresize.c:  x_offset=MagickAllocateArray(double *,sample_image->columns,sizeof(double));
magixresize.c:  y_offset=MagickAllocateArray(double *,sample_image->rows,sizeof(double));
magixresize.c:    for (x=0; x < (long) sample_image->columns; x++)
magixresize.c:      x_offset[x]=(double) x*image->columns/(double) sample_image->columns;
magixresize.c:    for (y=0; y < (long) sample_image->rows; y++)
magixresize.c:      y_offset[y]=(double) y*image->rows/(double) sample_image->rows;
magixresize.c:  j=(-1);
magixresize.c:  for (y=0; y < (long) sample_image->rows; y++)
magixresize.c:      q=SetImagePixels(sample_image,0,y,sample_image->columns,1);
magixresize.c:          p=AcquireImagePixels(image,0,j,image->columns,1,exception);
magixresize.c:          (void) memcpy(pixels,p,image->columns*sizeof(PixelPacket));
magixresize.c:      for (x=0; x < (long) sample_image->columns; x++)
magixresize.c:        for (x=0; x < (long) sample_image->columns; x++)
magixresize.c:      if (QuantumTick(y,sample_image->rows))
magixresize.c:        if (!MagickMonitorFormatted(y,sample_image->rows,exception,
magixresize.c:                                    "[%s] Sample (%lux%lu --> %lux%lu) image...",
magixresize.c:                                    image->filename,image->columns,image->rows,
magixresize.c:                                    sample_image->columns, sample_image->rows))
magixresize.c:  sample_image->is_monochrome=image->is_monochrome;
magixresize.c:  sample_image->is_grayscale=image->is_grayscale;
magixresize.c:  assert(image->signature == MagickSignature);
magixresize.c:  assert(exception->signature == MagickSignature);
magixresize.c:                        image->columns,image->rows,scale_image->columns,
magixresize.c:                        scale_image->rows);
magixresize.c:  scale_image->storage_class=DirectClass;
magixresize.c:                                image->columns*sizeof(DoublePixelPacket));
magixresize.c:  if (image->rows != scale_image->rows)
magixresize.c:                                  image->columns*sizeof(DoublePixelPacket));
magixresize.c:                                      scale_image->columns*sizeof(DoublePixelPacket));
magixresize.c:                                image->columns*sizeof(DoublePixelPacket));
magixresize.c:  y_scale=(double) scale_image->rows/image->rows;
magixresize.c:  (void) memset(y_vector,0,image->columns*sizeof(DoublePixelPacket));
magixresize.c:  for (y=0; y < (long) scale_image->rows; y++)
magixresize.c:      q=SetImagePixels(scale_image,0,y,scale_image->columns,1);
magixresize.c:      if (scale_image->rows == image->rows)
magixresize.c:          p=AcquireImagePixels(image,0,i++,image->columns,1,exception);
magixresize.c:          for (x=0; x < (long) image->columns; x++)
magixresize.c:              x_vector[x].red=p->red;
magixresize.c:              x_vector[x].green=p->green;
magixresize.c:              x_vector[x].blue=p->blue;
magixresize.c:              x_vector[x].opacity=p->opacity;
magixresize.c:              if (next_row && (number_rows < (long) image->rows))
magixresize.c:                  p=AcquireImagePixels(image,0,i++,image->columns,1,exception);
magixresize.c:                  for (x=0; x < (long) image->columns; x++)
magixresize.c:                      x_vector[x].red=p->red;
magixresize.c:                      x_vector[x].green=p->green;
magixresize.c:                      x_vector[x].blue=p->blue;
magixresize.c:                      x_vector[x].opacity=p->opacity;
magixresize.c:              for (x=0; x < (long) image->columns; x++)
magixresize.c:              y_span-=y_scale;
magixresize.c:              y_scale=(double) scale_image->rows/image->rows;
magixresize.c:          if (next_row && (number_rows < (long) image->rows))
magixresize.c:              p=AcquireImagePixels(image,0,i++,image->columns,1,exception);
magixresize.c:              for (x=0; x < (long) image->columns; x++)
magixresize.c:                  x_vector[x].red=p->red;
magixresize.c:                  x_vector[x].green=p->green;
magixresize.c:                  x_vector[x].blue=p->blue;
magixresize.c:                  x_vector[x].opacity=p->opacity;
magixresize.c:          for (x=0; x < (long) image->columns; x++)
magixresize.c:              s->red=pixel.red > MaxRGBDouble ? MaxRGBDouble : pixel.red;
magixresize.c:              s->green=pixel.green > MaxRGBDouble ? MaxRGBDouble : pixel.green;
magixresize.c:              s->blue=pixel.blue > MaxRGBDouble ? MaxRGBDouble : pixel.blue;
magixresize.c:              s->opacity=pixel.opacity > MaxRGBDouble ? MaxRGBDouble : pixel.opacity;
magixresize.c:          y_scale-=y_span;
magixresize.c:              y_scale=(double) scale_image->rows/image->rows;
magixresize.c:      if (scale_image->columns == image->columns)
magixresize.c:          for (x=0; x < (long) scale_image->columns; x++)
magixresize.c:              q->red=(Quantum) (s->red+0.5);
magixresize.c:              q->green=(Quantum) (s->green+0.5);
magixresize.c:              q->blue=(Quantum) (s->blue+0.5);
magixresize.c:              q->opacity=(Quantum) (s->opacity+0.5);
magixresize.c:          for (x=0; x < (long) image->columns; x++)
magixresize.c:              x_scale=(double) scale_image->columns/image->columns;
magixresize.c:                  pixel.red+=x_span*s->red;
magixresize.c:                  pixel.green+=x_span*s->green;
magixresize.c:                  pixel.blue+=x_span*s->blue;
magixresize.c:                  pixel.opacity+=x_span*s->opacity;
magixresize.c:                  t->red=pixel.red > MaxRGBDouble ? MaxRGBDouble : pixel.red;
magixresize.c:                  t->green=pixel.green > MaxRGBDouble ? MaxRGBDouble : pixel.green;
magixresize.c:                  t->blue=pixel.blue > MaxRGBDouble ? MaxRGBDouble : pixel.blue;
magixresize.c:                  t->opacity=pixel.opacity > MaxRGBDouble ? MaxRGBDouble : pixel.opacity;
magixresize.c:                  x_scale-=x_span;
magixresize.c:                  pixel.red+=x_scale*s->red;
magixresize.c:                  pixel.green+=x_scale*s->green;
magixresize.c:                  pixel.blue+=x_scale*s->blue;
magixresize.c:                  pixel.opacity+=x_scale*s->opacity;
magixresize.c:                  x_span-=x_scale;
magixresize.c:              s--;
magixresize.c:              pixel.red+=x_span*s->red;
magixresize.c:              pixel.green+=x_span*s->green;
magixresize.c:              pixel.blue+=x_span*s->blue;
magixresize.c:              pixel.opacity+=x_span*s->opacity;
magixresize.c:          if (!next_column && ((t-scale_scanline) < (long) scale_image->columns))
magixresize.c:              t->red=pixel.red > MaxRGBDouble ? MaxRGBDouble : pixel.red;
magixresize.c:              t->green=pixel.green > MaxRGBDouble ? MaxRGBDouble : pixel.green;
magixresize.c:              t->blue=pixel.blue > MaxRGBDouble ? MaxRGBDouble : pixel.blue;
magixresize.c:              t->opacity=pixel.opacity > MaxRGBDouble ? MaxRGBDouble : pixel.opacity;
magixresize.c:          for (x=0; x < (long) scale_image->columns; x++)
magixresize.c:              q->red=(Quantum) (t->red+0.5);
magixresize.c:              q->green=(Quantum) (t->green+0.5);
magixresize.c:              q->blue=(Quantum) (t->blue+0.5);
magixresize.c:              q->opacity=(Quantum) (t->opacity+0.5);
magixresize.c:      if (QuantumTick(y,scale_image->rows))
magixresize.c:        if (!MagickMonitorFormatted(y,scale_image->rows,exception,
magixresize.c:                                    ScaleImageText,image->filename))
magixresize.c:  if (scale_image->rows != image->rows)
magixresize.c:  scale_image->is_grayscale=image->is_grayscale;
magixresize.c:  if (UndefinedFilter != image->filter)
magixresize.c:    resize_filter=image->filter;
magixresize.c:  x_factor=(double) columns/image->columns;
magixresize.c:  y_factor=(double) rows/image->rows;
magixresize.c:    return(ResizeImage(image,columns,rows,resize_filter,image->blur,exception));
magixresize.c:    sample_image->blur,exception);
magixresize.c:%  Triangle is equivalent to bi-linear interpolation, and Mitchel giver slower,
magixresize.c:%  very high-quality results.  See Graphic Gems III for details on this
magixresize.c:  assert(image->signature == MagickSignature);
magixresize.c:  assert(exception->signature == MagickSignature);
magixresize.c:  zoom_image=ResizeImage(image,columns,rows,image->filter,image->blur,
makeimg.c:  fprintf(fp,"#ifndef D_%-s\n","GRAF");
makeimg.c:  fprintf(fp,"#define D_%-s\n","GRAF");
makeimg.c:  fprintf(fp,"  static unsigned char %-s_data[%d] = {\n  ","GRAF",w*h+1);
makeimg.c:  rem = (sizex*sizey) - size*3;
makeimg.c:  fprintf(fp,"  static PNGIMG  %-s_str = {\n","GRAF");
makeimg.c:  fprintf(fp,"    \"PNG\",1,\"%-s.png\", %d,%d,%d,%d,%-s_data \n  };\n","GRAF",sizex,sizey,sizex*4,4,"GRAF");
makeimg.c:static char FontName[30]={"Times-Roman"};
makeimg.c:#define TY(x,y) (cy -(x)*sint+(y)*cost)
makeimg.c:#define scr_x(x) (int)((x-w_x1)*u_x+D_x+0.5)
makeimg.c:#define scr_y(y) (int)((y-w_y1)*u_y+D_y+0.5)
makeimg.c:#define scr_z(z) (int)((z-clip_min)*CPCONS+0.5);
makeimg.c:#define fscr_z(z) (float)((z-clip_min)*CPCONS);
makeimg.c:#define usr_x(x) (float)((x-D_x)/u_x+w_x1)
makeimg.c:#define usr_y(y) (float)((y-D_y)/u_y+w_y1)
makeimg.c:#define cnv_x(x) (x*fx-sx)
makeimg.c:#define cnv_y(y) (y*fy-sy)
makeimg.c:#define pclr(p)  (float)(((p-pmin)*dfac+0.))
makeimg.c:     newstr.xstr = -(2.* ze/(oldstr.zstr)) * oldstr.xstr;
makeimg.c:     newstr.ystr = -(2.* ze/(oldstr.zstr)) * oldstr.ystr;
makeimg.c:  w  = Simg->image_width;
makeimg.c:  h  = Simg->image_height;
makeimg.c:  cy0=EVGAY-c_v_y2;
makeimg.c:  cy1=EVGAY-c_v_y1;
makeimg.c:  spixels = GetImagePixels((Image *)(Simg->image),0,0,((Image *)(Simg->image))->columns,((Image *)(Simg->image))->rows);
makeimg.c:  Y1=EVGAY-scr_y(y1);
makeimg.c:  Y2=EVGAY-scr_y(y2);
makeimg.c:  w = X2-X1+1;
makeimg.c:  h = Y2 -Y1+1;
makeimg.c:  iw = img->image_width;
makeimg.c:  ih = img->image_height;
makeimg.c:  rd-=xa;
makeimg.c:  icpos = pt->icpos;
makeimg.c:  icxv = pt->icxv;
makeimg.c:  icyv = pt->icyv;
makeimg.c:  m_f =  pt->m_f;
makeimg.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
makeimg.c:  v_yt1=(int)(v_y1-txt_ht);
makeimg.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
makeimg.c:  v_yt1=(int)(v_y1-txt_ht);
makeimg.c:   V_x=v_x2-v_x1;
makeimg.c:   V_y=v_y2-v_y1;
makeimg.c:   u_x=(V_x/(w_x2-w_x1));
makeimg.c:   u_y=(V_y/(w_y2-w_y1));
makeimg.c:   lcur_y=EVGAY-v_y1;
makeimg.c:   rcur_y=EVGAY-v_y2;
makeimg.c:  u_x=(V_x/(x2-x1));
makeimg.c:  u_y=(V_y/(y2-y1));
makeimg.c:  r_d=(((x2-x1)*(x2-x1)+
makeimg.c:       (y2-y1)*(y2-y1)));
makeimg.c:   sprintf(command,"lpstat -o %s>JoB_Fil 2>JoB_Fil",buf);
makeimg.c:  CPCONS = 65000./(float)(clip_max-clip_min);
makeimg.c:  CPCONS = 65000./(float)(clip_max-clip_min);
makeimg.c:  CPCONS = 65000./(float)(clip_max-clip_min);
makeimg.c:   CPCONS = 65000./(float)(clip_max-clip_min);
makeimg.c:     box3d.d = (x2 -x1)*(x2- x1) +
makeimg.c:               (y2 -y1)*(y2- y1) +
makeimg.c:               (clip_max -clip_min)*(clip_max- clip_min) ;
makeimg.c: xf=x2-x1;yf=y2-y1;
makeimg.c:  else m = (float)(z2-z1)/(float)(yf);
makeimg.c:  cons = z1 - y1*m;
makeimg.c:  m = (float)(z2-z1)/(float)(xf);
makeimg.c:  cons = z1 - x1*m;
makeimg.c:	  dx=xb-xa;
makeimg.c:	  dy=yb-ya;
makeimg.c:		 g=inc1-dx1;
makeimg.c:		 inc2=g-dx1;
makeimg.c:		 else ch=-1;
makeimg.c:		 else rh=-1;
makeimg.c:/*        while (labs(c-f)>0)*/
makeimg.c:		 r = EVGAY-r;
makeimg.c:		    if (g > 0) { r-=rh; g+=inc2; }
makeimg.c:	  put_pix3(xb,(EVGAY-yb),z);
makeimg.c:		 g=inc1-dy1;
makeimg.c:		 inc2=g-dy1;
makeimg.c:		 else ch=-1;
makeimg.c:		 else rh=-1;
makeimg.c:/*        while (labs(c-f)>0)*/
makeimg.c:		 c = EVGAY-c;
makeimg.c:		 f = EVGAY-f;
makeimg.c:		   z = z_inter((EVGAY-c),m,cons);
makeimg.c:		   c-=ch;
makeimg.c:	  put_pix3(xb,(EVGAY-yb),z);
makeimg.c:              put_pix3(xa,(EVGAY-i),z);}
makeimg.c:	    put_pix3(i,(EVGAY-ya),z);
makeimg.c:   dx = (float)(xb-xa);
makeimg.c:   dy = (float)(yb-ya);
makeimg.c:   if( ct< 0.) dy1 =(int)( ct*i2-0.5);
makeimg.c:   xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
makeimg.c:	     if( ct< 0.) dy1 =(int)( ct*i-0.5);
makeimg.c:	    _draw_line3( xa-dx1,ya+dy1,za,xb-dx1,yb+dy1,zb);
makeimg.c:     put_pix3(xa,(EVGAY-y),za);
makeimg.c:  m = (float)(z2-z1)/(float)(x2-x1);
makeimg.c:  cons = z1 - x1*m;
makeimg.c:  for(i=xa;i<=xb;i++) {z=z_inter(i,m,cons);put_pix3(i,(EVGAY-y),z);}
makeimg.c:    m = (float)(y-cur_y)/(float)(z-cur_z);
makeimg.c:    cons = cur_z - cur_y*m;  
makeimg.c:    m = (float)(x-cur_x)/(float)(z-cur_z);
makeimg.c:    cons = cur_z - cur_x*m;  
makeimg.c:   dx=xb-xa;
makeimg.c:   dy=yb-ya;
makeimg.c:    g=inc1-dx1;
makeimg.c:    inc2=g-dx1;
makeimg.c:    else ch=-1;
makeimg.c:    else rh=-1;
makeimg.c:    g=inc1-dy1;
makeimg.c:    inc2=g-dy1;
makeimg.c:    else ch=-1;
makeimg.c:    else rh=-1;
makeimg.c:   while (abs(c-f)>0)
makeimg.c:     while ((i<=ln_style) && (abs(c-f)>0))
makeimg.c:	 if ( dx1 > dy1 ) {z=z_inter(c,m,cons);put_pix3(c,(EVGAY-r),z);}
makeimg.c:	 else   {z=z_inter(r,m,cons);put_pix3(r,(EVGAY-c),z);}
makeimg.c:    while ((i<=ln_style) && (abs(c-f)>0))
makeimg.c:      dx = (float)(xb-xa);
makeimg.c:      dy = (float)(yb-ya);
makeimg.c:      if( ct< 0.) dy1 =(int)( ct*i2-0.5);
makeimg.c:      xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
makeimg.c:             if( ct< 0.) dy1 =(int)( ct*i-0.5);
makeimg.c:             cur_x=xa-dx1,cur_y=ya+dy1;
makeimg.c:            _draw3_( xb-dx1,yb+dy1,zb);
makeimg.c:  xup =-100000;
makeimg.c:  ygrt=-1239000;
makeimg.c:	j=i-1;
makeimg.c:	  j--;
makeimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
makeimg.c:                   zcord[cnt]=(((float)(zmax[i]-zmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +zmin[i]));
makeimg.c:		j=i-1;
makeimg.c:		while(j>=0 && txx < xcord[j]){ zcord[j+1]=zcord[j];xcord[j+1]=xcord[j];j--;}
makeimg.c:  xup =-100000;
makeimg.c:  ygrt=-1239000;
makeimg.c:	j=i-1;
makeimg.c:	  j--;
makeimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
makeimg.c:                   zcord[cnt]=(((float)(zmax[i]-zmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +zmin[i])+0.5);
makeimg.c:                   pcord[cnt]=(((float)(pmax[i]-pmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +pmin[i]));
makeimg.c:		j=i-1;
makeimg.c:                     pcord[j+1]=pcord[j];j--;}
makeimg.c:  yy = EVGAY-y;
makeimg.c:  if(xb != xa) pfac = (pb-pa)/(xb-xa);
makeimg.c:      {pval = pa+(c_v_x1-xa)*pfac;
makeimg.c:      {pval = pa+(c_v_x2-xa)*pfac;
makeimg.c:  m = (float)(z2-z1)/(float)(x2-x1);
makeimg.c:  cons = z1 - x1*m;
makeimg.c:    temp=(int)(pa+(i-xa)*pfac+0.5);
makeimg.c:    float zmax=-1.e+20,zmin = 1.e+20;
makeimg.c:    m = (float)(z2-z1)/(float)(y2-y1);
makeimg.c:    cons = z1 - y1*m;
makeimg.c:    m = (float)(z2-z1)/(float)(x2-x1);
makeimg.c:    cons = z1 - x1*m;
makeimg.c:           {z=z_inter(x_min,m,cons);put_pix3(x_min,EVGAY-j,z);}
makeimg.c:   float zmax=-1.e+20,zmin = 1.e+20;
makeimg.c:  xup =-100000;
makeimg.c:  ygrt=-1239000;
makeimg.c:j=i-1;
makeimg.c:  j--;
makeimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
makeimg.c:                   pcord[cnt]=(((float)(pmax[i]-pmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +pmin[i]));
makeimg.c:j=i-1;
makeimg.c:                     pcord[j+1]=pcord[j];j--;}
makeimg.c:  yy = EVGAY-y;
makeimg.c:  if(xb != xa) pfac = (pb-pa)/(xb-xa);
makeimg.c:      {pval = pa+(c_v_x1-xa)*pfac;
makeimg.c:      {pval = pa+(c_v_x2-xa)*pfac;
makeimg.c:    tempc=(int)(pa+(i-xa)*pfac+0.5);
makeimg.c:  yy = EVGAY-y;
makeimg.c:  if ((xb-xa)<10)
makeimg.c:          tempc=(int)(pa+(i-xa)*pfac+0.5);
makeimg.c:   float zmax=-1.e+20,zmin = 1.e+20;
makeimg.c:   if(cosval < 0. ) cosval = -cosval;
makeimg.c:/* --------------   Cross Product of two vectors   ------------- */
makeimg.c:   n.x = -(p2.y - p.y)*(p1.z - p.z) + (p2.z - p.z)*(p1.y - p.y);
makeimg.c:   n.y = ((p2.x - p.x)*(p1.z - p.z) - (p1.x - p.x)*(p2.z - p.z));
makeimg.c:   n.z = -(p2.x - p.x)*(p1.y - p.y) + (p1.x - p.x)*(p2.y - p.y);
makeimg.c:        j0 = (no+j-1)%no;
makeimg.c:        if( (n.x==0)&&(n.y==0)&&(n.z==0) ) count--;
makeimg.c:           //v.x = lpt->x - x[j] - xc;
makeimg.c:           //v.y = lpt->y - y[j] - yc;
makeimg.c:           //v.z = lpt->z - z[j] - zc;
makeimg.c:           v.x = lpt->x - x[j] ;
makeimg.c:           v.y = lpt->y - y[j] ;
makeimg.c:           v.z = lpt->z - z[j] ;
makeimg.c:   if( (lt2->zmax < lt1->zmax )) return 1;
makeimg.c:       switch(lt->code) {
makeimg.c:            c_color  = lt->clr;
makeimg.c:            ln_style = lt->style;
makeimg.c:            ln_width = lt->width;
makeimg.c:            t_move(lt->x1,lt->y1);
makeimg.c:            t_draw(lt->x2,lt->y2);
makeimg.c:            c_color  = pt->bclr;
makeimg.c:            t_panel(pt->x,pt->y,pt->fclr,pt->flag,pt->n);
makeimg.c:            free(pt->x),free(pt->y),free(pt->z);
makeimg.c:            c_color  = st->bclr;
makeimg.c:            t_godr_fill(st->n,st->x,st->y,st->v);
makeimg.c:            free(st->x),free(st->y),free(st->z),free(st->v);
makeimg.c: double Zmax=-1e+20,Zmin=1e+20,dz,zu,zl;
makeimg.c:      if(lt->zmax > Zmax ) Zmax = lt->zmax;
makeimg.c:      if(lt->zmin < Zmin ) Zmin = lt->zmin;
makeimg.c:      dz = (Zmax-Zmin)/n;
makeimg.c:          if((lt->zmax < zu) &&( lt->zmax >= zl) ) Dadd(tmp1,lt);
makeimg.c:        if( (entry > 5) &&((tmp1->st==NULL)||(tmp2->st==NULL)) ){
makeimg.c:          entry--;
makeimg.c:      entry--;
makeimg.c:                 _draw_line(x-3*fac,y-3*fac,x+3*fac,y+3*fac);
makeimg.c:                 _draw_line(x-3*fac,y+3*fac,x+3*fac,y-3*fac);
makeimg.c:                 _box_fill(x-3*fac,y-3*fac,x+3*fac,y+3*fac,(unsigned int)15);
makeimg.c:	case 3 : _draw_line(x,y-4*fac,x,y+4*fac);
makeimg.c:				_draw_line(x-4*fac,y,x+4*fac,y);
makeimg.c:				_draw_line(x-2*fac,y-4*fac,x+2*fac,y-4*fac);
makeimg.c:				_draw_line(x-2*fac,y+4*fac,x+2*fac,y+4*fac);
makeimg.c:				_draw_line(x-4*fac,y-2*fac,x-4*fac,y+2*fac);
makeimg.c:				_draw_line(x+4*fac,y-2*fac,x+4*fac,y+2*fac);
makeimg.c:	case 4 : _draw_line(x-4*fac,y-4*fac,x+4*fac,y+4*fac);
makeimg.c:				_draw_line(x-4*fac,y+4*fac,x+4*fac,y-4*fac);
makeimg.c:				_draw_line(x-4*fac,y,x+4*fac,y);
makeimg.c:				_draw_line(x,y-4*fac,x,y+4*fac);
makeimg.c:	case 5 : _draw_line(x+3*fac,y,x,y-8*fac);
makeimg.c:				_draw_line(x-3*fac,y,x,y-8*fac);
makeimg.c:				_draw_line(x-3*fac,y,x,y+8*fac);
makeimg.c:	case 6 : _draw_line(x-4*fac,y,x+4*fac,y);
makeimg.c:				_draw_line(x,y-4*fac,x,y+4*fac);
makeimg.c:				_draw_line(x+2*fac,y-2*fac,x+2*fac,y+2*fac);
makeimg.c:				_draw_line(x+2*fac,y+2*fac,x-2*fac,y+2*fac);
makeimg.c:				_draw_line(x-2*fac,y+2*fac,x-2*fac,y-2*fac);
makeimg.c:				_draw_line(x-2*fac,y-2*fac,x+2*fac,y-2*fac);
makeimg.c:				_draw_line(x+7*fac,y,x+3*fac,y-3*fac);
makeimg.c:				_draw_line(x+3*fac,y-3*fac,x,y-7*fac);
makeimg.c:				_draw_line(x,y-7*fac,x-3*fac,y-3*fac);
makeimg.c:				_draw_line(x-3*fac,y-3*fac,x-7*fac,y);
makeimg.c:				_draw_line(x-7*fac,y,x-3*fac,y+3*fac);
makeimg.c:				_draw_line(x-3*fac,y+3*fac,x,y+7*fac);
makeimg.c:	case 8 : _draw_line(x-4*fac,y-4*fac,x+4*fac,y+4*fac);
makeimg.c:				_draw_line(x+4*fac,y-4*fac,x-4*fac,y+4*fac);
makeimg.c:				_draw_line(x+4*fac,y-4*fac,x+4*fac,y-2*fac);
makeimg.c:				_draw_line(x+4*fac,y-4*fac,x+2*fac,y-4*fac);
makeimg.c:				_draw_line(x-4*fac,y-4*fac,x-2*fac,y-4*fac);
makeimg.c:				_draw_line(x-4*fac,y-4*fac,x-4*fac,y-2*fac);
makeimg.c:				_draw_line(x-4*fac,y+4*fac,x-4*fac,y+2*fac);
makeimg.c:				_draw_line(x-4*fac,y+4*fac,x-2*fac,y+4*fac);
makeimg.c:                 px[0]=x+4*fac;py[0]=y;px[1]=x-4*fac;py[1]=y+4*fac;
makeimg.c:                 px[2]=x-4*fac;py[2]=y-4*fac;
makeimg.c:                 px[0]=x-4*fac;py[0]=y;px[1]=x+4*fac;py[1]=y+4*fac;
makeimg.c:                 px[2]=x+4*fac;py[2]=y-4*fac;
makeimg.c:                 px[0]=x;py[0]=y+4*fac;px[1]=x-4*fac;py[1]=y-4*fac;
makeimg.c:                 px[2]=x+4*fac;py[2]=y-4*fac;
makeimg.c:                 px[0]=x;py[0]=y-4*fac;px[1]=x-4*fac;py[1]=y+4*fac;
makeimg.c:                 _draw_line(x-2*fac,y-2*fac,x+2*fac,y+2*fac);
makeimg.c:                 _draw_line(x-2*fac,y+2*fac,x+2*fac,y-2*fac);
makeimg.c:                 px[0]=x+2*fac;py[0]=y;px[1]=x-2*fac;py[1]=y+2*fac;
makeimg.c:                 px[2]=x-2*fac;py[2]=y-2*fac;
makeimg.c:                 px[0]=x-2*fac;py[0]=y;px[1]=x+2*fac;py[1]=y+2*fac;
makeimg.c:                 px[2]=x+2*fac;py[2]=y-2*fac;
makeimg.c:                 px[0]=x;py[0]=y+2*fac;px[1]=x-2*fac;py[1]=y-2*fac;
makeimg.c:                 px[2]=x+2*fac;py[2]=y-2*fac;
makeimg.c:                 px[0]=x;py[0]=y-2*fac;px[1]=x-2*fac;py[1]=y+2*fac;
makeimg.c:  theta=-t*rad;
makeimg.c:  xfact = (w_x2-w_x1)/x_mulf;
makeimg.c:  yfact = (w_y2-w_y1)/y_mulf;
makeimg.c:  txt_ht=txt_ht*V_y/((w_y2-w_y1));
makeimg.c:  txt_wt=txt_wt*V_x/((w_x2-w_x1));
makeimg.c:  txt_sp=txt_sp*V_x/((w_x2-w_x1));
makeimg.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
makeimg.c:  v_yt1=(int)(v_y1-txt_ht);
makeimg.c:         tx = ((*xb)-(*xa));
makeimg.c:         ty = ((*yb)-(*ya));
makeimg.c:		y=(int)(*ya+(c_v_x1-(*xa))*ty/tx);
makeimg.c:		y=(int)(*ya+(c_v_x2-(*xa))*ty/tx);
makeimg.c:		x=(int)(*xa+(c_v_y2-(*ya))*tx/ty);
makeimg.c:		x=(int)(*xa+(c_v_y1-(*ya))*tx/ty);
makeimg.c:      ixdf = ixe - ixb;
makeimg.c:      iydf = iye - iyb;
makeimg.c:      id = ixu-ixl;
makeimg.c:      if (id < iyu-iyl ) id = iyu-iyl;
makeimg.c:           put_pixl(ix,EVGAY-iy);
makeimg.c:	  dx=xb-xa;
makeimg.c:	  dy=yb-ya;
makeimg.c:		 g=inc1-dx1;
makeimg.c:		 inc2=g-dx1;
makeimg.c:		 else ch=-1;
makeimg.c:		 else rh=-1;
makeimg.c:/*        while (labs(c-f)>0)*/
makeimg.c:                 r = EVGAY-r;
makeimg.c:	            if (g > 0) { r-=rh; g+=inc2; }
makeimg.c:		 g=inc1-dy1;
makeimg.c:		 inc2=g-dy1;
makeimg.c:		 else ch=-1;
makeimg.c:		 else rh=-1;
makeimg.c:/*        while (labs(c-f)>0)*/
makeimg.c:                 c = EVGAY-c;
makeimg.c:                 f = EVGAY-f;
makeimg.c:                   c-=ch;
makeimg.c:          put_pixl(xb,(EVGAY-yb));
makeimg.c:  	  for (i=miny;i<=maxy;++i) put_pixl(xa,(EVGAY-i));
makeimg.c:          for (i=minx;i<=maxx;++i) put_pixl(i,(EVGAY-ya));
makeimg.c:   dx = (float)(xb-xa);
makeimg.c:   dy = (float)(yb-ya);
makeimg.c:   if( ct< 0.) dy1 =(int)( ct*i2-0.5);
makeimg.c:   xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
makeimg.c:             if( ct< 0.) dy1 =(int)( ct*i-0.5);
makeimg.c:            _draw_line( xa-dx1,ya+dy1,xb-dx1,yb+dy1);
makeimg.c:  for(i=xa;i<=xb;i++) put_pixl(i,(EVGAY-y));
makeimg.c:  j=EVGAY-y;
makeimg.c:  for(i=ya;i<=yb;i++) put_pixl(x,(EVGAY-i));
makeimg.c:   dx=xb-xa;
makeimg.c:   dy=yb-ya;
makeimg.c:    g=inc1-dx1;
makeimg.c:    inc2=g-dx1;
makeimg.c:    else ch=-1;
makeimg.c:    else rh=-1;
makeimg.c:    g=inc1-dy1;
makeimg.c:    inc2=g-dy1;
makeimg.c:    else ch=-1;
makeimg.c:    else rh=-1;
makeimg.c:   while (abs(c-f)>0)
makeimg.c:        if ( dx1 > dy1 ) put_pixl(c,(EVGAY-r));
makeimg.c:        else   put_pixl(r,(EVGAY-c));
makeimg.c:      dx = (float)(xb-xa);
makeimg.c:      dy = (float)(yb-ya);
makeimg.c:      if( ct< 0.) dy1 =(int)( ct*i2-0.5);
makeimg.c:      xa +=dx1,xb +=dx1,ya -=dy1,yb -=dy1;
makeimg.c:             if( ct< 0.) dy1 =(int)( ct*i-0.5);
makeimg.c:             cur_x=xa-dx1,cur_y=ya+dy1;
makeimg.c:            _draw_( xb-dx1,yb+dy1);
makeimg.c:  txt_htx=ht/(w_y2-w_y1)*(w_x2-w_x1);
makeimg.c:  txt_wty=wt/(w_x2-w_x1)*(w_y2-w_y1);
makeimg.c:  txt_spy=sp/(w_x2-w_x1)*(w_y2-w_y1);
makeimg.c:  txt_wt= sint*sint*txt_wty*(w_x2-w_x1)/(w_y2-w_y1)+cost*cost*txt_wtx;
makeimg.c:  txt_sp= sint*sint*txt_spy*(w_x2-w_x1)/(w_y2-w_y1)+cost*cost*txt_spx;
makeimg.c:  txt_ht= sint*sint*txt_htx/(w_x2-w_x1)*(w_y2-w_y1)+cost*cost*txt_hty;
makeimg.c:  txt_ht=txt_ht*V_y/((w_y2-w_y1));
makeimg.c:  txt_wt=txt_wt*V_x/((w_x2-w_x1));
makeimg.c:  txt_sp=txt_sp*V_x/((w_x2-w_x1));
makeimg.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
makeimg.c:  v_yt1=(int)(v_y1-txt_ht);
makeimg.c:  xfact = (w_x2-w_x1)/x_mulf;
makeimg.c:  yfact = (w_y2-w_y1)/y_mulf;
makeimg.c:  txt_ht=txt_ht*V_y/(w_y2-w_y1);
makeimg.c:  txt_wt=txt_wt*V_x/(w_x2-w_x1);
makeimg.c:  txt_sp=txt_sp*V_x/(w_x2-w_x1);
makeimg.c:  v_xt1=(int)(v_x1-txt_wt-txt_sp);
makeimg.c:  v_yt1=(int)(v_y1-txt_ht);
makeimg.c:  pt->icpos = icposf0;
makeimg.c:  pt->m_f = m_f0;
makeimg.c:  pt->icxv = icxvf0;
makeimg.c:  pt->icyv = icyvf0;
makeimg.c:  pt->fontname = fontname0;
makeimg.c:  pt->icpos = icposf1; pt->m_f = m_f1; pt->icxv = icxvf1;
makeimg.c:  pt->icyv = icyvf1; pt->fontname = fontname1;
makeimg.c:  pt->icpos = icposf2; pt->m_f = m_f2; pt->icxv = icxvf2;
makeimg.c:  pt->icyv = icyvf2; pt->fontname = fontname2;
makeimg.c:  pt->icpos = icposf3; pt->m_f = m_f3; pt->icxv = icxvf3;
makeimg.c:  pt->icyv = icyvf3; pt->fontname = fontname3;
makeimg.c:  pt->icpos = icposf4; pt->m_f = m_f4; pt->icxv = icxvf4;
makeimg.c:  pt->icyv = icyvf4; pt->fontname = fontname4;
makeimg.c:  pt->icpos = icposf5; pt->m_f = m_f5; pt->icxv = icxvf5;
makeimg.c:  pt->icyv = icyvf5; pt->fontname = fontname5;
makeimg.c:  pt->icpos = icposf6; pt->m_f = m_f6; pt->icxv = icxvf6;
makeimg.c:  pt->icyv = icyvf6; pt->fontname = fontname6;
makeimg.c:  pt->icpos = icposf7; pt->m_f = m_f7; pt->icxv = icxvf7;
makeimg.c:  pt->icyv = icyvf7; pt->fontname = fontname7;
makeimg.c:  pt->icpos = icposf8; pt->m_f = m_f8; pt->icxv = icxvf8;
makeimg.c:  pt->icyv = icyvf8; pt->fontname = fontname8;
makeimg.c:  pt->icpos = icposf9; pt->m_f = m_f9; pt->icxv = icxvf9;
makeimg.c:  pt->icyv = icyvf9; pt->fontname = fontname9;
makeimg.c:  pt->icpos = icposf10; pt->m_f = m_f10; pt->icxv = icxvf10;
makeimg.c:  pt->icyv = icyvf10; pt->fontname = fontname10;
makeimg.c:  pt->icpos = icposf11; pt->m_f = m_f11; pt->icxv = icxvf11;
makeimg.c:  pt->icyv = icyvf11; pt->fontname = fontname11;
makeimg.c:  pt->icpos = icposf12; pt->m_f = m_f12; pt->icxv = icxvf12;
makeimg.c:  pt->icyv = icyvf12; pt->fontname = fontname12;
makeimg.c:  pt->icpos = icposf13; pt->m_f = m_f13; pt->icxv = icxvf13;
makeimg.c:  pt->icyv = icyvf13; pt->fontname = fontname13;
makeimg.c:  pt->icpos = icposf14; pt->m_f = m_f14; pt->icxv = icxvf14;
makeimg.c:  pt->icyv = icyvf14; pt->fontname = fontname14;
makeimg.c:  pt->icpos = icposf15; pt->m_f = m_f15; pt->icxv = icxvf15;
makeimg.c:  pt->icyv = icyvf15; pt->fontname = fontname15;
makeimg.c:  pt->icpos = icposf16; pt->m_f = m_f16; pt->icxv = icxvf16;
makeimg.c:  pt->icyv = icyvf16; pt->fontname = fontname16;
makeimg.c:  pt->icpos = icposf17; pt->m_f = m_f17; pt->icxv = icxvf17;
makeimg.c:  pt->icyv = icyvf17; pt->fontname = fontname17;
makeimg.c:  pt->icpos = icposf18; pt->m_f = m_f18; pt->icxv = icxvf18;
makeimg.c:  pt->icyv = icyvf18; pt->fontname = fontname18;
makeimg.c:  pt->icpos = icposf19; pt->m_f = m_f19; pt->icxv = icxvf19;
makeimg.c:  pt->icyv = icyvf19; pt->fontname = fontname19;
makeimg.c:  pt->icpos = icposf20; pt->m_f = m_f20; pt->icxv = icxvf20;
makeimg.c:  pt->icyv = icyvf20; pt->fontname = fontname20;
makeimg.c:  pt->icpos = icposf21; pt->m_f = m_f21; pt->icxv = icxvf21;
makeimg.c:  pt->icyv = icyvf21; pt->fontname = fontname21;
makeimg.c:  pt->icpos = icposf22; pt->m_f = m_f22; pt->icxv = icxvf22;
makeimg.c:  pt->icyv = icyvf22; pt->fontname = fontname22;
makeimg.c:  pt->icpos = icposf23; pt->m_f = m_f23; pt->icxv = icxvf23;
makeimg.c:  pt->icyv = icyvf23; pt->fontname = fontname23;
makeimg.c:  pt->icpos = icposf24; pt->m_f = m_f24; pt->icxv = icxvf24;
makeimg.c:  pt->icyv = icyvf24; pt->fontname = fontname24;
makeimg.c:  pt->icpos = icposf25; pt->m_f = m_f25; pt->icxv = icxvf25;
makeimg.c:  pt->icyv = icyvf25; pt->fontname = fontname25;
makeimg.c:  pt->icpos = icposf26; pt->m_f = m_f26; pt->icxv = icxvf26;
makeimg.c:  pt->icyv = icyvf26; pt->fontname = fontname26;
makeimg.c:  pt->icpos = icposf27; pt->m_f = m_f27; pt->icxv = icxvf27;
makeimg.c:  pt->icyv = icyvf27; pt->fontname = fontname27;
makeimg.c:  pt->icpos = icposf28; pt->m_f = m_f28; pt->icxv = icxvf28;
makeimg.c:  pt->icyv = icyvf28; pt->fontname = fontname28;
makeimg.c:  pt->icpos = icposf29; pt->m_f = m_f29; pt->icxv = icxvf29;
makeimg.c:  pt->icyv = icyvf29; pt->fontname = fontname29;
makeimg.c:  pt->icpos = icposf30; pt->m_f = m_f30; pt->icxv = icxvf30;
makeimg.c:  pt->icyv = icyvf30; pt->fontname = fontname30;
makeimg.c:  pt->icpos = icposf31; pt->m_f = m_f31; pt->icxv = icxvf31;
makeimg.c:  pt->icyv = icyvf31; pt->fontname = fontname31;
makeimg.c:  pt->icpos = icposf32; pt->m_f = m_f32; pt->icxv = icxvf32;
makeimg.c:  pt->icyv = icyvf32; pt->fontname = fontname32;
makeimg.c:  pt->icpos = icposf33; pt->m_f = m_f33; pt->icxv = icxvf33;
makeimg.c:  pt->icyv = icyvf33; pt->fontname = fontname33;
makeimg.c:  pt->icpos = icposf34; pt->m_f = m_f34; pt->icxv = icxvf34;
makeimg.c:  pt->icyv = icyvf34; pt->fontname = fontname34;
makeimg.c:  pt->icpos = icposf35; pt->m_f = m_f35; pt->icxv = icxvf35;
makeimg.c:  pt->icyv = icyvf35; pt->fontname = fontname35;
makeimg.c:  pt->icpos = icposf36; pt->m_f = m_f36; pt->icxv = icxvf36;
makeimg.c:  pt->icyv = icyvf36; pt->fontname = fontname36;
makeimg.c:  pt->icpos = icposf37; pt->m_f = m_f37; pt->icxv = icxvf37;
makeimg.c:  pt->icyv = icyvf37; pt->fontname = fontname37;
makeimg.c:  pt->icpos = icposf38; pt->m_f = m_f38; pt->icxv = icxvf38;
makeimg.c:  pt->icyv = icyvf38; pt->fontname = fontname38;
makeimg.c:  pt->icpos = icposf39; pt->m_f = m_f39; pt->icxv = icxvf39;
makeimg.c:  pt->icyv = icyvf39; pt->fontname = fontname39;
makeimg.c:  pt->icpos = icposf40; pt->m_f = m_f40; pt->icxv = icxvf40;
makeimg.c:  pt->icyv = icyvf40; pt->fontname = fontname40;
makeimg.c:  pt->icpos = icposf41; pt->m_f = m_f41; pt->icxv = icxvf41;
makeimg.c:  pt->icyv = icyvf41; pt->fontname = fontname41;
makeimg.c:  pt->icpos = icposf42; pt->m_f = m_f42; pt->icxv = icxvf42;
makeimg.c:  pt->icyv = icyvf42; pt->fontname = fontname42;
makeimg.c:  pt->icpos = icposf43; pt->m_f = m_f43; pt->icxv = icxvf43;
makeimg.c:  pt->icyv = icyvf43; pt->fontname = fontname43;
makeimg.c:  pt->icpos = icposf44; pt->m_f = m_f44; pt->icxv = icxvf44;
makeimg.c:  pt->icyv = icyvf44; pt->fontname = fontname44;
makeimg.c:  pt->icpos = icposf45; pt->m_f = m_f45; pt->icxv = icxvf45;
makeimg.c:  pt->icyv = icyvf45; pt->fontname = fontname45;
makeimg.c:  pt->icpos = icposf46; pt->m_f = m_f46; pt->icxv = icxvf46;
makeimg.c:  pt->icyv = icyvf46; pt->fontname = fontname46;
makeimg.c:  pt->icpos = icposf47; pt->m_f = m_f47; pt->icxv = icxvf47;
makeimg.c:  pt->icyv = icyvf47; pt->fontname = fontname47;
makeimg.c:  pt->icpos = icposf48; pt->m_f = m_f48; pt->icxv = icxvf48;
makeimg.c:  pt->icyv = icyvf48; pt->fontname = fontname48;
makeimg.c:  pt->icpos = icposf49; pt->m_f = m_f49; pt->icxv = icxvf49;
makeimg.c:  pt->icyv = icyvf49; pt->fontname = fontname49;
makeimg.c:  pt->icpos = icposf50; pt->m_f = m_f50; pt->icxv = icxvf50;
makeimg.c:  pt->icyv = icyvf50; pt->fontname = fontname50;
makeimg.c:  pt->icpos = icposf51; pt->m_f = m_f51; pt->icxv = icxvf51;
makeimg.c:  pt->icyv = icyvf51; pt->fontname = fontname51;
makeimg.c:  pt->icpos = icposf52; pt->m_f = m_f52; pt->icxv = icxvf52;
makeimg.c:  pt->icyv = icyvf52; pt->fontname = fontname52;
makeimg.c:  icpos = pt->icpos;
makeimg.c:  icxv = pt->icxv;
makeimg.c:  icyv = pt->icyv;
makeimg.c:  m_f =  pt->m_f;
makeimg.c:  strcpy(FontName,pt->fontname);
makeimg.c:  icpos = pt->icpos;
makeimg.c:  icxv = pt->icxv;
makeimg.c:  icyv = pt->icyv;
makeimg.c:  m_f =  pt->m_f;
makeimg.c:  strcpy(FontName,pt->fontname);
makeimg.c:  icpos = pt->icpos;
makeimg.c:  icxv = pt->icxv;
makeimg.c:  icyv = pt->icyv;
makeimg.c:  m_f =  pt->m_f;
makeimg.c:  strcpy(FontName,pt->fontname);
makeimg.c:  pnt=asc-32+greek;
makeimg.c:  /*else if(greek> 0) xo -=(1.-fact)*0.5*txt_wt;*/
makeimg.c:  pnt=asc-32+greek;
makeimg.c:  /*else if(greek> 0) xo -=(1.-fact)*0.5*txt_wt;*/
makeimg.c:  ya=(cy-(xo)*sint+yo*cost);
makeimg.c:     y[i]=(cy+(ydum)*cost-(xdum)*sint);
makeimg.c:/* this for special use expecting roots between (0-1) */
makeimg.c:      disc = b*b - 4*a*c;
makeimg.c:          *r1=*r2= -b/(2.*a);
makeimg.c:          if(*r1*(1-*r1)<= 0 ) *r1=*r2=0;
makeimg.c:          *r1 = (-b+disc)/(2.*a);
makeimg.c:          if(*r1*(1-*r1)<= 0 ) *r1=0;
makeimg.c:          *r2 = (-b-disc)/(2.*a);
makeimg.c:          if(*r2*(1-*r2)<= 0 ) *r2=0;
makeimg.c:  if( fabs(y1-y2)*Mag > n) n = fabs(y1 - y2)*Mag;
makeimg.c:  if( fabs(y1-y3)*Mag > n) n = fabs(y1 - y3)*Mag;
makeimg.c:  if( fabs(y1-y4)*Mag > n) n = fabs(y1 - y4)*Mag;
makeimg.c:  if( fabs(y2-y3)*Mag > n) n = fabs(y2 - y3)*Mag;
makeimg.c:  if( fabs(y2-y4)*Mag > n) n = fabs(y2 - y4)*Mag;
makeimg.c:  if( fabs(y3-y4)*Mag > n) n = fabs(y3 - y4)*Mag;
makeimg.c:     cx = 3*(x2-x1);
makeimg.c:     cy = 3*(y2-y1);
makeimg.c:     bx = 3*(x3-x2)-cx;
makeimg.c:     by = 3*(y3-y2)-cy;
makeimg.c:     ax = x4-x1-cx-bx;
makeimg.c:     ay = y4-y1-cy-by;
makeimg.c:       dist = (x-x1)*(x-x1)+(y-y1)*(y-y1);
makeimg.c:    j1=j-1;
makeimg.c:      { if( (x1[i]==x1[i-1]) &&(y1[i]==y1[i-1]))
makeimg.c:          { j--; for(k=i;k<j;k++) {x1[k]=x1[k+1];y1[k]=y1[k+1];}}
makeimg.c:   for(i=1;i<j;i++){x2[i-1]=x1[i];y2[i-1]=y1[i];}
makeimg.c:   x2[j-1]=x1[0];y2[j-1]=y1[0];
makeimg.c:    j1=j-1;
makeimg.c:       else yp= yp-0.7*txt_ht;
makeimg.c:          if((pt->x2) < 0.){
makeimg.c:           if((pt->ymax)< (yp+1.4*txt_ht)) pt->ymax=yp+1.4*txt_ht;
makeimg.c:           if((pt->ymin)> (yp-0.4*txt_ht)) pt->ymin=yp-0.4*txt_ht;
makeimg.c:          pt=pt->Pr;
makeimg.c:      is = *ishft-((*ishft)/10)*10;
makeimg.c:                      *ishft = (*ishft)-1;
makeimg.c:                      yp = yp-1.4*txt_ht;
makeimg.c:                            xp =xp -txt_wt -txt_sp;
makeimg.c:                             while( (pt->x2) >=0.) pt=pt->Pr;
makeimg.c:                             (pt->x2)=xp-txt_sp;
makeimg.c:                             pt=pt->Pr;
makeimg.c:                              xp=O_P->x;
makeimg.c:                              yp=O_P->y;
makeimg.c:                              O_P=O_P->Pr;
makeimg.c:                              O_P->Nx=NULL;O_P->Pr=NULL;
makeimg.c:                              O_P->Nx=(B_K *) malloc((int)sizeof(B_K));
makeimg.c:                              O_P->Nx->Pr=O_P;
makeimg.c:                              O_P=O_P->Nx;
makeimg.c:                              O_P->Nx=NULL;
makeimg.c:                            (O_P->x) = xp;
makeimg.c:                            (O_P->y) = yp;
makeimg.c:                            yp -=0.2*txt_ht;
makeimg.c:                            yp -=0.9*txt_ht;
makeimg.c:                              O_L->Nx=NULL;O_L->Pr=NULL;
makeimg.c:                              O_L->Nx=(L_N *) malloc((int)sizeof(L_N));
makeimg.c:                              O_L->Nx->Pr=O_L;
makeimg.c:                              O_L=O_L->Nx;
makeimg.c:                              O_L->Nx=NULL;
makeimg.c:                            (O_L->x1) = xp;
makeimg.c:                            (O_L->x2) = -1.0;
makeimg.c:                            O_L->ymax = yp+1.4*txt_ht;
makeimg.c:                            O_L->ymin = yp-0.4*txt_ht;
makeimg.c:                            O_L->p=cntl;
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            Nu= Nu*10+(txt[i+2] -'0');
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            Nu= Nu*10+(txt[i+2] -'0');
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            De= (txt[i+2] -'0');
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            De= (txt[i+2] -'0');
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            De= (txt[i+2] -'0');
makeimg.c:       if(pt->x2 <0.) pt->x2=xp;
makeimg.c:       if(pt->p =='U') {
makeimg.c:        _move(TX((pt->x1),pt->ymin),TY((pt->x1),pt->ymin));
makeimg.c:        _draw(TX((pt->x2),pt->ymin),TY((pt->x2),pt->ymin));
makeimg.c:        _move(TX((pt->x1),pt->ymax),TY((pt->x1),pt->ymax));
makeimg.c:        _draw(TX((pt->x2),pt->ymax),TY((pt->x2),pt->ymax));
makeimg.c:       pt=pt->Nx;
makeimg.c:       O_P=O_P->Pr;
makeimg.c:                            xp =xp -txt_wt -txt_sp;
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            De= (txt[i+2] -'0');
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            De= (txt[i+2] -'0');
makeimg.c:                            Nu= (txt[i+1] -'0');
makeimg.c:                            De= (txt[i+2] -'0');
makeimg.c:  xup =-100000;
makeimg.c:  ygrt=-1239000;
makeimg.c:	j=i-1;
makeimg.c:	  j--;
makeimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
makeimg.c:		j=i-1;
makeimg.c:		while(j>=0 && txx < xcord[j]){ xcord[j+1]=xcord[j];j--;}
makeimg.c:  xup =-100000;
makeimg.c:  ygrt=-1239000;
makeimg.c:	j=i-1;
makeimg.c:	  j--;
makeimg.c:                   xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
makeimg.c:                              *(scan-ymin[i]) +xmin[i])+0.5);
makeimg.c:		j=i-1;
makeimg.c:		while((j>=0) && (txx < xcord[j])){ xcord[j+1]=xcord[j];j--;}
makeimg.c:  xup =-1000000;
makeimg.c:  ygrt=-1239000;
makeimg.c:    j=i-1;
makeimg.c:      j--;
makeimg.c:       xcord[cnt]=(((float)(xmax[i]-xmin[i])/(ymax[i]-ymin[i])
makeimg.c:                  *(scan-ymin[i]) +xmin[i]+0.5));
makeimg.c:   j=i-1;
makeimg.c:   while(j>=0 && txx < xcord[j]){ xcord[j+1]=xcord[j];j--;}
makeimg.c:  ym=y-(short)(r/sqrt((double)2.));
makeimg.c:  for (j=y;j>=ym;--j)
makeimg.c:	i=x+(short)sqrt((double)sqrd-((y-j)*(y-j)));
makeimg.c:	put_pixel(i,2*y-j);
makeimg.c:	put_pixel(x+y-j,y+i-x);
makeimg.c:	put_pixel(x-y+j,y+i-x);
makeimg.c:	put_pixel(2*x-i,2*y-j);
makeimg.c:	put_pixel(2*x-i,j);
makeimg.c:	put_pixel(x-y+j,y-i+x);
makeimg.c:	put_pixel(x+y-j,y-i+x);
makeimg.c:  ym=y-(short)(r/sqrt((double)2.));
makeimg.c:  put_pixel(x,y+r),put_pixel(x,y-r);
makeimg.c:  put_pixel(x+r,y),put_pixel(x-r,y);
makeimg.c:  phori_line(x-r+1,x+r-1,y);
makeimg.c:	t=sqrd-(float)(j*j);
makeimg.c:        put_pixel(x-i,y-j);
makeimg.c:        put_pixel(x+i,y-j);
makeimg.c:        put_pixel(x-i,y+j);
makeimg.c:        phori_line(x-i+1,x+i-1,y-j);
makeimg.c:        phori_line(x-i+1,x+i-1,y+j);
makeimg.c:      fj =0.0; gj = -1; fact = 1.0;
makeimg.c:            if( pr_txt>0) fact1=m_f[title[i]-32+greek]*fact;
makeimg.c:                         fj = fj-fact1;fjl-=1.; gj=gj-1;
makeimg.c:                          fj=O_P->x;
makeimg.c:                          fjl=O_P->xl;
makeimg.c:                          gj=O_P->y;
makeimg.c:                          O_P=O_P->Pr;
makeimg.c:                          O_P->Nx=NULL;O_P->Pr=NULL;
makeimg.c:                          O_P->Nx=(B_K *) malloc((int)sizeof(B_K));
makeimg.c:                          O_P->Nx->Pr=O_P;
makeimg.c:                          O_P=O_P->Nx;
makeimg.c:                          O_P->Nx=NULL;
makeimg.c:                        (O_P->x) = fj;
makeimg.c:                        (O_P->xl) = fjl;
makeimg.c:                        (O_P->y) = gj;
makeimg.c:                         Nu= (title[i+1] -'0');
makeimg.c:                         Nu= Nu*10+(title[i+2] -'0');
makeimg.c:                         Nu= (title[i+1] -'0');
makeimg.c:                         De= (title[i+2] -'0');
makeimg.c:                         Nu= (title[i+1] -'0');
makeimg.c:                         De= (title[i+2] -'0');
makeimg.c:                         Nu= (title[i+1] -'0');
makeimg.c:                         De= (title[i+2] -'0');
makeimg.c:       O_P=O_P->Pr;
makeimg.c:   dfac=(n-1)/(pmax-pmin);
makeimg.c:   dfac=(n-1)/(pmax-pmin);
makeimg.c:    temp->pt= (int *)c_loc;
makeimg.c:    temp->cx1=c_v_x1;
makeimg.c:    temp->cy1=c_v_y1;
makeimg.c:    temp->cx2=c_v_x2;
makeimg.c:    temp->cy2=c_v_y2;
makeimg.c:        temp=(CLIP *)c_loc->pt;
makeimg.c:        c_v_x1=c_loc->cx1;
makeimg.c:        c_v_y1=c_loc->cy1;
makeimg.c:        c_v_x2=c_loc->cx2;
makeimg.c:        c_v_y2=c_loc->cy2;
makeimg.c:        temp=(CLIP *)c_loc->pt;
makeimg.c:  addr = (evgay-row)*MAXB + (col);
makeimg.c:    pixels =GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
makeimg.c:    SyncImagePixels((Image *)(png->image));
makeimg.c:    pixels =GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
makeimg.c:    SyncImagePixels((Image *)(png->image));
makeimg.c:    pixels =GetImagePixels((Image *)(png->image),0,0,((Image *)(png->image))->columns,((Image *)(png->image))->rows);
makeimg.c:      SyncImagePixels((Image *)(png->image));
makeimg.c:    image =(Image *)(png->image);
makeimg.c:    pixels =GetImagePixels(image,0,0,image->columns,image->rows);
makepng.c:  (void) strcpy(image_info->filename,flname);
makepng.c:  pixels =GetImagePixels(image,0,0,image->columns,image->rows);
makepng.c:    png->image = image;
makepng.c:    strcpy(png->Sign,"PNG");
makepng.c:    png->incode=0;
makepng.c:    png->image_width= image->columns;
makepng.c:    png->image_height= image->rows;
makepng.c:    png->image_rowbytes = png->image_width*4;
makepng.c:    png->image_channels=4;
makepng.c:    png->image_data = (unsigned char *)malloc(png->image_width*(png->image_height+1)*4);
makepng.c:    for(i=0;i<(image->columns*image->rows);i++) {
makepng.c:     png->image_data[j++]= pixels[i].red;
makepng.c:     png->image_data[j++]= pixels[i].green;
makepng.c:     png->image_data[j++]= pixels[i].blue;
makepng.c:     png->image_data[j++]= 255 - pixels[i].opacity;
makepng.c:  image = (Image *)(png->image);
makepng.c:  w = image->columns*fac;
makepng.c:  h = image->rows*fac;
makepng.c:          resize_image->columns,resize_image->rows);
makepng.c:    png->image = resize_image;
makepng.c:    strcpy(png->Sign,"PNG");
makepng.c:    png->incode=0;
makepng.c:    png->image_width= resize_image->columns;
makepng.c:    png->image_height= resize_image->rows;
makepng.c:    png->image_rowbytes = png->image_width*4;
makepng.c:    png->image_channels=4;
makepng.c:    png->image_data = (unsigned char *)malloc(png->image_width*(png->image_height+1)*4);
makepng.c:    for(i=0;i<(resize_image->columns*resize_image->rows);i++) {
makepng.c:     png->image_data[j++]= pixels[i].red;
makepng.c:     png->image_data[j++]= pixels[i].green;
makepng.c:     png->image_data[j++]= pixels[i].blue;
makepng.c:     png->image_data[j++]= 255 - pixels[i].opacity;
makepng.c:  image = (Image *)(png->image);
makepng.c://  (void) strcpy(image_info->filename,flname);
makepng.c:  (void) strcpy(image->filename,flname);
makepng.c:  WriteImage(image_info,(Image *)(png->image));
makepng.c:  DestroyImage((Image *)(png->image));
makepng.c:  (void) strcpy(image_info->filename,argv[1]);
makepng.c:   printf("Reading %s ...", image_info->filename);
makepng.c:  printf(" %lu frames %lu columns %lu rows \n", GetImageListLength(image),image->columns,image->rows);
makepng.c:    strcpy(png->Sign,"PNG");
makepng.c:    png->incode=1;
makepng.c:    png->image_width= resize_image->columns;
makepng.c:    png->image_height= resize_image->rows;
makepng.c:    png->image_rowbytes = png->image_width*4;
makepng.c:    png->image_channels=4;
makepng.c:    png->image_data = (unsigned char *)malloc(png->image_width*(png->image_height+1)*4);
makepng.c:    for(i=0;i<(resize_image->columns*resize_image->rows);i++) {
makepng.c:     png->image_data[j++]= pixels[i].red;
makepng.c:     png->image_data[j++]= pixels[i].green;
makepng.c:     png->image_data[j++]= pixels[i].blue;
makepng.c://     png->image_data[j++]= 255;
makepng.c:     png->image_data[j++]= 255 - pixels[i].opacity;
ogl.c:    Dsp = WC(G->D)->Dsp;
ogl.c:    glWin = *((Window *)(G->glWindow));
ogl.c:    if(G->glDouble)glXSwapBuffers(Dsp,glWin);
ogl.c:    D = (DIALOG *)G->D;
ogl.c:    xDisplay = wc->Dsp;
ogl.c:    sWin = (Window *)G->glWindow;
ogl.c:        G->glDouble=0;
ogl.c:      G->glDouble=1;
ogl.c:    if(vInfoMain->class != TrueColor) {
ogl.c:    G->cMain = (void *) cMain;
ogl.c:    glViewport(0,0,(G->x2-G->x1+1),(G->y2-G->y1+1));
ogl.c:   D = (DIALOG *)(G->D);
ogl.c:   wc = D->wc;
ogl.c:    if (!glXMakeCurrent(wc->Dsp, *((Window *)(G->glWindow)), *((GLXContext *)(G->cMain)))) {
ogl.c:   D = (DIALOG *)(G->D);
ogl.c:   wc = D->wc;
ogl.c:   return wc->Dsp;
ogl.c:   if(G->glWindow==NULL) kgInitglWindow(Gtmp);
ogl.c:   return G->glWindow;
ogl.c:   D = (DIALOG *)(G->D);
ogl.c:   wc = D->wc;
ogl.c:   if(G->glWindow== NULL) return;
ogl.c:   if(G->cMain!=NULL){
ogl.c:   XDestroyWindow(wc->Dsp,*((Window *)G->glWindow));
ogl.c:   free(G->glWindow);
ogl.c:   G->glWindow= NULL;
ogl.c:   if(G->cMain==NULL) return;
ogl.c:   cMain = (GLXContext *)G->cMain;
ogl.c:   glXDestroyContext(wc->Dsp,*cMain);
ogl.c:   G->cMain=NULL;
ogl.c:   D = (DIALOG *)(G->D);
ogl.c:   wc = D->wc;
ogl.c:   if(G->glWindow== NULL) return;
ogl.c:   XDestroyWindow(wc->Dsp,*((Window *)G->glWindow));
ogl.c:   free(G->glWindow);
ogl.c:   G->glWindow= NULL;
ogl.c:   D = (DIALOG *)(G->D);
ogl.c:   wc = D->wc;
ogl.c://   XMapWindow(wc->Dsp, *((Window *)(G->glWindow)));
ogl.c:   return ((DIG *)Gtmp)->glWindow;
part1.c:          while ( pt [ l ] != '/' ) l--;
part1.c:  if returns -1 for search failed
part1.c:      int ch , ln , ret = -1 , ln1 , i = 0;
part1.c:      if ( ln1 < ln ) ret = -1;
part1.c:          for ( i = 0;i <= ( ln1-ln ) ;i++ ) {
part1.c:          while ( isdigit ( s1 [ i ] ) ) {n1 = n1*10+ ( s1 [ i ] -'0' ) ;i++;}
part1.c:          while ( isdigit ( s2 [ i ] ) ) {n2 = n2*10+ ( s2 [ i ] -'0' ) ;i++;}
part1.c:          while ( pt [ l ] != '/' ) l--;
part1.c:      while ( pt [ i ] <= ' ' ) {pt [ i ] = '\0'; i--;if ( i == 0 ) break;}
part1.c:          ptmp = strstr ( Icon , "-" ) ;
part1.c:      ret = br-> df;
part1.c:      D = br-> D;
part1.c:      ret = kgMenu ( br-> D , br-> x1 , br-> y1 , ret , ret , br-> menu , br-> size ) ;
part1.c:      br-> df = ret;
part1.c://   ui_draw_browser((DIW *)br->wid);
part1.c:      _uiMake_W ( ( DIW * ) br-> wid ) ;
part1.c:      uiUpdateOn ( br-> D ) ;
part1.c:                  size = size*10+ ( *cpt -'0' ) ;
part1.c:                  sprintf ( dfmt , "%%-%-dd" , fln [ it ] -1 ) ;
part1.c:                  wrk [ fln [ it ] -1 ] = '\0';
part1.c:                  sprintf ( ffmt , "%%-%-df" , fln [ it ] -1 ) ;
part1.c:                  wrk [ fln [ it ] -1 ] = '\0';
part1.c:                  sprintf ( ffmt , "%%-%-dlf" , fln [ it ] -1 ) ;
part1.c:                  wrk [ fln [ it ] -1 ] = '\0';
part1.c:                  sprintf ( sfmt , "%%-%-ds" , fln [ it ] -1 ) ;
part1.c:                  wrk [ fln [ it ] -1 ] = '\0';
part1.c:      for ( i = 0;i < n-1;i++ ) {
part1.c:      D = ( DIALOG * ) ( d [ i ] .t-> D ) ;
part1.c:      if ( d [ i ] .t-> Update != NULL ) ret = d [ i ] .t-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      D = ( DIALOG * ) ( d [ i ] .b-> D ) ;
part1.c:      if ( d [ i ] .b-> Update != NULL ) ret = d [ i ] .b-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .f-> Update != NULL ) ret = d [ i ] .f-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .d-> Update != NULL ) ret = d [ i ] .d-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .B-> Update != NULL ) ret = d [ i ] .B-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .t-> Update != NULL ) ret = d [ i ] .t-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .t-> Update != NULL ) ret = d [ i ] .t-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .y-> Update != NULL ) ret = d [ i ] .y-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .b-> Update != NULL ) ret = d [ i ] .b-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .N-> Update != NULL ) ret = d [ i ] .N-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .h-> Update != NULL ) ret = d [ i ] .h-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .H-> Update != NULL ) ret = d [ i ] .H-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .w-> Update != NULL ) ret = d [ i ] .w-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .e-> Update != NULL ) ret = d [ i ] .e-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      d = D-> d;
part1.c:      if ( d [ i ] .x-> Update != NULL ) ret = d [ i ] .x-> Update 
part1.c:      else if ( D-> Callback != NULL ) ret = D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:      if ( D-> PON_X < D-> xo ) return 0;
part1.c:      if ( D-> PON_X > ( D-> xo+D-> xl ) ) return 0;
part1.c:      if ( D-> PON_Y < D-> yo ) return 0;
part1.c:      if ( D-> PON_Y > ( D-> yo+D-> yl ) ) return 0;
part1.c:      if ( D-> PON_X < D-> xo ) return -1;
part1.c:      if ( D-> PON_X > ( D-> xo+D-> xl ) ) return -1;
part1.c:      if ( D-> PON_Y < D-> yo ) return -1;
part1.c:      if ( D-> PON_Y > ( D-> yo+D-> yl ) ) return -1;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .t-> x1+x1 , d [ i ] .t-> y1+y1 , d [ i ] .t-> x2+x1 , d [ i ] .t-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .y-> x1+x1 , d [ i ] .y-> y1+y1 , d [ i ] .y-> x2+x1 , d [ i ] .y-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .c-> x1+x1 , d [ i ] .c-> y1+y1 , d [ i ] .c-> x2+x1 , d [ i ] .c-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .r-> x1+x1 , d [ i ] .r-> y1+y1 , d [ i ] .r-> x2+x1 , d [ i ] .r-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .h-> x1+x1 , d [ i ] .h-> y1+y1 , d [ i ] .h-> x2+x1 , d [ i ] .h-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .b-> x1+x1 , d [ i ] .b-> y1+y1 , d [ i ] .b-> x2+x1 , d [ i ] .b-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .f-> x1+x1 , d [ i ] .f-> y1+y1 , d [ i ] .f-> x2+x1 , d [ i ] .f-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .d-> x1+x1 , d [ i ] .d-> y1+y1 , d [ i ] .d-> x2+x1 , d [ i ] .d-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .B-> x1+x1 , d [ i ] .B-> y1+y1 , d [ i ] .B-> x2+x1 , d [ i ] .B-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .w-> x1+x1 , d [ i ] .w-> y1+y1 , d [ i ] .w-> x2+x1 , d [ i ] .w-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .x-> x1+x1 , d [ i ] .x-> y1+y1 , d [ i ] .x-> x2+x1 , d [ i ] .x-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .e-> x1+x1 , d [ i ] .e-> y1+y1 , d [ i ] .e-> x2+x1 , d [ i ] .e-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .s-> x1+x1 , d [ i ] .s-> y1+y1 , d [ i ] .s-> x2+x1 , d [ i ] .s-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .v-> x1+x1 , d [ i ] .v-> y1+y1 , d [ i ] .v-> x2+x1 , d [ i ] .v-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:              if ( uiCheckClickPosition ( d [ i ] .z-> x1+x1 , d [ i ] .z-> y1+y1 , d [ i ] .z-> x2+x1 , d [ i ] .z-> y2+y1 , D-> PON_X , D-> PON_Y ) == 1 ) return i%n;
part1.c:      return -1;
part1.c:      if ( ! D-> kbattn ) return 0;
part1.c:      x1 = D-> xo;
part1.c:      y1 = D-> yo;
part1.c:      d = D-> d;
part1.c:      ch = ( d [ i ] .t-> code ) ;
part1.c:          X1 = d [ i ] .t-> x1+x1;
part1.c:          Y1 = d [ i ] .t-> y1+y1;
part1.c:          X2 = d [ i ] .t-> x2+x1;
part1.c:          Y2 = d [ i ] .t-> y2+y1;
part1.c:          X1 = d [ i ] .t-> x1+x1;
part1.c:          Y1 = d [ i ] .t-> y1+y1;
part1.c:          X2 = d [ i ] .t-> x2+x1;
part1.c:          Y2 = d [ i ] .t-> y2+y1;
part1.c:          X1 = d [ i ] .v-> x1+x1;
part1.c:          Y1 = d [ i ] .v-> y1+y1;
part1.c:          X2 = d [ i ] .v-> x2+x1;
part1.c:          Y2 = d [ i ] .v-> y2+y1;
part1.c:          X1 = d [ i ] .z-> x1+x1;
part1.c:          Y1 = d [ i ] .z-> y1+y1;
part1.c:          X2 = d [ i ] .z-> x2+x1;
part1.c:          Y2 = d [ i ] .z-> y2+y1;
part1.c:          X1 = d [ i ] .x-> x1+x1;
part1.c:          Y1 = d [ i ] .x-> y1+y1;
part1.c:          X2 = d [ i ] .x-> x2+x1;
part1.c:          Y2 = d [ i ] .x-> y2+y1;
part1.c:          X1 = d [ i ] .y-> x1+x1;
part1.c:          Y1 = d [ i ] .x-> y1+y1;
part1.c:          X2 = d [ i ] .y-> x2+x1;
part1.c:          Y2 = d [ i ] .y-> y2+y1;
part1.c:          X1 = d [ i ] .r-> x1+x1;
part1.c:          Y1 = d [ i ] .r-> y1+y1;
part1.c:          X2 = d [ i ] .r-> x2+x1;
part1.c:          Y2 = d [ i ] .r-> y2+y1;
part1.c:          X1 = d [ i ] .c-> x1+x1;
part1.c:          Y1 = d [ i ] .c-> y1+y1;
part1.c:          X2 = d [ i ] .c-> x2+x1;
part1.c:          Y2 = d [ i ] .c-> y2+y1;
part1.c:          X1 = d [ i ] .h-> x1+x1;
part1.c:          Y1 = d [ i ] .h-> y1+y1;
part1.c:          X2 = d [ i ] .h-> x2+x1;
part1.c:          Y2 = d [ i ] .h-> y2+y1;
part1.c:          X1 = d [ i ] .b-> x1+x1;
part1.c:          Y1 = d [ i ] .b-> y1+y1;
part1.c:          X2 = d [ i ] .b-> x2+x1;
part1.c:          Y2 = d [ i ] .b-> y2+y1;
part1.c:          X1 = d [ i ] .f-> x1+x1;
part1.c:          Y1 = d [ i ] .f-> y1+y1;
part1.c:          X2 = d [ i ] .f-> x2+x1;
part1.c:          Y2 = d [ i ] .f-> y2+y1;
part1.c:          X1 = d [ i ] .d-> x1+x1;
part1.c:          Y1 = d [ i ] .d-> y1+y1;
part1.c:          X2 = d [ i ] .d-> x2+x1;
part1.c:          Y2 = d [ i ] .d-> y2+y1;
part1.c:          X1 = d [ i ] .B-> x1+x1;
part1.c:          Y1 = d [ i ] .B-> y1+y1;
part1.c:          X2 = d [ i ] .B-> x2+x1;
part1.c:          Y2 = d [ i ] .B-> y2+y1;
part1.c:          X1 = d [ i ] .w-> x1+x1;
part1.c:          Y1 = d [ i ] .w-> y1+y1;
part1.c:          X2 = d [ i ] .w-> x2+x1;
part1.c:          Y2 = d [ i ] .w-> y2+y1;
part1.c:          X1 = d [ i ] .e-> x1+x1;
part1.c:          Y1 = d [ i ] .e-> y1+y1;
part1.c:          X2 = d [ i ] .e-> x2+x1;
part1.c:          Y2 = d [ i ] .e-> y2+y1;
part1.c:          X1 = d [ i ] .s-> x1+x1;
part1.c:          Y1 = d [ i ] .s-> y1+y1;
part1.c:          X2 = d [ i ] .s-> x2+x1;
part1.c:          Y2 = d [ i ] .s-> y2+y1;
part1.c:          return -1;
part1.c:      switch ( D-> kbattn ) {
part1.c:      return -1;
part1.c:      if ( ! D-> kbattn ) return 0;
part1.c:      x1 = D-> xo;
part1.c:      y1 = D-> yo;
part1.c:      d = D-> d;
part1.c:      ch = ( d [ i ] .t-> code ) ;
part1.c:          X1 = d [ i ] .t-> x1+x1;
part1.c:          Y1 = d [ i ] .t-> y1+y1;
part1.c:          X2 = d [ i ] .t-> x2+x1;
part1.c:          Y2 = d [ i ] .t-> y2+y1;
part1.c:          X1 = d [ i ] .t-> x1+x1;
part1.c:          Y1 = d [ i ] .t-> y1+y1;
part1.c:          X2 = d [ i ] .t-> x2+x1;
part1.c:          Y2 = d [ i ] .t-> y2+y1;
part1.c:          X1 = d [ i ] .v-> x1+x1;
part1.c:          Y1 = d [ i ] .v-> y1+y1;
part1.c:          X2 = d [ i ] .v-> x2+x1;
part1.c:          Y2 = d [ i ] .v-> y2+y1;
part1.c:          X1 = d [ i ] .z-> x1+x1;
part1.c:          Y1 = d [ i ] .z-> y1+y1;
part1.c:          X2 = d [ i ] .z-> x2+x1;
part1.c:          Y2 = d [ i ] .z-> y2+y1;
part1.c:          X1 = d [ i ] .x-> x1+x1;
part1.c:          Y1 = d [ i ] .x-> y1+y1;
part1.c:          X2 = d [ i ] .x-> x2+x1;
part1.c:          Y2 = d [ i ] .x-> y2+y1;
part1.c:          X1 = d [ i ] .y-> x1+x1;
part1.c:          Y1 = d [ i ] .y-> y1+y1;
part1.c:          X2 = d [ i ] .y-> x2+x1;
part1.c:          Y2 = d [ i ] .y-> y2+y1;
part1.c:          X1 = d [ i ] .r-> x1+x1;
part1.c:          Y1 = d [ i ] .r-> y1+y1;
part1.c:          X2 = d [ i ] .r-> x2+x1;
part1.c:          Y2 = d [ i ] .r-> y2+y1;
part1.c:          X1 = d [ i ] .c-> x1+x1;
part1.c:          Y1 = d [ i ] .c-> y1+y1;
part1.c:          X2 = d [ i ] .c-> x2+x1;
part1.c:          Y2 = d [ i ] .c-> y2+y1;
part1.c:          X1 = d [ i ] .h-> x1+x1;
part1.c:          Y1 = d [ i ] .h-> y1+y1;
part1.c:          X2 = d [ i ] .h-> x2+x1;
part1.c:          Y2 = d [ i ] .h-> y2+y1;
part1.c:          X1 = d [ i ] .b-> x1+x1;
part1.c:          Y1 = d [ i ] .b-> y1+y1;
part1.c:          X2 = d [ i ] .b-> x2+x1;
part1.c:          Y2 = d [ i ] .b-> y2+y1;
part1.c:          X1 = d [ i ] .f-> x1+x1;
part1.c:          Y1 = d [ i ] .f-> y1+y1;
part1.c:          X2 = d [ i ] .f-> x2+x1;
part1.c:          Y2 = d [ i ] .f-> y2+y1;
part1.c:          X1 = d [ i ] .d-> x1+x1;
part1.c:          Y1 = d [ i ] .d-> y1+y1;
part1.c:          X2 = d [ i ] .d-> x2+x1;
part1.c:          Y2 = d [ i ] .d-> y2+y1;
part1.c:          X1 = d [ i ] .B-> x1+x1;
part1.c:          Y1 = d [ i ] .B-> y1+y1;
part1.c:          X2 = d [ i ] .B-> x2+x1;
part1.c:          Y2 = d [ i ] .B-> y2+y1;
part1.c:          X1 = d [ i ] .w-> x1+x1;
part1.c:          Y1 = d [ i ] .w-> y1+y1;
part1.c:          X2 = d [ i ] .w-> x2+x1;
part1.c:          Y2 = d [ i ] .w-> y2+y1;
part1.c:          X1 = d [ i ] .e-> x1+x1;
part1.c:          Y1 = d [ i ] .e-> y1+y1;
part1.c:          X2 = d [ i ] .e-> x2+x1;
part1.c:          Y2 = d [ i ] .e-> y2+y1;
part1.c:          X1 = d [ i ] .s-> x1+x1;
part1.c:          Y1 = d [ i ] .s-> y1+y1;
part1.c:          X2 = d [ i ] .s-> x2+x1;
part1.c:          Y2 = d [ i ] .s-> y2+y1;
part1.c:          return -1;
part1.c:      switch ( D-> kbattn ) {
part1.c:      return -1;
part1.c:      int n , i , controls = 0 , item , ch , oldi = -1;
part1.c:      d = D-> d;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              g-> D = D;
part1.c:              if ( g-> initgraph != NULL ) {
part1.c:                  g-> initgraph ( i , D ) ;
part1.c://       D->df=0;
part1.c:      int n , i , controls = 0 , item , ch , oldi = -1;
part1.c:      d = D-> d;
part1.c:      D-> df = 0;
part1.c:      if ( D-> DrawBkgr == 1 ) _ui_Draw_Dialog_Area_Transparent ( D ) ;
part1.c:      if ( D-> Bkpixmap != NULL ) kgImage ( ( D ) , D-> Bkpixmap , 0 , 0 , D-> xl , D-> yl , D-> transparency , 1.0 ) ;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  if ( D-> InputWid < 0 ) D-> InputWid = i;
part1.c:                  D-> df = i;
part1.c:                  if ( D-> InputWid < 0 ) D-> InputWid = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:                  D-> df = i;
part1.c:      D-> controls = controls;
part1.c:      D-> TotWid = i;
part1.c:      int i , k , ret = -1;
part1.c:      d = D-> d;
part1.c:      int n , controls = 0 , item , ch , oldi = -1 , ret = 0 , i , k;
part1.c:      d = D-> d;
part1.c:      if ( k != -1 ) {
part1.c:          ch = ( t-> code ) ;
part1.c:              if ( d [ i ] .o-> item == -1 ) _uiDrawO ( D , i ) ;
part1.c:              if ( d [ i ] .p-> item == -1 ) _uiDrawP ( D , i ) ;
part1.c:              if ( d [ i ] .i-> item == -1 ) _uiDrawI ( D , i ) ;
part1.c:              if ( d [ i ] .x-> item == -1 ) _uiDrawX ( D , i ) ;
part1.c:              if ( d [ i ] .v-> item == -1 ) _uiDrawV ( D , i ) ;
part1.c:              if ( d [ i ] .z-> item == -1 ) _uiDrawZ ( D , i ) ;
part1.c:              if ( d [ i ] .y-> item == -1 ) _uiDrawY ( D , i ) ;
part1.c:              if ( d [ i ] .r-> item == -1 ) _uiDrawRadioButton ( D , i ) ;
part1.c:              if ( d [ i ] .c-> item == -1 ) _uiDrawCheckBox ( D , i ) ;
part1.c:              if ( d [ i ] .t-> item == -1 ) _uiDrawTextBox ( D , i ) ;
part1.c:              if ( d [ i ] .t-> item == -1 ) _uiDrawTableBox ( D , i ) ;
part1.c:              if ( d [ i ] .h-> item == -1 ) _uiDrawN ( D , i ) ;
part1.c:              if ( d [ i ] .H-> item == -1 ) _uiDrawHoriButtons ( D , i ) ;
part1.c:              if ( d [ i ] .N-> item == -1 ) _uiDrawN ( D , i ) ;
part1.c:              if ( d [ i ] .b-> item == -1 ) _uiDrawB ( D , i ) ;
part1.c:              if ( d [ i ] .f-> item == -1 ) _uiDrawSlideFloat ( D , i ) ;
part1.c:              if ( d [ i ] .B-> item == -1 ) _uiDrawHbar ( D , i ) ;
part1.c:              if ( d [ i ] .d-> item == -1 ) _uiDrawSlideInteger ( D , i ) ;
part1.c:              if ( d [ i ] .w-> item == -1 ) _uiDrawBrowser ( D , i ) ;
part1.c:              if ( d [ i ] .e-> item == -1 ) _uiDrawE ( D , i ) ;
part1.c:              if ( d [ i ] .s-> item == -1 ) _uiDrawScrollMsgItem ( D , i ) ;
part1.c:              if ( d [ i ] .g-> item == -1 ) _uiDrawGraphicsArea ( D , i ) ;
part1.c:              if ( d [ i ] .m-> item == -1 ) _uiDrawMessage ( D , i ) ;
part1.c:              ret = -1;
part1.c:      int n , i , controls = 0 , item , ch , oldi = -1;
part1.c:      d = D-> d;
part1.c:      D-> df = 0;
part1.c:      if ( D-> DrawBkgr == 1 ) _ui_Draw_Dialog_Area_Transparent ( D ) ;
part1.c:      if ( D-> Bkpixmap != NULL ) kgImage ( ( D ) , D-> Bkpixmap , 0 , 0 , D-> xl , D-> yl , D-> transparency , 1.0 ) ;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              if ( d [ i ] .o-> hide != 1 ) break;
part1.c:              item = d [ i ] .o-> item;
part1.c:              if ( d [ i ] .o-> item == -1 ) _uiDrawO ( D , i ) ;
part1.c:              if ( d [ i ] .p-> hide != 1 ) break;
part1.c:              item = d [ i ] .p-> item;
part1.c:              if ( d [ i ] .p-> item == -1 ) _uiDrawP ( D , i ) ;
part1.c:              if ( d [ i ] .i-> hide != 1 ) break;
part1.c:              item = d [ i ] .i-> item;
part1.c:              if ( d [ i ] .i-> item == -1 ) _uiDrawI ( D , i ) ;
part1.c:              if ( d [ i ] .x-> hide != 1 ) break;
part1.c:              item = d [ i ] .x-> item;
part1.c:              if ( d [ i ] .x-> item == -1 ) _uiDrawX ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .v-> hide != 1 ) break;
part1.c:              item = d [ i ] .v-> item;
part1.c:              if ( d [ i ] .v-> item == -1 ) _uiDrawV ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .z-> hide != 1 ) break;
part1.c:              item = d [ i ] .z-> item;
part1.c:              if ( d [ i ] .z-> item == -1 ) _uiDrawZ ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .y-> hide != 1 ) break;
part1.c:              item = d [ i ] .y-> item;
part1.c:              if ( d [ i ] .y-> item == -1 ) _uiDrawY ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .r-> hide != 1 ) break;
part1.c:              item = d [ i ] .r-> item;
part1.c:              if ( d [ i ] .r-> item == -1 ) _uiDrawRadioButton ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .c-> hide != 1 ) break;
part1.c:              item = d [ i ] .c-> item;
part1.c:              if ( d [ i ] .c-> item == -1 ) _uiDrawCheckBox ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .t-> hide != 1 ) break;
part1.c:              item = d [ i ] .t-> item;
part1.c:              if ( d [ i ] .t-> item == -1 ) _uiDrawTextBox ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .t-> hide != 1 ) break;
part1.c:              item = d [ i ] .t-> item;
part1.c:              if ( d [ i ] .t-> item == -1 ) _uiDrawTableBox ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .h-> hide != 1 ) break;
part1.c:              item = d [ i ] .h-> item;
part1.c:              if ( d [ i ] .h-> item == -1 ) _uiDrawN ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .H-> hide != 1 ) break;
part1.c:              item = d [ i ] .H-> item;
part1.c:              if ( d [ i ] .H-> item == -1 ) _uiDrawHoriButtons ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .N-> hide != 1 ) break;
part1.c:              item = d [ i ] .N-> item;
part1.c:              if ( d [ i ] .N-> item == -1 ) _uiDrawN ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .b-> hide != 1 ) break;
part1.c:              item = d [ i ] .b-> item;
part1.c:              if ( d [ i ] .b-> item == -1 ) _uiDrawB ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .f-> hide != 1 ) break;
part1.c:              item = d [ i ] .f-> item;
part1.c:              if ( d [ i ] .f-> item == -1 ) _uiDrawSlideFloat ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .B-> hide != 1 ) break;
part1.c:              item = d [ i ] .B-> item;
part1.c:              if ( d [ i ] .B-> item == -1 ) _uiDrawHbar ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .d-> hide != 1 ) break;
part1.c:              item = d [ i ] .d-> item;
part1.c:              if ( d [ i ] .d-> item == -1 ) _uiDrawSlideInteger ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .w-> hide != 1 ) break;
part1.c:              item = d [ i ] .w-> item;
part1.c:              if ( d [ i ] .w-> item == -1 ) _uiDrawBrowser ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .e-> hide != 1 ) break;
part1.c:              item = d [ i ] .e-> item;
part1.c:              if ( d [ i ] .e-> item == -1 ) _uiDrawE ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .s-> hide != 1 ) break;
part1.c:              item = d [ i ] .s-> item;
part1.c:              if ( d [ i ] .s-> item == -1 ) _uiDrawScrollMsgItem ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .g-> hide != 1 ) break;
part1.c:              item = d [ i ] .g-> item;
part1.c:              if ( d [ i ] .g-> item == -1 ) _uiDrawGraphicsArea ( D , i ) ;
part1.c:              if ( d [ i ] .m-> hide != 1 ) break;
part1.c:              item = d [ i ] .m-> item;
part1.c:              if ( d [ i ] .m-> item == -1 ) _uiDrawMessage ( D , i ) ;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              if ( d [ i ] .o-> hide == 1 ) break;
part1.c:              item = d [ i ] .o-> item;
part1.c:              if ( d [ i ] .o-> item == -1 ) _uiDrawO ( D , i ) ;
part1.c:              if ( d [ i ] .p-> hide == 1 ) break;
part1.c:              item = d [ i ] .p-> item;
part1.c:              if ( d [ i ] .p-> item == -1 ) _uiDrawP ( D , i ) ;
part1.c:              if ( d [ i ] .i-> hide == 1 ) break;
part1.c:              item = d [ i ] .i-> item;
part1.c:              if ( d [ i ] .i-> item == -1 ) _uiDrawI ( D , i ) ;
part1.c:              if ( d [ i ] .x-> hide == 1 ) break;
part1.c:              item = d [ i ] .x-> item;
part1.c:              if ( d [ i ] .x-> item == -1 ) _uiDrawX ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .v-> hide == 1 ) break;
part1.c:              item = d [ i ] .v-> item;
part1.c:              if ( d [ i ] .v-> item == -1 ) _uiDrawV ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .z-> hide == 1 ) break;
part1.c:              item = d [ i ] .z-> item;
part1.c:              if ( d [ i ] .z-> item == -1 ) _uiDrawZ ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .y-> hide == 1 ) break;
part1.c:              item = d [ i ] .y-> item;
part1.c:              if ( d [ i ] .y-> item == -1 ) _uiDrawY ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .r-> hide == 1 ) break;
part1.c:              item = d [ i ] .r-> item;
part1.c:              if ( d [ i ] .r-> item == -1 ) _uiDrawRadioButton ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .c-> hide == 1 ) break;
part1.c:              item = d [ i ] .c-> item;
part1.c:              if ( d [ i ] .c-> item == -1 ) _uiDrawCheckBox ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .t-> hide == 1 ) break;
part1.c:              item = d [ i ] .t-> item;
part1.c:              if ( d [ i ] .t-> item == -1 ) _uiDrawTextBox ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .t-> hide == 1 ) break;
part1.c:              item = d [ i ] .t-> item;
part1.c:              if ( d [ i ] .t-> item == -1 ) _uiDrawTableBox ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .h-> hide == 1 ) break;
part1.c:              item = d [ i ] .h-> item ;
part1.c:              if ( d [ i ] .h-> item == -1 ) _uiDrawN ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .H-> hide == 1 ) break;
part1.c:              item = d [ i ] .H-> item;
part1.c:              if ( d [ i ] .H-> item == -1 ) _uiDrawHoriButtons ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .N-> hide == 1 ) break;
part1.c:              item = d [ i ] .N-> item;
part1.c:              if ( d [ i ] .N-> item == -1 ) _uiDrawN ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .b-> hide == 1 ) break;
part1.c:              item = d [ i ] .b-> item;
part1.c:              if ( d [ i ] .b-> item == -1 ) _uiDrawB ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .f-> hide == 1 ) break;
part1.c:              item = d [ i ] .f-> item;
part1.c:              if ( d [ i ] .f-> item == -1 ) _uiDrawSlideFloat ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .B-> hide == 1 ) break;
part1.c:              item = d [ i ] .B-> item;
part1.c:              if ( d [ i ] .B-> item == -1 ) _uiDrawHbar ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .d-> hide == 1 ) break;
part1.c:              item = d [ i ] .d-> item;
part1.c:              if ( d [ i ] .d-> item == -1 ) _uiDrawSlideInteger ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .w-> hide == 1 ) break;
part1.c:              item = d [ i ] .w-> item;
part1.c:              if ( d [ i ] .w-> item == -1 ) _uiDrawBrowser ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .e-> hide == 1 ) break;
part1.c:              item = d [ i ] .e-> item;
part1.c:              if ( d [ i ] .e-> item == -1 ) _uiDrawE ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .s-> hide == 1 ) break;
part1.c:              item = d [ i ] .s-> item;
part1.c:              if ( d [ i ] .s-> item == -1 ) _uiDrawScrollMsgItem ( D , i ) ;
part1.c:              D-> df = i;
part1.c:              if ( d [ i ] .g-> hide == 1 ) break;
part1.c:              item = d [ i ] .g-> item;
part1.c:              if ( d [ i ] .g-> item == -1 ) _uiDrawGraphicsArea ( D , i ) ;
part1.c:              if ( d [ i ] .m-> hide == 1 ) break;
part1.c:              item = d [ i ] .m-> item;
part1.c:              if ( d [ i ] .m-> item == -1 ) _uiDrawMessage ( D , i ) ;
part1.c:      D-> controls = controls;
part1.c:      D-> TotWid = i;
part1.c:      d = D-> d;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              FreeImg ( ( ( DIV * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIZ * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIO * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  kgFreeImage ( p-> Bimg ) ;
part1.c:                  p-> Bimg = NULL;
part1.c:                  Free ( I-> twin ) ;
part1.c:              FreeImg ( ( ( DII * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c://         free(((TX_STR *)(t->tstr))->tit);
part1.c://         free(((TX_STR *)(t->tstr))->ln);
part1.c:                  Free ( t-> tstr ) ;
part1.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c://          free(((TX_STR *)(T->tstr))->ln);
part1.c:                  Free ( T-> tstr ) ;
part1.c:                  T-> tstr = NULL;
part1.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  butn = ( BUT_STR * ) b-> buts;
part1.c:                  if ( b-> buts != NULL ) {
part1.c:                      n = b-> nx*b-> ny;
part1.c:                      Free ( b-> buts ) ;
part1.c:                      b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIL * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( h-> buts ) ;
part1.c:                  h-> buts = NULL;
part1.c:              FreeImg ( ( ( DILN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  butn = ( BUT_STR * ) b-> buts;
part1.c:                  if ( b-> buts != NULL ) {
part1.c:                      n = b-> nx*b-> ny;
part1.c:                      Free ( b-> buts ) ;
part1.c:                      b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  buts = n-> buts;
part1.c:                      Free ( buts-> sw ) ;
part1.c:                      n-> buts = NULL;
part1.c:              FreeImg ( ( ( DIBN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  if ( b-> buts != NULL ) {
part1.c:                      Free ( b-> buts ) ;
part1.c:                      b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIB * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( f-> sptr ) ;
part1.c:                  f-> sptr = NULL;
part1.c:              FreeImg ( ( ( DIF * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  pt = B-> sptr;
part1.c:                      kgFreeImage ( pt-> bimg ) ;
part1.c:                      kgFreeImage ( pt-> fimg ) ;
part1.c:                      Free ( B-> sptr ) ;
part1.c:                      B-> sptr = NULL;
part1.c:              FreeImg ( ( ( DIHB * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( di-> sptr ) ;
part1.c:                  di-> sptr = NULL;
part1.c:              FreeImg ( ( ( DID * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIX * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIY * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DICH * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIRA * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIW * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIE * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIS * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  wc = g-> wc;
part1.c://          Dempty(wc->SBlist);
part1.c:                  Dempty ( wc-> Clip ) ;
part1.c:                  if ( g-> img != NULL ) uiFreeImage ( g-> img ) ;
part1.c:                  if ( g-> rzimg != NULL ) uiFreeImage ( g-> rzimg ) ;
part1.c:                  g-> img = NULL;
part1.c:                  g-> rzimg = NULL;
part1.c:                  if ( g-> dc != NULL ) {
part1.c:                      dc = ( kgDC * ) ( g-> dc ) ;
part1.c://            Dfree(dc->Fontlist);
part1.c:                      Dempty ( dc-> Fontlist ) ;
part1.c:                      Free ( g-> dc ) ;
part1.c:                  if ( g-> wc != NULL ) Free ( g-> wc ) ;
part1.c:              FreeImg ( ( ( DIG * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:      Dempty ( ( Dlink * ) ( D-> SearchList ) ) ;
part1.c:      D-> SearchList = NULL;
part1.c:      d = D-> d;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              FreeImg ( ( ( DIV * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIZ * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIO * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIP * ) ( d [ i ] .p ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DII * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIL * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DILN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIBN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIB * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIF * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIHB * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DID * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIX * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIY * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DICH * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIRA * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIW * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIE * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIS * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIG * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:          ch = ( t-> code ) ;
part1.c:              FreeImg ( ( ( DIV * ) ( t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIZ * ) ( t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIO * ) ( t ) ) -> Bimg ) ;
part1.c:                  uiFreeXpm ( p-> xpm ) ;
part1.c:                  p-> xpm = NULL;
part1.c:              FreeImg ( ( ( DIP * ) ( t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DII * ) ( t ) ) -> Bimg ) ;
part1.c:                  e = t-> elmt;
part1.c:                  n = t-> nx*t-> ny;
part1.c:                      t-> elmt = NULL;
part1.c:                  if ( t-> pt != NULL ) kgFreeDouble ( t-> pt ) ;
part1.c:                  t-> pt = NULL;
part1.c:              FreeImg ( ( ( DIT * ) ( t ) ) -> Bimg ) ;
part1.c:                  e = T-> elmt;
part1.c:                  n = T-> nx*T-> ny;
part1.c:                      T-> elmt = NULL;
part1.c:                  if ( T-> pt != NULL ) kgFreeDouble ( T-> pt ) ;
part1.c:                  T-> pt = NULL;
part1.c:              FreeImg ( ( ( DIT * ) ( t ) ) -> Bimg ) ;
part1.c:                  butn = ( BUT_STR * ) b-> buts;
part1.c:                      b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIL * ) ( t ) ) -> Bimg ) ;
part1.c:                  if ( h-> xpm != NULL ) {
part1.c:                      n = h-> nx*h-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) uiFreeXpm ( h-> xpm [ j ] ) ;
part1.c:                      Free ( h-> xpm ) ;
part1.c:                  Free ( h-> sw ) ;
part1.c:                  Free ( h-> bkgr ) ;
part1.c:                  if ( h-> butncode != NULL ) Free ( h-> butncode ) ;
part1.c:                  if ( h-> titles != NULL ) {
part1.c:                      n = h-> nx*h-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) if ( h-> titles [ j ] != NULL ) Free 
part1.c:                          ( h-> titles [ j ] ) ;
part1.c:                      Free ( h-> titles ) ;
part1.c:              FreeImg ( ( ( DILN * ) ( t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIBN * ) ( t ) ) -> Bimg ) ;
part1.c:                  butn = ( BUT_STR * ) b-> buts;
part1.c:                      Free ( b-> buts ) ;
part1.c:                      b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIN * ) ( t ) ) -> Bimg ) ;
part1.c:                  if ( b-> xpm != NULL ) {
part1.c:                      n = b-> nx*b-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) uiFreeXpm ( b-> xpm [ j ] ) ;
part1.c:                      Free ( b-> xpm ) ;
part1.c:                  Free ( b-> sw ) ;
part1.c:                  Free ( b-> bkgr ) ;
part1.c:                  if ( b-> butncode != NULL ) Free ( b-> butncode ) ;
part1.c:                  if ( b-> titles != NULL ) {
part1.c:                      n = b-> nx*b-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) if ( b-> titles [ j ] != NULL ) Free 
part1.c:                          ( b-> titles [ j ] ) ;
part1.c:                      Free ( b-> titles ) ;
part1.c:              FreeImg ( ( ( DIB * ) ( t ) ) -> Bimg ) ;
part1.c:                  pt = w-> sptr;
part1.c:                  Free ( w-> sptr ) ;
part1.c:              FreeImg ( ( ( DIF * ) ( t ) ) -> Bimg ) ;
part1.c:                  pt = w-> sptr;
part1.c:                      kgFreeImage ( pt-> bimg ) ;
part1.c:                      kgFreeImage ( pt-> fimg ) ;
part1.c:                  w-> sptr = NULL;
part1.c:              FreeImg ( ( ( DIHB * ) ( t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> sptr ) ;
part1.c:              FreeImg ( ( ( DID * ) ( t ) ) -> Bimg ) ;
part1.c:                  kgFreeDouble ( ( void ** ) ( w-> pt ) ) ;
part1.c:                  w-> pt = NULL;
part1.c:              FreeImg ( ( ( DIX * ) ( t ) ) -> Bimg ) ;
part1.c:                  kgFreeDouble ( ( void ** ) ( w-> pt ) ) ;
part1.c:                  w-> pt = NULL;
part1.c:              FreeImg ( ( ( DIY * ) ( t ) ) -> Bimg ) ;
part1.c:                  kgFreeDouble ( ( void ** ) ( w-> list ) ) ;
part1.c:                  w-> list = NULL;
part1.c:              FreeImg ( ( ( DICH * ) ( t ) ) -> Bimg ) ;
part1.c:                  kgFreeDouble ( ( void ** ) ( w-> list ) ) ;
part1.c:                  w-> list = NULL;
part1.c:              FreeImg ( ( ( DIRA * ) ( t ) ) -> Bimg ) ;
part1.c:                  if ( w-> prompt != NULL ) Free ( w-> prompt ) ;
part1.c:                  kgFreeDouble ( ( void ** ) w-> menu ) ;
part1.c:                  w-> menu = NULL;
part1.c:              FreeImg ( ( ( DIW * ) ( t ) ) -> Bimg ) ;
part1.c:                  kgFreeDouble ( ( void ** ) w-> menu ) ;
part1.c:                  w-> menu = NULL;
part1.c:              FreeImg ( ( ( DIE * ) ( t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIS * ) ( t ) ) -> Bimg ) ;
part1.c:                  uiFreeXpm ( g-> xpm ) ;
part1.c:                  g-> xpm = NULL;
part1.c:              FreeImg ( ( ( DIG * ) ( t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( t ) ) -> Bimg ) ;
part1.c:      d = D-> d;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              FreeImg ( ( ( DIV * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIZ * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIO * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  uiFreeXpm ( p-> xpm ) ;
part1.c:                  p-> xpm = NULL;
part1.c:              FreeImg ( ( ( DIP * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DII * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  e = t-> elmt;
part1.c:                      n = t-> nx*t-> ny;
part1.c:                      t-> elmt = NULL;
part1.c:                  if ( t-> pt != NULL ) kgFreeDouble ( t-> pt ) ;
part1.c:                  t-> pt = NULL;
part1.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  e = T-> elmt;
part1.c:                      n = T-> nx*T-> ny;
part1.c:                      T-> elmt = NULL;
part1.c:                  if ( T-> pt != NULL ) kgFreeDouble ( T-> pt ) ;
part1.c:                  T-> pt = NULL;
part1.c:              FreeImg ( ( ( DIT * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  butn = ( BUT_STR * ) b-> buts;
part1.c:                  b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIL * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  if ( h-> xpm != NULL ) {
part1.c:                      n = h-> nx*h-> ny;
part1.c:                      if ( h-> xpm != NULL ) for ( j = 0;j < n;j++ ) uiFreeXpm ( h-> xpm [ j ] ) ;
part1.c:                      Free ( h-> xpm ) ;
part1.c:                      h-> xpm = NULL;
part1.c:                  Free ( h-> sw ) ;
part1.c:                  Free ( h-> bkgr ) ;
part1.c:                  if ( h-> butncode != NULL ) Free ( h-> butncode ) ;
part1.c:                  if ( h-> titles != NULL ) {
part1.c:                      n = h-> nx*h-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) if ( h-> titles [ j ] != NULL ) Free 
part1.c:                          ( h-> titles [ j ] ) ;
part1.c:                      Free ( h-> titles ) ;
part1.c:                      h-> titles = NULL;
part1.c:              FreeImg ( ( ( DILN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  butn = ( BUT_STR * ) b-> buts;
part1.c:                  b-> buts = NULL;
part1.c:              FreeImg ( ( ( DIN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIBN * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  if ( b-> xpm != NULL ) {
part1.c:                      n = b-> nx*b-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) uiFreeXpm ( b-> xpm [ j ] ) ;
part1.c:                      Free ( b-> xpm ) ;
part1.c:                      b-> xpm = NULL;
part1.c:                  Free ( b-> sw ) ;
part1.c:                  b-> sw = NULL;
part1.c:                  Free ( b-> bkgr ) ;
part1.c:                  b-> bkgr = NULL;
part1.c:                  if ( b-> butncode != NULL ) Free ( b-> butncode ) ;
part1.c:                  b-> butncode = NULL;
part1.c:                  if ( b-> titles != NULL ) {
part1.c:                      n = b-> nx*b-> ny;
part1.c:                      for ( j = 0;j < n;j++ ) if ( b-> titles [ j ] != NULL ) Free 
part1.c:                          ( b-> titles [ j ] ) ;
part1.c:                      Free ( b-> titles ) ;
part1.c:                      b-> titles = NULL;
part1.c:              FreeImg ( ( ( DIB * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( f-> sptr ) ;
part1.c:                  f-> sptr = NULL;
part1.c:              FreeImg ( ( ( DIF * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  pt = B-> sptr;
part1.c:                      kgFreeImage ( pt-> bimg ) ;
part1.c:                      kgFreeImage ( pt-> fimg ) ;
part1.c:                  B-> sptr = NULL;
part1.c:              FreeImg ( ( ( DIHB * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( di-> sptr ) ;
part1.c:                  di-> sptr = NULL;
part1.c:              FreeImg ( ( ( DID * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  if ( ( D-> VerId == 1401010200 ) || ( D-> VerId == 2107030000 ) ) {
part1.c:                      kgFreeDouble ( ( void ** ) ( w-> pt ) ) ;
part1.c:                      w-> pt = NULL;
part1.c:              FreeImg ( ( ( DIX * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  if ( ( D-> VerId == 1401010200 ) || ( D-> VerId == 2107030000 ) ) {
part1.c:                      kgFreeDouble ( ( void ** ) ( w-> pt ) ) ;
part1.c:                      w-> pt = NULL;
part1.c:              FreeImg ( ( ( DIY * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c://         kgFreeDouble((void **)(w->list));
part1.c:                  w-> list = NULL;
part1.c:              FreeImg ( ( ( DICH * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c://         kgFreeDouble((void **)(w->list));
part1.c:                  w-> list = NULL;
part1.c:              FreeImg ( ( ( DIRA * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  if ( w-> prompt != NULL ) Free ( w-> prompt ) ;
part1.c:                  kgFreeDouble ( ( void ** ) w-> menu ) ;
part1.c:                  w-> menu = NULL;
part1.c:              FreeImg ( ( ( DIW * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  kgFreeDouble ( ( void ** ) w-> menu ) ;
part1.c:                  w-> menu = NULL;
part1.c:              FreeImg ( ( ( DIE * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  Free ( w-> bwsr ) ;
part1.c:              FreeImg ( ( ( DIS * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:                  uiFreeXpm ( g-> xpm ) ;
part1.c:                  g-> xpm = NULL;
part1.c:              FreeImg ( ( ( DIG * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:              FreeImg ( ( ( DIM * ) ( d [ i ] .t ) ) -> Bimg ) ;
part1.c:      D = B-> D;
part1.c:      wd = B-> width;
part1.c:      ln = B-> lngth;
part1.c:      xgap = B-> xgap;
part1.c:      ygap = B-> ygap;
part1.c:      sw = B-> sw;
part1.c:      if ( B-> code == 'N' ) code = 0;
part1.c:      for ( j = 0;j < ( B-> ny ) ;j++ ) {
part1.c:          yy = B-> y1+D-> yo+ygap/2+j* ( ygap+wd ) ;
part1.c:          for ( i = 0; i < ( B-> nx ) ;i++ ) {
part1.c:              xx = B-> x1+D-> xo+xgap/2+i* ( ln+xgap ) ;
part1.c:              xd = xpo-xx;yd = ypo-yy;
part1.c:              if ( ( ( xd* ( xd-ln ) ) <= 0 ) && ( ( yd* ( yd-wd ) ) <= 0 ) ) {
part1.c:                  _dv_draw_newbutton ( B , k , -1 ) ;
part1.c:                  * ( B-> df ) = df;
part1.c:      if ( df == 0 ) { return -1; }
part1.c:      D = B-> D;
part1.c:      wd = B-> width;
part1.c:      ln = B-> lngth;
part1.c:      xgap = B-> xgap;
part1.c:      ygap = B-> ygap;
part1.c:      butn = B-> buts;
part1.c:      nb = -1;
part1.c:      for ( j = 0;j < ( B-> ny ) ;j++ ) {
part1.c://     yy=B->y1+D->yo+ygap/2+j*(ygap+wd);
part1.c:          for ( i = 0; i < ( B-> nx ) ;i++ ) {
part1.c://         xx=B->x1+D->xo+xgap/2+i*(ln+xgap);
part1.c:                  xd = xpo-xx;yd = ypo-yy;
part1.c:                  if ( ( ( xd* ( xd-ln ) ) <= 0 ) && ( ( yd* ( yd-wd ) ) <= 0 ) ) {
part1.c:                      _dv_draw_button ( B , nb , -1 ) ;
part1.c:                       ( B-> bval ) = df;
part1.c:      if ( df == 0 ) { return -1; }
part1.c:      df = -1;
part1.c:      df = -1;
part1.c:      df = -1;
part1.c:          df = * ( B-> df ) ;
part1.c:      df = -1;
part1.c:          df = ( B-> bval ) ;
part1.c:      df = -1;
part1.c:          df = * ( B-> df ) ;
part1.c:      D = ( DIALOG * ) ( w-> D ) ;
part1.c:      x1 = w-> x2-w-> width-w-> offset+D-> xo;
part1.c:      yoff = ( w-> y2+w-> y1 ) *0.5;
part1.c:      y1 = D-> yo+yoff-w-> width*.5;
part1.c:      x2 = x1+w-> width;
part1.c:      y2 = y1+w-> width;
part1.c:          ( PON_Y ) ) || ( y2 < ( PON_Y ) ) ) ) {return -1;}
part1.c:      y1 = D-> evgay-y1;y2 = D-> evgay-y2;
part1.c:      gc = D-> gc;
part1.c:      br = w-> bwsr;
part1.c:      m = br-> menu;
part1.c:      * ( w-> df ) = br-> df;
part1.c:      return ( br-> df ) ;
part1.c:      df = -1;
part1.c:          df = * ( w-> df ) ;
part1.c:      df = -1;
part1.c:          df = sptr-> df;
part1.c:      df = -1;
part1.c:          df = sptr-> df;
part1.c:      sptr = B-> sptr;
part1.c:      df = -1;
part1.c:          df = sptr-> df;
part1.c:      int ok = -1 , NOK = 1 , item;
part1.c:      int ans , df = -1;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item;
part1.c:      int ans , df = -1;
part1.c:      br = x-> bwsr;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item;
part1.c:      int ans , df = -1;
part1.c:      br = x-> bwsr;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item;
part1.c:      int ans , df = -1;
part1.c:      br = x-> bwsr;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item , ret = -1;
part1.c:      int ans , df = -1;
part1.c:      br = y-> bwsr;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item , ret = -1 , k;
part1.c:      int ans , df = -1;
part1.c:      D = t-> D;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:      elmt = t-> elmt;
part1.c:      tx = t-> tstr;
part1.c:      k = tx-> row*tx-> nx+tx-> col;
part1.c:                      elmt [ k ] .hxs = xo-elmt [ k ] .x1;
part1.c:                      elmt [ k ] .hxe = xe-elmt [ k ] .x1;
part1.c:                      elmt [ k ] .hxs = xe-elmt [ k ] .x1;
part1.c:                      elmt [ k ] .hxe = xo-elmt [ k ] .x1;
part1.c:              if ( WC ( D ) -> Pstr != NULL ) free ( WC ( D ) -> Pstr ) ;
part1.c:              WC ( D ) -> Pstr = str;
part1.c:      int ok = -1 , NOK = 1 , item , ret = -1;
part1.c:      int ans , df = -1;
part1.c:      D = y-> D;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:      int ok = -1 , NOK = 1 , item , ret = -1;
part1.c:      int ans , df = -1;
part1.c:      D = y-> D;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:      int ok = -1 , NOK = 1 , item , ret = -1;
part1.c:      int ans , df = -1;
part1.c:      br = y-> bwsr;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item , ret = -1;
part1.c:      int ans , df = -1;
part1.c:      br = y-> bwsr;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c:              if ( ok == 0 ) br-> df = item;
part1.c://  if(item!=br->df) ok = br->df;
part1.c:      int ok = -1 , NOK = 1 , item;
part1.c:      int ans , df = -1;
part1.c:      D = br-> D;
part1.c:      if ( br-> menu == NULL ) return ok;
part1.c:      if ( br-> menu [ 0 ] == NULL ) return ok;
part1.c:      item = br-> df;
part1.c:      D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part1.c:      if ( kb-> event == 1 ) {
part1.c:          switch ( kb-> button ) {
part1.c:      d = D-> d;
part1.c:          ch = D-> d [ i ] .t-> code;
part1.c:              df = MousePressInButtonBox ( ( D-> d [ i ] .h ) , kbevent ) ;
part1.c:                  _uiDrawButtons_n ( ( D-> d [ i ] .h ) ) ;
part1.c:               else if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:              df = MousePressInButtonBox ( ( D-> d [ i ] .N ) , kbevent ) ;
part1.c:                  uperr = Up_D_Btn_Box ( ( D-> d [ i ] .N-> bval ) , i , D ) ;
part1.c:                  _uiDrawButtons_n ( ( D-> d [ i ] .b ) ) ;
part1.c:               else if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:              df = MousePressInNewButtonBox ( ( D-> d [ i ] .b ) , kbevent ) ;
part1.c:                  uperr = Up_D_Bt_Box ( * ( D-> d [ i ] .b-> df ) , i , D ) ;
part1.c:                  _uiDrawButtons ( ( D-> d [ i ] .b ) ) ;
part1.c:               else if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:              df = MousePressInHBar ( ( D-> d [ i ] .H ) , kbevent ) ;
part1.c:                  _uiDrawButtons ( ( D-> d [ i ] .b ) ) ;
part1.c:               else if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:              df = MousePressInBrowser ( ( DIW * ) ( D-> d [ i ] .w ) , kbevent ) ;
part1.c:               else if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:              ret = EventInNewMenu ( D-> d [ i ] .x , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .x-> df ) ;
part1.c:               else if ( ( ret == -1 ) && ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              df = EventInV ( D-> d [ i ] .v , kbevent ) ;
part1.c:              df = EventInZ ( D-> d [ i ] .z , kbevent ) ;
part1.c:              ret = EventInY ( D-> d [ i ] .y , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .y-> df ) ;
part1.c:               else if ( ( ret == -1 ) && ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              ret = EventInCheckBox ( D-> d [ i ] .c , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .c-> df ) ;
part1.c:               else if ( ( ret == -1 ) && ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              ret = EventInRadioButton ( D-> d [ i ] .r , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .r-> df ) ;
part1.c:               else if ( ( ret == -1 ) && ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              df = MousePressInFslide ( ( S_STR * ) ( D-> d [ i ] .f-> sptr ) , kbevent ) ;
part1.c:                      ( D-> d [ i ] .f-> sptr ) ) , i , D ) ;
part1.c:               else if ( ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              df = MousePressInDslide ( ( S_STR * ) ( D-> d [ i ] .d-> sptr ) , kbevent ) ;
part1.c:                      ( D-> d [ i ] .d-> sptr ) ) , i , D ) ;
part1.c:               else if ( ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              df = MousePressInHslideBar ( ( D-> d [ i ] .B ) , kbevent ) ;
part1.c:                      ( D-> d [ i ] .B-> sptr ) ) , i , D ) ;
part1.c://       _ui_getdslidevalue((S_STR *)(D->d[i].B->sptr));
part1.c:               else if ( ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:                  ( D-> d [ i ] .t-> tstr ) , kbevent ) ;
part1.c:                  ( D-> d [ i ] .t-> tstr ) , kbevent ) ;
part1.c:              ret = EventInE ( ( D-> d [ i ] .e ) , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .e-> df ) ;
part1.c:               else if ( ( ret == -1 ) && ( D-> Callback != NULL ) ) OK = D-> Callback 
part1.c:              df = EventInMS ( D-> d [ i ] .s , kbevent ) ;
part1.c:               else if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:               if ( D-> Callback != NULL ) OK = D-> Callback 
part1.c:          if ( D-> Callback != NULL ) OK = D-> Callback ( D , & kbevent ) ;
part1.c:      df = -1;
part1.c:          df = sptr-> df;
part1.c:      df = -1;
part1.c:          df = sptr-> df;
part1.c:      sptr = B-> sptr;
part1.c:      B-> item = i;
part1.c:      D = ( DIALOG * ) B-> D;
part1.c:      df = -1;
part1.c:          df = sptr-> df;
part1.c:          if ( B-> Update == NULL ) {
part1.c:              if ( D-> Callback != NULL ) D-> Callback ( D , & ( D-> kb ) ) ;
part1.c:          d = D-> d;
part1.c:          ch = D-> d [ i ] .t-> code;
part1.c:              df = EventInTextBox ( D-> d [ i ] .t , kbevent ) ;
part1.c:              df = EventInV ( D-> d [ i ] .v , kbevent ) ;
part1.c:              df = EventInZ ( D-> d [ i ] .z , kbevent ) ;
part1.c:              df = EventInNewMenu ( D-> d [ i ] .x , kbevent ) ;
part1.c:                  bwsr = ( BRW_STR * ) ( D-> d [ i ] .x-> bwsr ) ;
part1.c:                  uperr = Up_D_NewMenu_Box ( bwsr-> df , i , D ) ;
part1.c:              df = EventInY ( D-> d [ i ] .y , kbevent ) ;
part1.c:                  bwsr = ( BRW_STR * ) ( D-> d [ i ] .y-> bwsr ) ;
part1.c:                  uperr = Up_D_Y_Box ( bwsr-> df , i , D ) ;
part1.c:              df = EventInRadioButton ( D-> d [ i ] .r , kbevent ) ;
part1.c:                  bwsr = ( BRW_STR * ) ( D-> d [ i ] .r-> bwsr ) ;
part1.c:                  uperr = Up_D_Y_Box ( bwsr-> df , i , D ) ;
part1.c:              df = EventInCheckBox ( D-> d [ i ] .c , kbevent ) ;
part1.c:                  bwsr = ( BRW_STR * ) ( D-> d [ i ] .c-> bwsr ) ;
part1.c:                  uperr = Up_D_Y_Box ( bwsr-> df , i , D ) ;
part1.c:              df = MouseDragInFslide ( ( S_STR * ) ( D-> d [ i ] .f-> sptr ) , kbevent ) ;
part1.c://         Up_Fsld_Bar(_ui_getfslidevalue((S_STR *)(D->d[i].f->sptr)),i,D);
part1.c:              df = MouseDragInDslide ( ( S_STR * ) ( D-> d [ i ] .d-> sptr ) , kbevent ) ;
part1.c://         Up_Isld_Bar(_ui_getdslidevalue((S_STR *)(D->d[i].d->sptr)),i,D);
part1.c:              df = MouseDragInHslide ( ( D-> d [ i ] .B ) , kbevent , i ) ;
part1.c://         Up_Hsld_Bar(_ui_getdslidevalue((S_STR *)(D->d[i].B->sptr)),i,D);
part1.c:              df = EventInE ( ( D-> d [ i ] .e ) , kbevent ) ;
part1.c:                  bwsr = ( BRW_STR * ) ( D-> d [ i ] .e-> bwsr ) ;
part1.c:                  uperr = Up_D_Menu_Box ( bwsr-> df , i , D ) ;
part1.c:              df = EventInMS ( D-> d [ i ] .s , kbevent ) ;
part1.c:          d = D-> d;
part1.c:          ch = D-> d [ i ] .t-> code;
part1.c: //      df = EventInMenu((BRW_STR *)(D->d[i].x->bwsr),kbevent);
part1.c: //      df = EventInMenu((BRW_STR *)(D->d[i].e->bwsr),kbevent);
part1.c://       df = EventInMsg((BRW_STR *)(D->d[i].s->bwsr),kbevent);
part1.c:      df = * ( B-> df ) ;
part1.c:      nbx = B-> nx;
part1.c:      nby = B-> ny;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          dfmt--;if ( dfmt < 0 ) dfmt = nby-1;
part1.c:          while ( ( B-> sw [ df-1 ] < 1 ) ) {
part1.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
part1.c:          * ( B-> df ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          while ( ( B-> sw [ df-1 ] < 1 ) ) {
part1.c:          * ( B-> df ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          dfrm--;if ( dfrm < 1 ) dfrm = nbx;
part1.c:          while ( ( B-> sw [ df-1 ] < 1 ) ) {
part1.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
part1.c:          * ( B-> df ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          while ( ( B-> sw [ df-1 ] < 1 ) ) {
part1.c:          * ( B-> df ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:      df = B-> bval;
part1.c:      butn = ( BUT_STR * ) B-> buts;
part1.c:      nbx = B-> nx;
part1.c:      nby = B-> ny;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          dfmt--;if ( dfmt < 0 ) dfmt = nby-1;
part1.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
part1.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
part1.c:           ( B-> bval ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
part1.c:           ( B-> bval ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          dfrm--;if ( dfrm < 1 ) dfrm = nbx;
part1.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
part1.c:              dfrm--;if ( dfrm < 1 ) dfrm = nbx;
part1.c:           ( B-> bval ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:          dfmt = ( df-1 ) /nbx;
part1.c:          dfrm = ( df-1 ) %nbx+1;
part1.c:          while ( ( butn [ df-1 ] .sw < 1 ) ) {
part1.c:           ( B-> bval ) = df;
part1.c:          uiUpdateOn ( B-> D ) ;
part1.c:          return -1;
part1.c:                       ( B-> bval ) = df;
part1.c:                      uiUpdateOn ( B-> D ) ;
part1.c:      return -1;
part1.c:      df = -1;
part1.c:          df = * ( B-> df ) ;
part1.c:      df = -1;
part1.c:          df = ( B-> bval ) ;
part1.c:      df = -1;
part1.c:          df = bt-> df;
part1.c:              uiUpdateOn ( bt-> D ) ;
part1.c:      int ans , df = -1;
part1.c:          D = ( DIALOG * ) ( w-> D ) ;
part1.c:          evgay = D-> evgay;
part1.c:          x1 = w-> x2-w-> width-w-> offset+D-> xo;
part1.c:          y1 = w-> y1+D-> yo;
part1.c:          x2 = x1+w-> width;
part1.c:          y2 = y1+w-> width;
part1.c:          br = w-> bwsr;
part1.c:          gc = D-> gc;
part1.c:          m = br-> menu;
part1.c:          return ( br-> df ) ;
part1.c:          d = D-> d;
part1.c:          ch = D-> d [ i ] .t-> code;
part1.c:              df = KeyReleaseInButtonBox ( ( D-> d [ i ] .h ) , kbevent ) ;
part1.c:                  _uiDrawButtons_n ( ( D-> d [ i ] .H ) ) ;
part1.c:              df = KeyReleaseInButtonBox ( ( D-> d [ i ] .N ) , kbevent ) ;
part1.c:                  uperr = Up_D_Btn_Box ( ( D-> d [ i ] .N-> bval ) , i , D ) ;
part1.c:                  _uiDrawButtons_n ( ( D-> d [ i ] .n ) ) ;
part1.c:              df = KeyReleaseInNewButtonBox ( ( D-> d [ i ] .n ) , kbevent ) ;
part1.c:                  uperr = Up_D_Bt_Box ( ( ( BUTS * ) D-> d [ i ] .n-> buts ) -> df , i , D ) ;
part1.c:                  _uiDrawButtons ( ( D-> d [ i ] .n ) ) ;
part1.c:              df = KeyReleaseInHBar ( ( BUTS* ) ( D-> d [ i ] .H-> buts ) , kbevent ) ;
part1.c:                  _uiDrawButtons ( ( D-> d [ i ] .n ) ) ;
part1.c:              df = EventInV ( D-> d [ i ] .v , kbevent ) ;
part1.c:              df = EventInZ ( D-> d [ i ] .z , kbevent ) ;
part1.c:              ret = EventInNewMenu ( D-> d [ i ] .x , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .x-> df ) ;
part1.c:              ret = EventInY ( D-> d [ i ] .y , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .y-> df ) ;
part1.c:              ret = EventInCheckBox ( D-> d [ i ] .c , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .c-> df ) ;
part1.c:              ret = EventInRadioButton ( D-> d [ i ] .r , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .r-> df ) ;
part1.c:              ret = EventInE ( ( D-> d [ i ] .e ) , kbevent ) ;
part1.c:                  df = * ( D-> d [ i ] .e-> df ) ;
part1.c:              df = EventInMS ( D-> d [ i ] .s , kbevent ) ;
part1.c:              df = KeyReleaseInFslide ( ( S_STR * ) ( D-> d [ i ] .f-> sptr ) , kbevent ) ;
part1.c:                      ( D-> d [ i ] .f-> sptr ) ) , i , D ) ;
part1.c:              df = KeyReleaseInDslide ( ( S_STR * ) ( D-> d [ i ] .d-> sptr ) , kbevent ) ;
part1.c:                      ( D-> d [ i ] .d-> sptr ) ) , i , D ) ;
part1.c:              df = KeyReleaseInHslide ( ( D-> d [ i ] .B ) , kbevent ) ;
part1.c:                      ( D-> d [ i ] .B-> sptr ) ) , i , D ) ;
part1.c:                  ( D-> d [ i ] .t-> tstr ) , kbevent ) ;
part1.c:                  if ( _ui_readtextbox ( ( TX_STR * ) ( D-> d [ i ] .t-> tstr ) ) < 0 ) {
part1.c:                  ( D-> d [ i ] .t-> tstr ) , kbevent ) ;
part1.c:              if ( df != -1 ) {
part1.c:                  if ( _ui_readtextbox ( ( TX_STR * ) ( D-> d [ i ] .t-> tstr ) ) < 0 ) {
part1.c:      ch = D-> d [ i ] .t-> code;
part1.c:      sprintf ( pidstr , "%-d" , pid ) ;
part1.c:          sprintf ( tmpdir , "/dev/shm/%-d*" , PID ) ;
part1.c:      else sprintf ( tmpdir , "/tmp/%-d*" , PID ) ;
part1.c:      sprintf ( pidstr , "%-d" , pid ) ;
part1.c:      d = D-> d;
part1.c:          ch = ( d [ i ] .t-> code ) ;
part1.c:              * ( d [ i ] .r-> df ) = ( ( BRW_STR * ) d [ i ] .r-> bwsr ) -> df;
part1.c:              * ( d [ i ] .c-> df ) = ( ( BRW_STR * ) d [ i ] .c-> bwsr ) -> df;
part1.c:              * ( d [ i ] .y-> df ) = ( ( BRW_STR * ) d [ i ] .y-> bwsr ) -> df;
part1.c:              * ( d [ i ] .x-> df ) = ( ( BRW_STR * ) d [ i ] .x-> bwsr ) -> df;
part1.c:              ret = ( d [ i ] .h-> bval ) ;
part1.c:              ret = * ( d [ i ] .H-> df ) ;
part1.c:              * ( d [ i ] .f-> df ) = _ui_getfslidevalue 
part1.c:                  ( ( S_STR * ) ( d [ i ] .f-> sptr ) ) ;
part1.c:              * ( d [ i ] .d-> df ) = _ui_getdslidevalue 
part1.c:                  ( ( S_STR * ) ( d [ i ] .d-> sptr ) ) ;
part1.c:              * ( d [ i ] .d-> df ) = _ui_getdslidevalue 
part1.c:                  ( ( S_STR * ) ( d [ i ] .B-> sptr ) ) ;
part1.c:              * ( d [ i ] .w-> df ) = ( ( BRW_STR * ) d [ i ] .w-> bwsr ) -> df;
part1.c:              * ( d [ i ] .e-> df ) = ( ( BRW_STR * ) d [ i ] .e-> bwsr ) -> df;
part1.c:      D-> xo = D-> yo = 10;
part1.c:      D-> xl = D-> yl = 300;
part1.c:      D-> bkup = 0;
part1.c:      D-> bor_type = 4;
part1.c:      D-> tw = D-> bw = D-> lw = D-> rw = 4;
part1.c:      D-> df = 0;
part1.c:      D-> Initfun = NULL;
part1.c:      D-> Cleanupfun = NULL;
part1.c:      D-> ResizeCallback = NULL;
part1.c:      D-> WaitCallback = NULL;
part1.c:      D-> Callback = NULL;
part1.c:      D-> kbattn = D-> butattn = 0;
part1.c:      kgDefaultGuiTheme ( & ( D-> gc ) ) ;
part1.c:      D-> fullscreen = 0;
part1.c:      D-> KILL = 0;
part1.c:      D-> SUBWIN = 0;
part1.c:      D-> PWIN = NULL;
part1.c:      D-> NoWinMngr = 0;
part1.c:      D-> Maxl = 0;
part1.c:      D-> Maxw = 0;
part1.c:      D-> ThInfo = NULL;
part1.c:// D->VerId=VER;  //yymmvvss
part1.c:// strcpy(D->name,"Kulina Designer");
part1.c:      sprintf ( D-> name , "Kulina Designer Ver. %d.%2.2d" , ( 
part1.c:          ( D-> VerId%10000 ) /100 ) , ( ( D-> VerId%100 ) ) ) ;
part1.c:      D-> Deco = D-> DrawBkgr = D-> Newwin = 1;
part1.c:      D-> Sticky = 0;
part1.c:      D-> Fixpos = D-> NoTaskBar = 0;
part1.c:      D-> transparency = 0.0;
part1.c:      D-> StackPos = 0;
part1.c:      D-> Resize = 0;
part1.c:      D-> MinWidth = 100;
part1.c:      D-> MinHeight = 100;
part1.c:      D-> wc = D-> parent = D-> pt = D-> Shapexpm = D-> SearchList = D-> GrpList = NULL;
part1.c:      D-> TotWid = 0;
part1.c:      D-> CurWid = 0;
part1.c:      D-> InputWid = -1;
part1.c:      D-> Kbrd = NULL;
part1.c:      D-> wc = wc;
part1.c:      wc-> Dsp = ( Display * ) Dsp;
part1.c:      wc-> Win = ( Window ) Win;
part1.c:      wc-> Cmap = ( Colormap ) cmap;
part1.c:      if ( Dtmp-> wc != NULL ) Free ( Dtmp-> wc ) ;
part1.c:      if ( D-> SearchList != NULL ) Dempty ( ( Dlink * ) D-> SearchList ) ;
part1.c:      Grp = ( Dlink * ) D-> GrpList;
part1.c:              if ( pt-> CleanupGrp != NULL ) pt-> CleanupGrp ( D ) ;
part1.c:              Dfree ( ( Dlink * ) pt-> wlist ) ;
part1.c:              if ( pt-> arg != NULL ) kgFreeDouble ( pt-> arg ) ;
part1.c:              pt-> arg = NULL;
part1.c:          D-> GrpList = NULL;
part1.c:      D-> SearchList = D-> GrpList = NULL;
part1.c:      switch ( D-> VerId ) {
part1.c:          kgFreeDouble ( ( void ** ) ( D-> d ) ) ;
part1.c:          D-> d = NULL;
part1.c:          if ( D-> Cleanupfun != NULL ) D-> Cleanupfun ( D ) ;
part1.c:          kgFreeDouble ( ( void ** ) ( D-> d ) ) ;
part1.c:          D-> d = NULL;
part1.c:          if ( D-> Cleanupfun != NULL ) D-> Cleanupfun ( D ) ;
part1.c:          Free ( ( D-> Kbrd ) ) ;
part1.c:          kgFreeDouble ( ( void ** ) ( D-> d ) ) ;
part1.c:          D-> d = NULL;
part1.c:          if ( D-> Cleanupfun != NULL ) D-> Cleanupfun ( D ) ;
part1.c:          kgFreeDouble ( ( void ** ) ( D-> d ) ) ;
part1.c:          D-> d = NULL;
part1.c:      Grp = ( Dlink * ) D-> GrpList;
part1.c:          D-> GrpList = Grp;
part1.c:      pt-> wlist = ( void * ) Gpt;
part1.c:      pt-> arg = NULL;
part1.c:      pt-> hide = 0;
part1.c:      pt-> CleanupGrp = NULL;
part1.c:      Grp = ( Dlink * ) D-> GrpList;
part1.c:      Gpt = ( Dlink * ) pt-> wlist;
part1.c:      Grp = ( Dlink * ) D-> GrpList;
part1.c:      Gpt = ( Dlink * ) pt-> wlist;
part1.c:      Grp = ( Dlink * ) D-> GrpList;
part1.c:      pt-> CleanupGrp = Cleanup;
part1.c:      Grp = ( Dlink * ) D-> GrpList;
part1.c:      d = D-> d;
part1.c:      d [ i-1 ] .t = ( DIT * ) Widget;
part1.c:      D-> d = d;
part1.c:      d = D-> d;
part1.c:          D-> KILL = 1000;
part1.c:      if ( D-> InputWid < 0 ) return;
part1.c:      i = D-> InputWid;
part1.c:      code = D-> d [ i ] .t-> code;
part1.c:              ( D-> d [ i ] .t-> tstr ) , kbevent ) ;
part1.c:              if ( _ui_readtextbox ( ( TX_STR * ) ( D-> d [ i ] .t-> tstr ) ) < 0 ) {
part1.c:              ( D-> d [ i ] .t-> tstr ) , kbevent ) ;
part1.c:          if ( df != -1 ) {
part1.c:              if ( _ui_readtextbox ( ( TX_STR * ) ( D-> d [ i ] .t-> tstr ) ) < 0 ) {
part2.c:   d = D->d;
part2.c:   D->tmpdir = ui_mktmpdir();
part2.c:   D->df=0;
part2.c:   pthread_mutex_init(&(D->Lock),NULL);
part2.c:   D->ThInfo = OpenThreads(getCores());
part2.c://   D->ThInfo = OpenThreads(1);
part2.c:   if((D->Newwin==1)||(D->parent==NULL)) {
part2.c:      D->Newwin=1;
part2.c:      D->bkup=0;
part2.c:      D->name[299]='\0';
part2.c:      if(D->Resize) {
part2.c:        if(D->xl < D->MinWidth) { D->MinWidth= D->xl/2; }
part2.c:        if(D->yl < D->MinHeight) { D->MinHeight= D->yl/2; }
part2.c:      D->xo=0,D->yo=0;
part2.c:   else D->bkup=1;
part2.c:   if(D->Newwin!=1) {
part2.c:     wc = Parent->wc;
part2.c:     D->wc = Parent->wc;
part2.c:     tempc=wc->c_color;
part2.c:   pthread_mutex_init(&(wc->Rlock),NULL);
part2.c:   D->evgax = WC(Parent)->EVGAX;
part2.c:   D->evgay = WC(Parent)->EVGAY;
part2.c:   if(D->SearchList==NULL) D->SearchList=(void *)Dopen();
part2.c://   if(n <= 0 ) {return -1;}
part2.c:   x2 = D->xo+D->xl,y2=D->yo+D->yl;
part2.c:   D->Hsize = Hsize;
part2.c:   if(D->StackPos==1) kgRaiseWindow(D);
part2.c:   if(D->bkup==1) kg_scr_back(D->wc, D->xo-1,D->yo-1,D->xo+D->xl+1,D->yo+D->yl+1);
part2.c:   if(D->Initfun != NULL){
part2.c:     OK=(D->Initfun(D));
part2.c:     if(D->Callback == NULL) {
part2.c:   else {if(D->Initfun==NULL) OK=1;else OK=0;}
part2.c:   oldi = D->df;
part2.c:   D->df=-1;
part2.c:   if(D->controls>1){
part2.c:        ch =  (d[i].t->code);
part2.c:          if((d[j].t->code=='H')||(d[j].t->code=='h')){hcontrols++;break;}
part2.c://   if(D->controls>0){OK=0; kbevent = kgGetEvent(Parent);} // skipping one event to clean
part2.c:   if(D->controls>0){OK=0; kgSkipEvents(D);} // skipping one event to clean
part2.c:   D->CurWid =i;
part2.c:   WaitThreads( D->ThInfo);
part2.c:   pthread_mutex_lock(&(D->Lock));
part2.c:    if(D->KILL==1000) {OK=1002;break;}
part2.c:    pthread_mutex_unlock(&(D->Lock));
part2.c:    if(D->WaitCallback != NULL) {
part2.c:          OK=D->WaitCallback(D);
part2.c:          pthread_mutex_lock(&(D->Lock));
part2.c:    pthread_mutex_lock(&(D->Lock));
part2.c:    D->kb = kbevent;
part2.c:    D->PON_X=kbevent.x; D->PON_Y=kbevent.y;
part2.c:    wc->eventback=wc->event;
part2.c:      if(D->ResizeCallback== NULL) {
part2.c:          D->xl=kbevent.x;
part2.c:          D->yl=kbevent.y;
part2.c:          D->xl = xres;
part2.c:          D->yl = yres;
part2.c:        D->ResizeCallback(D);
part2.c:      if((D->Callback != NULL)) OK=D->Callback(D,&kbevent); 
part2.c:    if(D->controls > 0) {
part2.c:          ProcessMouseMovement(D,kbevent,i,D->controls);
part2.c:         click = check_pointer_click(D,&n,D->xo,D->yo,d);
part2.c:            D->CurWid=i;
part2.c:            if((i!=oldi)&&(D->controls>1)) {
part2.c:                 ch =  (d[oldi].t->code);
part2.c:                   _ui_readtextbox((TX_STR *)(d[oldi].t->tstr));
part2.c:                   D->InputWid=oldi;
part2.c:            OK = ProcessMousePress(D,kbevent,i,hcontrols,D->controls);
part2.c:            if((D->Callback != NULL)) {
part2.c:               OK=D->Callback(D,&kbevent); 
part2.c:         OK = ProcessMousePressDrag(D,kbevent,i,hcontrols,D->controls);
part2.c:             n = D->TotWid;
part2.c:             D->CurWid=i;
part2.c:             if((i!=oldi)&&(D->controls>1)) {
part2.c:                 ch =  (d[oldi].t->code);
part2.c:                 if( (ch=='t') ||(ch=='T')){_ui_readtextbox((TX_STR *)(d[oldi].t->tstr));}
part2.c:                 D->InputWid=oldi;
part2.c:         i = D->CurWid;
part2.c:         if((i!=oldi)&&(D->controls>1)) {
part2.c:         OK = ProcessKeyRelease(D,kbevent,i,hcontrols,D->controls);
part2.c:       n= D->TotWid;
part2.c:          ch =  (d[j].t->code);
part2.c:           if(d[j].t->hide!=1) {
part2.c:            if( _ui_readtextbox((TX_STR *)(d[j].t->tstr)) < 0) {
part2.c:               OK=-1;
part2.c:      if((D->Callback != NULL)) OK=D->Callback(D,&kbevent); 
part2.c:   pthread_mutex_unlock(&(D->Lock));
part2.c:   pthread_mutex_destroy(&(D->Lock));
part2.c:   if(D->bkup==1) {
part2.c:      kg_scr_recover(D->wc); 
part2.c:   if(D->Newwin==1) {
part2.c:     ui_cleandir(D->tmpdir);
part2.c:     kgCheckAndRemoveParent(D->tmpdir);
part2.c:   if(D->Newwin) {
part2.c:     if(!WC(D)->FullScreen) {
part2.c:       pthread_cancel(WC(D)->Pth);
part2.c:       pthread_join(WC(D)->Pth,NULL);
part2.c:     Dempty(WC(D)->Clip);
part2.c://     Dempty(WC(D)->SBlist);
part2.c:     Dempty(WC(D)->TLIST);
part2.c:     free(WC(D)->kgcolors);
part2.c:     if(WC(D)->Pstr != NULL) free(WC(D)->Pstr);
part2.c:     if(WC(D)->Cstr != NULL) free(WC(D)->Cstr);
part2.c:   ui_cleandir(D->tmpdir);
part2.c:   kgCheckAndRemoveParent(D->tmpdir);
part2.c:   Free(D->tmpdir);
part2.c:   CloseThreads(D->ThInfo);
part2.c:   D->ThInfo=NULL;
part2.c:  for(i=0;i<(ls-lchk+1);i++) {
part2.c:     i=ln-1;
part2.c:     while((i>0)&&(buff[i]!='/'))i--;
part2.c:  sprintf(filter,"%-d_*",pid);
part2.c:    sprintf(dir,"/dev/shm/%-d",pid);
part2.c:      sprintf(dir,"/tmp/%-d",pid);
part2.c:    sprintf(dirname,"%-s/%-d",dir,entry);
part2.c:    sprintf(dir,"/tmp/%-d",pid);
part2.c:    sprintf(dirname,"%-s_%-d",dir,entry);
part2.c:    while(isdigit(*cpt)||(*cpt=='.')||(*cpt=='-')){ cpt++; }
part2.c:       /*value.c= va_arg(ad,char );*/ /* 14-2-2001 */
part2.c:       value.c= va_arg(ad,int ); /* 14-2-2001 */
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  Ti = Tstr->tit;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  e = T->elmt;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  e = T->elmt;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  e = T->elmt;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  e = T->elmt;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  e = T->elmt;
part2.c:  Tstr = (TX_STR *)(T->tstr);
part2.c:  e = T->elmt;
part2.c:  e = T->elmt;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  uiinfo_wprintf((DIALOG *)Tmp,I->twin,str);
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  if(I->code=='i') {
part2.c:    if(I->hide==1) return 0;
part2.c:    uiinfo_wprintf((DIALOG *)Tmp,I->twin,str);
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return E->menu[B->df-1];
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return B->df;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  B->df = df;
part2.c:  return B->df;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return B->menu;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  B->menu = list;
part2.c:  E->menu = list;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  S->menu = list;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(S->bwsr);
part2.c:  return B->menu;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  E->menu = list;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return E->menu;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  E->xpm = img;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  cpt = (char *) E->xpm;
part2.c:  img = (JPGIMG *)E->xpm;
part2.c:  p->xpm = img;
part2.c:  cpt =(char *) p->xpm;
part2.c:  uiFreeImage(p->xpm);
part2.c:  p->xpm=NULL;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  v[0]= G->vxmin;
part2.c:  v[1]= G->vymin;
part2.c:  v[2]= G->vxmax;
part2.c:  v[3]= G->vymax;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c://  m->msg = msg;
part2.c:  strncpy(m->msg,msg,499);
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c://  m->msg = msg;
part2.c:  if(m->hide==1) return 0;
part2.c:  if( (m->code=='M') ||(m->code=='m') ||(m->code=='B')) {
part2.c:   strncpy(m->msg,msg,499);
part2.c:  switch(m->code) {
part2.c:   if(m->hide==1) return 0;
part2.c:   strncpy(m->msg,msg,499);
part2.c:   kgUpdateOn(m->D);
part2.c:	   menu = s->menu;
part2.c:	   s->menu  = menu;
part2.c:	   kgUpdateOn(s->D);
part2.c:   if(I->hide==1) return 0;
part2.c:   uiinfo_wprintf((DIALOG *)I->D,I->twin,msg);
part2.c:   kgUpdateOn(I->D);
part2.c:  switch(X->code) {
part2.c:    df = *(X->df);
part2.c:    df = *(E->df);
part2.c:    df = *(W->df);
part2.c:  switch(X->code) {
part2.c:    *(X->df)=val;;
part2.c:    df = *(X->df);
part2.c:    *(E->df)=val;
part2.c:    df = *(E->df);
part2.c:    *(W->df)=val;
part2.c:    df = *(W->df);
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  list = (ThumbNail **)E->list;
part2.c:  return list[B->df-1]->name;
part2.c:  switch(X->code) {
part2.c:    df = *(X->df)-1;
part2.c:    list = (ThumbNail **)X->list;
part2.c:      return list[df]->name;
part2.c:    df = *(E->df)-1;
part2.c:    m = (char **)((DIE *)E)->menu;
part2.c:    df = *(W->df)-1;
part2.c:    m = (char **)W->menu;
part2.c:  switch(X->code) {
part2.c:    df = *(X->df)-1;
part2.c:    list = (ThumbNail **)X->list;
part2.c:    df = *(E->df)-1;
part2.c:    m = (char **)((DIE *)E)->menu;
part2.c:    df = *(W->df)-1;
part2.c:    m = (char **)W->menu;
part2.c:  switch(X->code) {
part2.c:    X->list=list;
part2.c:    X->nitems= nitems;
part2.c:    *(X->df) = 0;
part2.c:    X->list=list;
part2.c:    X->nitems= nitems;
part2.c:    X->list=list;
part2.c:    X->nitems= nitems;
part2.c:    *(X->df) = 0;
part2.c:    E->menu= (char **)list;
part2.c:    W->menu=(char **)list;
part2.c:  switch(X->code) {
part2.c:	    list = (ThumbNail **)X->list;
part2.c:  switch(X->code) {
part2.c:	    list = (ThumbNail **)X->list;
part2.c:	    return list[item]->name;
part2.c:  switch(X->code) {
part2.c:	    list = (ThumbNail **)X->list;
part2.c:	    return list[item]->img;
part2.c:  switch(X->code) {
part2.c:	    list = (ThumbNail **)X->list;
part2.c:	    list[item]->img=img;
part2.c:  switch(X->code) {
part2.c:	    list = (ThumbNail **)X->list;
part2.c:	    list[item]->name=(char *)malloc(strlen(name)+1);
part2.c:	    strcpy(list[item]->name,name);
part2.c:	thret->name = NULL;
part2.c:	thret->img = NULL;
part2.c:	thret->sw = th->sw;
part2.c:	thret->id = th->id;
part2.c:	thret->state = th->state;
part2.c:	if (th->name != NULL) {
part2.c:		thret->name=(char *)malloc(strlen(th->name)+1);
part2.c:		strcpy(thret->name,th->name);
part2.c:	if(th->img != NULL) {
part2.c:		thret->img= kgCopyImage(th->img);
part2.c:	if(th->img != NULL) uiFreeImage(th->img);
part2.c:        if(th->name!= NULL) free(th->name);
part2.c:	if(th->img != NULL) uiFreeImage(th->img);
part2.c:        if(th->name!= NULL) free(th->name);
part2.c:           kgAddThumbNail(wid,kgPickThumbNail(wid,item),pos-1);
part2.c:	if(p->code != 'p') return NULL;
part2.c:	p->xpm = img;
part2.c:	if(p->code != 'p') return NULL;
part2.c:	img = p->xpm;
part2.c:	ret = strcmp(th1->name,th2->name);
part2.c://	printf("%s : %s :ret = %d\n",th1->name,th2->name,ret);
part2.c:	ret = strcmp(th1->name,th2->name);
part2.c:  switch(X->code) {
part2.c:    df = *(X->df)-1;
part2.c:    list = (ThumbNail **)X->list;
part2.c:    df = list[item]->sw;
part2.c:  switch(X->code) {
part2.c:      if(((X->type)%10)>0) {
part2.c:      df = *(X->df)-1;
part2.c:      list = (ThumbNail **)X->list;
part2.c:      list[item]->sw=val;
part2.c:      df = list[item]->sw;
part2.c:      list = (ThumbNail **)X->list;
part2.c:      list[item]->sw=val;
part2.c:    if(((X->type)%10)>0) {
part2.c:      df = *(X->df)-1;
part2.c:      list = (ThumbNail **)X->list;
part2.c:      list[item]->sw=val;
part2.c:      df = list[item]->sw;
part2.c:      list = (ThumbNail **)X->list;
part2.c:      list[item]->sw=val;
part2.c:    df = *(X->df)-1;
part2.c:    list = (ThumbNail **)X->list;
part2.c:    list[item]->sw=val;
part2.c:    df = list[item]->sw;
part2.c:	switch (V->code) {
part2.c:			V->ds=percent;
part2.c:	switch (V->code) {
part2.c:			V->df=percent;
part2.c:	switch (V->code) {
part2.c:			return V->df;
part2.c:	switch (V->code) {
part2.c:			return V->ds;
part2.c:	*xsize = T->x2 -T->x1;
part2.c:	*ysize = T->y2 -T->y1;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return B->df;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  if(df > E->nitems) df=E->nitems;
part2.c:  B->df = df;
part2.c:  *(E->df) = df;
part2.c:  return B->df;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  return E->list;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  E->list = list;
part2.c:  if(E->nx< 1) E->nx=1;
part2.c:  E->ny=ny/E->nx;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  if(E->nx<1 ) E->nx=1;
part2.c:  return E->nitems;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  switch(E->code) {
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  uiFreeThumbNails((ThumbNail **)E->list);
part2.c:  E->list=NULL;
part2.c:  return (void *) (D->d[id].x);
part2.c:  return (void *) (D->d[id].x);
part2.c:  return kgGetWidget(Tmp,D->CurWid);
part2.c:  if( ret )D->CurWid=Wid;
part2.c:  if( ret )D->df=Wid;
part2.c:  return kgGetWidgetName(Tmp,D->CurWid);
part2.c: kb = D->kb;
part2.c: d = D->d;
part2.c: if(x1 <D->xo) return NULL;
part2.c: if(x1 >(D->xo+D->xl)) return NULL;
part2.c: if(y1 <D->yo) return NULL;
part2.c: if(y1 >(D->yo+D->yl)) return NULL;
part2.c: xo = D->xo;
part2.c: yo = D->yo;
part2.c:   if( uiCheckClickPosition(d[i].t->x1+xo,d[i].t->y1+yo,d[i].t->x2+xo,
part2.c:               d[i].t->y2+yo,x1,y1) ==1) {wid = (void *)d[i].t; break;}
part2.c: kb = D->kb;
part2.c: d = D->d;
part2.c: *x= -1;*y=-1;
part2.c: *x = x1 - D->xo;
part2.c: *y = y1 - D->yo;
part2.c:		*x1 = T->x1;
part2.c:		*y1 = T->y1;
part2.c: kb = D->kb;
part2.c: d = D->d;
part2.c: if(x1 <D->xo) return NULL;
part2.c: if(x1 >(D->xo+D->xl)) return NULL;
part2.c: if(y1 <D->yo) return NULL;
part2.c: if(y1 >(D->yo+D->yl)) return NULL;
part2.c: xo = D->xo;
part2.c: yo = D->yo;
part2.c: for(i=n-1;i>=0;i--) {
part2.c:   if( uiCheckClickPosition(d[i].t->x1+xo,d[i].t->y1+yo,d[i].t->x2+xo,
part2.c:               d[i].t->y2+yo,x1,y1) ==1) {wid = (void *)d[i].t; break;}
part2.c:  switch(x->code) {
part2.c:      x->hide = hide;
part2.c:      ((DIO *)x)->hide=hide;
part2.c:  switch(x->code) {
part2.c:      hide = x->hide;
part2.c:      hide =((DIO *)x)->hide;
part2.c:  switch(x->code) {
part2.c:      hide = x->hide;
part2.c:      hide = ((DIV *)x)->hide;
part2.c:      hide = ((DIZ *)x)->hide;
part2.c:      hide = ((DIO *)x)->hide;
part2.c:      hide = ((DIP *)x)->hide;
part2.c:      hide = ((DII *)x)->hide;
part2.c:         hide = ((DIT *)x)->hide;
part2.c:         hide = ((DIL *)x)->hide;
part2.c:         hide = ((DILN *)x)->hide;
part2.c:         hide = ((DIN *)x)->hide;
part2.c:         hide = ((DIBN *)x)->hide;
part2.c:         hide = ((DIF *)x)->hide;
part2.c:         hide = ((DIHB *)x)->hide;
part2.c:         hide = ((DID *)x)->hide;
part2.c:         hide =  ((DIW *)x)->hide;
part2.c:         hide = ((DIE *)x)->hide;
part2.c:         hide = ((DIS *)x)->hide;
part2.c:         hide = ((DIG *)x)->hide;
part2.c:         hide = ((DIM *)x)->hide;
part2.c:  switch(x->code) {
part2.c:      hideo = x->hide;
part2.c:      x->hide = hide;
part2.c:      D= (DIALOG *)(x->D);
part2.c:      hideo = ((DIV *)x)->hide;
part2.c:      ((DIV *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIV *)x)->D);
part2.c:      hideo = ((DIZ *)x)->hide;
part2.c:      ((DIZ *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIZ *)x)->D);
part2.c:      hideo = ((DIO *)x)->hide;
part2.c:      ((DIO *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DID *)x)->D);
part2.c:      hideo = ((DIP *)x)->hide;
part2.c:      ((DIP *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIP *)x)->D);
part2.c:      hideo = ((DII *)x)->hide;
part2.c:      ((DII *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DII *)x)->D);
part2.c:         hideo = ((DIT *)x)->hide;
part2.c:         ((DIT *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIT *)x)->D);
part2.c:         hideo = ((DIL *)x)->hide;
part2.c:         ((DIL *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIL *)x)->D);
part2.c:         hideo = ((DILN *)x)->hide;
part2.c:         ((DILN *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DILN *)x)->D);
part2.c:         hideo = ((DIN *)x)->hide;
part2.c:         ((DIN *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIN *)x)->D);
part2.c:         hideo = ((DIB *)x)->hide;
part2.c:         ((DIB *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIB *)x)->D);
part2.c:          hideo = ((DIBN *)x)->hide;
part2.c:         ((DIBN *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIBN *)x)->D);
part2.c:          hideo = ((DIF *)x)->hide;
part2.c:          ((DIF *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIF *)x)->D);
part2.c:          hideo = ((DIHB *)x)->hide;
part2.c:          ((DIHB *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIHB *)x)->D);
part2.c:           hideo = ((DID *)x)->hide;
part2.c:           ((DID *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DID *)x)->D);
part2.c:           hideo = ((DIW *)x)->hide;
part2.c:           ((DIW *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIW *)x)->D);
part2.c:           hideo = ((DIE *)x)->hide;
part2.c:           ((DIE *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIE *)x)->D);
part2.c:           hideo = ((DIS *)x)->hide;
part2.c:           ((DIS *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIS *)x)->D);
part2.c:           hideo = ((DIG *)x)->hide;
part2.c:           ((DIG *)x)->hide=hide;
part2.c:           hideo = ((DIM *)x)->hide;
part2.c:          ((DIM *)x)->hide=hide;
part2.c:      D= (DIALOG *)(((DIM *)x)->D);
part2.c:  switch(x->code) {
part2.c:         return x->Wid ;
part2.c:         return ((DIV *)x)->Wid ;
part2.c:         return ((DIZ *)x)->Wid ;
part2.c:         return ((DIO *)x)->Wid ;
part2.c:         return ((DIP *)x)->Wid ;
part2.c:         return ((DII *)x)->Wid ;
part2.c:         return ((DIT *)x)->Wid ;
part2.c:         return ((DIL *)x)->Wid ;
part2.c:         return ((DILN *)x)->Wid ;
part2.c:         return ((DIBN *)x)->Wid ;
part2.c:         return ((DIB *)x)->Wid ;
part2.c:         return ((DIF *)x)->Wid;
part2.c:         return ((DIHB *)x)->Wid ;
part2.c:         return ((DID *)x)->Wid ;
part2.c:         return ((DIW *)x)->Wid ;
part2.c:         return ((DIE *)x)->Wid ;
part2.c:         return ((DIS *)x)->Wid ;
part2.c:         return ((DIG *)x)->Wid ;
part2.c:         return ((DIM *)x)->Wid ;
part2.c:  d = D->d;
part2.c:    switch(x->code) {
part2.c:         if(strcmp(x->Wid ,id)==0) return (void *)x;
part2.c:         if(strcmp(((DIV *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIZ *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIO *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIP *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DII *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIT *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIL *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DILN *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIN *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIB *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIF *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIHB *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DID *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIW *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIE *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIS *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIG *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:         if(strcmp(((DIM *)x)->Wid ,id)==0 ) return (void *)x;
part2.c:  switch(x->code) {
part2.c:         if(strcmp(x->Wid ,name)==0) return 1;
part2.c:         if(strcmp(((DIV *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIZ *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIO *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIP *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DII *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIT *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIL *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DILN *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIN *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIB *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIF *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIHB *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DID *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIW *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIE *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIS *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIG *)x)->Wid ,name)==0 ) return 1;
part2.c:         if(strcmp(((DIM *)x)->Wid ,name)==0 ) return 1;
part2.c: Grp = (Dlink *)D->GrpList;
part2.c: Gpt = (Dlink *)pt->wlist;
part2.c: pt->hide=hide;
part2.c://  printf("Code = %c\n",x->code);
part2.c:  switch(x->code) {
part2.c:      hideo = x->hide;
part2.c:      x->hide = hide;
part2.c:      hideo = x->hide;
part2.c:      x->hide = hide;
part2.c:      hideo = x->hide;
part2.c:      x->hide = hide;
part2.c:      hideo = x->hide;
part2.c:      x->hide = hide;
part2.c:      hideo = ((DIV *)x)->hide;
part2.c:      ((DIV *)x)->hide=hide;
part2.c:      hideo = ((DIZ *)x)->hide;
part2.c:      ((DIZ *)x)->hide=hide;
part2.c:      hideo = ((DIO *)x)->hide;
part2.c:      ((DIO *)x)->hide=hide;
part2.c:      hideo = ((DIP *)x)->hide;
part2.c:      ((DIP *)x)->hide=hide;
part2.c:      hideo = ((DII *)x)->hide;
part2.c:      ((DII *)x)->hide=hide;
part2.c:      hideo = ((DIT *)x)->hide;
part2.c:      ((DIT *)x)->hide=hide;
part2.c:      hideo = ((DIT *)x)->hide;
part2.c:      ((DIT *)x)->hide=hide;
part2.c:      hideo = ((DIL *)x)->hide;
part2.c:      ((DIL *)x)->hide=hide;
part2.c:      hideo = ((DILN *)x)->hide;
part2.c:      ((DILN *)x)->hide=hide;
part2.c:      hideo = ((DIN *)x)->hide;
part2.c:      ((DIN *)x)->hide=hide;
part2.c:      hideo = ((DIB *)x)->hide;
part2.c:      ((DIB *)x)->hide=hide;
part2.c:      hideo = ((DIBN *)x)->hide;
part2.c:      ((DIB *)x)->hide=hide;
part2.c:      hideo = ((DIF *)x)->hide;
part2.c:      ((DIF *)x)->hide=hide;
part2.c:      hideo = ((DIHB *)x)->hide;
part2.c:      ((DIHB *)x)->hide=hide;
part2.c:      hideo = ((DID *)x)->hide;
part2.c:      ((DID *)x)->hide=hide;
part2.c:      hideo = ((DIW *)x)->hide;
part2.c:      ((DIW *)x)->hide=hide;
part2.c:      hideo = ((DIE *)x)->hide;
part2.c:      ((DIE *)x)->hide=hide;
part2.c:      hideo = ((DIS *)x)->hide;
part2.c:      ((DIS *)x)->hide=hide;
part2.c:      hideo = ((DIG *)x)->hide;
part2.c:      ((DIG *)x)->hide=hide;
part2.c:      hideo = ((DIM *)x)->hide;
part2.c:      ((DIM *)x)->hide=hide;
part2.c:   if( (D->wc != NULL) &&(D->TotWid> 0) ) {
part2.c:      xl = x->x2 - x->x1;\
part2.c:      yl = x->y2 - x->y1;\
part2.c:      x->x1 =x1; x->y1=y1;\
part2.c:      x->x2 = x1+xl; x->y2 = y1+yl;\
part2.c:      x->hide=0;\
part2.c:      xl = x->x2 - x->x1;\
part2.c:      yl = x->y2 - x->y1;\
part2.c:      x->x1 =x1; x->y1=y1;\
part2.c:      x->x2 = x1+xl; x->y2 = y1+yl;\
part2.c:      x->x1 +=xl; x->y1+=yl;\
part2.c:      x->x2 += xl; x->y2 += yl;\
part2.c:  if(T->item==-1) return;
part2.c:  n = T->nx*T->ny;
part2.c:  elmt = T->elmt;
part2.c:  if(b->item==-1) return;
part2.c:  n = b->nx*b->ny;
part2.c:  buts = (BUT_STR *)(b->buts);
part2.c: Grp = (Dlink *)D->GrpList;
part2.c: Gpt = (Dlink *)pt->wlist;
part2.c:  if(x->D!=Tmp) {WMOVE_(x);continue;}
part2.c:  switch(x->code) {
part2.c:      x->hide=1;
part2.c:      FreeImg( ((DIX *)(x))->Bimg);
part2.c:       r->hide=1;
part2.c:      FreeImg( ((DIRA *)(x))->Bimg);
part2.c:       c->hide=1;
part2.c:      FreeImg( ((DICH *)(x))->Bimg);
part2.c:       y->hide=1;
part2.c:       FreeImg( ((DIY *)(x))->Bimg);
part2.c:      v->hide=1;
part2.c:       FreeImg( ((DIV *)(x))->Bimg);
part2.c:      z->hide=1;
part2.c:       FreeImg( ((DIZ *)(x))->Bimg);
part2.c:      o->hide=1;
part2.c:       FreeImg( ((DIO *)(x))->Bimg);
part2.c:      p->hide=1;
part2.c:       FreeImg( ((DIP *)(x))->Bimg);
part2.c:      I->hide=1;
part2.c:       FreeImg( ((DII *)(x))->Bimg);
part2.c:      T->hide=1;
part2.c:       FreeImg( ((DIT *)(x))->Bimg);
part2.c:      T->hide=1;
part2.c:       FreeImg( ((DIT *)(x))->Bimg);
part2.c:      H->hide=1;
part2.c:       FreeImg( ((DIL *)(x))->Bimg);
part2.c:      h->hide=1;
part2.c:       FreeImg( ((DILN *)(x))->Bimg);
part2.c:      n->hide=1;
part2.c:       FreeImg( ((DIBN *)(x))->Bimg);
part2.c:      N->hide=1;
part2.c:       FreeImg( ((DIN *)(x))->Bimg);
part2.c:      b->hide=1;
part2.c:       FreeImg( ((DIBN *)(x))->Bimg);
part2.c:      f->hide=1;
part2.c:       FreeImg( ((DIF *)(x))->Bimg);
part2.c:      P->hide=1;
part2.c:       FreeImg( ((DIHB *)(x))->Bimg);
part2.c:      d->hide=1;
part2.c:       FreeImg( ((DID *)(x))->Bimg);
part2.c:      w->hide=1;
part2.c:       FreeImg( ((DIW *)(x))->Bimg);
part2.c:      e->hide=1;
part2.c:       FreeImg( ((DIE *)(x))->Bimg);
part2.c:      s->hide=1;
part2.c:       FreeImg( ((DIS *)(x))->Bimg);
part2.c:      g->hide=1;
part2.c:       FreeImg( ((DIG *)(x))->Bimg);
part2.c:      m->hide=1;
part2.c:       FreeImg( ((DIM *)(x))->Bimg);
part2.c:      x->x2 = x->x1+xl; x->y2 = x->y1+yl;\
part2.c:      x->hide=0;\
part2.c:      x->x2 = x->x1+xl; x->y2 = x->y1+yl;\
part2.c: Grp = (Dlink *)D->GrpList;
part2.c: Gpt = (Dlink *)pt->wlist;
part2.c: if(x->D!=Tmp) {WRESIZE_(x);continue;}
part2.c:  switch(x->code) {
part2.c:      x->hide=1;
part2.c:       r->hide=1;
part2.c:       c->hide=1;
part2.c:       y->hide=1;
part2.c:      v->hide=1;
part2.c:      z->hide=1;
part2.c:      o->hide=1;
part2.c:      p->hide=1;
part2.c:      I->hide=1;
part2.c:      T->hide=1;
part2.c:      T->hide=1;
part2.c:      H->hide=1;
part2.c:      h->hide=1;
part2.c:      n->hide=1;
part2.c:      N->hide=1;
part2.c:      b->hide=1;
part2.c:      f->hide=1;
part2.c:      P->hide=1;
part2.c:      d->hide=1;
part2.c:      w->hide=1;
part2.c:      e->hide=1;
part2.c:      s->hide=1;
part2.c:      g->hide=1;
part2.c:      m->hide=1;
part2.c: Grp = (Dlink *)D->GrpList;
part2.c: Gpt = (Dlink *)pt->wlist;
part2.c:   x->x1 +=xs;
part2.c:   x->y1 +=ys;
part2.c:   x->x2 +=xs;
part2.c:   x->y2 +=ys;
part2.c: if(x->D!= Tmp) {
part2.c:  switch(x->code) {
part2.c:      x->hide=1;
part2.c:       r->hide=1;
part2.c:       c->hide=1;
part2.c:       y->hide=1;
part2.c:      v->hide=1;
part2.c:      z->hide=1;
part2.c:      o->hide=1;
part2.c:      p->hide=1;
part2.c:      I->hide=1;
part2.c:      T->hide=1;
part2.c:      T->hide=1;
part2.c:      H->hide=1;
part2.c:      h->hide=1;
part2.c:      n->hide=1;
part2.c:      N->hide=1;
part2.c:      b->hide=1;
part2.c:      f->hide=1;
part2.c:      P->hide=1;
part2.c:      d->hide=1;
part2.c:      w->hide=1;
part2.c:      e->hide=1;
part2.c:      s->hide=1;
part2.c:      g->hide=1;
part2.c:      m->hide=1;
part2.c: x1 = x->x1+xs;
part2.c: y1 = x->y1+ys;
part2.c: if(x->D!= Tmp) {
part2.c:  switch(x->code) {
part2.c:      x->hide=1;
part2.c:       r->hide=1;
part2.c:       c->hide=1;
part2.c:       y->hide=1;
part2.c:      v->hide=1;
part2.c:      z->hide=1;
part2.c:      o->hide=1;
part2.c:      p->hide=1;
part2.c:      I->hide=1;
part2.c:      T->hide=1;
part2.c:      T->hide=1;
part2.c:      H->hide=1;
part2.c:      h->hide=1;
part2.c:      n->hide=1;
part2.c:      N->hide=1;
part2.c:      b->hide=1;
part2.c:      f->hide=1;
part2.c:      P->hide=1;
part2.c:      d->hide=1;
part2.c:      w->hide=1;
part2.c:      e->hide=1;
part2.c:      s->hide=1;
part2.c:      g->hide=1;
part2.c:      m->hide=1;
part2.c:  if(x->D!=Tmp) {
part2.c:  switch(x->code) {
part2.c:      x->hide=1;
part2.c:       r->hide=1;
part2.c:       c->hide=1;
part2.c:       y->hide=1;
part2.c:      v->hide=1;
part2.c:      z->hide=1;
part2.c:      o->hide=1;
part2.c:      p->hide=1;
part2.c:      I->hide=1;
part2.c:      T->hide=1;
part2.c:      T->hide=1;
part2.c:      H->hide=1;
part2.c:      h->hide=1;
part2.c:      n->hide=1;
part2.c:      N->hide=1;
part2.c:      b->hide=1;
part2.c:      f->hide=1;
part2.c:      P->hide=1;
part2.c:      d->hide=1;
part2.c:      w->hide=1;
part2.c:      e->hide=1;
part2.c:      s->hide=1;
part2.c:      g->hide=1;
part2.c:      m->hide=1;
part2.c: Grp = (Dlink *)D->GrpList;
part2.c: Gpt = (Dlink *)pt->wlist;
part2.c: if(pt->hide == 0) {
part2.c:  switch(x->code) {
part2.c:  switch(x->code) {
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return B->df;
part2.c:  D = ((DIALOG *)Tmp)->d;
part2.c:  B = (BRW_STR *)(E->bwsr);
part2.c:  return B->menu;
part2.c:  o = D->d[id].o;
part2.c:  o->percent=val;
part2.c:  o = D->d[id].o;
part2.c:  if(hide==o->hide) return;
part2.c:  o->hide = hide;
part2.c:  D  = (DIALOG *)o->D;
part2.c:  if(o->hide) return;
part2.c:  if(val==o->oldval) return;
part2.c:  o->percent=val;
part2.c:  buts = (BUT_STR *)B->buts;
part2.c:  color = -color;
part2.c:  if(B->item != -1) {
part2.c:  buts = (BUT_STR *)B->buts;
part2.c:  if(B->item != -1) {
part2.c:  buts = (BUT_STR *)B->buts;
part2.c:  if(B->item != -1) {
part2.c:  buts = (BUT_STR *)B->buts;
part2.c:  if(B->item != -1) {
part2.c:  buts = (BUT_STR *)B->buts;
part2.c:  if(B->item != -1) {
part2.c:  buts = (BUT_STR *)B->buts;
part2.c:  switch(X->code) {
part2.c:    sptr = X->sptr;
part2.c:    *(X->df)= df;
part2.c:    df = *(X->df);
part2.c:  switch(X->code) {
part2.c:    if(val < X->min) val=X->min;
part2.c:    if(val > X->max) val=X->max;
part2.c:    *(X->df)=val;;
part2.c:    df = *(X->df);
part2.c:  switch(X->code) {
part2.c:    sptr = X->sptr;
part2.c:    *(X->df)= df;
part2.c:    df = *(X->df);
part2.c:  switch(X->code) {
part2.c:    if(val < X->min) val=X->min;
part2.c:    if(val > X->max) val=X->max;
part2.c:    *(X->df)=val;;
part2.c:    df = *(X->df);
part2.c:  switch(X->code) {
part2.c:    sptr = X->sptr;
part2.c://    *(X->df)= df;
part2.c://    df = *(X->df);
part2.c:  switch(X->code) {
part2.c:    if(val < X->min) val=X->min;
part2.c:    if(val > X->max) val=X->max;
part2.c:    *(X->df)=val;;
part2.c:    df = *(X->df);
part2.c:  pthread_mutex_lock(&(D->Lock));
part2.c:  pthread_mutex_unlock(&(D->Lock));
part2.c:  e = T->elmt;
part2.c:     ch =  (t->code);
part2.c:         Bimg=( ((DIV *)(t))->Bimg);
part2.c:         Bimg=( ((DIZ *)(t))->Bimg);
part2.c:        Bimg=( ((DIO *)(t))->Bimg);
part2.c:         Bimg=( ((DIP *)(t))->Bimg);
part2.c:         Bimg=( ((DII *)(t))->Bimg);
part2.c:         Bimg=( ((DIT *)(t))->Bimg);
part2.c:         Bimg=( ((DIT *)(t))->Bimg);
part2.c:         Bimg=( ((DIL *)(t))->Bimg);
part2.c:         Bimg=( ((DILN *)(t))->Bimg);
part2.c:         Bimg=( ((DIBN *)(t))->Bimg);
part2.c:         Bimg=( ((DIN *)(t))->Bimg);
part2.c:         Bimg=( ((DIB *)(t))->Bimg);
part2.c:         Bimg=( ((DIF *)(t))->Bimg);
part2.c:         Bimg=( ((DIHB *)(t))->Bimg);
part2.c:         Bimg=( ((DID *)(t))->Bimg);
part2.c:         Bimg=( ((DIX *)(t))->Bimg);
part2.c:         Bimg=( ((DIY *)(t))->Bimg);
part2.c:         Bimg=( ((DICH *)(t))->Bimg);
part2.c:         Bimg=( ((DIRA *)(t))->Bimg);
part2.c:         Bimg=( ((DIW *)(t))->Bimg);
part2.c:         Bimg=( ((DIE *)(t))->Bimg);
part2.c:         Bimg=( ((DIS *)(t))->Bimg);
part2.c:         Bimg=( ((DIG *)(t))->Bimg);
part2.c:         Bimg=( ((DIM *)(t))->Bimg);
part2.c:         Bimg=( ((DIM *)(t))->Bimg);
part2.c:    wc->cpCallback=cpCallback;
part2.c:    wc->cpmenu =menu;
part2.c: kb = D->kb;
part2.c: d = D->d;
part2.c: for(i=n-1;i>=0;i--) {
part2.c:   if(T->code=='t') {
part2.c:     elmt = T->elmt;
part2.c:     tx = T->tstr;
part2.c:     k = tx->row*tx->nx+tx->col;
part2.c:    if(wc->Rth==0) return 0;
part2.c:      nsize = rsize*(0.65+((rfac-0.5)/0.5)*0.35);
part2.c:  if(nsize > (rsize-8) ) nsize = rsize-8;
part2.c:  nsize = (nsize/2)*2-1;
part2.c:    if((img->image_width > (nsize))||(img->image_height >(nsize))) {
part2.c:     kgUserFrame(fid,-l,-w,l,w);
part2.c:    fid =kgInitImage(rsize-2,rsize-2,8);
part2.c:    kgUserFrame(fid,-l-2,-w-2,l+2,w+2);
part2.c:   kgRoundedRectangleFill(fid,0.,0.,2*l-4.,2*l-4.,0,151,rfac);
part2.c:   kgRoundedRectangleFill(fid,0.,0.,2*l-4.,2*l-4.,0,151,rfac);
part2.c:	return ((DIALOG *)Tmp)->pt;
part21.c:   d = D->d;
part21.c:   D->tmpdir = ui_mktmpdir();
part21.c:   D->df=0;
part21.c:   pthread_mutex_init(&(D->Lock),NULL);
part21.c:   D->ThInfo = OpenThreads(getCores());
part21.c://   D->ThInfo = OpenThreads(1);
part21.c:   if((D->Newwin==1)||(D->parent==NULL)) {
part21.c:      D->Newwin=1;
part21.c:      D->bkup=0;
part21.c:      D->name[299]='\0';
part21.c:      if(D->Resize) {
part21.c:        if(D->xl < D->MinWidth) { D->MinWidth= D->xl/2; }
part21.c:        if(D->yl < D->MinHeight) { D->MinHeight= D->yl/2; }
part21.c:      D->xo=0,D->yo=0;
part21.c:   else D->bkup=1;
part21.c:   if(D->Newwin!=1) {
part21.c:     wc = Parent->wc;
part21.c:     D->wc = Parent->wc;
part21.c:     tempc=wc->c_color;
part21.c:   pthread_mutex_init(&(wc->Rlock),NULL);
part21.c:   D->evgax = WC(Parent)->EVGAX;
part21.c:   D->evgay = WC(Parent)->EVGAY;
part21.c:   if(D->SearchList==NULL) D->SearchList=(void *)Dopen();
part21.c://   if(n <= 0 ) {return -1;}
part21.c:   x2 = D->xo+D->xl,y2=D->yo+D->yl;
part21.c:   D->Hsize = Hsize;
part21.c:   if(D->StackPos==1) kgRaiseWindow(D);
part21.c:   if(D->bkup==1) kg_scr_back(D->wc, D->xo-1,D->yo-1,D->xo+D->xl+1,D->yo+D->yl+1);
part21.c:   if(D->Initfun != NULL){
part21.c:     OK=(D->Initfun(D));
part21.c:     if(D->Callback == NULL) {
part21.c:   else {if(D->Initfun==NULL) OK=1;else OK=0;}
part21.c:   oldi = D->df;
part21.c:   D->df=-1;
part21.c:   if(D->controls>1){
part21.c:        ch =  (d[i].t->code);
part21.c:          if((d[j].t->code=='H')||(d[j].t->code=='h')){hcontrols++;break;}
part21.c://   if(D->controls>0){OK=0; kbevent = kgGetEvent(Parent);} // skipping one event to clean
part21.c:   if(D->controls>0){OK=0; kgSkipEvents(D);} // skipping one event to clean
part21.c:   D->CurWid =i;
part21.c:   WaitThreads( D->ThInfo);
part21.c:   pthread_mutex_lock(&(D->Lock));
part21.c:    if(D->KILL==1000) {OK=1002;break;}
part21.c:    pthread_mutex_unlock(&(D->Lock));
part21.c:    if(D->WaitCallback != NULL) {
part21.c:          OK=D->WaitCallback(D);
part21.c:          pthread_mutex_lock(&(D->Lock));
part21.c:    pthread_mutex_lock(&(D->Lock));
part21.c:    D->kb = kbevent;
part21.c:    D->PON_X=kbevent.x; D->PON_Y=kbevent.y;
part21.c:    wc->eventback=wc->event;
part21.c:      if(D->ResizeCallback== NULL) {
part21.c:          D->xl=kbevent.x;
part21.c:          D->yl=kbevent.y;
part21.c:          D->xl = xres;
part21.c:          D->yl = yres;
part21.c:        D->ResizeCallback(D);
part21.c:      if((D->Callback != NULL)) OK=D->Callback(D,&kbevent); 
part21.c:    if(D->controls > 0) {
part21.c:          ProcessMouseMovement(D,kbevent,i,D->controls);
part21.c:         click = check_pointer_click(D,&n,D->xo,D->yo,d);
part21.c:            D->CurWid=i;
part21.c:            if((i!=oldi)&&(D->controls>1)) {
part21.c:                 ch =  (d[oldi].t->code);
part21.c:                   _ui_readtextbox((TX_STR *)(d[oldi].t->tstr));
part21.c:                   D->InputWid=oldi;
part21.c:            OK = ProcessMousePress(D,kbevent,i,hcontrols,D->controls);
part21.c:            if((D->Callback != NULL)) {
part21.c:               OK=D->Callback(D,&kbevent); 
part21.c:         OK = ProcessMousePressDrag(D,kbevent,i,hcontrols,D->controls);
part21.c:             n = D->TotWid;
part21.c:             D->CurWid=i;
part21.c:             if((i!=oldi)&&(D->controls>1)) {
part21.c:                 ch =  (d[oldi].t->code);
part21.c:                 if( (ch=='t') ||(ch=='T')){_ui_readtextbox((TX_STR *)(d[oldi].t->tstr));}
part21.c:                 D->InputWid=oldi;
part21.c:         i = D->CurWid;
part21.c:         if((i!=oldi)&&(D->controls>1)) {
part21.c:         OK = ProcessKeyRelease(D,kbevent,i,hcontrols,D->controls);
part21.c:       n= D->TotWid;
part21.c:          ch =  (d[j].t->code);
part21.c:           if(d[j].t->hide!=1) {
part21.c:            if( _ui_readtextbox((TX_STR *)(d[j].t->tstr)) < 0) {
part21.c:               OK=-1;
part21.c:      if((D->Callback != NULL)) OK=D->Callback(D,&kbevent); 
part21.c:   pthread_mutex_unlock(&(D->Lock));
part21.c:   pthread_mutex_destroy(&(D->Lock));
part21.c:   if(D->bkup==1) {
part21.c:      kg_scr_recover(D->wc); 
part21.c:   if(D->Newwin==1) {
part21.c:     ui_cleandir(D->tmpdir);
part21.c:     kgCheckAndRemoveParent(D->tmpdir);
part21.c:   if(D->Newwin) {
part21.c:     if(!WC(D)->FullScreen) {
part21.c:       pthread_cancel(WC(D)->Pth);
part21.c:       pthread_join(WC(D)->Pth,NULL);
part21.c:     Dempty(WC(D)->Clip);
part21.c://     Dempty(WC(D)->SBlist);
part21.c:     Dempty(WC(D)->TLIST);
part21.c:     free(WC(D)->kgcolors);
part21.c:     if(WC(D)->Pstr != NULL) free(WC(D)->Pstr);
part21.c:     if(WC(D)->Cstr != NULL) free(WC(D)->Cstr);
part21.c:   ui_cleandir(D->tmpdir);
part21.c:   kgCheckAndRemoveParent(D->tmpdir);
part21.c:   Free(D->tmpdir);
part21.c:   CloseThreads(D->ThInfo);
part21.c:   D->ThInfo=NULL;
part21.c:  for(i=0;i<(ls-lchk+1);i++) {
part21.c:     i=ln-1;
part21.c:     while((i>0)&&(buff[i]!='/'))i--;
part21.c:  sprintf(filter,"%-d_*",pid);
part21.c:    sprintf(dir,"/dev/shm/%-d",pid);
part21.c:      sprintf(dir,"/tmp/%-d",pid);
part21.c:    sprintf(dirname,"%-s/%-d",dir,entry);
part21.c:    sprintf(dir,"/tmp/%-d",pid);
part21.c:    sprintf(dirname,"%-s_%-d",dir,entry);
part21.c:    while(isdigit(*cpt)||(*cpt=='.')||(*cpt=='-')){ cpt++; }
part21.c:       /*value.c= va_arg(ad,char );*/ /* 14-2-2001 */
part21.c:       value.c= va_arg(ad,int ); /* 14-2-2001 */
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  Ti = Tstr->tit;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  e = T->elmt;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  e = T->elmt;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  e = T->elmt;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  e = T->elmt;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  e = T->elmt;
part21.c:  Tstr = (TX_STR *)(T->tstr);
part21.c:  e = T->elmt;
part21.c:  e = T->elmt;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  uiinfo_wprintf((DIALOG *)Tmp,I->twin,str);
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  if(I->code=='i') {
part21.c:    if(I->hide==1) return 0;
part21.c:    uiinfo_wprintf((DIALOG *)Tmp,I->twin,str);
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  return E->menu[B->df-1];
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  return B->df;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  B->df = df;
part21.c:  return B->df;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  return B->menu;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  B->menu = list;
part21.c:  E->menu = list;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  S->menu = list;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(S->bwsr);
part21.c:  return B->menu;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  E->menu = list;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  return E->menu;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  E->xpm = img;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  cpt = (char *) E->xpm;
part21.c:  img = (JPGIMG *)E->xpm;
part21.c:  p->xpm = img;
part21.c:  cpt =(char *) p->xpm;
part21.c:  uiFreeImage(p->xpm);
part21.c:  p->xpm=NULL;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  v[0]= G->vxmin;
part21.c:  v[1]= G->vymin;
part21.c:  v[2]= G->vxmax;
part21.c:  v[3]= G->vymax;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c://  m->msg = msg;
part21.c:  strncpy(m->msg,msg,499);
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c://  m->msg = msg;
part21.c:  if(m->hide==1) return 0;
part21.c:  if( (m->code=='M') ||(m->code=='m') ||(m->code=='B')) {
part21.c:   strncpy(m->msg,msg,499);
part21.c:  switch(m->code) {
part21.c:   if(m->hide==1) return 0;
part21.c:   strncpy(m->msg,msg,499);
part21.c:   kgUpdateOn(m->D);
part21.c:	   menu = s->menu;
part21.c:	   s->menu  = menu;
part21.c:	   kgUpdateOn(s->D);
part21.c:   if(I->hide==1) return 0;
part21.c:   uiinfo_wprintf((DIALOG *)I->D,I->twin,msg);
part21.c:   kgUpdateOn(I->D);
part21.c:  switch(X->code) {
part21.c:    df = *(X->df);
part21.c:    df = *(E->df);
part21.c:    df = *(W->df);
part21.c:  switch(X->code) {
part21.c:    *(X->df)=val;;
part21.c:    df = *(X->df);
part21.c:    *(E->df)=val;
part21.c:    df = *(E->df);
part21.c:    *(W->df)=val;
part21.c:    df = *(W->df);
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  list = (ThumbNail **)E->list;
part21.c:  return list[B->df-1]->name;
part21.c:  switch(X->code) {
part21.c:    df = *(X->df)-1;
part21.c:    list = (ThumbNail **)X->list;
part21.c:      return list[df]->name;
part21.c:    df = *(E->df)-1;
part21.c:    m = (char **)((DIE *)E)->menu;
part21.c:    df = *(W->df)-1;
part21.c:    m = (char **)W->menu;
part21.c:  switch(X->code) {
part21.c:    df = *(X->df)-1;
part21.c:    list = (ThumbNail **)X->list;
part21.c:    df = *(E->df)-1;
part21.c:    m = (char **)((DIE *)E)->menu;
part21.c:    df = *(W->df)-1;
part21.c:    m = (char **)W->menu;
part21.c:  switch(X->code) {
part21.c:    X->list=list;
part21.c:    X->nitems= nitems;
part21.c:    *(X->df) = 0;
part21.c:    X->list=list;
part21.c:    X->nitems= nitems;
part21.c:    X->list=list;
part21.c:    X->nitems= nitems;
part21.c:    *(X->df) = 0;
part21.c:    E->menu= (char **)list;
part21.c:    W->menu=(char **)list;
part21.c:  switch(X->code) {
part21.c:	    list = (ThumbNail **)X->list;
part21.c:  switch(X->code) {
part21.c:	    list = (ThumbNail **)X->list;
part21.c:	    return list[item]->name;
part21.c:  switch(X->code) {
part21.c:	    list = (ThumbNail **)X->list;
part21.c:	    return list[item]->img;
part21.c:  switch(X->code) {
part21.c:	    list = (ThumbNail **)X->list;
part21.c:	    list[item]->img=img;
part21.c:  switch(X->code) {
part21.c:	    list = (ThumbNail **)X->list;
part21.c:	    list[item]->name=(char *)malloc(strlen(name)+1);
part21.c:	    strcpy(list[item]->name,name);
part21.c:	thret->name = NULL;
part21.c:	thret->img = NULL;
part21.c:	thret->sw = th->sw;
part21.c:	thret->id = th->id;
part21.c:	thret->state = th->state;
part21.c:	if (th->name != NULL) {
part21.c:		thret->name=(char *)malloc(strlen(th->name)+1);
part21.c:		strcpy(thret->name,th->name);
part21.c:	if(th->img != NULL) {
part21.c:		thret->img= kgCopyImage(th->img);
part21.c:	if(th->img != NULL) uiFreeImage(th->img);
part21.c:        if(th->name!= NULL) free(th->name);
part21.c:	if(th->img != NULL) uiFreeImage(th->img);
part21.c:        if(th->name!= NULL) free(th->name);
part21.c:           kgAddThumbNail(wid,kgPickThumbNail(wid,item),pos-1);
part21.c:	if(p->code != 'p') return NULL;
part21.c:	p->xpm = img;
part21.c:	if(p->code != 'p') return NULL;
part21.c:	img = p->xpm;
part21.c:	ret = strcmp(th1->name,th2->name);
part21.c://	printf("%s : %s :ret = %d\n",th1->name,th2->name,ret);
part21.c:	ret = strcmp(th1->name,th2->name);
part21.c:  switch(X->code) {
part21.c:    df = *(X->df)-1;
part21.c:    list = (ThumbNail **)X->list;
part21.c:    df = list[item]->sw;
part21.c:  switch(X->code) {
part21.c:      if(((X->type)%10)>0) {
part21.c:      df = *(X->df)-1;
part21.c:      list = (ThumbNail **)X->list;
part21.c:      list[item]->sw=val;
part21.c:      df = list[item]->sw;
part21.c:      list = (ThumbNail **)X->list;
part21.c:      list[item]->sw=val;
part21.c:    if(((X->type)%10)>0) {
part21.c:      df = *(X->df)-1;
part21.c:      list = (ThumbNail **)X->list;
part21.c:      list[item]->sw=val;
part21.c:      df = list[item]->sw;
part21.c:      list = (ThumbNail **)X->list;
part21.c:      list[item]->sw=val;
part21.c:    df = *(X->df)-1;
part21.c:    list = (ThumbNail **)X->list;
part21.c:    list[item]->sw=val;
part21.c:    df = list[item]->sw;
part21.c:	switch (V->code) {
part21.c:			V->ds=percent;
part21.c:	switch (V->code) {
part21.c:			V->df=percent;
part21.c:	switch (V->code) {
part21.c:			return V->df;
part21.c:	switch (V->code) {
part21.c:			return V->ds;
part21.c:	*xsize = T->x2 -T->x1;
part21.c:	*ysize = T->y2 -T->y1;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  return B->df;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  if(df > E->nitems) df=E->nitems;
part21.c:  B->df = df;
part21.c:  *(E->df) = df;
part21.c:  return B->df;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  return E->list;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  B = (BRW_STR *)(E->bwsr);
part21.c:  E->list = list;
part21.c:  if(E->nx< 1) E->nx=1;
part21.c:  E->ny=ny/E->nx;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  if(E->nx<1 ) E->nx=1;
part21.c:  return E->nitems;
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  switch(E->code) {
part21.c:  D = ((DIALOG *)Tmp)->d;
part21.c:  uiFreeThumbNails((ThumbNail **)E->list);
part21.c:  E->list=NULL;
part21.c:  return (void *) (D->d[id].x);
part21.c:  return (void *) (D->d[id].x);
part21.c:  return kgGetWidget(Tmp,D->CurWid);
part21.c:  if( ret )D->CurWid=Wid;
part21.c:  if( ret )D->df=Wid;
part21.c:  return kgGetWidgetName(Tmp,D->CurWid);
part21.c: kb = D->kb;
part21.c: d = D->d;
part21.c: if(x1 <D->xo) return NULL;
part21.c: if(x1 >(D->xo+D->xl)) return NULL;
part21.c: if(y1 <D->yo) return NULL;
part21.c: if(y1 >(D->yo+D->yl)) return NULL;
part21.c: xo = D->xo;
part21.c: yo = D->yo;
part21.c:   if( uiCheckClickPosition(d[i].t->x1+xo,d[i].t->y1+yo,d[i].t->x2+xo,
part21.c:               d[i].t->y2+yo,x1,y1) ==1) {wid = (void *)d[i].t; break;}
part21.c: kb = D->kb;
part21.c: d = D->d;
part21.c: *x= -1;*y=-1;
part21.c: *x = x1 - D->xo;
part21.c: *y = y1 - D->yo;
part21.c:		*x1 = T->x1;
part21.c:		*y1 = T->y1;
part21.c: kb = D->kb;
part21.c: d = D->d;
part21.c: if(x1 <D->xo) return NULL;
part21.c: if(x1 >(D->xo+D->xl)) return NULL;
part21.c: if(y1 <D->yo) return NULL;
part21.c: if(y1 >(D->yo+D->yl)) return NULL;
part21.c: xo = D->xo;
part21.c: yo = D->yo;
part21.c: for(i=n-1;i>=0;i--) {
part21.c:   if( uiCheckClickPosition(d[i].t->x1+xo,d[i].t->y1+yo,d[i].t->x2+xo,
part21.c:               d[i].t->y2+yo,x1,y1) ==1) {wid = (void *)d[i].t; break;}
part21.c:  switch(x->code) {
part21.c:      x->hide = hide;
part21.c:      ((DIO *)x)->hide=hide;
part21.c:  switch(x->code) {
part21.c:      hide = x->hide;
part21.c:      hide =((DIO *)x)->hide;
part21.c:  switch(x->code) {
part21.c:      hide = x->hide;
part21.c:      hide = ((DIV *)x)->hide;
part21.c:      hide = ((DIZ *)x)->hide;
part21.c:      hide = ((DIO *)x)->hide;
part21.c:      hide = ((DIP *)x)->hide;
part21.c:      hide = ((DII *)x)->hide;
part21.c:         hide = ((DIT *)x)->hide;
part21.c:         hide = ((DIL *)x)->hide;
part21.c:         hide = ((DILN *)x)->hide;
part21.c:         hide = ((DIN *)x)->hide;
part21.c:         hide = ((DIBN *)x)->hide;
part21.c:         hide = ((DIF *)x)->hide;
part21.c:         hide = ((DIHB *)x)->hide;
part21.c:         hide = ((DID *)x)->hide;
part21.c:         hide =  ((DIW *)x)->hide;
part21.c:         hide = ((DIE *)x)->hide;
part21.c:         hide = ((DIS *)x)->hide;
part21.c:         hide = ((DIG *)x)->hide;
part21.c:         hide = ((DIM *)x)->hide;
part211.c:      d = D-> d;
part211.c:      D-> tmpdir = ui_mktmpdir ( ) ;
part211.c:      D-> df = 0;
part211.c:      pthread_mutex_init ( & ( D-> Lock ) , NULL ) ;
part211.c:      D-> ThInfo = OpenThreads ( getCores ( ) ) ;
part211.c://   D->ThInfo = OpenThreads(1);
part211.c:      if ( ( D-> Newwin == 1 ) || ( D-> parent == NULL ) ) {
part211.c:          D-> Newwin = 1;
part211.c:          D-> bkup = 0;
part211.c:          D-> name [ 299 ] = '\0';
part211.c:          if ( D-> Resize ) {
part211.c:              if ( D-> xl < D-> MinWidth ) { D-> MinWidth = D-> xl/2; }
part211.c:              if ( D-> yl < D-> MinHeight ) { D-> MinHeight = D-> yl/2; }
part211.c:          D-> xo = 0 , D-> yo = 0;
part211.c:      else D-> bkup = 1;
part211.c:      if ( D-> Newwin != 1 ) {
part211.c:          wc = Parent-> wc;
part211.c:          D-> wc = Parent-> wc;
part211.c:          tempc = wc-> c_color;
part211.c:      pthread_mutex_init ( & ( wc-> Rlock ) , NULL ) ;
part211.c:      D-> evgax = WC ( Parent ) -> EVGAX;
part211.c:      D-> evgay = WC ( Parent ) -> EVGAY;
part211.c:      if ( D-> SearchList == NULL ) D-> SearchList = ( void * ) Dopen ( ) ;
part211.c://   if(n <= 0 ) {return -1;}
part211.c:      x2 = D-> xo+D-> xl , y2 = D-> yo+D-> yl;
part211.c:      D-> Hsize = Hsize;
part211.c:      if ( D-> StackPos == 1 ) kgRaiseWindow ( D ) ;
part211.c:      if ( D-> bkup == 1 ) kg_scr_back ( D-> wc , D-> xo-1 , D-> yo-1 , D-> xo+D-> xl+1 , D-> yo+D-> yl+1 ) ;
part211.c:      if ( D-> Initfun != NULL ) {
part211.c:          OK = ( D-> Initfun ( D ) ) ;
part211.c:          if ( D-> Callback == NULL ) {
part211.c:      else {if ( D-> Initfun == NULL ) OK = 1;else OK = 0;}
part211.c:      oldi = D-> df;
part211.c:      D-> df = -1;
part211.c:      if ( D-> controls > 1 ) {
part211.c:          ch = ( d [ i ] .t-> code ) ;
part211.c:              if ( ( d [ j ] .t-> code == 'H' ) || ( d [ j ] .t-> code == 'h' ) ) 
part211.c://   if(D->controls>0){OK=0; kbevent = kgGetEvent(Parent);} // skipping one event to clean
part211.c:       if ( D-> controls > 0 ) {OK = 0; kgSkipEvents 
part211.c:      D-> CurWid = i;
part211.c:      WaitThreads ( D-> ThInfo ) ;
part211.c:      pthread_mutex_lock ( & ( D-> Lock ) ) ;
part211.c:          if ( D-> KILL == 1000 ) {OK = 1002;break;}
part211.c:          pthread_mutex_unlock ( & ( D-> Lock ) ) ;
part211.c:          if ( D-> WaitCallback != NULL ) {
part211.c:                  OK = D-> WaitCallback ( D ) ;
part211.c:                  pthread_mutex_lock ( & ( D-> Lock ) ) ;
part211.c:          pthread_mutex_lock ( & ( D-> Lock ) ) ;
part211.c:          D-> kb = kbevent;
part211.c:          D-> PON_X = kbevent.x; D-> PON_Y = kbevent.y;
part211.c:          wc-> eventback = wc-> event;
part211.c:              if ( D-> ResizeCallback == NULL ) {
part211.c:                  D-> xl = kbevent.x;
part211.c:                  D-> yl = kbevent.y;
part211.c:                  D-> xl = xres;
part211.c:                  D-> yl = yres;
part211.c:                  D-> ResizeCallback ( D ) ;
part211.c:              if ( ( D-> Callback != NULL ) ) OK = D-> Callback ( D , & kbevent ) ;
part211.c:          if ( D-> controls > 0 ) {
part211.c:                  ProcessMouseMovement ( D , kbevent , i , D-> controls ) ;
part211.c:                  click = check_pointer_click ( D , & n , D-> xo , D-> yo , d ) ;
part211.c:                      D-> CurWid = i;
part211.c:                      if ( ( i != oldi ) && ( D-> controls > 1 ) ) {
part211.c:                          ch = ( d [ oldi ] .t-> code ) ;
part211.c:                              _ui_readtextbox ( ( TX_STR * ) ( d [ oldi ] .t-> tstr ) ) ;
part211.c:                              D-> InputWid = oldi;
part211.c:                      OK = ProcessMousePress ( D , kbevent , i , hcontrols , D-> controls ) ;
part211.c:                      if ( ( D-> Callback != NULL ) ) {
part211.c:                          OK = D-> Callback ( D , & kbevent ) ;
part211.c:                  OK = ProcessMousePressDrag ( D , kbevent , i , hcontrols , D-> controls ) ;
part211.c:                      n = D-> TotWid;
part211.c:                      D-> CurWid = i;
part211.c:                      if ( ( i != oldi ) && ( D-> controls > 1 ) ) {
part211.c:                          ch = ( d [ oldi ] .t-> code ) ;
part211.c:                              ( ( TX_STR * ) ( d [ oldi ] .t-> tstr ) ) ;}
part211.c:                          D-> InputWid = oldi;
part211.c:                  i = D-> CurWid;
part211.c:                  if ( ( i != oldi ) && ( D-> controls > 1 ) ) {
part211.c:                  OK = ProcessKeyRelease ( D , kbevent , i , hcontrols , D-> controls ) ;
part211.c:                  n = D-> TotWid;
part211.c:                      ch = ( d [ j ] .t-> code ) ;
part211.c:                          if ( d [ j ] .t-> hide != 1 ) {
part211.c:                              if ( _ui_readtextbox ( ( TX_STR * ) ( d [ j ] .t-> tstr ) ) < 0 ) {
part211.c:                                  OK = -1;
part211.c:              if ( ( D-> Callback != NULL ) ) OK = D-> Callback ( D , & kbevent ) ;
part211.c:      pthread_mutex_unlock ( & ( D-> Lock ) ) ;
part211.c:      pthread_mutex_destroy ( & ( D-> Lock ) ) ;
part211.c:      if ( D-> bkup == 1 ) {
part211.c:          kg_scr_recover ( D-> wc ) ;
part211.c:      if ( D-> Newwin == 1 ) {
part211.c:              ui_cleandir ( D-> tmpdir ) ;
part211.c:              kgCheckAndRemoveParent ( D-> tmpdir ) ;
part211.c:      if ( D-> Newwin ) {
part211.c:          if ( ! WC ( D ) -> FullScreen ) {
part211.c:              pthread_cancel ( WC ( D ) -> Pth ) ;
part211.c:              pthread_join ( WC ( D ) -> Pth , NULL ) ;
part211.c:          Dempty ( WC ( D ) -> Clip ) ;
part211.c://     Dempty(WC(D)->SBlist);
part211.c:          Dempty ( WC ( D ) -> TLIST ) ;
part211.c:          free ( WC ( D ) -> kgcolors ) ;
part211.c:          if ( WC ( D ) -> Pstr != NULL ) free ( WC ( D ) -> Pstr ) ;
part211.c:          if ( WC ( D ) -> Cstr != NULL ) free ( WC ( D ) -> Cstr ) ;
part211.c:      ui_cleandir ( D-> tmpdir ) ;
part211.c:      kgCheckAndRemoveParent ( D-> tmpdir ) ;
part211.c:      Free ( D-> tmpdir ) ;
part211.c:      CloseThreads ( D-> ThInfo ) ;
part211.c:      D-> ThInfo = NULL;
part211.c:      for ( i = 0;i < ( ls-lchk+1 ) ;i++ ) {
part211.c:      i = ln-1;
part211.c:      while ( ( i > 0 ) && ( buff [ i ] != '/' ) ) i--;
part211.c:      sprintf ( filter , "%-d_*" , pid ) ;
part211.c:              sprintf ( dir , "/tmp/%-d" , pid ) ;
part211.c:          sprintf ( dirname , "%-s/%-d" , dir , entry ) ;
part211.c:      sprintf ( dir , "/tmp/%-d" , pid ) ;
part211.c:      sprintf ( dirname , "%-s_%-d" , dir , entry ) ;
part211.c:              while ( isdigit ( *cpt ) || ( *cpt == '.' ) || ( *cpt == '-' ) ) { cpt++; }
part211.c:       /*value.c= va_arg(ad,char );*/ /* 14-2-2001 */
part211.c:                  value.c = va_arg ( ad , int ) ; /* 14-2-2001 */
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      Ti = Tstr-> tit;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      e = T-> elmt;
part211.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part211.c:      Tstr = ( TX_STR * ) ( T-> tstr ) ;
part211.c:      e = T-> elmt;
part22.c:      switch ( x-> code ) {
part22.c:          hideo = x-> hide;
part22.c:          x-> hide = hide;
part22.c:          D = ( DIALOG * ) ( x-> D ) ;
part22.c:          hideo = ( ( DIV * ) x ) -> hide;
part22.c:           ( ( DIV * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIV * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIZ * ) x ) -> hide;
part22.c:           ( ( DIZ * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIZ * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIO * ) x ) -> hide;
part22.c:           ( ( DIO * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DID * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIP * ) x ) -> hide;
part22.c:           ( ( DIP * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIP * ) x ) -> D ) ;
part22.c:          hideo = ( ( DII * ) x ) -> hide;
part22.c:           ( ( DII * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DII * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIT * ) x ) -> hide;
part22.c:           ( ( DIT * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIT * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIL * ) x ) -> hide;
part22.c:           ( ( DIL * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIL * ) x ) -> D ) ;
part22.c:          hideo = ( ( DILN * ) x ) -> hide;
part22.c:           ( ( DILN * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DILN * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIN * ) x ) -> hide;
part22.c:           ( ( DIN * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIN * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIB * ) x ) -> hide;
part22.c:           ( ( DIB * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIB * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIBN * ) x ) -> hide;
part22.c:           ( ( DIBN * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIBN * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIF * ) x ) -> hide;
part22.c:           ( ( DIF * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIF * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIHB * ) x ) -> hide;
part22.c:           ( ( DIHB * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIHB * ) x ) -> D ) ;
part22.c:          hideo = ( ( DID * ) x ) -> hide;
part22.c:           ( ( DID * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DID * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIW * ) x ) -> hide;
part22.c:           ( ( DIW * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIW * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIE * ) x ) -> hide;
part22.c:           ( ( DIE * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIE * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIS * ) x ) -> hide;
part22.c:           ( ( DIS * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIS * ) x ) -> D ) ;
part22.c:          hideo = ( ( DIG * ) x ) -> hide;
part22.c:           ( ( DIG * ) x ) -> hide = hide;
part22.c:          hideo = ( ( DIM * ) x ) -> hide;
part22.c:           ( ( DIM * ) x ) -> hide = hide;
part22.c:          D = ( DIALOG * ) ( ( ( DIM * ) x ) -> D ) ;
part22.c:      switch ( x-> code ) {
part22.c:          return x-> Wid ;
part22.c:          return ( ( DIV * ) x ) -> Wid ;
part22.c:          return ( ( DIZ * ) x ) -> Wid ;
part22.c:          return ( ( DIO * ) x ) -> Wid ;
part22.c:          return ( ( DIP * ) x ) -> Wid ;
part22.c:          return ( ( DII * ) x ) -> Wid ;
part22.c:          return ( ( DIT * ) x ) -> Wid ;
part22.c:          return ( ( DIL * ) x ) -> Wid ;
part22.c:          return ( ( DILN * ) x ) -> Wid ;
part22.c:          return ( ( DIBN * ) x ) -> Wid ;
part22.c:          return ( ( DIB * ) x ) -> Wid ;
part22.c:          return ( ( DIF * ) x ) -> Wid;
part22.c:          return ( ( DIHB * ) x ) -> Wid ;
part22.c:          return ( ( DID * ) x ) -> Wid ;
part22.c:          return ( ( DIW * ) x ) -> Wid ;
part22.c:          return ( ( DIE * ) x ) -> Wid ;
part22.c:          return ( ( DIS * ) x ) -> Wid ;
part22.c:          return ( ( DIG * ) x ) -> Wid ;
part22.c:          return ( ( DIM * ) x ) -> Wid ;
part22.c:      d = D-> d;
part22.c:          switch ( x-> code ) {
part22.c:              if ( strcmp ( x-> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIV * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIZ * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIO * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIP * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DII * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIT * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIL * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DILN * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIN * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIB * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIF * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIHB * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DID * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIW * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIE * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIS * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIG * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:              if ( strcmp ( ( ( DIM * ) x ) -> Wid , id ) == 0 ) return ( void * ) x;
part22.c:      switch ( x-> code ) {
part22.c:          if ( strcmp ( x-> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIV * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIZ * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIO * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIP * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DII * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIT * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIL * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DILN * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIN * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIB * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIF * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIHB * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DID * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIW * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIE * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIS * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIG * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:          if ( strcmp ( ( ( DIM * ) x ) -> Wid , name ) == 0 ) return 1;
part22.c:      Grp = ( Dlink * ) D-> GrpList;
part22.c:      Gpt = ( Dlink * ) pt-> wlist;
part22.c:      pt-> hide = hide;
part22.c://  printf("Code = %c\n",x->code);
part22.c:          switch ( x-> code ) {
part22.c:              hideo = x-> hide;
part22.c:              x-> hide = hide;
part22.c:              hideo = x-> hide;
part22.c:              x-> hide = hide;
part22.c:              hideo = x-> hide;
part22.c:              x-> hide = hide;
part22.c:              hideo = x-> hide;
part22.c:              x-> hide = hide;
part22.c:              hideo = ( ( DIV * ) x ) -> hide;
part22.c:               ( ( DIV * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIZ * ) x ) -> hide;
part22.c:               ( ( DIZ * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIO * ) x ) -> hide;
part22.c:               ( ( DIO * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIP * ) x ) -> hide;
part22.c:               ( ( DIP * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DII * ) x ) -> hide;
part22.c:               ( ( DII * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIT * ) x ) -> hide;
part22.c:               ( ( DIT * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIT * ) x ) -> hide;
part22.c:               ( ( DIT * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIL * ) x ) -> hide;
part22.c:               ( ( DIL * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DILN * ) x ) -> hide;
part22.c:               ( ( DILN * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIN * ) x ) -> hide;
part22.c:               ( ( DIN * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIB * ) x ) -> hide;
part22.c:               ( ( DIB * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIBN * ) x ) -> hide;
part22.c:               ( ( DIB * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIF * ) x ) -> hide;
part22.c:               ( ( DIF * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIHB * ) x ) -> hide;
part22.c:               ( ( DIHB * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DID * ) x ) -> hide;
part22.c:               ( ( DID * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIW * ) x ) -> hide;
part22.c:               ( ( DIW * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIE * ) x ) -> hide;
part22.c:               ( ( DIE * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIS * ) x ) -> hide;
part22.c:               ( ( DIS * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIG * ) x ) -> hide;
part22.c:               ( ( DIG * ) x ) -> hide = hide;
part22.c:              hideo = ( ( DIM * ) x ) -> hide;
part22.c:               ( ( DIM * ) x ) -> hide = hide;
part22.c:          if ( ( D-> wc != NULL ) && ( D-> TotWid > 0 ) ) {
part22.c:  xl = x-> x2 - x-> x1;\
part22.c:      yl = x-> y2 - x-> y1;\
part22.c:      x-> x1 = x1; x-> y1 = y1;\
part22.c:      x-> x2 = x1+xl; x-> y2 = y1+yl;\
part22.c:      x-> hide = 0;\
part22.c:  xl = x-> x2 - x-> x1;\
part22.c:      yl = x-> y2 - x-> y1;\
part22.c:      x-> x1 = x1; x-> y1 = y1;\
part22.c:      x-> x2 = x1+xl; x-> y2 = y1+yl;\
part22.c:  x-> x1 += xl; x-> y1+= yl;\
part22.c:      x-> x2 += xl; x-> y2 += yl;\
part22.c:      if ( T-> item == -1 ) return;
part22.c:      n = T-> nx*T-> ny;
part22.c:      elmt = T-> elmt;
part22.c:      if ( b-> item == -1 ) return;
part22.c:      n = b-> nx*b-> ny;
part22.c:      buts = ( BUT_STR * ) ( b-> buts ) ;
part22.c:      Grp = ( Dlink * ) D-> GrpList;
part22.c:      Gpt = ( Dlink * ) pt-> wlist;
part22.c:          if ( x-> D != Tmp ) {WMOVE_ ( x ) ;continue;}
part22.c:          switch ( x-> code ) {
part22.c:              x-> hide = 1;
part22.c:              FreeImg ( ( ( DIX * ) ( x ) ) -> Bimg ) ;
part22.c:              r-> hide = 1;
part22.c:              FreeImg ( ( ( DIRA * ) ( x ) ) -> Bimg ) ;
part22.c:              c-> hide = 1;
part22.c:              FreeImg ( ( ( DICH * ) ( x ) ) -> Bimg ) ;
part22.c:              y-> hide = 1;
part22.c:              FreeImg ( ( ( DIY * ) ( x ) ) -> Bimg ) ;
part22.c:              v-> hide = 1;
part22.c:              FreeImg ( ( ( DIV * ) ( x ) ) -> Bimg ) ;
part22.c:              z-> hide = 1;
part22.c:              FreeImg ( ( ( DIZ * ) ( x ) ) -> Bimg ) ;
part22.c:              o-> hide = 1;
part22.c:              FreeImg ( ( ( DIO * ) ( x ) ) -> Bimg ) ;
part22.c:              p-> hide = 1;
part22.c:              FreeImg ( ( ( DIP * ) ( x ) ) -> Bimg ) ;
part22.c:              I-> hide = 1;
part22.c:              FreeImg ( ( ( DII * ) ( x ) ) -> Bimg ) ;
part22.c:              T-> hide = 1;
part22.c:              FreeImg ( ( ( DIT * ) ( x ) ) -> Bimg ) ;
part22.c:              T-> hide = 1;
part22.c:              FreeImg ( ( ( DIT * ) ( x ) ) -> Bimg ) ;
part22.c:              H-> hide = 1;
part22.c:              FreeImg ( ( ( DIL * ) ( x ) ) -> Bimg ) ;
part22.c:              h-> hide = 1;
part22.c:              FreeImg ( ( ( DILN * ) ( x ) ) -> Bimg ) ;
part22.c:              n-> hide = 1;
part22.c:              FreeImg ( ( ( DIBN * ) ( x ) ) -> Bimg ) ;
part22.c:              N-> hide = 1;
part22.c:              FreeImg ( ( ( DIN * ) ( x ) ) -> Bimg ) ;
part22.c:              b-> hide = 1;
part22.c:              FreeImg ( ( ( DIBN * ) ( x ) ) -> Bimg ) ;
part22.c:              f-> hide = 1;
part22.c:              FreeImg ( ( ( DIF * ) ( x ) ) -> Bimg ) ;
part22.c:              P-> hide = 1;
part22.c:              FreeImg ( ( ( DIHB * ) ( x ) ) -> Bimg ) ;
part22.c:              d-> hide = 1;
part22.c:              FreeImg ( ( ( DID * ) ( x ) ) -> Bimg ) ;
part22.c:              w-> hide = 1;
part22.c:              FreeImg ( ( ( DIW * ) ( x ) ) -> Bimg ) ;
part22.c:              e-> hide = 1;
part22.c:              FreeImg ( ( ( DIE * ) ( x ) ) -> Bimg ) ;
part22.c:              s-> hide = 1;
part22.c:              FreeImg ( ( ( DIS * ) ( x ) ) -> Bimg ) ;
part22.c:              g-> hide = 1;
part22.c:              FreeImg ( ( ( DIG * ) ( x ) ) -> Bimg ) ;
part22.c:              m-> hide = 1;
part22.c:              FreeImg ( ( ( DIM * ) ( x ) ) -> Bimg ) ;
part22.c:  x-> x2 = x-> x1+xl; x-> y2 = x-> y1+yl;\
part22.c:      x-> hide = 0;\
part22.c:  x-> x2 = x-> x1+xl; x-> y2 = x-> y1+yl;\
part22.c:      Grp = ( Dlink * ) D-> GrpList;
part22.c:      Gpt = ( Dlink * ) pt-> wlist;
part22.c:          if ( x-> D != Tmp ) {WRESIZE_ ( x ) ;continue;}
part22.c:          switch ( x-> code ) {
part22.c:              x-> hide = 1;
part22.c:              r-> hide = 1;
part22.c:              c-> hide = 1;
part22.c:              y-> hide = 1;
part22.c:              v-> hide = 1;
part22.c:              z-> hide = 1;
part22.c:              o-> hide = 1;
part22.c:              p-> hide = 1;
part22.c:              I-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              H-> hide = 1;
part22.c:              h-> hide = 1;
part22.c:              n-> hide = 1;
part22.c:              N-> hide = 1;
part22.c:              b-> hide = 1;
part22.c:              f-> hide = 1;
part22.c:              P-> hide = 1;
part22.c:              d-> hide = 1;
part22.c:              w-> hide = 1;
part22.c:              e-> hide = 1;
part22.c:              s-> hide = 1;
part22.c:              g-> hide = 1;
part22.c:              m-> hide = 1;
part22.c:      Grp = ( Dlink * ) D-> GrpList;
part22.c:      Gpt = ( Dlink * ) pt-> wlist;
part22.c:          x-> x1 += xs;
part22.c:          x-> y1 += ys;
part22.c:          x-> x2 += xs;
part22.c:          x-> y2 += ys;
part22.c:      if ( x-> D != Tmp ) {
part22.c:          switch ( x-> code ) {
part22.c:              x-> hide = 1;
part22.c:              r-> hide = 1;
part22.c:              c-> hide = 1;
part22.c:              y-> hide = 1;
part22.c:              v-> hide = 1;
part22.c:              z-> hide = 1;
part22.c:              o-> hide = 1;
part22.c:              p-> hide = 1;
part22.c:              I-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              H-> hide = 1;
part22.c:              h-> hide = 1;
part22.c:              n-> hide = 1;
part22.c:              N-> hide = 1;
part22.c:              b-> hide = 1;
part22.c:              f-> hide = 1;
part22.c:              P-> hide = 1;
part22.c:              d-> hide = 1;
part22.c:              w-> hide = 1;
part22.c:              e-> hide = 1;
part22.c:              s-> hide = 1;
part22.c:              g-> hide = 1;
part22.c:              m-> hide = 1;
part22.c:      x1 = x-> x1+xs;
part22.c:      y1 = x-> y1+ys;
part22.c:      if ( x-> D != Tmp ) {
part22.c:          switch ( x-> code ) {
part22.c:              x-> hide = 1;
part22.c:              r-> hide = 1;
part22.c:              c-> hide = 1;
part22.c:              y-> hide = 1;
part22.c:              v-> hide = 1;
part22.c:              z-> hide = 1;
part22.c:              o-> hide = 1;
part22.c:              p-> hide = 1;
part22.c:              I-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              H-> hide = 1;
part22.c:              h-> hide = 1;
part22.c:              n-> hide = 1;
part22.c:              N-> hide = 1;
part22.c:              b-> hide = 1;
part22.c:              f-> hide = 1;
part22.c:              P-> hide = 1;
part22.c:              d-> hide = 1;
part22.c:              w-> hide = 1;
part22.c:              e-> hide = 1;
part22.c:              s-> hide = 1;
part22.c:              g-> hide = 1;
part22.c:              m-> hide = 1;
part22.c:          if ( x-> D != Tmp ) {
part22.c:          switch ( x-> code ) {
part22.c:              x-> hide = 1;
part22.c:              r-> hide = 1;
part22.c:              c-> hide = 1;
part22.c:              y-> hide = 1;
part22.c:              v-> hide = 1;
part22.c:              z-> hide = 1;
part22.c:              o-> hide = 1;
part22.c:              p-> hide = 1;
part22.c:              I-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              T-> hide = 1;
part22.c:              H-> hide = 1;
part22.c:              h-> hide = 1;
part22.c:              n-> hide = 1;
part22.c:              N-> hide = 1;
part22.c:              b-> hide = 1;
part22.c:              f-> hide = 1;
part22.c:              P-> hide = 1;
part22.c:              d-> hide = 1;
part22.c:              w-> hide = 1;
part22.c:              e-> hide = 1;
part22.c:              s-> hide = 1;
part22.c:              g-> hide = 1;
part22.c:              m-> hide = 1;
part22.c:      Grp = ( Dlink * ) D-> GrpList;
part22.c:      Gpt = ( Dlink * ) pt-> wlist;
part22.c:      if ( pt-> hide == 0 ) {
part22.c:              switch ( x-> code ) {
part22.c:              switch ( x-> code ) {
part22.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part22.c:      B = ( BRW_STR * ) ( E-> bwsr ) ;
part22.c:      return B-> df;
part22.c:      D = ( ( DIALOG * ) Tmp ) -> d;
part22.c:      B = ( BRW_STR * ) ( E-> bwsr ) ;
part22.c:      return B-> menu;
part22.c:      o = D-> d [ id ] .o;
part22.c:      o-> percent = val;
part22.c:      o = D-> d [ id ] .o;
part22.c:      if ( hide == o-> hide ) return;
part22.c:      o-> hide = hide;
part22.c:      D = ( DIALOG * ) o-> D;
part22.c:      if ( o-> hide ) return;
part22.c:      if ( val == o-> oldval ) return;
part22.c:      o-> percent = val;
part22.c:      buts = ( BUT_STR * ) B-> buts;
part22.c:      color = -color;
part22.c:      if ( B-> item != -1 ) {
part22.c:      buts = ( BUT_STR * ) B-> buts;
part22.c:      if ( B-> item != -1 ) {
part22.c:      buts = ( BUT_STR * ) B-> buts;
part22.c:      if ( B-> item != -1 ) {
part22.c:      buts = ( BUT_STR * ) B-> buts;
part22.c:      if ( B-> item != -1 ) {
part22.c:      buts = ( BUT_STR * ) B-> buts;
part22.c:      if ( B-> item != -1 ) {
part22.c:      buts = ( BUT_STR * ) B-> buts;
part22.c:      switch ( X-> code ) {
part22.c:          sptr = X-> sptr;
part22.c:          * ( X-> df ) = df;
part22.c:          df = * ( X-> df ) ;
part22.c:      switch ( X-> code ) {
part22.c:          if ( val < X-> min ) val = X-> min;
part22.c:          if ( val > X-> max ) val = X-> max;
part22.c:          * ( X-> df ) = val;;
part22.c:          df = * ( X-> df ) ;
part22.c:      switch ( X-> code ) {
part22.c:          sptr = X-> sptr;
part22.c:          * ( X-> df ) = df;
part22.c:          df = * ( X-> df ) ;
part22.c:      switch ( X-> code ) {
part22.c:          if ( val < X-> min ) val = X-> min;
part22.c:          if ( val > X-> max ) val = X-> max;
part22.c:          * ( X-> df ) = val;;
part22.c:          df = * ( X-> df ) ;
part22.c:      switch ( X-> code ) {
part22.c:          sptr = X-> sptr;
part22.c://    *(X->df)= df;
part22.c://    df = *(X->df);
part22.c:      switch ( X-> code ) {
part22.c:          if ( val < X-> min ) val = X-> min;
part22.c:          if ( val > X-> max ) val = X-> max;
part22.c:          * ( X-> df ) = val;;
part22.c:          df = * ( X-> df ) ;
part22.c:      pthread_mutex_lock ( & ( D-> Lock ) ) ;
part22.c:      pthread_mutex_unlock ( & ( D-> Lock ) ) ;
part22.c:      e = T-> elmt;
part22.c:          ch = ( t-> code ) ;
part22.c:              Bimg = ( ( ( DIV * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIZ * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIO * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIP * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DII * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIT * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIT * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIL * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DILN * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIBN * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIN * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIB * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIF * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIHB * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DID * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIX * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIY * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DICH * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIRA * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIW * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIE * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIS * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIG * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIM * ) ( t ) ) -> Bimg ) ;
part22.c:              Bimg = ( ( ( DIM * ) ( t ) ) -> Bimg ) ;
part22.c:      wc-> cpCallback = cpCallback;
part22.c:      wc-> cpmenu = menu;
part22.c:      kb = D-> kb;
part22.c:      d = D-> d;
part22.c:      for ( i = n-1;i >= 0;i-- ) {
part22.c:          if ( T-> code == 't' ) {
part22.c:              elmt = T-> elmt;
part22.c:              tx = T-> tstr;
part22.c:              k = tx-> row*tx-> nx+tx-> col;
part22.c:      if ( wc-> Rth == 0 ) return 0;
part22.c:          nsize = rsize* ( 0.65+ ( ( rfac-0.5 ) /0.5 ) *0.35 ) ;
part22.c:      if ( nsize > ( rsize-8 ) ) nsize = rsize-8;
part22.c:      nsize = ( nsize/2 ) *2-1;
part22.c:          if ( ( img-> image_width > ( nsize ) ) 
part22.c:              || ( img-> image_height > ( nsize ) ) ) {
part22.c:          kgUserFrame ( fid , -l , -w , l , w ) ;
part22.c:          fid = kgInitImage ( rsize-2 , rsize-2 , 8 ) ;
part22.c:          kgUserFrame ( fid , -l-2 , -w-2 , l+2 , w+2 ) ;
part22.c:          kgRoundedRectangleFill ( fid , 0. , 0. , 2*l-4. , 2*l-4. , 0 , 151 , rfac ) ;
part22.c:          kgRoundedRectangleFill ( fid , 0. , 0. , 2*l-4. , 2*l-4. , 0 , 151 , rfac ) ;
part22.c:      return ( ( DIALOG * ) Tmp ) -> pt;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  e = T->elmt;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  e = T->elmt;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  e = T->elmt;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  e = T->elmt;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  e = T->elmt;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  e = T->elmt;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  e = T->elmt;
part221.c:  Tstr = (TX_STR *)(T->tstr);
part221.c:  e = T->elmt;
part221.c:  e = T->elmt;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  uiinfo_wprintf((DIALOG *)Tmp,I->twin,str);
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  if(I->code=='i') {
part221.c:    if(I->hide==1) return 0;
part221.c:    uiinfo_wprintf((DIALOG *)Tmp,I->twin,str);
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  return E->menu[B->df-1];
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  return B->df;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  B->df = df;
part221.c:  return B->df;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  return B->menu;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  B->menu = list;
part221.c:  E->menu = list;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  S->menu = list;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(S->bwsr);
part221.c:  return B->menu;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  E->menu = list;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  return E->menu;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  E->xpm = img;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  cpt = (char *) E->xpm;
part221.c:  img = (JPGIMG *)E->xpm;
part221.c:  p->xpm = img;
part221.c:  cpt =(char *) p->xpm;
part221.c:  uiFreeImage(p->xpm);
part221.c:  p->xpm=NULL;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  v[0]= G->vxmin;
part221.c:  v[1]= G->vymin;
part221.c:  v[2]= G->vxmax;
part221.c:  v[3]= G->vymax;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c://  m->msg = msg;
part221.c:  strncpy(m->msg,msg,499);
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c://  m->msg = msg;
part221.c:  if(m->hide==1) return 0;
part221.c:  if( (m->code=='M') ||(m->code=='m') ||(m->code=='B')) {
part221.c:   strncpy(m->msg,msg,499);
part221.c:  switch(m->code) {
part221.c:   if(m->hide==1) return 0;
part221.c:   strncpy(m->msg,msg,499);
part221.c:   kgUpdateOn(m->D);
part221.c:	   menu = s->menu;
part221.c:	   s->menu  = menu;
part221.c:	   kgUpdateOn(s->D);
part221.c:   if(I->hide==1) return 0;
part221.c:   uiinfo_wprintf((DIALOG *)I->D,I->twin,msg);
part221.c:   kgUpdateOn(I->D);
part221.c:  switch(X->code) {
part221.c:    df = *(X->df);
part221.c:    df = *(E->df);
part221.c:    df = *(W->df);
part221.c:  switch(X->code) {
part221.c:    *(X->df)=val;;
part221.c:    df = *(X->df);
part221.c:    *(E->df)=val;
part221.c:    df = *(E->df);
part221.c:    *(W->df)=val;
part221.c:    df = *(W->df);
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  list = (ThumbNail **)E->list;
part221.c:  return list[B->df-1]->name;
part221.c:  switch(X->code) {
part221.c:    df = *(X->df)-1;
part221.c:    list = (ThumbNail **)X->list;
part221.c:      return list[df]->name;
part221.c:    df = *(E->df)-1;
part221.c:    m = (char **)((DIE *)E)->menu;
part221.c:    df = *(W->df)-1;
part221.c:    m = (char **)W->menu;
part221.c:  switch(X->code) {
part221.c:    df = *(X->df)-1;
part221.c:    list = (ThumbNail **)X->list;
part221.c:    df = *(E->df)-1;
part221.c:    m = (char **)((DIE *)E)->menu;
part221.c:    df = *(W->df)-1;
part221.c:    m = (char **)W->menu;
part221.c:  switch(X->code) {
part221.c:    X->list=list;
part221.c:    X->nitems= nitems;
part221.c:    *(X->df) = 0;
part221.c:    X->list=list;
part221.c:    X->nitems= nitems;
part221.c:    X->list=list;
part221.c:    X->nitems= nitems;
part221.c:    *(X->df) = 0;
part221.c:    E->menu= (char **)list;
part221.c:    W->menu=(char **)list;
part221.c:  switch(X->code) {
part221.c:	    list = (ThumbNail **)X->list;
part221.c:  switch(X->code) {
part221.c:	    list = (ThumbNail **)X->list;
part221.c:	    return list[item]->name;
part221.c:  switch(X->code) {
part221.c:	    list = (ThumbNail **)X->list;
part221.c:	    return list[item]->img;
part221.c:  switch(X->code) {
part221.c:	    list = (ThumbNail **)X->list;
part221.c:	    list[item]->img=img;
part221.c:  switch(X->code) {
part221.c:	    list = (ThumbNail **)X->list;
part221.c:	    list[item]->name=(char *)malloc(strlen(name)+1);
part221.c:	    strcpy(list[item]->name,name);
part221.c:	thret->name = NULL;
part221.c:	thret->img = NULL;
part221.c:	thret->sw = th->sw;
part221.c:	thret->id = th->id;
part221.c:	thret->state = th->state;
part221.c:	if (th->name != NULL) {
part221.c:		thret->name=(char *)malloc(strlen(th->name)+1);
part221.c:		strcpy(thret->name,th->name);
part221.c:	if(th->img != NULL) {
part221.c:		thret->img= kgCopyImage(th->img);
part221.c:	if(th->img != NULL) uiFreeImage(th->img);
part221.c:        if(th->name!= NULL) free(th->name);
part221.c:	if(th->img != NULL) uiFreeImage(th->img);
part221.c:        if(th->name!= NULL) free(th->name);
part221.c:           kgAddThumbNail(wid,kgPickThumbNail(wid,item),pos-1);
part221.c:	if(p->code != 'p') return NULL;
part221.c:	p->xpm = img;
part221.c:	if(p->code != 'p') return NULL;
part221.c:	img = p->xpm;
part221.c:	ret = strcmp(th1->name,th2->name);
part221.c://	printf("%s : %s :ret = %d\n",th1->name,th2->name,ret);
part221.c:	ret = strcmp(th1->name,th2->name);
part221.c:  switch(X->code) {
part221.c:    df = *(X->df)-1;
part221.c:    list = (ThumbNail **)X->list;
part221.c:    df = list[item]->sw;
part221.c:  switch(X->code) {
part221.c:      if(((X->type)%10)>0) {
part221.c:      df = *(X->df)-1;
part221.c:      list = (ThumbNail **)X->list;
part221.c:      list[item]->sw=val;
part221.c:      df = list[item]->sw;
part221.c:      list = (ThumbNail **)X->list;
part221.c:      list[item]->sw=val;
part221.c:    if(((X->type)%10)>0) {
part221.c:      df = *(X->df)-1;
part221.c:      list = (ThumbNail **)X->list;
part221.c:      list[item]->sw=val;
part221.c:      df = list[item]->sw;
part221.c:      list = (ThumbNail **)X->list;
part221.c:      list[item]->sw=val;
part221.c:    df = *(X->df)-1;
part221.c:    list = (ThumbNail **)X->list;
part221.c:    list[item]->sw=val;
part221.c:    df = list[item]->sw;
part221.c:	switch (V->code) {
part221.c:			V->ds=percent;
part221.c:	switch (V->code) {
part221.c:			V->df=percent;
part221.c:	switch (V->code) {
part221.c:			return V->df;
part221.c:	switch (V->code) {
part221.c:			return V->ds;
part221.c:	*xsize = T->x2 -T->x1;
part221.c:	*ysize = T->y2 -T->y1;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  return B->df;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  if(df > E->nitems) df=E->nitems;
part221.c:  B->df = df;
part221.c:  *(E->df) = df;
part221.c:  return B->df;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  return E->list;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  B = (BRW_STR *)(E->bwsr);
part221.c:  E->list = list;
part221.c:  if(E->nx< 1) E->nx=1;
part221.c:  E->ny=ny/E->nx;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  if(E->nx<1 ) E->nx=1;
part221.c:  return E->nitems;
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  switch(E->code) {
part221.c:  D = ((DIALOG *)Tmp)->d;
part221.c:  uiFreeThumbNails((ThumbNail **)E->list);
part221.c:  E->list=NULL;
part221.c:  return (void *) (D->d[id].x);
part221.c:  return (void *) (D->d[id].x);
part221.c:  return kgGetWidget(Tmp,D->CurWid);
part221.c:  if( ret )D->CurWid=Wid;
part221.c:  if( ret )D->df=Wid;
part221.c:  return kgGetWidgetName(Tmp,D->CurWid);
part221.c: kb = D->kb;
part221.c: d = D->d;
part221.c: if(x1 <D->xo) return NULL;
part221.c: if(x1 >(D->xo+D->xl)) return NULL;
part221.c: if(y1 <D->yo) return NULL;
part221.c: if(y1 >(D->yo+D->yl)) return NULL;
part221.c: xo = D->xo;
part221.c: yo = D->yo;
part221.c:   if( uiCheckClickPosition(d[i].t->x1+xo,d[i].t->y1+yo,d[i].t->x2+xo,
part221.c:               d[i].t->y2+yo,x1,y1) ==1) {wid = (void *)d[i].t; break;}
part221.c: kb = D->kb;
part221.c: d = D->d;
part221.c: *x= -1;*y=-1;
part221.c: *x = x1 - D->xo;
part221.c: *y = y1 - D->yo;
part221.c:		*x1 = T->x1;
part221.c:		*y1 = T->y1;
part221.c: kb = D->kb;
part221.c: d = D->d;
part221.c: if(x1 <D->xo) return NULL;
part221.c: if(x1 >(D->xo+D->xl)) return NULL;
part221.c: if(y1 <D->yo) return NULL;
part221.c: if(y1 >(D->yo+D->yl)) return NULL;
part221.c: xo = D->xo;
part221.c: yo = D->yo;
part221.c: for(i=n-1;i>=0;i--) {
part221.c:   if( uiCheckClickPosition(d[i].t->x1+xo,d[i].t->y1+yo,d[i].t->x2+xo,
part221.c:               d[i].t->y2+yo,x1,y1) ==1) {wid = (void *)d[i].t; break;}
part221.c:  switch(x->code) {
part221.c:      x->hide = hide;
part221.c:      ((DIO *)x)->hide=hide;
part221.c:  switch(x->code) {
part221.c:      hide = x->hide;
part221.c:      hide =((DIO *)x)->hide;
part221.c:  switch(x->code) {
part221.c:      hide = x->hide;
part221.c:      hide = ((DIV *)x)->hide;
part221.c:      hide = ((DIZ *)x)->hide;
part221.c:      hide = ((DIO *)x)->hide;
part221.c:      hide = ((DIP *)x)->hide;
part221.c:      hide = ((DII *)x)->hide;
part221.c:         hide = ((DIT *)x)->hide;
part221.c:         hide = ((DIL *)x)->hide;
part221.c:         hide = ((DILN *)x)->hide;
part221.c:         hide = ((DIN *)x)->hide;
part221.c:         hide = ((DIBN *)x)->hide;
part221.c:         hide = ((DIF *)x)->hide;
part221.c:         hide = ((DIHB *)x)->hide;
part221.c:         hide = ((DID *)x)->hide;
part221.c:         hide =  ((DIW *)x)->hide;
part221.c:         hide = ((DIE *)x)->hide;
part221.c:         hide = ((DIS *)x)->hide;
part221.c:         hide = ((DIG *)x)->hide;
part221.c:         hide = ((DIM *)x)->hide;
printerdia.c:  D = ((DIALOG *)Tmp)->d;
printerdia.c:  e = T->elmt;
printerdia.c:  D = ((DIALOG *)Tmp)->d;
printerdia.c:  n = B->nx;
printerdia.c:  D.df = -1;
printerdia.c:  n=j-i+1;
printerdia.c:  for(k=0;k<n-1;k++) pt[k]=buff[k+i];
printerdia.c:  pt[n-1]='\0';
printerdia.c:  D = ((DIALOG *)Tmp)->d;
printerdia.c:    -1,
printerdia.c:    -1,-1
printerdia.c:    -1 /* bkgr colour */ 
printerdia.c:    -1 /* bkgr colour */ 
printerdia.c:    -1 /* bkgr colour */ 
printerdia.c:  D.df = -1;
printerdia.c:             sprintf(command,"lpr -r -h  -P \"%s\" -# %-d GRAF",pt,v2);
printerdia.c:  D = ((DIALOG *)Tmp)->d;
printerdia.c:  n = B->nx;
printerdia.c:    -1, 
printerdia.c:    -1, 
printerdia.c:    -1
printerdia.c:    -1 /* bkgr colour */ 
printerdia.c:    -1 /* bkgr colour */ 
printerdia.c:  D.df = -1;
printerdia.c:     if(v0 > 1)sprintf(command,"lpr -r -h  -P \"%s\" -# %-d %s",pt,v1,flname);
printerdia.c:             sprintf(command,"lpr -h -r -P%s -#%-d GRAF",pt,v2);
printerdia.c:             printf("lpr -h -r -P%s -#%-d GRAF",pt,v2);
printerdia.c:     sprintf(command,"lpr -h -r -P%s  GRAF",printer);
ps2jpg.c:	   printf("Usage: ps2jpg [-r res] <psfile> \n");
ps2jpg.c:	   printf("       ps2jpg [-r res] <psfile> <jpgfile>\n");
ps2jpg.c:	   strcpy(outfile,argv[count-1]);
ps2jpg.c:   sprintf(command,"gs -sDEVICE=jpeg  -r%-d -dBATCH -dNOPAUSE -sOutputFile=%s %s >/dev/null",res,outfile,argv[count-1]);
raised.c:   dv = vmax-vmin;
raised.c:   xp = xl*0.5 -dl;
raised.c:   yp = yl*0.5 - dl;
raised.c:     x[count1+i]= -x[count-i];
raised.c:     y[count1+i] = y[count-i];
raised.c:     x[2*count1+i]= x[2*count1-1-i];
raised.c:     y[2*count1+i] = -y[2*count1-1-i];
raised.c:     v[i]= v[count-i];
raised.c:     x[3*count1+i]=  -x[3*count1-1-i];
raised.c:     y[3*count1+i] = y[3*count1-1-i];
raised.c:   size1 = size -2*bordrsize;
raised.c:   fac1 = (1-size*size1*(1-2*fac))*0.5;
raised.c:   vv =vorg +(1.-vorg)*0.6;
raised.c:   vmid = vorg +(1-vorg)*0.55;
raised.c:   vmid1 = vorg +(1-vorg)*0.45;
raised.c:       fac = (fac-0.5)/0.5;
raised.c:       count = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 3;
raised.c:     xp = xl*0.5 -dl;
raised.c:     yp = yl*0.5 - dl;
raised.c:     x[count1+i]= -x[count-i];
raised.c:     y[count1+i] = y[count-i];
raised.c:     x[2*count1+i]= x[2*count1-1-i];
raised.c:     y[2*count1+i] = -y[2*count1-1-i];
raised.c:   np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, *xd, *yd, *vd,vlow,vv, count) {
raised.c:     npj = np-1-i;
rgb2hsl.c:   r,g,b range is 0-255
rgb2hsl.c:   h range 0-360
rgb2hsl.c:   s 0-100
rgb2hsl.c:   l 0-100
rgb2hsl.c:  *h = (int)atan((2.0*r -g -b)/sqrt((double)(3.*(g - b))))/(2*pi);
rgb2hsl.c:  *s =(int) sqrt((double)(r*r+g*g+b*b -r*g -r*b - b*g))/2.550;
ring.c:   count1= cunt-1;
ring.c:   Dang = 315.0/(np-1);
ring.c:   ri= size*0.5-2*size1;
ring.c:   kgUserFrame(fid,-R,-R,+R,+R);
ring.c:         x[count1-i]=ro*cs;
ring.c:         y[count1-i]=ro*ss;
ring.c:   x[np]=(ri-size1)*cs;
ring.c:   y[np]=(ri-size1)*ss;
rotate.c:    TR[12] = -tx; TR[13] = -ty; TR[14] = -tz;
rotate.c:    TX[5] = cos(ang); TX[6] = sin(ang); TX[9] = -(TX[6]);
rotate.c:    TY[0] = cos(ang); TY[2] = -(sin(ang)); TY[8] = sin(ang);
rotate.c:    TZ[0] = cos(ang); TZ[1] = sin(ang); TZ[4] = -TZ[1];
shade.c:   if it is made in the legal range that is (0. - 1.)
shade.c:#define scale(z) (((+(z)-box3d.zmin)/(box3d.zmax-box3d.zmin))+0.4)
shade.c:#define scale(z) ((((z+box3d.ze)-box3d.zmin)/(box3d.zmax-box3d.zmin))+0.4)
shade.c:#define scale_cos(a) (((a>0.)?(1+ (a))/2:(1-(a))/2)*illm_fac)
shade.c:#define dist(d) ((d<1)?((1. -(d))*(1. -(d))):0.0)
shade.c:  range r: 0-255
shade.c:  range g: 0-255
shade.c:  range b: 0-255
shade.c:        h: 0-360
shade.c:        s: 0-1
shade.c:        v: 0-1
shade.c:    while(h >= 360.) h -=360;
shade.c:    f = h-i;
shade.c:    p = v*(1-s);
shade.c:    q = v*(1-s*f);
shade.c:    t = v*(1-(s*(1-f)));
shade.c:  if(max != 0) *s = (max -min)/max;
shade.c:     del = max - min;
shade.c:     if( r==max) *h= (g-b)/del;
shade.c:       if(g==max) *h = 2+(b-r)/del;
shade.c:          if(b==max) *h= 4+(r-g)/del;
shade.c:    if( *l <= 0.5 ) *s = (max - min)/(max+min);
shade.c:    else *s = (max - min)/(2 - max - min);
shade.c:    del = max - min;
shade.c:    if( r == max ) *h = (g-b)/del;
shade.c:      if( g == max ) *h = 2+(b-r)/del;
shade.c:      else *h = 4 + (r-g)/del;
shade.c:  while (h >360) h -=360;
shade.c:  if( h < 60 ) val = n1 + (n2 - n1)*h/60.;
shade.c:       if( h < 240. ) val = n1 + (n2 - n1)*(240 -h)/60.;
shade.c:   else m2 = l+s - l*s;
shade.c:   m1 = 2*l -m2;
shade.c:     *b = Value(m1,m2,h-120);
shade.c:   r,g,b range is 0-255
shade.c:   h range 0-360
shade.c:   s 0-1
shade.c:   l 0-1
shade.c:  hue1 = atan2((double)(2.0*r -g -b),((double)(1.73205*(g - b))))/(2*pi);
shade.c:  //hue3 = atan2((double)(2.0*b -r -g),((double)(1.73205*(r - g))))/(2*pi);
shade.c:  //hue2 = atan2((double)(2.0*g -b -r),((double)(1.73205*(b - r))))/(2*pi);
shade.c:  *s = (sqrt((double)(r*r+g*g+b*b -r*g -r*b - b*g))/255.0);
shade.c:     f = h-i;
shade.c:     p = v*(1-s);
shade.c:     q = v*(1- (s*f));
shade.c:     t = v*(1-(s*(1-f)));
shade.c:  h -(0-360)
shade.c:  s  (0 -1)
shade.c:  v  (0 - 1)
shade.c:     f = h-i;
shade.c:     p = v*(1-s);
shade.c:     q = v*(1- (s*f));
shade.c:     t = v*(1-(s*(1-f)));
shade.c:     f = h-i;
shade.c:     p = v*(1-s);
shade.c:     q = v*(1- (s*f));
shade.c:     t = v*(1-(s*(1-f)));
shade.c:     f = h-i;
shade.c:     p = v*(1-s);
shade.c:     q = v*(1- (s*f));
shade.c:     t = v*(1-(s*(1-f)));
shade.c:  dc = G->dc;
shade.c:  if(G->D !=NULL) {
shade.c:    *(x+i) = dc->trnstr.xstr;
shade.c:    *(y+i) = dc->trnstr.ystr;
shade.c:    *(z+i) = dc->trnstr.zstr;
shade.c:    dc->trnstr.xstr = x[i];
shade.c:    dc->trnstr.ystr = y[i];
shade.c:    dc->trnstr.zstr = z[i];
shade.c:    kgprojection(dc,dc->trnstr);
shade.c:    *(x+i) = dc->newstr.xstr;
shade.c:    *(y+i) = dc->newstr.ystr;
shade.c:    *(z+i) = dc->newstr.zstr;
shade.c:  if (G->D_ON) {
shade.c:    if (dc->ZBUFF == 1) ui_3_godr_fill(G,n,x,y,z,v);
shade.c:    if (dc->ZBUFF == 1) img_godrfill3f(G,n,x,y,z,v);
shade.c:  dc = G->dc;
shade.c:    *(x+i) = dc->trnstr.xstr;
shade.c:    *(y+i) = dc->trnstr.ystr;
shade.c:    *(z+i) = dc->trnstr.zstr;
shade.c:    dc->trnstr.xstr = x[i];
shade.c:    dc->trnstr.ystr = y[i];
shade.c:    dc->trnstr.zstr = z[i];
shade.c:    kgprojection(dc,dc->trnstr);
shade.c:    *(x+i) = dc->newstr.xstr;
shade.c:    *(y+i) = dc->newstr.ystr;
shade.c:    *(z+i) = dc->newstr.zstr;
shade.c: if (G->D_ON){
shade.c:   if (dc->ZBUFF == 1) ui_3_shade_fill(G,n,x,y,z,v,baseclr);
shade.c:  if (G->D_ON) {
shade.c:    if (dc->ZBUFF == 1) ui_3_godr_fill(G,n,x,y,z,v);
shade.c:    if (dc->ZBUFF == 1) img_godrfill3f(G,n,x,y,z,v);
shade.c:  dc = G->dc;
shade.c:    *(x+i) = dc->trnstr.xstr;
shade.c:    *(y+i) = dc->trnstr.ystr;
shade.c:    *(z+i) = dc->trnstr.zstr;
shade.c:    dc->trnstr.xstr = x[i];
shade.c:    dc->trnstr.ystr = y[i];
shade.c:    dc->trnstr.zstr = z[i];
shade.c:    kgprojection(dc,dc->trnstr);
shade.c:    *(x+i) = dc->newstr.xstr;
shade.c:    *(y+i) = dc->newstr.ystr;
shade.c:    *(z+i) = dc->newstr.zstr;
shade.c:  if (G->D_ON) {
shade.c:    if (dc->ZBUFF == 1) ui_3_godr_fill(G,n,x,y,z,v);
shade.c:    if (dc->ZBUFF == 1) img_godrfill3f(G,n,x,y,z,v);
shade.c:   if(cosval < 0. ) cosval = -cosval;
shade.c:/* --------------   Cross Product of two vectors   ------------- */
shade.c:   n.x = -(p2.y - p.y)*(p1.z - p.z) + (p2.z - p.z)*(p1.y - p.y);
shade.c:   n.y = ((p2.x - p.x)*(p1.z - p.z) - (p1.x - p.x)*(p2.z - p.z));
shade.c:   n.z = -(p2.x - p.x)*(p1.y - p.y) + (p1.x - p.x)*(p2.y - p.y);
shade.c://--------------------
shade.c:  dc= G->dc;
shade.c:  xc = +dc->box3d.xe;
shade.c:  yc = dc->box3d.ye;
shade.c:  zc = +dc->box3d.zc +dc->box3d.ze;
shade.c:  if(dc->ls_list==NULL) {
shade.c:        j0 = (no+j-1)%no;
shade.c:        if( (n.x==0)&&(n.y==0)&&(n.z==0) ) count--;
shade.c:        Resetlink(dc->ls_list);
shade.c:        while((lpt = (LIGHT *) Getrecord(dc->ls_list)) != NULL)
shade.c:           //v.x = lpt->x - x[j] - xc;
shade.c:           //v.y = lpt->y - y[j] - yc;
shade.c:           //v.z = lpt->z - z[j] - zc;
shade.c:           v.x = lpt->x - x[j] ;
shade.c:           v.y = lpt->y - y[j] ;
shade.c:           v.z = lpt->z - z[j] ;
shade.c:	   d = (sqrt(d)/(DSCALE*(dc->box3d.d)));
shade.c:        No_of_lights = Dcount(dc->ls_list);
shade.c:  dc= G->dc;
shade.c:  if(dc->ls_list == NULL) {
shade.c:     dc->ls_list = Dopen();
shade.c:  pt->x = x;
shade.c:  pt->y = y;
shade.c:  pt->z = z;
shade.c:  Dadd(dc->ls_list,pt);
shade.c:  dc->No_of_lights++;
shade.c:  dc= G->dc;
shade.c:  if(dc->ls_list != NULL) Dempty(dc->ls_list);
shade.c:  dc->ls_list = NULL;
shade.c:  dc->No_of_lights=0;
shade.c:/* --------------------  Get color combinations for shading  ------------------------------ */
shade.c:    exit(-1);
shade.c:  dx = (255. -gray)/(nclrs+1 );
shade.c:    exit(-1);
shade.c:  dx = (1. -gray)/(nclrs+1 );
shade.c:    exit(-1);
shade.c:  dx = (1. -gray)/(nclrs+1 );
shade.c:    exit(-1);
shade.c:  dx = (vmax -gray)/(nclrs );
shade.c:    exit(-1);
shade.c:  dx = (vmax -gray)/(nclrs );
shade.c:    exit(-1);
shade.c:  dx = (1. -gray)/(nclrs+1 );
shade.c:  dx = (1. -gray)/(nclrs+1 );
shade4.c:   dl1 = dl -bordrsize;
shade4.c:   fac1 = dl1/(size-2*bordrsize);
shade4.c:   vv = (vmin+0.4*(vmax-vmin));
shade4.c:       fac = (fac-0.5)/0.5;
shade4.c:       fac1 = (fac1-0.5)/0.5;
shade4.c:       np = kgGetEllipsePoints(xl, yl,fac,count,x,y) - 2;
shade4.c:       np =kgGetEllipsePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, count,xd, yd)-2;
shade4.c:       dv = (vmax-vmin);
shade4.c:       dv1 = (vmax1-vmin1);
shade4.c:       Dang = 90.0/(np-1);
shade4.c:       np =kgGetCirclePoints( xl-2*bordrsize,yl-2*bordrsize,fac1, xd, yd, vd,vmid,vmid, count);
shade4.c:     npj = np-1-i;
shade4.c:   xd[0]= x[np-1];
shade4.c:   yd[0]= y[np-1];
shade4.c:   vd[0]= v[np-1];
shade4.c:   xd[2]= -x[np];
shade4.c:   xd[3]= -x[np-1];
shade4.c:   yd[3]= y[np-1];
shade4.c:   vd[3]= v[np-1];
shade4.c:     xd[i] = -x[i]+xo;
shade4.c:     vd[i] = v[np-1];
shade4.c:     xd[i] = -x[i]+xo;
shade4.c:   xd[0]= -x[0];
shade4.c:   vd[0]= v[np-1];
shade4.c:   xd[1]= -x[0];
shade4.c:   yd[1]= -y[0];
shade4.c:   vd[1]= v[np-1];
shade4.c:   xd[2]= -x[np2-1];
shade4.c:   yd[2]= -y[np2-1];
shade4.c:   xd[3]= -x[np2-1];
shade4.c:   yd[3]=  y[np2-1];
shade4.c:   yd[1]= -y[0];
shade4.c:   xd[2]= x[np2-1];
shade4.c:   yd[2]= -y[np2-1];
shade4.c:   vd[2]= v[np2-1];
shade4.c:   xd[3]= x[np2-1];
shade4.c:   yd[3]=  y[np2-1];
shade4.c:   vd[3]= v[np2-1];
shade4.c:     xd[i] = -x[i]+xo;
shade4.c:     yd[i] = -y[i] +yo;
shade4.c:     vd[i]= v[np-1-i];
shade4.c:     vd[np+i]= v[np2-1-i];
shade4.c:     yd[i] = -y[i] +yo;
shade4.c:     vd[np+i]= v[np2-1];
shade4.c:   xd[0]= x[np-1];
shade4.c:   yd[0]= y[np-1];
shade4.c:   vd[1]= v[np2-1];
shade4.c:   xd[2]= -x[np];
shade4.c:   vd[2]= v[np2-1];
shade4.c:   xd[3]= -x[np-1];
shade4.c:   yd[3]= y[np-1];
shade4.c:     yd[i] = -yd[i] +yo;
skeybrd.c:static int ButClr=-1;
skeybrd.c:   Kbrd = D->Kbrd;
skeybrd.c:   if(Kbrd->Vis) return 0;
skeybrd.c:   kgSetGrpVisibility(D,Kbrd->cgrp,0);
skeybrd.c:   kgSetGrpVisibility(D,Kbrd->symgrp,0);
skeybrd.c:   kgSetGrpVisibility(D,Kbrd->sgrp,1);
skeybrd.c:   Kbrd->ShiftPress=0;
skeybrd.c:   Kbrd->CapsLock=0;
skeybrd.c:   if(D->wc != NULL) {
skeybrd.c:     kgUpdateGrp(D,Kbrd->sgrp);
skeybrd.c:   Kbrd->Vis = 1;
skeybrd.c:   return Kbrd->GrpId;
skeybrd.c:   Kbrd = D->Kbrd;
skeybrd.c:   if(Kbrd->Vis==0) return 0;
skeybrd.c:   kgSetGrpVisibility(D,Kbrd->GrpId,0);
skeybrd.c:   if(D->wc != NULL) {
skeybrd.c:     kgUpdateGrp(D,Kbrd->GrpId);
skeybrd.c:   Kbrd->ShiftPress=0;
skeybrd.c:   Kbrd->CapsLock=0;
skeybrd.c:   Kbrd->Vis = 0;
skeybrd.c:   return Kbrd->GrpId;
skeybrd.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s",Sfac,Bfont,Bclr,str);
skeybrd.c:   kgUserFrame(fid,-2.,-2.,(float)xl+2,(float)yl+2);
skeybrd.c:   gc->FontSize =8;
skeybrd.c:   gc->Font=23;
skeybrd.c:  p0.item = -1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b1.item = -1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b2.item = -1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b3.item = -1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b4.item = -1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b5.item = -1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b6.item = -1;
skeybrd.c:  Procpy(butn7[24].title,(char *)"-");
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b7.item = -1;
skeybrd.c:  dtmp = D->d;
skeybrd.c:  d[0].p->item = -1;
skeybrd.c:  d[1].N->item = -1;
skeybrd.c:  d[2].N->item = -1;
skeybrd.c:  d[3].N->item = -1;
skeybrd.c:  d[4].N->item = -1;
skeybrd.c:  d[5].N->item = -1;
skeybrd.c:  d[6].N->item = -1;
skeybrd.c:  d[7].N->item = -1;
skeybrd.c:  D->d = dtmp;
skeybrd.c:  p0.item = -1;
skeybrd.c:  butn1[0].bkgr=-1;
skeybrd.c:  butn1[1].bkgr=-1;
skeybrd.c:  butn1[2].bkgr=-1;
skeybrd.c:  butn1[3].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b1.item = -1;
skeybrd.c:  butn2[0].bkgr=-1;
skeybrd.c:  butn2[1].bkgr=-1;
skeybrd.c:  butn2[2].bkgr=-1;
skeybrd.c:  butn2[3].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b2.item = -1;
skeybrd.c:  butn3[0].bkgr=-1;
skeybrd.c:  butn3[1].bkgr=-1;
skeybrd.c:  butn3[2].bkgr=-1;
skeybrd.c:  butn3[3].bkgr=-1;
skeybrd.c:  butn3[4].bkgr=-1;
skeybrd.c:  butn3[5].bkgr=-1;
skeybrd.c:  butn3[6].bkgr=-1;
skeybrd.c:  butn3[7].bkgr=-1;
skeybrd.c:  butn3[8].bkgr=-1;
skeybrd.c:  butn3[9].bkgr=-1;
skeybrd.c:  butn3[10].bkgr=-1;
skeybrd.c:  butn3[11].bkgr=-1;
skeybrd.c:  butn3[12].bkgr=-1;
skeybrd.c:  butn3[13].bkgr=-1;
skeybrd.c:  butn3[14].bkgr=-1;
skeybrd.c:  butn3[15].bkgr=-1;
skeybrd.c:  butn3[16].bkgr=-1;
skeybrd.c:  butn3[17].bkgr=-1;
skeybrd.c:  butn3[18].bkgr=-1;
skeybrd.c:  butn3[19].bkgr=-1;
skeybrd.c:  butn3[20].bkgr=-1;
skeybrd.c:  butn3[21].bkgr=-1;
skeybrd.c:  butn3[22].bkgr=-1;
skeybrd.c:  butn3[23].bkgr=-1;
skeybrd.c:  butn3[24].bkgr=-1;
skeybrd.c:  butn3[25].bkgr=-1;
skeybrd.c:  butn3[26].bkgr=-1;
skeybrd.c:  butn3[27].bkgr=-1;
skeybrd.c:  butn3[28].bkgr=-1;
skeybrd.c:  butn3[29].bkgr=-1;
skeybrd.c:  butn3[30].bkgr=-1;
skeybrd.c:  butn3[31].bkgr=-1;
skeybrd.c:  butn3[32].bkgr=-1;
skeybrd.c:  butn3[33].bkgr=-1;
skeybrd.c:  butn3[34].bkgr=-1;
skeybrd.c:  butn3[35].bkgr=-1;
skeybrd.c:  butn3[36].bkgr=-1;
skeybrd.c:  butn3[37].bkgr=-1;
skeybrd.c:  butn3[38].bkgr=-1;
skeybrd.c:  butn3[39].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b3.item = -1;
skeybrd.c:  butn4[0].bkgr=-1;
skeybrd.c:  butn4[1].bkgr=-1;
skeybrd.c:  butn4[2].bkgr=-1;
skeybrd.c:  butn4[3].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b4.item = -1;
skeybrd.c:  butn5[0].bkgr=-1;
skeybrd.c:  butn5[1].bkgr=-1;
skeybrd.c:  butn5[2].bkgr=-1;
skeybrd.c:  butn5[3].bkgr=-1;
skeybrd.c:  butn5[4].bkgr=-1;
skeybrd.c:  butn5[5].bkgr=-1;
skeybrd.c:  butn5[6].bkgr=-1;
skeybrd.c:  butn5[7].bkgr=-1;
skeybrd.c:  butn5[8].bkgr=-1;
skeybrd.c:  butn5[9].bkgr=-1;
skeybrd.c:  butn5[10].bkgr=-1;
skeybrd.c:  butn5[11].bkgr=-1;
skeybrd.c:  butn5[12].bkgr=-1;
skeybrd.c:  butn5[13].bkgr=-1;
skeybrd.c:  butn5[14].bkgr=-1;
skeybrd.c:  butn5[15].bkgr=-1;
skeybrd.c:  butn5[16].bkgr=-1;
skeybrd.c:  butn5[17].bkgr=-1;
skeybrd.c:  butn5[18].bkgr=-1;
skeybrd.c:  butn5[19].bkgr=-1;
skeybrd.c:  butn5[20].bkgr=-1;
skeybrd.c:  butn5[21].bkgr=-1;
skeybrd.c:  butn5[22].bkgr=-1;
skeybrd.c:  butn5[23].bkgr=-1;
skeybrd.c:  butn5[24].bkgr=-1;
skeybrd.c:  butn5[25].bkgr=-1;
skeybrd.c:  butn5[26].bkgr=-1;
skeybrd.c:  butn5[27].bkgr=-1;
skeybrd.c:  butn5[28].bkgr=-1;
skeybrd.c:  butn5[29].bkgr=-1;
skeybrd.c:  butn5[30].bkgr=-1;
skeybrd.c:  butn5[31].bkgr=-1;
skeybrd.c:  butn5[32].bkgr=-1;
skeybrd.c:  butn5[33].bkgr=-1;
skeybrd.c:  butn5[34].bkgr=-1;
skeybrd.c:  butn5[35].bkgr=-1;
skeybrd.c:  butn5[36].bkgr=-1;
skeybrd.c:  butn5[37].bkgr=-1;
skeybrd.c:  butn5[38].bkgr=-1;
skeybrd.c:  butn5[39].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b5.item = -1;
skeybrd.c:  butn6[0].bkgr=-1;
skeybrd.c:  butn6[1].bkgr=-1;
skeybrd.c:  butn6[2].bkgr=-1;
skeybrd.c:  butn6[3].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b6.item = -1;
skeybrd.c:  butn7[0].bkgr=-1;
skeybrd.c:  butn7[1].bkgr=-1;
skeybrd.c:  butn7[2].bkgr=-1;
skeybrd.c:  butn7[3].bkgr=-1;
skeybrd.c:  butn7[4].bkgr=-1;
skeybrd.c:  butn7[5].bkgr=-1;
skeybrd.c:  butn7[6].bkgr=-1;
skeybrd.c:  butn7[7].bkgr=-1;
skeybrd.c:  butn7[8].bkgr=-1;
skeybrd.c:  butn7[9].bkgr=-1;
skeybrd.c:  butn7[10].bkgr=-1;
skeybrd.c:  butn7[11].bkgr=-1;
skeybrd.c:  butn7[12].bkgr=-1;
skeybrd.c:  butn7[13].bkgr=-1;
skeybrd.c:  butn7[14].bkgr=-1;
skeybrd.c:  butn7[15].bkgr=-1;
skeybrd.c:  butn7[16].bkgr=-1;
skeybrd.c:  butn7[17].bkgr=-1;
skeybrd.c:  butn7[18].bkgr=-1;
skeybrd.c:  butn7[19].bkgr=-1;
skeybrd.c:  butn7[20].bkgr=-1;
skeybrd.c:  butn7[21].bkgr=-1;
skeybrd.c:  butn7[22].bkgr=-1;
skeybrd.c:  butn7[23].bkgr=-1;
skeybrd.c:  Procpy(butn7[24].title,(char *)"-");
skeybrd.c:  butn7[24].bkgr=-1;
skeybrd.c:  butn7[25].bkgr=-1;
skeybrd.c:  butn7[26].bkgr=-1;
skeybrd.c:  butn7[27].bkgr=-1;
skeybrd.c:  butn7[28].bkgr=-1;
skeybrd.c:  butn7[29].bkgr=-1;
skeybrd.c:  butn7[30].bkgr=-1;
skeybrd.c:  butn7[31].bkgr=-1;
skeybrd.c:  butn7[32].bkgr=-1;
skeybrd.c:  butn7[33].bkgr=-1;
skeybrd.c:  butn7[34].bkgr=-1;
skeybrd.c:  butn7[35].bkgr=-1;
skeybrd.c:  butn7[36].bkgr=-1;
skeybrd.c:  butn7[37].bkgr=-1;
skeybrd.c:  butn7[38].bkgr=-1;
skeybrd.c:  butn7[39].bkgr=-1;
skeybrd.c:    Btype,Rfac,0,0,0,1, /* button type and roundinfg factor(0-0.5),bordr,hide ,nodrawbkgr*/
skeybrd.c:  b7.item = -1;
skeybrd.c:  dtmp = D->d;
skeybrd.c:  d[0].p->item = -1;
skeybrd.c:  d[1].N->item = -1;
skeybrd.c:  d[2].N->item = -1;
skeybrd.c:  d[3].N->item = -1;
skeybrd.c:  d[4].N->item = -1;
skeybrd.c:  d[5].N->item = -1;
skeybrd.c:  d[6].N->item = -1;
skeybrd.c:  d[7].N->item = -1;
skeybrd.c:  D->d = dtmp;
skeybrd.c:     clr = -clr;
skeybrd.c:   d = (DIA *)(D->d);
skeybrd.c:     if(xm > (d[i].t->x1) ) xm = d[i].t->x1;
skeybrd.c:     if(ym > (d[i].t->y1) ) ym = d[i].t->y1;
skeybrd.c:   kgShiftGrp(D,Kbrd->GrpId,xo-xm,yo-ym);
skeybrd.c:   d = D->d;
skeybrd.c:   if(Kbrd->kbtype==2) {
skeybrd.c:     kgShiftGrp(D,rgrp,-7,0);
skeybrd.c:   Kbrd->sgrp = kgOpenGrp(D);
skeybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[0+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[1+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[3+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->sgrp,d[2+offset].t);
skeybrd.c:   Kbrd->cgrp = kgOpenGrp(D);
skeybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[0+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[1+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[5+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->cgrp,d[4+offset].t);
skeybrd.c:   Kbrd->symgrp = kgOpenGrp(D);
skeybrd.c:   kgAddtoGrp(D,Kbrd->symgrp,d[0+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->symgrp,d[1+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->symgrp,d[7+offset].t);
skeybrd.c:   kgAddtoGrp(D,Kbrd->symgrp,d[6+offset].t);
skeybrd.c:   Kbrd->CurWid = -1;
skeybrd.c:   Kbrd->Vis = Vis;
skeybrd.c:   Kbrd->D = D;
skeybrd.c:   Kbrd->ShiftPress=0;
skeybrd.c:   Kbrd->CapsLock=0;
skeybrd.c:    kgSetGrpVisibility(D,Kbrd->GrpId,0);
skeybrd.c:    kgSetGrpVisibility(D,Kbrd->cgrp,0);
skeybrd.c:    kgSetGrpVisibility(D,Kbrd->symgrp,0);
skeybrd.c:    kgSetGrpVisibility(D,Kbrd->sgrp,1);
skeybrd.c:   D->Kbrd = Kbrd;
skeybrd.c:   Kbrd->TargetWindow = NULL;
skeybrd.c:   gc = D->gc;
skeybrd.c:   D->wc=NULL;
skeybrd.c:   strcpy(Kbrd->Sfac,Sfac);
skeybrd.c:   Kbrd->Bclr = Bclr;
skeybrd.c:   Kbrd->Bfont = Bfont;
skeybrd.c:   Kbrd->Btype=Btype;
skeybrd.c:   Kbrd->ButClr = ButClr;
skeybrd.c:   dtmp = D->d;
skeybrd.c:   Gpt->arg= v; // kulina will double free this; you may modify
skeybrd.c:   Kbrd->kbtype=1;
skeybrd.c:   Kbrd->GrpId = GrpId;
skeybrd.c:   D->Kbrd = Kbrd;
skeybrd.c:   Kbrd->TargetWindow = NULL;
skeybrd.c:   gc = D->gc;
skeybrd.c:   D->wc=NULL;
skeybrd.c:   strcpy(Kbrd->Sfac,Sfac);
skeybrd.c:   Kbrd->Bclr = Bclr;
skeybrd.c:   Kbrd->Bfont = Bfont;
skeybrd.c:   Kbrd->Btype=Btype;
skeybrd.c:   Kbrd->Rfac=rfac;
skeybrd.c:   Kbrd->ButClr = ButClr;
skeybrd.c:   dtmp = D->d;
skeybrd.c:   kgShiftGrp(D,GrpId,xo-14,yo-7);
skeybrd.c:   Gpt->arg= v; // kulina will double free this; you may modify
skeybrd.c:   Kbrd->GrpId=GrpId;
skeybrd.c:   Kbrd->kbtype=1;
skeybrd.c:   D->Kbrd = Kbrd;
skeybrd.c:   Kbrd->TargetWindow = NULL;
skeybrd.c:   gc = D->gc;
skeybrd.c:   D->wc=NULL;
skeybrd.c:   strcpy(Kbrd->Sfac,Sfac);
skeybrd.c:   Kbrd->Bclr = Bclr;
skeybrd.c:   Kbrd->Bfont = Bfont;
skeybrd.c:   Kbrd->Btype=Btype;
skeybrd.c:   Kbrd->ButClr = ButClr;
skeybrd.c:   Kbrd->Rfac = Rfac;
skeybrd.c:   dtmp = D->d;
skeybrd.c:   Gpt->arg= v; // kulina will double free this; you may modify
skeybrd.c:   Kbrd->kbtype=2;
skeybrd.c:   Kbrd->GrpId = GrpId;
skeybrd.c:   D->Kbrd = Kbrd;
skeybrd.c:   Kbrd->TargetWindow = NULL;
skeybrd.c:   gc = D->gc;
skeybrd.c:   D->wc=NULL;
skeybrd.c:   strcpy(Kbrd->Sfac,Sfac);
skeybrd.c:   Kbrd->Bclr = Bclr;
skeybrd.c:   Kbrd->Bfont = Bfont;
skeybrd.c:   Kbrd->Rfac = rfac;
skeybrd.c:   Kbrd->kbtype=2;
skeybrd.c:   Kbrd->Btype=Btype;
skeybrd.c:   Kbrd->ButClr = ButClr;
skeybrd.c:   dtmp = D->d;
skeybrd.c:   Gpt->arg= v; // kulina will double free this; you may modify
skeybrd.c:   Kbrd->kbtype=2;
skeybrd.c:   Kbrd->GrpId = GrpId;
skeybrd.c:  D.StackPos = 0;    /* -1,0,1 for for Stack Position -1:below 0:normal 1:above*/
skeybrd.c:      // D.xo=D.yo=0; D.xl = xres-10; D.yl=yres-80;
skeybrdCallbacks.c:static char Label3[]="1234567890~`!@#$%^&*()_+-={}|[]\\:\";',.<>?";
skeybrdCallbacks.c:  sprintf(BUFF,"!h15!d!h51!z%-s!f%2.2d!c%2.2d%-s",Kbrd->Sfac,Kbrd->Bfont,Kbrd->Bclr,str);
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) { 
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  CurWid = Kbrd->CurWid;
skeybrdCallbacks.c:  if(D->InputWid >= 0) {
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:     CurWid = Kbrd->CurWid;
skeybrdCallbacks.c:  ch= Label[butno-1];
skeybrdCallbacks.c:  if(Kbrd->ShiftPress) {
skeybrdCallbacks.c:    Kbrd->ShiftPress=0;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) {
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:  n = B->nx*B->ny;
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) {
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:  n = B->nx*B->ny;
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->symgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,1);
skeybrdCallbacks.c:      kgUpdateGrp(D,Kbrd->cgrp);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->symgrp,1);
skeybrdCallbacks.c:      kgUpdateGrp(D,Kbrd->symgrp);
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) { 
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) {
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:  n = B->nx*B->ny;
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->symgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,1);
skeybrdCallbacks.c:      kgUpdateGrp(D,Kbrd->sgrp);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->symgrp,1);
skeybrdCallbacks.c:      kgUpdateGrp(D,Kbrd->symgrp);
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) { 
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) {
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:  n = B->nx*B->ny;
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetCurrentWidget(D,Kbrd->CurWid);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->symgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,1);
skeybrdCallbacks.c:      kgUpdateGrp(D,Kbrd->cgrp);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->cgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->symgrp,0);
skeybrdCallbacks.c:      kgSetGrpVisibility(D,Kbrd->sgrp,1);
skeybrdCallbacks.c:      kgUpdateGrp(D,Kbrd->sgrp);
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:    i :  Index of Widget  (0 to max_widgets-1) 
skeybrdCallbacks.c:  Kbrd = D->Kbrd;
skeybrdCallbacks.c:  Kbrd->CurWid =-1;
skeybrdCallbacks.c:  if(D->InputWid >= 0) { 
skeybrdCallbacks.c:     Kbrd->CurWid = D->InputWid;
skeybrdCallbacks.c:  if(Kbrd->CurWid < 0) return 0;
skeybrdCallbacks.c:   but = B->buts;
skeybrdCallbacks.c:   n = B->nx * B->ny;
skeybrdCallbacks.c:   B->nodrawbkgr = NOBKGR;
skeybrdCallbacks.c:    but[i].bkgr = Kbrd->ButClr;
skeybrdCallbacks.c:  pt = D->pt;
skeybrdCallbacks.c:  pt = D->pt;
skeybrdCallbacks.c:  if(kbe->event ==1) {
skeybrdCallbacks.c:    if(kbe->button ==1) {
skeybrdCallbacks.c:  dx = xres - D->xl;
skeybrdCallbacks.c:  dy = yres - D->yl;
skeybrdCallbacks.c:  D->xl= xres;
skeybrdCallbacks.c:  D->yl= yres;
threadtool.c:      ThInfo->nCores = thds;
threadtool.c:      ThInfo->threads = ( Thread * ) malloc ( sizeof ( Thread ) *thds ) ;
threadtool.c:      ThInfo->PIPES = ( int ** ) malloc ( sizeof ( int * ) *thds ) ;
threadtool.c:      ThInfo->RPIPES = ( int ** ) malloc ( sizeof ( int * ) *thds ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) {
threadtool.c:          ThInfo->PIPES [ i ] = ( int * ) malloc ( sizeof ( int ) *2 ) ;
threadtool.c:          ThInfo->RPIPES [ i ] = ( int * ) malloc ( sizeof ( int ) *2 ) ;
threadtool.c:          rval = pipe ( ThInfo->PIPES [ i ] ) ;
threadtool.c:          rval = pipe ( ThInfo->RPIPES [ i ] ) ;
threadtool.c:      if ( ThInfo->threads == NULL ) {
threadtool.c:      ThInfo->ActSize = sizeof ( Thaction ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) {
threadtool.c:          ThInfo->threads [ i ] .num = i;
threadtool.c:          ThInfo->threads [ i ] .ThInfo = ThInfo;
threadtool.c:          pthread_create ( & ( ThInfo->threads [ i ] .id ) , NULL , threadFunc , ThInfo->threads+i ) ;
threadtool.c:      ThInfo->nTh = 0;
threadtool.c:      nTh = ThInfo->nTh;
threadtool.c:      nw = ThInfo->ActSize;
threadtool.c:      count = write ( ThInfo->PIPES [ nTh ] [ 1 ] , pt , nw ) ;
threadtool.c:          wd = write ( ThInfo->PIPES [ nTh ] [ 1 ] , pt+count , nw-count ) ;
threadtool.c:      nTh %= ThInfo->nCores;
threadtool.c:      ThInfo->nTh = nTh;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) rwval = write ( ThInfo->PIPES [ i ] [ 1 ] , & job , ThInfo->ActSize ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) rwval = read ( ThInfo->RPIPES [ i ] [ 0 ] , & rjob , ThInfo->ActSize ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) rwval = write ( ThInfo->PIPES [ i ] [ 1 ] , & job , ThInfo->ActSize ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) rwval = read ( ThInfo->RPIPES [ i ] [ 0 ] , & rjob , ThInfo->ActSize ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) rwval = write ( ThInfo->PIPES [ i ] [ 1 ] , & job , ThInfo->ActSize ) ;
threadtool.c:      ThInfo = th->ThInfo;
threadtool.c:      num = ( th )->num;
threadtool.c:      nr = ThInfo->ActSize;
threadtool.c:          count = read ( ThInfo->PIPES [ num ] [ 0 ] , pt , nr ) ;
threadtool.c:              rd = read ( ThInfo->PIPES [ num ] [ 0 ] , pt+count , nr-count ) ;
threadtool.c:          th->status = BUSY;
threadtool.c:              rwval = write ( ThInfo->RPIPES [ num ] [ 1 ] , & job , ThInfo->ActSize ) ;
threadtool.c:                  th->status = FREE;
threadtool.c:                  count = read ( ThInfo->PIPES [ num ] [ 0 ] , pt , nr ) ;
threadtool.c:                      rd = read ( ThInfo->PIPES [ num ] [ 0 ] , pt+count , nr-count ) ;
threadtool.c:          th->status = FREE;
threadtool.c:          for ( i = 0;i < ThInfo->nCores;i++ ) rwval = write ( ThInfo->PIPES [ i ] [ 1 ] , & job , ThInfo->ActSize ) ;
threadtool.c:          for ( i = 0;i < ThInfo->nCores;i++ ) rwval = read ( ThInfo->RPIPES [ i ] [ 0 ] , & rjob , ThInfo->ActSize ) ;
threadtool.c:          for ( i = 0;i < ThInfo->nCores;i++ ) rwval = write ( ThInfo->PIPES [ i ] [ 1 ] , & job , ThInfo->ActSize ) ;
threadtool.c://   fprintf(stderr,"In Close Threads: %d\n",ThInfo->nCores);
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) {
threadtool.c://     pthread_join((ThInfo->threads[i].id),NULL);
threadtool.c://     pthread_cancel((ThInfo->threads[i].id));
threadtool.c:          pthread_join ( ( ThInfo->threads [ i ] .id ) , & Rval ) ;
threadtool.c:      for ( i = 0;i < ThInfo->nCores;i++ ) {
threadtool.c:          close ( ThInfo->PIPES [ i ] [ 0 ] ) ;
threadtool.c:          close ( ThInfo->PIPES [ i ] [ 1 ] ) ;
threadtool.c:          close ( ThInfo->RPIPES [ i ] [ 0 ] ) ;
threadtool.c:          close ( ThInfo->RPIPES [ i ] [ 1 ] ) ;
threadtool.c:          free ( ThInfo->PIPES [ i ] ) ;
threadtool.c:          free ( ThInfo->RPIPES [ i ] ) ;
threadtool.c:      free ( ThInfo->PIPES ) ;
threadtool.c:      free ( ThInfo->RPIPES ) ;
threadtool.c:      free ( ThInfo->threads ) ;
txlib.c:#define FONT "-adobe-courier-bold-r-*-*-13-*-*-*-*-*-*-*"
txlib.c:#define TY(x,y) (cy -(x)*sint+(y)*cost)
txlib.c:#define pclr(p)  (float)(((p-pmin)*dfac+1.))
txlib.c:#define scr_x(x) (int)((x-w_x1)*u_x+D_x+0.5)
txlib.c:#define scr_y(y) (int)((y-w_y1)*u_y+D_y+0.5)
txlib.c:#define usr_x(x) (float)((x-D_x)/u_x+w_x1)
txlib.c:#define usr_y(y) (float)((y-D_y)/u_y+w_y1)
txlib.c:#define cnv_x(x) (x*fx-sx)
txlib.c:#define cnv_y(y) (y*fy-sy)
txlib.c:#define icde(i,j) icode[j-1][i-1]
txlib.c:#define XDraw(x1,y1,x2,y2) XDrawLine(Dsp,Win,Gc,x1,(EVGAY-y1),x2,(EVGAY-y2))
txlib.c:#define XCPix(x1,y1,x2,y2) XCreatePixmap(Dsp,Win,(short)(x2-(x1)+1),(short)(y2-(y1)+1),Dpth);
txlib.c:  static int Scan_code [ 256 ] = {0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 27 , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , '-' , '=' , '\b' , 0 , 'q' , 'w' , 'e' , 'r' , 't' , 'y' , 'u' , 'i' , 'o' , 'p' , 0 , 0 , '\r' , 0 , 'a' , 's' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' , ';' , '\'' , '`' , 0 , '\\' , 'z' , 'x' , 'c' , 'v' , 'b' , 'n' , 'm' , ',' , '.' , '/' , 0 , 0 , 0 , ' ' , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 103 , 104 , 105 , 106};
txlib.c:   _rect_fill ( menu_x , menu_y-4 , menu_x+nine , menu_y+9 , c ) ;\
txlib.c:          ( x2-x1+1 ) , ( short ) ( y2-y1+1 ) , ( short ) x1 , 
txlib.c:          ( short ) ( y1-width ) ) ;
txlib.c:      yy1 = EVGAY-y1;
txlib.c:      yy2 = EVGAY-y2;
txlib.c:    scr_copy(-22,0);
txlib.c:  /*else t_graph_new((x2-x1+1),(y2-y1+1));*/
txlib.c:      else {t_graph_new ( ( x2-x1 ) , ( y2-y1 ) ) ;GR_ON = 1;GUI_ON = 1;}
txlib.c:              if ( ( event.type == KeyPress ) && Shift_key ) { Shift = 1;return ( -1 ) ;}
txlib.c:              if ( ( event.type == KeyRelease ) && Shift_key ) { Shift = 0;return ( -1 ) ;}
txlib.c:                  { Caplock = 1;return ( -1 ) ;}
txlib.c:                  { Caplock = 0;return ( -1 ) ;}
txlib.c:              else return ( -1 ) ;
txlib.c:          else return ( -1 ) ;
txlib.c:      else return ( -1 ) ;
txlib.c:          if ( ( Shift != 0 ) && ( ch >= 'A' ) && ( ch <= 'Z' ) ) ch+= ( 'a'-'A' ) ;
txlib.c:          if ( ( Shift == 0 ) && ( ch >= 'a' ) && ( ch <= 'z' ) ) ch-= ( 'a'-'A' ) ;
txlib.c:      if ( key_press ( & ch ) < 0 ) return ( -1 ) ;
txlib.c:      if ( ch == 0 ) return ( -1 ) ;
txlib.c:          ( -100 ) ;
txlib.c:      if ( Child != Win ) { return ( -1 ) ; };
txlib.c:   if(XQueryPointer(Dsp,Curwin,&Root,&Child,&x1,&y1,x,y,&pb)==False)return(-100);
txlib.c:  if( Child != Win){ return(-1); };
txlib.c:      *x -= ( x0 ) ;*y-= ( y0 ) ;
txlib.c:      else{ return ( -1 ) ;}
txlib.c:      *dx = x-xo , *dy = y-yo;
txlib.c:      if ( ( abs ( *dx ) < 2 ) && ( abs ( *dy ) < 2 ) ) return ( -1 ) ;
txlib.c:      if ( ( key1 = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
txlib.c:      if ( ( key2 = GetPointer ( & x2 , & y2 ) ) < 0 ) return ( -1 ) ;
txlib.c:          ( & x2 , & y2 ) ) < 0 ) return ( -1 ) ;
txlib.c:      *x = x2-x1;*y = y2-y1;
txlib.c:      y2 -= ( dy/2 ) ;
txlib.c:      yy -= y1;
txlib.c:      if ( ierr == -1 ) printf ( "ERROR IN  IOCTL\n" ) ;
txlib.c:      if ( ierr == -1 ) printf ( "ERROR IN IOCTL\n" ) ;
txlib.c:      if ( ierr == -1 ) printf ( "ERROR IN  IOCTL\n" ) ;
txlib.c:              yy = EVGAY-dy;
txlib.c:                      if ( ( ( r [ i ] .x1-dx ) * ( r [ i ] .x2-dx ) <= 0 ) && 
txlib.c:                          ( ( r [ i ] .y1-yy ) * ( r [ i ] .y2-yy ) <= 0 ) ) {
txlib.c:              ire = abs ( icode [ i ] [ 0 ] -ir ) ;
txlib.c:              ige = abs ( icode [ i ] [ 2 ] -ig ) ;
txlib.c:              ibe = abs ( icode [ i ] [ 1 ] -ib ) ;
txlib.c:      v_xt1 = ( int ) ( v_x1-txt_wt-txt_sp ) ;
txlib.c:      v_yt1 = ( int ) ( v_y1-txt_ht ) ;
txlib.c:      x1 = ( int ) ( ( float ) w_x1+ ( float ) ( lcur_x - v_x1 ) * 
txlib.c:          ( w_x2 - w_x1 ) /V_x ) ;
txlib.c:      x2 = ( int ) ( ( float ) w_x1+ ( float ) ( rcur_x - v_x1+1 ) * 
txlib.c:          ( w_x2 - w_x1 ) /V_x ) ;
txlib.c:      y1 = w_x2- ( int ) ( ( float ) w_y1+ ( float ) 
txlib.c:          ( lcur_y - v_y2+1 ) * ( w_y2 - w_y1 ) /V_y ) ;
txlib.c:      y2 = w_x2- ( int ) ( ( float ) w_y1+ ( float ) 
txlib.c:          ( rcur_y - v_y2 ) * ( w_y2 - w_y1 ) /V_y ) ;
txlib.c:      j = EVGAY-row;
txlib.c:      visclass = vis->class;
txlib.c:      msg_x = ( EVGAX-316 ) /2;
txlib.c:      msg_y = EVGAY-24;
txlib.c:      gcv.font = fontstruct->fid;
txlib.c:      msg_x = ( EVGAX-316 ) /2;
txlib.c:      msg_y = EVGAY-24;
txlib.c:      gcv.font = fontstruct->fid;
txlib.c:      msg_x = ( EVGAX-316 ) /2;
txlib.c:      msg_y = EVGAY-24;
txlib.c:      gcv.font = fontstruct->fid;
txlib.c:          _draw_line ( x-3*fac , y-3*fac , x+3*fac , y+3*fac ) ;
txlib.c:          _draw_line ( x-3*fac , y+3*fac , x+3*fac , y-3*fac ) ;
txlib.c:          _box_fill ( x-3*fac , y-3*fac , x+3*fac , y+3*fac , 
txlib.c:          case 3 : _draw_line ( x , y-4*fac , x , y+4*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y , x+4*fac , y ) ;
txlib.c:          _draw_line ( x-2*fac , y-4*fac , x+2*fac , y-4*fac ) ;
txlib.c:          _draw_line ( x-2*fac , y+4*fac , x+2*fac , y+4*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y-2*fac , x-4*fac , y+2*fac ) ;
txlib.c:          _draw_line ( x+4*fac , y-2*fac , x+4*fac , y+2*fac ) ;
txlib.c:          case 4 : _draw_line ( x-4*fac , y-4*fac , x+4*fac , y+4*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y+4*fac , x+4*fac , y-4*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y , x+4*fac , y ) ;
txlib.c:          _draw_line ( x , y-4*fac , x , y+4*fac ) ;
txlib.c:          case 5 : _draw_line ( x+3*fac , y , x , y-8*fac ) ;
txlib.c:          _draw_line ( x-3*fac , y , x , y-8*fac ) ;
txlib.c:          _draw_line ( x-3*fac , y , x , y+8*fac ) ;
txlib.c:          case 6 : _draw_line ( x-4*fac , y , x+4*fac , y ) ;
txlib.c:          _draw_line ( x , y-4*fac , x , y+4*fac ) ;
txlib.c:          _draw_line ( x+2*fac , y-2*fac , x+2*fac , y+2*fac ) ;
txlib.c:          _draw_line ( x+2*fac , y+2*fac , x-2*fac , y+2*fac ) ;
txlib.c:          _draw_line ( x-2*fac , y+2*fac , x-2*fac , y-2*fac ) ;
txlib.c:          _draw_line ( x-2*fac , y-2*fac , x+2*fac , y-2*fac ) ;
txlib.c:          _draw_line ( x+7*fac , y , x+3*fac , y-3*fac ) ;
txlib.c:          _draw_line ( x+3*fac , y-3*fac , x , y-7*fac ) ;
txlib.c:          _draw_line ( x , y-7*fac , x-3*fac , y-3*fac ) ;
txlib.c:          _draw_line ( x-3*fac , y-3*fac , x-7*fac , y ) ;
txlib.c:          _draw_line ( x-7*fac , y , x-3*fac , y+3*fac ) ;
txlib.c:          _draw_line ( x-3*fac , y+3*fac , x , y+7*fac ) ;
txlib.c:          case 8 : _draw_line ( x-4*fac , y-4*fac , x+4*fac , y+4*fac ) ;
txlib.c:          _draw_line ( x+4*fac , y-4*fac , x-4*fac , y+4*fac ) ;
txlib.c:          _draw_line ( x+4*fac , y-4*fac , x+4*fac , y-2*fac ) ;
txlib.c:          _draw_line ( x+4*fac , y-4*fac , x+2*fac , y-4*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y-4*fac , x-2*fac , y-4*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y-4*fac , x-4*fac , y-2*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y+4*fac , x-4*fac , y+2*fac ) ;
txlib.c:          _draw_line ( x-4*fac , y+4*fac , x-2*fac , y+4*fac ) ;
txlib.c:          px [ 0 ] = x+4*fac;py [ 0 ] = y;px [ 1 ] = x-4*fac;py [ 1 ] = y+4*fac;
txlib.c:          px [ 2 ] = x-4*fac;py [ 2 ] = y-4*fac;
txlib.c:          px [ 0 ] = x-4*fac;py [ 0 ] = y;px [ 1 ] = x+4*fac;py [ 1 ] = y+4*fac;
txlib.c:          px [ 2 ] = x+4*fac;py [ 2 ] = y-4*fac;
txlib.c:          px [ 0 ] = x;py [ 0 ] = y+4*fac;px [ 1 ] = x-4*fac;py [ 1 ] = y-4*fac;
txlib.c:          px [ 2 ] = x+4*fac;py [ 2 ] = y-4*fac;
txlib.c:          px [ 0 ] = x;py [ 0 ] = y-4*fac;px [ 1 ] = x-4*fac;py [ 1 ] = y+4*fac;
txlib.c:          _draw_line ( x-2*fac , y-2*fac , x+2*fac , y+2*fac ) ;
txlib.c:          _draw_line ( x-2*fac , y+2*fac , x+2*fac , y-2*fac ) ;
txlib.c:          px [ 0 ] = x+2*fac;py [ 0 ] = y;px [ 1 ] = x-2*fac;py [ 1 ] = y+2*fac;
txlib.c:          px [ 2 ] = x-2*fac;py [ 2 ] = y-2*fac;
txlib.c:          px [ 0 ] = x-2*fac;py [ 0 ] = y;px [ 1 ] = x+2*fac;py [ 1 ] = y+2*fac;
txlib.c:          px [ 2 ] = x+2*fac;py [ 2 ] = y-2*fac;
txlib.c:          px [ 0 ] = x;py [ 0 ] = y+2*fac;px [ 1 ] = x-2*fac;py [ 1 ] = y-2*fac;
txlib.c:          px [ 2 ] = x+2*fac;py [ 2 ] = y-2*fac;
txlib.c:          px [ 0 ] = x;py [ 0 ] = y-2*fac;px [ 1 ] = x-2*fac;py [ 1 ] = y+2*fac;
txlib.c:          tx = ( ( *xb ) - ( *xa ) ) ;
txlib.c:          ty = ( ( *yb ) - ( *ya ) ) ;
txlib.c:              y = ( int ) ( *ya+ ( c_v_x1- ( *xa ) ) *ty/tx ) ;
txlib.c:              y = ( int ) ( *ya+ ( c_v_x2- ( *xa ) ) *ty/tx ) ;
txlib.c:              x = ( int ) ( *xa+ ( c_v_y2- ( *ya ) ) *tx/ty ) ;
txlib.c:              x = ( int ) ( *xa+ ( c_v_y1- ( *ya ) ) *tx/ty ) ;
txlib.c:      ixdf = ixe - ixb;
txlib.c:      iydf = iye - iyb;
txlib.c:      id = ixu-ixl;
txlib.c:      if ( id < iyu-iyl ) id = iyu-iyl;
txlib.c:              put_pixl ( ix , EVGAY-iy ) ;
txlib.c:      lnwidth = ln_width-2;
txlib.c:      dx = ( float ) ( xb-xa ) ;
txlib.c:      dy = ( float ) ( yb-ya ) ;
txlib.c:      if ( ct < 0. ) dy1 = ( int ) ( ct*i2-0.5 ) ;
txlib.c:      xa += dx1 , xb += dx1 , ya -= dy1 , yb -= dy1;
txlib.c:          if ( ct < 0. ) dy1 = ( int ) ( ct*i-0.5 ) ;
txlib.c:          _draw_line ( xa-dx1 , ya+dy1 , xb-dx1 , yb+dy1 ) ;
txlib.c:          dx = xb-xa;
txlib.c:          dy = yb-ya;
txlib.c:              g = inc1-dx1;
txlib.c:              inc2 = g-dx1;
txlib.c:              else ch = -1;
txlib.c:              else rh = -1;
txlib.c:              g = inc1-dy1;
txlib.c:              inc2 = g-dy1;
txlib.c:              else ch = -1;
txlib.c:              else rh = -1;
txlib.c:          while ( abs ( c-f ) > 0 ) {
txlib.c:                  if ( dx1 > dy1 ) put_pixl ( c , ( EVGAY-r ) ) ;
txlib.c:                  else put_pixl ( r , ( EVGAY-c ) ) ;
txlib.c:              dx = ( float ) ( xb-xa ) ;
txlib.c:              dy = ( float ) ( yb-ya ) ;
txlib.c:              if ( ct < 0. ) dy1 = ( int ) ( ct*i2-0.5 ) ;
txlib.c:              xa += dx1 , xb += dx1 , ya -= dy1 , yb -= dy1;
txlib.c:                  if ( ct < 0. ) dy1 = ( int ) ( ct*i-0.5 ) ;
txlib.c:                  cur_x = xa-dx1 , cur_y = ya+dy1;
txlib.c:                  _draw_ ( xb-dx1 , yb+dy1 ) ;
txlib.c:          tm = 1.-t;
txlib.c:          dist = ( x-x1 ) * ( x-x1 ) + ( y-y1 ) * ( y-y1 ) ;
txlib.c:          tm = 1.-t;
txlib.c:          j1 = j-1;
txlib.c:          while ( i < j ) { if ( ( x1 [ i ] == x1 [ i-1 ] ) && ( y1 [ i ] == y1 [ i-1 ] ) ) 
txlib.c:              { j--; for ( k = i;k < j;k++ ) {x1 [ k ] = x1 [ k+1 ] ;
txlib.c:      for ( i = 1;i < j;i++ ) {x2 [ i-1 ] = x1 [ i ] ;y2 [ i-1 ] = y1 [ i ] ;}
txlib.c:      x2 [ j-1 ] = x1 [ 0 ] ;y2 [ j-1 ] = y1 [ 0 ] ;
txlib.c:          j1 = j-1;
txlib.c:      xup = -100000;
txlib.c:      ygrt = -1239000;
txlib.c:          j = i-1;
txlib.c:              j--;
txlib.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib.c:                          ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
txlib.c:              j = i-1;
txlib.c:              while ( j >= 0 && txx < xcord [ j ] ) { xcord [ j+1 ] = xcord [ j ] ;j--;}
txlib.c:      pnt = asc-32+greek;
txlib.c:      else xo -= ( 1.-fact ) *0.5*txt_wt;
txlib.c:      pnt = asc-32+greek;
txlib.c:      else xo -= ( 1.-fact ) *0.5*txt_wt;
txlib.c:      ya = ( cy- ( xo ) *sint+yo*cost ) ;
txlib.c:                  y [ i ] = ( cy+ ( ydum ) *cost- ( xdum ) *sint ) ;
txlib.c:      pnt = asc-32+greek;
txlib.c:      else xo -= ( 1.-fact ) *0.5*txt_wt;
txlib.c:      pnt = asc-32+greek;
txlib.c:      else xo -= ( 1.-fact ) *0.5*txt_wt;
txlib.c:      ya = ( cy- ( xo ) *sint+yo*cost ) ;
txlib.c:                  y [ i ] = ( cy+ ( ydum ) *cost- ( xdum ) *sint ) ;
txlib.c:      pnt = asc-33+greek;
txlib.c:      if ( pr_txt == 0 ) { xo += ( 1.-fact ) *0.5*txt_wt;
txlib.c:                  if ( ( icxv [ j ] == icxv [ j-1 ] ) && ( icyv [ j ] == icyv [ j-1 ] ) ) {
txlib.c:      pnt = asc-33+greek;
txlib.c:      ya = ( int ) ( cy- ( xp ) *sint+yp*cost ) ;
txlib.c:              ya = ( int ) ( cy+ ( tempy ) *cost- ( tempx ) *sint ) ;
txlib.c:                  if ( ( icxv [ j ] == icxv [ j-1 ] ) && ( icyv [ j ] == icyv [ j-1 ] ) ) {
txlib.c:                      ya = ( int ) ( cy+ ( tempy ) *cost- ( tempx ) *sint ) ;
txlib.c:                  y = ( int ) ( cy+ ( tempy ) *cost- ( tempx ) *sint ) ;
txlib.c:      else yp = yp-0.7*txt_ht;
txlib.c:          if ( ( pt->x2 ) < 0. ) {
txlib.c:              if ( ( pt->ymax ) < ( yp+1.4*txt_ht ) ) pt->ymax = yp+1.4*txt_ht;
txlib.c:              if ( ( pt->ymin ) > ( yp-0.4*txt_ht ) ) pt->ymin = yp-0.4*txt_ht;
txlib.c:          pt = pt->Pr;
txlib.c:      is = *ishft- ( ( *ishft ) /10 ) *10;
txlib.c:          *ishft = ( *ishft ) -1;
txlib.c:          yp = yp-1.4*txt_ht;
txlib.c:              XFillRectangle ( Dsp , Win , Gc , x_min , EVGAY-y_max , x_max1-x_min+1 , y_max-y_min+1 ) ;
txlib.c:      xup = -100000;
txlib.c:      ygrt = -1239000;
txlib.c:          j = i-1;
txlib.c:              j--;
txlib.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib.c:                          ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
txlib.c:              j = i-1;
txlib.c:              while ( j >= 0 && txx < xcord [ j ] ) { xcord [ j+1 ] = xcord [ j ] ;j--;}
txlib.c:      ym = y- ( short ) ( r/sqrt ( ( double ) 2. ) ) ;
txlib.c:      for ( j = y;j >= ym;--j ) {
txlib.c:          i = x+ ( short ) sqrt ( ( double ) sqrd- ( ( y-j ) * ( y-j ) ) ) ;
txlib.c:          put_pixel ( i , 2*y-j ) ;
txlib.c:          put_pixel ( x+y-j , y+i-x ) ;
txlib.c:          put_pixel ( x-y+j , y+i-x ) ;
txlib.c:          put_pixel ( 2*x-i , 2*y-j ) ;
txlib.c:          put_pixel ( 2*x-i , j ) ;
txlib.c:          put_pixel ( x-y+j , y-i+x ) ;
txlib.c:          put_pixel ( x+y-j , y-i+x ) ;
txlib.c:      ym = y- ( short ) ( r/sqrt ( ( double ) 2. ) ) ;
txlib.c:      put_pixel ( x , y+r ) , put_pixel ( x , y-r ) ;
txlib.c:      put_pixel ( x+r , y ) , put_pixel ( x-r , y ) ;
txlib.c:      hori_line ( x-r+1 , x+r-1 , y ) ;
txlib.c:          t = sqrd- ( float ) ( j*j ) ;
txlib.c:          put_pixel ( x-i , y-j ) ;
txlib.c:          put_pixel ( x+i , y-j ) ;
txlib.c:          put_pixel ( x-i , y+j ) ;
txlib.c:          hori_line ( x-i+1 , x+i-1 , y-j ) ;
txlib.c:          hori_line ( x-i+1 , x+i-1 , y+j ) ;
txlib.c:          scpt->nx = NULL;
txlib.c:          scpt->pv = NULL;
txlib.c:          tmp->nx = NULL;
txlib.c:          tmp->pv = scpt;
txlib.c:          scpt->nx = tmp;
txlib.c:          scpt = scpt->nx;
txlib.c:          scpt = scpt->pv;
txlib.c:          scpt = scpt->pv;
txlib.c:      scpt->x1 = x1; scpt->x2 = x2;
txlib.c:      scpt->y1 = y1; scpt->y2 = y2;
txlib.c:      scpt->buf = XCPix ( x1 , y1 , x2 , y2 ) ;
txlib.c:      XCopyArea ( Dsp , Win , ( scpt->buf ) , Gc , ( short ) x1 , ( short ) 
txlib.c:          ( y1 ) , ( short ) ( x2-x1+1 ) , ( short ) ( y2-y1+1 ) , 0 , 0 ) ;
txlib.c:      x1 = scpt->x1; x2 = scpt->x2;
txlib.c:      y1 = scpt->y1; y2 = scpt->y2;
txlib.c:      XCopyArea ( Dsp , ( scpt->buf ) , Win , Gc , 0 , 0 , ( short ) ( x2-x1+1 ) , 
txlib.c:          ( short ) ( y2-y1+1 ) , ( short ) x1 , ( short ) y1 ) ;
txlib.c:      XFreePixmap ( Dsp , scpt->buf ) ;
txlib.c:      x1 = scpt->x1 + x0; x2 = scpt->x2 + x0;
txlib.c:      y1 = scpt->y1 + y0; y2 = scpt->y2 + y0;
txlib.c:      XCopyArea ( Dsp , ( scpt->buf ) , Win , Gc , 0 , 0 , ( short ) ( x2-x1+1 ) , 
txlib.c:          ( short ) ( y2-y1+1 ) , ( short ) x1 , ( short ) y1 ) ;
txlib.c:      hori_line ( gcur_x-8 , gcur_x+8 , EVGAY-gcur_y ) ;
txlib.c:      vert_line ( EVGAY-gcur_y-8 , EVGAY-gcur_y+8 , gcur_x ) ;
txlib.c:      if ( gcur_y > EVGAY-v_y1-2 ) {gcur_y = EVGAY-v_y1-2;gbell ( ) ;};
txlib.c:      if ( gcur_y < EVGAY-v_y2 ) {gcur_y = EVGAY-v_y2;gbell ( ) ;};
txlib.c:      y = usr_y ( EVGAY-gcur_y ) ;
txlib.c:      if ( gcur_y > EVGAY-v_y1-2 ) {gcur_y = EVGAY-v_y1-2;gbell ( ) ;};
txlib.c:      if ( gcur_y < EVGAY-v_y2 ) {gcur_y = EVGAY-v_y2;gbell ( ) ;};
txlib.c:      y = usr_y ( EVGAY-gcur_y ) ;
txlib.c:  if(gcur_y>EVGAY-v_y1-2 ){gcur_y=EVGAY-v_y1-2;gbell();};
txlib.c:  if(gcur_y<EVGAY-v_y2 ){gcur_y=EVGAY-v_y2;gbell();};
txlib.c:      y = usr_y ( EVGAY-gcur_y ) ;
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:      scr_back ( gcur_x-8 , gcur_y-8 , gcur_x+8 , gcur_y+8 ) ;
txlib.c:              if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:                  *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      gcur_x-= jmp;
txlib.c:      gcur_y-= jmp;
txlib.c:      hori_line ( lcur_x , lcur_x+16 , EVGAY-lcur_y ) ;
txlib.c:      vert_line ( EVGAY-lcur_y , EVGAY-lcur_y+16 , lcur_x ) ;
txlib.c:      hori_line ( rcur_x , rcur_x-16 , EVGAY-rcur_y ) ;
txlib.c:      vert_line ( EVGAY-rcur_y , EVGAY-rcur_y-16 , rcur_x ) ;
txlib.c:      jmpy = ( float ) jmp/ ( v_x2-v_x1 ) * ( v_y2-v_y1 ) ;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) {jmp = ch-'0'; jmpy = 
txlib.c:                      ( float ) jmp/ ( v_x2-v_x1 ) * ( v_y2-v_y1 ) ;};
txlib.c:              scr_back ( xmin , ymax-1 , xmax , ymax ) ;
txlib.c:              scr_back ( xmax-1 , ymin , xmax , ymax ) ;
txlib.c:              _draw_bound ( xmin , EVGAY-ymin , xmax , EVGAY-ymax ) ;
txlib.c:      lcur_x-= jmp;
txlib.c:/*  lcur_y+=jmp-2;*/
txlib.c:      yrcur -= jmpy;
txlib.c:/*  rcur_y-=jmp-2;*/
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:/*  lcur_y-=jmp-2;*/
txlib.c:      ylcur -= jmpy;
txlib.c:      rcur_x-= jmp;
txlib.c:/*  rcur_y+=jmp-2;*/
txlib.c:          lcur_x-= jmp;
txlib.c:          yrcur -= jmpy;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:              if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:      lcur_y-= jmp;
txlib.c:      rcur_y-= jmp;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      lcur_x-= jmp;
txlib.c:      rcur_x-= jmp;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:              if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:      rcur_y-= jmp;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      lcur_y-= jmp;
txlib.c:          rcur_y-= jmp;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      lcur_x-= jmp;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      rcur_x-= jmp;
txlib.c:          lcur_x-= jmp;
txlib.c:      scr_back ( lcur_x , lcur_y-16 , lcur_x+16 , lcur_y ) ;
txlib.c:      scr_back ( rcur_x-16 , rcur_y , rcur_x , rcur_y+16 ) ;
txlib.c:      xup = -100000;
txlib.c:      ygrt = -1239000;
txlib.c:          j = i-1;
txlib.c:              j--;
txlib.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib.c:                          ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
txlib.c:                      pcord [ cnt ] = ( ( ( float ) ( pmax [ i ] -pmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib.c:                          ( scan-ymin [ i ] ) +pmin [ i ] ) ) ;
txlib.c:              j = i-1;
txlib.c:                  j--;}
txlib.c:      yy = EVGAY-y;
txlib.c:      if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib.c:      if ( xa < c_v_x1 ) {pval = pa+ ( c_v_x1-xa ) *pfac;
txlib.c:      if ( xb > c_v_x2 ) {pval = pa+ ( c_v_x2-xa ) *pfac;
txlib.c:          tempc = ( int ) ( pa+ ( i-xa ) *pfac+0.5 ) ;
txlib.c:              XFillRectangle ( Dsp , Win , Gc , x_min , EVGAY-y_max , x_max1-x_min+1 , y_max-y_min+1 ) ;
txlib.c:      iy = EVGAY-iy1-11;
txlib.c:      XDrawString ( Dsp , Win , Gc , ix1+2 , EVGAY-iy1 , str , 1 ) ;
txlib.c:      sam = 462- ( nmenu-1 ) *28;
txlib.c:              else b_y-= 28;
txlib.c:      tw = txt_wt* ( w_x2-w_x1 ) /V_x;
txlib.c:      tg = txt_sp* ( w_x2-w_x1 ) /V_x;
txlib.c:      ytwtg = ( tw+tg ) / ( w_x2-w_x1 ) * ( w_y2-w_y1 ) /0.75;
txlib.c:                      if ( ihori == 1 ) xx = xx-tw-tg;
txlib.c:                      else yy = yy -ytwtg;
txlib.c:                      t_txt_wr ( 1 , & bf [ i-1 ] ) ;
txlib.c:                      loc--;count--;
txlib.c:                  i--; bf [ i ] = '\0';};
txlib.c:                  t_txt_wr ( 1 , & bf [ i-1 ] ) ;
txlib.c:      tw = txt_wt* ( w_x2-w_x1 ) /V_x;
txlib.c:      tg = txt_sp* ( w_x2-w_x1 ) /V_x;
txlib.c:      ytwtg = ( tw+tg ) / ( w_x2-w_x1 ) * ( w_y2-w_y1 ) /0.75;
txlib.c:                      if ( ihori == 1 ) xx = xx-tw-tg;
txlib.c:                      else yy = yy -ytwtg;
txlib.c:                      t_txt_wr ( 1 , & bf [ i-1 ] ) ;
txlib.c:                      loc--;count--;
txlib.c:                  i--; bf [ i ] = '\0';};
txlib.c:                  t_txt_wr ( 1 , & bf [ i-1 ] ) ;
txlib.c:      V_x = v_x2-v_x1;
txlib.c:      V_y = v_y2-v_y1;
txlib.c:      u_x = ( V_x/ ( w_x2-w_x1 ) ) ;
txlib.c:      u_y = ( V_y/ ( w_y2-w_y1 ) ) ;
txlib.c:      lcur_y = EVGAY-v_y1;
txlib.c:      rcur_y = EVGAY-v_y2;
txlib.c:      u_x = ( V_x/ ( x2-x1 ) ) ;
txlib.c:      u_y = ( V_y/ ( y2-y1 ) ) ;
txlib.c:      r_d = ( ( ( x2-x1 ) * ( x2-x1 ) + ( y2-y1 ) * ( y2-y1 ) ) ) ;
txlib.c:      txt_ht = ( w_y2-w_y1 ) *0.03;
txlib.c:      txt_wt = ( w_x2-w_x1 ) *0.03;
txlib.c:      txt_sp = ( w_x2-w_x1 ) *0.003;
txlib.c:  txt_htx=ht/(w_y2-w_y1)*(w_x2-w_x1);
txlib.c:  txt_wty=wt/(w_x2-w_x1)*(w_y2-w_y1);
txlib.c:  txt_spy=sp/(w_x2-w_x1)*(w_y2-w_y1);
txlib.c:      txt_wt = sint*sint*txt_wty* ( w_x2-w_x1 ) / ( w_y2-w_y1 ) +cost*cost*txt_wtx;
txlib.c:      txt_sp = sint*sint*txt_spy* ( w_x2-w_x1 ) / ( w_y2-w_y1 ) +cost*cost*txt_spx;
txlib.c:      txt_ht = sint*sint*txt_htx/ ( w_x2-w_x1 ) * ( w_y2-w_y1 ) +cost*cost*txt_hty;
txlib.c:      txt_ht = txt_ht*V_y/ ( w_y2-w_y1 ) ;
txlib.c:      txt_wt = txt_wt*V_x/ ( w_x2-w_x1 ) ;
txlib.c:      txt_sp = txt_sp*V_x/ ( w_x2-w_x1 ) ;
txlib.c:      v_xt1 = ( int ) ( v_x1-txt_wt-txt_sp ) ;
txlib.c:      v_yt1 = ( int ) ( v_y1-txt_ht ) ;
txlib.c:      theta = -t*rad;
txlib.c:      txt_wt = sint*sint*txt_wty* ( w_x2-w_x1 ) / ( w_y2-w_y1 ) +cost*cost*txt_wtx;
txlib.c:      txt_sp = sint*sint*txt_spy* ( w_x2-w_x1 ) / ( w_y2-w_y1 ) +cost*cost*txt_spx;
txlib.c:      txt_ht = sint*sint*txt_htx/ ( w_x2-w_x1 ) * ( w_y2-w_y1 ) +cost*cost*txt_hty;
txlib.c:      txt_ht = txt_ht*V_y/ ( w_y2-w_y1 ) ;
txlib.c:      txt_wt = txt_wt*V_x/ ( w_x2-w_x1 ) ;
txlib.c:      txt_sp = txt_sp*V_x/ ( w_x2-w_x1 ) ;
txlib.c:      v_xt1 = ( int ) ( v_x1-txt_wt-txt_sp ) ;
txlib.c:      v_yt1 = ( int ) ( v_y1-txt_ht ) ;
txlib.c:                          xp = xp -txt_wt -txt_sp;
txlib.c:                              while ( ( pt->x2 ) >= 0. ) pt = pt->Pr;
txlib.c:                               ( pt->x2 ) = xp-txt_sp;
txlib.c:                              pt = pt->Pr;
txlib.c:                              xp = O_P->x;
txlib.c:                              yp = O_P->y;
txlib.c:                              O_P = O_P->Pr;
txlib.c:                              O_P->Nx = NULL;O_P->Pr = NULL;
txlib.c:                              O_P->Nx = ( B_K * ) Malloc ( ( int ) sizeof ( B_K ) ) ;
txlib.c:                              O_P->Nx->Pr = O_P;
txlib.c:                              O_P = O_P->Nx;
txlib.c:                              O_P->Nx = NULL;
txlib.c:                           ( O_P->x ) = xp;
txlib.c:                           ( O_P->y ) = yp;
txlib.c:                          yp -= 0.2*txt_ht;
txlib.c:                          yp -= 0.9*txt_ht;
txlib.c:                              O_L->Nx = NULL;O_L->Pr = NULL;
txlib.c:                              O_L->Nx = ( L_N * ) Malloc ( ( int ) sizeof ( L_N ) ) ;
txlib.c:                              O_L->Nx->Pr = O_L;
txlib.c:                              O_L = O_L->Nx;
txlib.c:                              O_L->Nx = NULL;
txlib.c:                           ( O_L->x1 ) = xp;
txlib.c:                           ( O_L->x2 ) = -1.0;
txlib.c:                          O_L->ymax = yp+1.4*txt_ht;
txlib.c:                          O_L->ymin = yp-0.4*txt_ht;
txlib.c:                          O_L->p = cntl;
txlib.c:                          Nu = ( txt [ i+1 ] -'0' ) ;
txlib.c:                          De = ( txt [ i+2 ] -'0' ) ;
txlib.c:                          Nu = ( txt [ i+1 ] -'0' ) *10+ ( txt [ i+2 ] -'0' ) ;
txlib.c:                          Nu = ( txt [ i+1 ] -'0' ) ;
txlib.c:                          De = ( txt [ i+2 ] -'0' ) ;
txlib.c:                          Nu = ( txt [ i+1 ] -'0' ) ;
txlib.c:                          De = ( txt [ i+2 ] -'0' ) ;
txlib.c:          if ( pt->x2 < 0. ) pt->x2 = xp;
txlib.c:          if ( pt->p == 'U' ) {
txlib.c:              _move ( TX ( ( pt->x1 ) , pt->ymin ) , TY ( ( pt->x1 ) , pt->ymin ) ) ;
txlib.c:              _draw ( TX ( ( pt->x2 ) , pt->ymin ) , TY ( ( pt->x2 ) , pt->ymin ) ) ;
txlib.c:              _move ( TX ( ( pt->x1 ) , pt->ymax ) , TY ( ( pt->x1 ) , pt->ymax ) ) ;
txlib.c:              _draw ( TX ( ( pt->x2 ) , pt->ymax ) , TY ( ( pt->x2 ) , pt->ymax ) ) ;
txlib.c:          pt = pt->Nx;
txlib.c:          O_P = O_P->Pr;
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:                      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      msg_x = ( EVGAX-316 ) /2;
txlib.c:      msg_y = EVGAY-24;
txlib.c:      dfac = ( n -1 ) / ( pmax-pmin ) ;
txlib.c:      lcur_y = EVGAY-v_y1;
txlib.c:      rcur_y = EVGAY-v_y2;
txlib.c:      gw_y1 = usr_y ( ( EVGAY-lcur_y ) ) ;
txlib.c:      gw_y2 = usr_y ( ( EVGAY-rcur_y ) ) ;
txlib.c:              gw_y1 = usr_y ( ( EVGAY-lcur_y ) ) ;
txlib.c:              gw_y2 = usr_y ( ( EVGAY-rcur_y ) ) ;
txlib.c:              lcur_y = EVGAY-v_y1;
txlib.c:              rcur_y = EVGAY-v_y2;
txlib.c:      gw_y1 = usr_y ( ( EVGAY-lcur_y ) ) ;
txlib.c:      gw_y2 = usr_y ( ( EVGAY-rcur_y ) ) ;
txlib.c:              gw_y1 = usr_y ( ( EVGAY-lcur_y ) ) ;
txlib.c:              gw_y2 = usr_y ( ( EVGAY-rcur_y ) ) ;
txlib.c:      i = ln-1;
txlib.c:      * ( ptr+i ) = '\0';i--;
txlib.c:      while ( ( i >= 0 ) && ( * ( ptr+i ) <= ' ' ) ) {* ( ptr+i ) = '\0';i--;}
txlib.c:      pnt = asc-32;
txlib.c:              xdum = ( icxvF [ ptr ] -1500. ) *fact+1500;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:          nm_f = m_fps [ font-4 ] ;
txlib.c:      rd -= xa;
txlib.c:      fj = 0.0; gj = -1; fact = 1.0;
txlib.c:              if ( pr_txt > 0 ) fact1 = m_f [ title [ i ] -32+greek ] *fact;
txlib.c:                  fj = fj-fact1;fjl-= 1.; gj = gj-1;
txlib.c:                      fj = O_P->x;
txlib.c:                      fjl = O_P->xl;
txlib.c:                      gj = O_P->y;
txlib.c:                      O_P = O_P->Pr;
txlib.c:                      O_P->Nx = NULL;O_P->Pr = NULL;
txlib.c:                      O_P->Nx = ( B_K * ) Malloc ( ( int ) sizeof ( B_K ) ) ;
txlib.c:                      O_P->Nx->Pr = O_P;
txlib.c:                      O_P = O_P->Nx;
txlib.c:                      O_P->Nx = NULL;
txlib.c:                   ( O_P->x ) = fj;
txlib.c:                   ( O_P->xl ) = fjl;
txlib.c:                   ( O_P->y ) = gj;
txlib.c:                  val = title [ i+1 ] -'0';
txlib.c:                  val = val*10+ ( title [ i+2 ] -'0' ) ;
txlib.c:                         /*gj = gj-2;*/
txlib.c:                  val = title [ i+2 ] -'0';
txlib.c:                  val = ( float ) ( title [ i+1 ] -'0' ) /val;
txlib.c:                         /*gj = gj-2;*/
txlib.c:                  val = title [ i+2 ] -'0';
txlib.c:                  val = ( float ) ( title [ i+1 ] -'0' ) /val;
txlib.c:                         /*gj = gj-2;*/
txlib.c:                  val = title [ i+2 ] -'0';
txlib.c:                  val = ( float ) ( title [ i+1 ] -'0' ) /val;
txlib.c:                         /*gj = gj-2;*/
txlib.c:          O_P = O_P->Pr;
txlib.c:      temp->pt = ( int * ) c_loc;
txlib.c:      temp->cx1 = c_v_x1;
txlib.c:      temp->cy1 = c_v_y1;
txlib.c:      temp->cx2 = c_v_x2;
txlib.c:      temp->cy2 = c_v_y2;
txlib.c:          temp = ( CLIP * ) c_loc->pt;
txlib.c:          c_v_x1 = c_loc->cx1;
txlib.c:          c_v_y1 = c_loc->cy1;
txlib.c:          c_v_x2 = c_loc->cx2;
txlib.c:          c_v_y2 = c_loc->cy2;
txlib.c:          temp = ( CLIP * ) c_loc->pt;
txlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
txlib.c:          scr_back ( xmin , ymax-1 , xmax , ymax ) ;
txlib.c:          scr_back ( xmax-1 , ymin , xmax , ymax ) ;
txlib.c:          _draw_bound ( xmin , EVGAY-ymin , xmax , EVGAY-ymax ) ;
txlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
txlib.c:          ymin = y1;ymax = y1-y0;
txlib.c:          scr_back ( xmin , ymax-1 , xmax , ymax ) ;
txlib.c:          scr_back ( xmax-1 , ymin , xmax , ymax ) ;
txlib.c:          _draw_bound ( xmin , EVGAY-ymin , xmax , EVGAY-ymax ) ;
txlib.c:      yorg1 = EVGAY-scr_y ( *yy ) ;
txlib.c:      yorg = EVGAY-scr_y ( *ybgn ) ;
txlib.c:      xorg -= xorg1;
txlib.c:      yorg = yorg1-yorg;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:                      gcur_y-= jmp;
txlib.c:                      gcur_x-= jmp;
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:      yorg = EVGAY-scr_y ( *ybgn ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      if ( *entry == 0 ) {x2 = -1;y2 = -1;};
txlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
txlib.c:          if ( xmin == EVGAX ) {xmax = x1;xmin = xmax-1;};
txlib.c:          if ( ymin == EVGAY ) {ymax = y1;ymin = ymax-1;};
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:      yorg = EVGAY-scr_y ( *ybgn ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:   dx=xb-xa;
txlib.c:   dy=yb-ya;
txlib.c:    g=inc1-dx1;
txlib.c:    inc2=g-dx1;
txlib.c:    else ch=-1;
txlib.c:    else rh=-1;
txlib.c:    g=inc1-dy1;
txlib.c:    inc2=g-dy1;
txlib.c:    else ch=-1;
txlib.c:    else rh=-1;
txlib.c:   while (abs(c-f)>0)
txlib.c:   dx=xb-xa;
txlib.c:   dy=yb-ya;
txlib.c:    g=inc1-dx1;
txlib.c:    inc2=g-dx1;
txlib.c:    else ch=-1;
txlib.c:    else rh=-1;
txlib.c:    g=inc1-dy1;
txlib.c:    inc2=g-dy1;
txlib.c:    else ch=-1;
txlib.c:    else rh=-1;
txlib.c:   while (abs(c-f)>0)
txlib.c:          ( short ) ( xmax-xmin+1 ) , ( short ) ( ymax-ymin+1 ) , i*nx , 0 ) ;
txlib.c:      dx = x2-x1;
txlib.c:      dy = y2-y1;
txlib.c:      if ( ny < 0 ) ny -= 2; else ny+= 2;
txlib.c:      if ( nx < 0 ) nx -= 2; else nx+= 2;
txlib.c:      for ( i = 0;i < ( nb-1 ) ;i++ ) {
txlib.c:      xl = x1 + ( nb-1 ) *dxx;
txlib.c:      yl = y1 + ( nb-1 ) *dyy;
txlib.c:      copy_area ( xl , yl , x2 , y2 , nb-1 , nxp ) ;
txlib.c:      XCopyArea ( Dsp , linebuf , Win , Gc , i*nx , 0 , ( short ) ( xmax-xmin+1 ) , 
txlib.c:          ( short ) ( ymax-ymin+1 ) , ( short ) xmin , ( short ) ( ymin ) ) ;
txlib.c:      dx = x2-x1;
txlib.c:      dy = y2-y1;
txlib.c:      if ( ny < 0 ) ny -= 2; else ny+= 2;
txlib.c:      if ( nx < 0 ) nx -= 2; else nx+= 2;
txlib.c:      for ( i = 0;i < ( nb-1 ) ;i++ ) {
txlib.c:      xl = x1 + ( nb-1 ) *dxx;
txlib.c:      yl = y1 + ( nb-1 ) *dyy;
txlib.c:      rest_area ( xl , yl , x2 , y2 , nb-1 , nxp ) ;
txlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
txlib.c:          if ( xmin == EVGAX ) {xmax = x1;xmin = xmax-1;};
txlib.c:          if ( ymin == EVGAY ) {ymax = y1;ymin = ymax-1;};
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:      yorg = EVGAY-scr_y ( *ybgn ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      t = atan2 ( ( double ) ( *y1-yorg ) , ( double ) ( *x1-xorg ) ) ;
txlib.c:/*  if((*x1<0)||(*x1>EVGAX)||(*y1<0)||(*y1>EVGAY)) return -1;*/
txlib.c:      gcur_t = 360-gcur_t;
txlib.c:      if ( ( key = GetPointer ( & x1 , & y1 ) ) < 0 ) return ( -1 ) ;
txlib.c:      if ( limit_cur ( & x1 , & y1 , xorg , yorg ) < 0 ) return -1;
txlib.c:          if ( xmin == EVGAX ) {xmax = x1;xmin = xmax-1;};
txlib.c:          if ( ymin == EVGAY ) {ymax = y1;ymin = ymax-1;};
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:      yorg = EVGAY-scr_y ( *ybgn ) ;
txlib.c:      gcur_r = sqrt ( ( double ) ( ( gcur_x-xorg ) * ( gcur_x-xorg ) + 
txlib.c:          ( gcur_y-yorg ) * ( gcur_y-yorg ) ) ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:                      gcurx = gcur_x;gcury = gcur_y-jmp;
txlib.c:                      gcurx = gcur_x-jmp;gcury = gcur_y;
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      y = usr_y ( EVGAY-gcur_y ) ;
txlib.c:      dist = sqrt ( ( double ) ( xo-x ) * ( xo-x ) + ( yo-y ) * ( yo-y ) ) ;
txlib.c:      t = atan2 ( ( double ) ( y-yo ) , ( double ) ( x-xo ) ) ;
txlib.c:      gcur_y = EVGAY-scr_y ( *yy ) ;
txlib.c:      yorg = EVGAY-scr_y ( *ybgn ) ;
txlib.c:              else pointer = -1;
txlib.c:                  if ( ( isdigit ( ch ) ) && ( ch != '0' ) ) jmp = ch-'0';
txlib.c:                      gcur_y-= jmp;
txlib.c:                      gcur_x-= jmp;
txlib.c:      *yy = usr_y ( ( EVGAY-gcur_y ) ) ;
txlib.c:      keysym = XGetKeyboardMapping ( Dsp , K_min , K_max-K_min+1 , & code ) ;
txlib3d.c:#define scr_z(z) (int)((z-clip_min)*CPCONS+0.5);
txlib3d.c:#define fscr_z(z) (float)((z-clip_min)*CPCONS); /* float version */
txlib3d.c:#define uiscr_z(z) (int)((z-dc->clip_min)*dc->CPCONS+0.5);
txlib3d.c:#define uifscr_z(z) (float)((z-dc->clip_min)*dc->CPCONS); /* float version */
txlib3d.c:      dc = G->dc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      wcset_clr ( dc->wc , dc->ln_color ) ;
txlib3d.c:      int xmin = 100000000 , xmax = -100000000 , ymin = 100000000 , ymax = -100000000;
txlib3d.c:      dc = G->dc;
txlib3d.c://  if((xmax < dc->v_x1)||(xmin >dc->v_x2)||(ymax<dc->v_y1)||(ymin >dc->v_y2)) return;
txlib3d.c:      if ( ( xmax < ( dc->v_x1+dc->D_x ) ) || ( xmin > ( dc->v_x2+dc->D_x ) ) 
txlib3d.c:          || ( ymax < ( dc->v_y1+dc->D_y ) ) || ( ymin > 
txlib3d.c:          ( dc->v_y2+dc->D_y ) ) ) return;
txlib3d.c:      dc = G->dc;
txlib3d.c:      int xmin = 100000000 , xmax = -100000000 , ymin = 100000000 , ymax = -100000000;
txlib3d.c:      dc = G->dc;
txlib3d.c://  if((xmax < dc->v_x1)||(xmin >dc->v_x2)||(ymax<dc->v_y1)||(ymin >dc->v_y2)) return;
txlib3d.c:      if ( ( xmax < ( dc->v_x1+dc->D_x ) ) || ( xmin > ( dc->v_x2+dc->D_x ) ) 
txlib3d.c:          || ( ymax < ( dc->v_y1+dc->D_y ) ) || ( ymin > 
txlib3d.c:          ( dc->v_y2+dc->D_y ) ) ) return;
txlib3d.c:      _uigodard_fill3 ( G , ( short ) n , x1 , y1 , z1 , ( short ) dc->ibdr , p1 ) ;
txlib3d.c:      int xmin = 100000000 , xmax = -100000000 , ymin = 100000000 , ymax = -100000000;
txlib3d.c:      dc = G->dc;
txlib3d.c://  if((xmax < dc->v_x1)||(xmin >dc->v_x2)||(ymax<dc->v_y1)||(ymin >dc->v_y2)) return;
txlib3d.c:      if ( ( xmax < ( dc->v_x1+dc->D_x ) ) || ( xmin > ( dc->v_x2+dc->D_x ) ) 
txlib3d.c:          || ( ymax < ( dc->v_y1+dc->D_y ) ) || ( ymin > 
txlib3d.c:          ( dc->v_y2+dc->D_y ) ) ) return;
txlib3d.c:      temp = dc->wc->c_color;
txlib3d.c:      wcset_clr ( dc->wc , clr ) ;
txlib3d.c:      _uishade_fill3 ( G , ( short ) n , x1 , y1 , z1 , ( short ) dc->ibdr , p ) ;
txlib3d.c:      wcset_clr ( dc->wc , temp ) ;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      pt = ( UNSIGNED * ) dc->zbuf;
txlib3d.c:      max = dc->Z_max;
txlib3d.c:      pt = ( UNSIGNED * ) dc->redbuf;
txlib3d.c:          pt = ( UNSIGNED * ) dc->greenbuf;
txlib3d.c:          pt = ( UNSIGNED * ) dc->bluebuf;
txlib3d.c:          pt = ( UNSIGNED * ) dc->clrbuf;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      if ( dc->zbuf != NULL ) ui_release_buf ( G ) ;
txlib3d.c:      if ( G->D_ON == 0 ) {
txlib3d.c:          dc->Z_max = ( G->x2-G->x1+1 ) * ( G->y2-G->y1+1 ) *G->MAG*G->MAG;
txlib3d.c:          dc->redbuf = NULL;
txlib3d.c:          dc->greenbuf = NULL;
txlib3d.c:          dc->bluebuf = NULL;
txlib3d.c:          dc->clrbuf = NULL;
txlib3d.c:          dc->Z_max = ( wc->EVGAY+3 ) * ( wc->EVGAX+3 ) ;
txlib3d.c:          dc->redbuf = ( UNSIGNED * ) malloc ( sizeof ( UNSIGNED ) *dc->Z_max ) ;
txlib3d.c:          dc->greenbuf = ( UNSIGNED * ) malloc ( sizeof ( UNSIGNED ) *dc->Z_max ) ;
txlib3d.c:          dc->bluebuf = ( UNSIGNED * ) malloc ( sizeof ( UNSIGNED ) *dc->Z_max ) ;
txlib3d.c:          dc->clrbuf = ( UNSIGNED * ) malloc ( sizeof ( UNSIGNED ) *dc->Z_max ) ;
txlib3d.c:          dc->redbuf = NULL;
txlib3d.c:          dc->greenbuf = NULL;
txlib3d.c:          dc->bluebuf = NULL;
txlib3d.c:          dc->clrbuf = NULL;
txlib3d.c:      dc->zbuf = ( UNSIGNED * ) malloc ( sizeof ( UNSIGNED ) *dc->Z_max ) ;
txlib3d.c:      if ( dc->zbuf == NULL ) {
txlib3d.c:      dc = G->dc;
txlib3d.c:      dc->clip_min = cpmin;
txlib3d.c:      dc->clip_max = cpmax;
txlib3d.c:      dc->CPCONS = MAXZ/ ( float ) ( dc->clip_max-dc->clip_min ) ;
txlib3d.c:      dc = G->dc;
txlib3d.c:      dc->clip_min = cp;
txlib3d.c:      dc->CPCONS = MAXZ/ ( float ) ( dc->clip_max-dc->clip_min ) ;
txlib3d.c:      dc = G->dc;
txlib3d.c:      dc->clip_max = cp;
txlib3d.c:      dc->CPCONS = MAXZ/ ( float ) ( dc->clip_max-dc->clip_min ) ;
txlib3d.c:      dc = G->dc;
txlib3d.c://  dc->clip_min=0;
txlib3d.c://  dc->CPCONS=1.;
txlib3d.c:      if ( dc->zbuf != NULL ) free ( ( void * ) dc->zbuf ) ;
txlib3d.c:      if ( dc->redbuf != NULL ) free ( ( void * ) dc->redbuf ) ;
txlib3d.c:      if ( dc->greenbuf != NULL ) free ( ( void * ) dc->greenbuf ) ;
txlib3d.c:      if ( dc->bluebuf != NULL ) free ( ( void * ) dc->bluebuf ) ;
txlib3d.c:      if ( dc->clrbuf != NULL ) free ( ( void * ) dc->clrbuf ) ;
txlib3d.c:      dc->zbuf = dc->redbuf = dc->greenbuf = dc->bluebuf = dc->clrbuf = NULL;
txlib3d.c:      dc = G->dc;
txlib3d.c:      wc = G->wc;
txlib3d.c:      pos = row* ( wc->EVGAX ) +col;
txlib3d.c:      loc = dc->zbuf+pos;
txlib3d.c:      fac1 = 1 -fac;
txlib3d.c:      cclr = wc->c_color;
txlib3d.c:      clr = dc->clrbuf+pos;
txlib3d.c:      r = dc->redbuf+pos;
txlib3d.c:      g = dc->greenbuf+pos;
txlib3d.c:      b = dc->bluebuf+pos;
txlib3d.c:      dc = G->dc;
txlib3d.c://  wc=G->wc; not correct since it is a copy for clipping
txlib3d.c:      wc = WC ( ( G->D ) ) ;
txlib3d.c://  row = wc->EVGAY-1-row;
txlib3d.c:      pos = row* ( wc->EVGAX+1 ) +col;
txlib3d.c:      loc = dc->zbuf+pos;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      pos = row* ( wc->EVGAX ) +col;
txlib3d.c:      loc = dc->zbuf+pos;
txlib3d.c:      fac1 = 1 -fac;
txlib3d.c:      cclr = wc->c_color;
txlib3d.c://  clr = dc->clrbuf+pos;
txlib3d.c:      r = dc->redbuf+pos;
txlib3d.c:      g = dc->greenbuf+pos;
txlib3d.c:      b = dc->bluebuf+pos;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      pos = row* ( wc->EVGAX ) +col;
txlib3d.c:      loc = dc->zbuf+pos;
txlib3d.c:      fac1 = 1 -fac;
txlib3d.c:      cclr = wc->c_color;
txlib3d.c://  clr = dc->clrbuf+pos;
txlib3d.c:      r = dc->redbuf+pos;
txlib3d.c:      g = dc->greenbuf+pos;
txlib3d.c:      b = dc->bluebuf+pos;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      dc->cur_x = xp ;
txlib3d.c:      dc->cur_y = yp ;
txlib3d.c:      dc->cur_z = zp;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      xf = x2-x1;yf = y2-y1;
txlib3d.c:          else m = ( double ) ( z2-z1 ) / ( double ) ( yf ) ;
txlib3d.c:          cons = z1 - y1*m;
txlib3d.c:          m = ( double ) ( z2-z1 ) / ( double ) ( xf ) ;
txlib3d.c:          cons = z1 - x1*m;
txlib3d.c:          dx = xb-xa;
txlib3d.c:          dy = yb-ya;
txlib3d.c:              g = inc1-dx1;
txlib3d.c:              inc2 = g-dx1;
txlib3d.c:              else ch = -1;
txlib3d.c:              else rh = -1;
txlib3d.c:/*        while (labs(c-f)>0)*/
txlib3d.c:              r = wc->EVGAY-r;
txlib3d.c:                  if ( g > 0 ) { r-= rh; g+= inc2; }
txlib3d.c:              uiput_pix3 ( G , xb , ( wc->EVGAY-yb ) , z ) ;
txlib3d.c:              g = inc1-dy1;
txlib3d.c:              inc2 = g-dy1;
txlib3d.c:              else ch = -1;
txlib3d.c:              else rh = -1;
txlib3d.c:/*        while (labs(c-f)>0)*/
txlib3d.c:              c = wc->EVGAY-c;
txlib3d.c:              f = wc->EVGAY-f;
txlib3d.c:                  z = z_inter ( ( wc->EVGAY-c ) , m , cons ) ;
txlib3d.c:                  c-= ch;
txlib3d.c:              uiput_pix3 ( G , xb , ( wc->EVGAY-yb ) , z ) ;
txlib3d.c:              uiput_pix3 ( G , xa , ( wc->EVGAY-i ) , z ) ;}
txlib3d.c:                  uiput_pix3 ( G , i , ( wc->EVGAY-ya ) , z ) ;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      if ( dc->ln_width == 1 ) { _uidraw_line3 ( G , xa , ya , za , xb , yb , zb ) ;
txlib3d.c:      i2 = dc->ln_width/2;
txlib3d.c:      dx = ( float ) ( xb-xa ) ;
txlib3d.c:      dy = ( float ) ( yb-ya ) ;
txlib3d.c:      if ( ct < 0. ) dy1 = ( int ) ( ct*i2-0.5 ) ;
txlib3d.c:      xa += dx1 , xb += dx1 , ya -= dy1 , yb -= dy1;
txlib3d.c:      for ( i = 1;i < dc->ln_width;i++ ) {
txlib3d.c:          if ( ct < 0. ) dy1 = ( int ) ( ct*i-0.5 ) ;
txlib3d.c:          _uidraw_line3 ( G , xa-dx1 , ya+dy1 , za , xb-dx1 , yb+dy1 , zb ) ;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:          uiput_pix3 ( G , xa , ( wc->EVGAY-y ) , za ) ;
txlib3d.c:      m = ( double ) ( z2-z1 ) / ( double ) ( x2-x1 ) ;
txlib3d.c:      cons = z1 - x1*m;
txlib3d.c:          uiput_pix3 ( G , i , ( wc->EVGAY-y ) , z ) ;}
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:          uiput_pix3 ( G , xa , ( wc->EVGAY-y ) , ( int ) ( za+0.5 ) ) ;
txlib3d.c:      m = ( double ) ( z2-z1 ) / ( double ) ( x2-x1 ) ;
txlib3d.c:      cons = z1 - x1*m;
txlib3d.c:          uiput_pix3 ( G , i , ( wc->EVGAY-y ) , z ) ;}
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      xa = dc->cur_x;
txlib3d.c:      ya = dc->cur_y;
txlib3d.c:      za = dc->cur_z;
txlib3d.c:          dc->cur_x = x;
txlib3d.c:          dc->cur_y = y;
txlib3d.c:          dc->cur_z = z;
txlib3d.c:      if ( dc->cur_x == x ) {
txlib3d.c:          m = ( double ) ( y-dc->cur_y ) / ( double ) ( z-dc->cur_z ) ;
txlib3d.c:          cons = dc->cur_z - dc->cur_y*m;
txlib3d.c:          m = ( double ) ( x-dc->cur_x ) / ( double ) ( z-dc->cur_z ) ;
txlib3d.c:          cons = dc->cur_z - dc->cur_x*m;
txlib3d.c:      dx = xb-xa;
txlib3d.c:      dy = yb-ya;
txlib3d.c:          g = inc1-dx1;
txlib3d.c:          inc2 = g-dx1;
txlib3d.c:          else ch = -1;
txlib3d.c:          else rh = -1;
txlib3d.c:          g = inc1-dy1;
txlib3d.c:          inc2 = g-dy1;
txlib3d.c:          else ch = -1;
txlib3d.c:          else rh = -1;
txlib3d.c:      while ( abs ( c-f ) > 0 ) { i = 0;
txlib3d.c:          while ( ( i <= dc->ln_style ) && ( abs ( c-f ) > 0 ) ) {
txlib3d.c:                  uiput_pix3 ( G , c , ( wc->EVGAY-r ) , z ) ;}
txlib3d.c:                  ( G , r , ( wc->EVGAY-c ) , z ) ;}
txlib3d.c:          while ( ( i <= dc->ln_style ) && ( abs ( c-f ) > 0 ) ) {
txlib3d.c:      dc->cur_x = x;
txlib3d.c:      dc->cur_y = y;
txlib3d.c:      dc->cur_z = z;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      xa = dc->cur_x;
txlib3d.c:      ya = dc->cur_y;
txlib3d.c:      za = dc->cur_z;
txlib3d.c:      if ( dc->ln_style == 0 ) {uidraw_line3 ( G , xa , ya , za , xb , yb , zb ) ;}
txlib3d.c:          if ( dc->ln_width == 1 ) _uidraw3_ ( G , x , y , z ) ;
txlib3d.c:              i2 = dc->ln_width/2;
txlib3d.c:              dx = ( float ) ( xb-xa ) ;
txlib3d.c:              dy = ( float ) ( yb-ya ) ;
txlib3d.c:              if ( ct < 0. ) dy1 = ( int ) ( ct*i2-0.5 ) ;
txlib3d.c:              xa += dx1 , xb += dx1 , ya -= dy1 , yb -= dy1;
txlib3d.c:              dc->cur_x = xa , dc->cur_y = ya;
txlib3d.c:              for ( i = 1;i < dc->ln_width;i++ ) {
txlib3d.c:                  if ( ct < 0. ) dy1 = ( int ) ( ct*i-0.5 ) ;
txlib3d.c:                  dc->cur_x = xa-dx1 , dc->cur_y = ya+dy1;
txlib3d.c:                  _uidraw3_ ( G , xb-dx1 , yb+dy1 , zb ) ;
txlib3d.c:      dc->cur_x = x;
txlib3d.c:      dc->cur_y = y;
txlib3d.c:      dc->cur_z = z;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:          m = ( double ) ( z2-z1 ) / ( double ) ( y2-y1 ) ;
txlib3d.c:          cons = z1 - y1*m;
txlib3d.c:          m = ( double ) ( z2-z1 ) / ( double ) ( x2-x1 ) ;
txlib3d.c:          cons = z1 - x1*m;
txlib3d.c:      temp = wc->c_color;
txlib3d.c:      if ( ( x_min <= wc->c_v_x2 ) && ( x_max1 >= wc->c_v_x1 ) ) {
txlib3d.c:          if ( ( y_min <= wc->c_v_y2 ) && ( y_max >= wc->c_v_y1 ) ) {
txlib3d.c:              if ( x_max1 > wc->c_v_x2 ) x_max1 = wc->c_v_x2;
txlib3d.c:              if ( x_min < wc->c_v_x1 ) x_min = wc->c_v_x1;
txlib3d.c:              if ( y_max > wc->c_v_y2 ) y_max = wc->c_v_y2;
txlib3d.c:              if ( y_min < wc->c_v_y1 ) y_min = wc->c_v_y1;
txlib3d.c:                      uiput_pix3 ( G , x_min , wc->EVGAY-j , z ) ;}
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      xup = -100000;
txlib3d.c:      ygrt = -1239000;
txlib3d.c:          j = i-1;
txlib3d.c:              j--;
txlib3d.c:      if ( ( scan > wc->c_v_y2 ) || ( ygrt < wc->c_v_y1 ) || 
txlib3d.c:          ( xlow > wc->c_v_x2 ) || ( xup < wc->c_v_x1 ) ) return;
txlib3d.c:      tempc = wc->c_color;
txlib3d.c:          if ( scan < wc->c_v_y1 ) {scan++;continue;}
txlib3d.c:          if ( scan > wc->c_v_y2 ) break;
txlib3d.c:                      xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                          ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
txlib3d.c:                      zcord [ cnt ] = ( ( ( float ) ( zmax [ i ] -zmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                          ( scan-ymin [ i ] ) +zmin [ i ] ) ) ;
txlib3d.c:              j = i-1;
txlib3d.c:                  xcord [ j+1 ] = xcord [ j ] ;j--;}
txlib3d.c:      wcset_clr ( wc , dc->ln_color ) ;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      xup = -100000000;
txlib3d.c:      ygrt = -123900000;
txlib3d.c:      temp = wc->c_color;
txlib3d.c:          j = i-1;
txlib3d.c:              j--;
txlib3d.c:      if ( ( scan > wc->c_v_y2 ) || ( ygrt < wc->c_v_y1 ) || 
txlib3d.c:          ( xlow > wc->c_v_x2 ) || ( xup < wc->c_v_x1 ) ) return;
txlib3d.c:              if ( scan < wc->c_v_y1 ) {scan++;continue;}
txlib3d.c:              if ( scan > wc->c_v_y2 ) break;
txlib3d.c:                          xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                              ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
txlib3d.c:                          zcord [ cnt ] = ( ( ( float ) ( zmax [ i ] -zmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                              ( scan-ymin [ i ] ) +zmin [ i ] ) +0.5 ) ;
txlib3d.c:                          pcord [ cnt ] = ( ( ( float ) ( pmax [ i ] -pmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                              ( scan-ymin [ i ] ) +pmin [ i ] ) ) ;
txlib3d.c:                  j = i-1;
txlib3d.c:                  pcord [ j+1 ] = pcord [ j ] ;j--;}
txlib3d.c:      wcset_clr ( wc , dc->ln_color ) ;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      yy = wc->EVGAY-y;
txlib3d.c:      if ( ( y > wc->c_v_y2 ) || ( y < wc->c_v_y1 ) ) return;
txlib3d.c:      if ( p1 < 1 ) p1 = dc->Cutoff;
txlib3d.c:      if ( p2 < 1 ) p2 = dc->Cutoff;
txlib3d.c:      if ( p1 > dc->max_clr ) p1 = dc->max_clr;
txlib3d.c:      if ( p2 > dc->max_clr ) p2 = dc->max_clr;
txlib3d.c:          tempc = wc->c_color;
txlib3d.c:          if ( p1 > 0 ) c_color = p1+dc->min_clr;
txlib3d.c:      if ( xa > wc->c_v_x2 ) return;
txlib3d.c:      if ( xb < wc->c_v_x1 ) return;
txlib3d.c:      if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib3d.c:      if ( xa < wc->c_v_x1 ) {
txlib3d.c:          pval = pa+ ( wc->c_v_x1-xa ) *pfac;
txlib3d.c:          xa = wc->c_v_x1;
txlib3d.c:          if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib3d.c:      if ( xb > wc->c_v_x2 ) {
txlib3d.c:          pval = pa+ ( wc->c_v_x2-xa ) *pfac;
txlib3d.c:          xb = wc->c_v_x2;
txlib3d.c:          if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib3d.c:      m = ( double ) ( z2-z1 ) / ( double ) ( x2-x1 ) ;
txlib3d.c:      cons = z1 - x1*m;
txlib3d.c:          temp = ( char ) ( pa+ ( i-xa ) *pfac+0.5 ) ;
txlib3d.c:          if ( temp < 1 ) temp = dc->Cutoff;
txlib3d.c:          if ( temp > dc->max_clr ) temp = dc->max_clr;
txlib3d.c:          if ( temp > 0 ) temp += dc->min_clr;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      xup = -100000000;
txlib3d.c:      ygrt = -123900000;
txlib3d.c:      temp = wc->c_color;
txlib3d.c:          j = i-1;
txlib3d.c:              j--;
txlib3d.c:      if ( ( scan > wc->c_v_y2 ) || ( ygrt < wc->c_v_y1 ) || 
txlib3d.c:          ( xlow > wc->c_v_x2 ) || ( xup < wc->c_v_x1 ) ) return;
txlib3d.c:              if ( scan < wc->c_v_y1 ) {scan++;continue;}
txlib3d.c:              if ( scan > wc->c_v_y2 ) break;
txlib3d.c:                          xcord [ cnt ] = ( ( ( float ) ( xmax [ i ] -xmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                              ( scan-ymin [ i ] ) +xmin [ i ] ) +0.5 ) ;
txlib3d.c:                          zcord [ cnt ] = ( ( ( float ) ( zmax [ i ] -zmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                              ( scan-ymin [ i ] ) +zmin [ i ] ) +0.5 ) ;
txlib3d.c:                          pcord [ cnt ] = ( ( ( float ) ( pmax [ i ] -pmin [ i ] ) / ( ymax [ i ] -ymin [ i ] ) * 
txlib3d.c:                              ( scan-ymin [ i ] ) +pmin [ i ] ) ) ;
txlib3d.c:                  j = i-1;
txlib3d.c:                  pcord [ j+1 ] = pcord [ j ] ;j--;}
txlib3d.c:      wcset_clr ( wc , dc->ln_color ) ;
txlib3d.c:      wc = G->wc;
txlib3d.c:      dc = G->dc;
txlib3d.c:      yy = wc->EVGAY-y;
txlib3d.c:      if ( ( y > wc->c_v_y2 ) || ( y < wc->c_v_y1 ) ) return;
txlib3d.c:      if ( xa > wc->c_v_x2 ) return;
txlib3d.c:      if ( xb < wc->c_v_x1 ) return;
txlib3d.c:      if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib3d.c:      if ( xa < wc->c_v_x1 ) {
txlib3d.c:          pval = pa+ ( wc->c_v_x1-xa ) *pfac;
txlib3d.c:          xa = wc->c_v_x1;
txlib3d.c:          if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib3d.c:      if ( xb > wc->c_v_x2 ) {
txlib3d.c:          pval = pa+ ( wc->c_v_x2-xa ) *pfac;
txlib3d.c:          xb = wc->c_v_x2;
txlib3d.c:          if ( xb != xa ) pfac = ( pb-pa ) / ( xb-xa ) ;
txlib3d.c:      else m = ( double ) ( z2-z1 ) / ( double ) ( x2-x1 ) ;
txlib3d.c:      cons = z1 - x1*m;
txlib3d.c:          tempp = ( pa+ ( i-xa ) *pfac ) ;
uiFiletoC.c:  if(ot < 0) return -1;
uiFiletoC.c:  i--;
uiFiletoC.c:     i--;
uiFiletoC.c://  sprintf(flname,"%-s.c",infile);
uiFiletoC.c:  fprintf(fp,"  char %-s_data[]= {\n",basename);
uiFiletoC.c:  fprintf(fp,"  FMGIMG %-s_str = { \"FMG\",1,\"%-s\",%d,%-s_data,NULL};\n",basename,basename,sum,basename);
